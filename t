
u-boot:     file format elf32-littlearm


Disassembly of section .text:

34800000 <__image_copy_start>:
#include <version.h>
#include <asm/system.h>
#include <linux/linkage.h>

.globl _start
_start: b	reset
34800000:	ea000014 	b	34800058 <reset>
	ldr	pc, _undefined_instruction
34800004:	e59ff014 	ldr	pc, [pc, #20]	; 34800020 <_undefined_instruction>
	ldr	pc, _software_interrupt
34800008:	e59ff014 	ldr	pc, [pc, #20]	; 34800024 <_software_interrupt>
	ldr	pc, _prefetch_abort
3480000c:	e59ff014 	ldr	pc, [pc, #20]	; 34800028 <_prefetch_abort>
	ldr	pc, _data_abort
34800010:	e59ff014 	ldr	pc, [pc, #20]	; 3480002c <_data_abort>
	ldr	pc, _not_used
34800014:	e59ff014 	ldr	pc, [pc, #20]	; 34800030 <_not_used>
	ldr	pc, _irq
34800018:	e59ff014 	ldr	pc, [pc, #20]	; 34800034 <_irq>
	ldr	pc, _fiq
3480001c:	e59ff014 	ldr	pc, [pc, #20]	; 34800038 <_fiq>

34800020 <_undefined_instruction>:
34800020:	34800220 	.word	0x34800220

34800024 <_software_interrupt>:
34800024:	34800280 	.word	0x34800280

34800028 <_prefetch_abort>:
34800028:	348002e0 	.word	0x348002e0

3480002c <_data_abort>:
3480002c:	34800340 	.word	0x34800340

34800030 <_not_used>:
34800030:	348003a0 	.word	0x348003a0

34800034 <_irq>:
34800034:	34800400 	.word	0x34800400

34800038 <_fiq>:
34800038:	34800460 	.word	0x34800460

3480003c <_pad>:
3480003c:	12345678 	.word	0x12345678

34800040 <_TEXT_BASE>:
34800040:	34800000 	.word	0x34800000

34800044 <_bss_start_ofs>:
34800044:	00029854 	.word	0x00029854

34800048 <_image_copy_end_ofs>:
34800048:	00029854 	.word	0x00029854

3480004c <_bss_end_ofs>:
3480004c:	0002bbc0 	.word	0x0002bbc0

34800050 <_end_ofs>:
34800050:	0002db8c 	.word	0x0002db8c

34800054 <IRQ_STACK_START_IN>:
34800054:	0badc0de 	.word	0x0badc0de

34800058 <reset>:
/*
 * the actual reset code
 */

reset:
	bl	save_boot_params
34800058:	eb00005a 	bl	348001c8 <save_boot_params>
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr
3480005c:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x1f
34800060:	e3c0001f 	bic	r0, r0, #31
	orr	r0, r0, #0xd3
34800064:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
34800068:	e129f000 	msr	CPSR_fc, r0
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
3480006c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0
34800070:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
34800074:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
34800078:	e59f0428 	ldr	r0, [pc, #1064]	; 348004a8 <fiq+0x48>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
3480007c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
34800080:	eb000051 	bl	348001cc <cpu_init_cp15>
	bl	cpu_init_crit
34800084:	eb00005e 	bl	34800204 <cpu_init_crit>

34800088 <call_board_init_f>:
#endif

/* Set stackpointer in internal RAM to call board_init_f */
call_board_init_f:
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
34800088:	e3a0d423 	mov	sp, #587202560	; 0x23000000
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
3480008c:	e3cdd007 	bic	sp, sp, #7
	//bl	board_init_f
//	ldr r0, =0x3480
//	bl display_num_dat
//	bl display_addr_dat

	ldr r0, =_start
34800090:	e59f0410 	ldr	r0, [pc, #1040]	; 348004a8 <fiq+0x48>
	ldr r1, _board_init_f_ofs
34800094:	e59f1008 	ldr	r1, [pc, #8]	; 348000a4 <_board_init_f_ofs>

	add lr, r0, r1
34800098:	e080e001 	add	lr, r0, r1
	ldr	r0,=0x00000000
3480009c:	e3a00000 	mov	r0, #0
	mov pc, lr
348000a0:	e1a0f00e 	mov	pc, lr

348000a4 <_board_init_f_ofs>:
348000a4:	00001b94 	.word	0x00001b94

348000a8 <relocate_code>:
 * This "function" does not return, instead it continues in RAM
 * after relocating the monitor code.
 *
 */
ENTRY(relocate_code)
	mov	r4, r0	/* save addr_sp */
348000a8:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
348000ac:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination */
348000b0:	e1a06002 	mov	r6, r2

348000b4 <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	mov	sp, r4
348000b4:	e1a0d004 	mov	sp, r4

	adr	r0, _start
348000b8:	e24f00c0 	sub	r0, pc, #192	; 0xc0
	cmp	r0, r6
348000bc:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
348000c0:	03a09000 	moveq	r9, #0
	beq	clear_bss		/* skip relocation */
348000c4:	0a000026 	beq	34800164 <clear_bss>
	mov	r1, r6			/* r1 <- scratch for copy_loop */
348000c8:	e1a01006 	mov	r1, r6
	ldr	r3, _image_copy_end_ofs
348000cc:	e51f308c 	ldr	r3, [pc, #-140]	; 34800048 <_image_copy_end_ofs>
	add	r2, r0, r3		/* r2 <- source end address	    */
348000d0:	e0802003 	add	r2, r0, r3

348000d4 <copy_loop>:

copy_loop:
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
348000d4:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
348000d8:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]    */
348000dc:	e1500002 	cmp	r0, r2
	blo	copy_loop
348000e0:	3afffffb 	bcc	348000d4 <copy_loop>

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
348000e4:	e51f00ac 	ldr	r0, [pc, #-172]	; 34800040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset */
348000e8:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
348000ec:	e59fa06c 	ldr	sl, [pc, #108]	; 34800160 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
348000f0:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
348000f4:	e59f205c 	ldr	r2, [pc, #92]	; 34800158 <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
348000f8:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
348000fc:	e59f3058 	ldr	r3, [pc, #88]	; 3480015c <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
34800100:	e0833000 	add	r3, r3, r0

34800104 <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
34800104:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
34800108:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]
3480010c:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
34800110:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
34800114:	e3570017 	cmp	r7, #23
	beq	fixrel
34800118:	0a000007 	beq	3480013c <fixrel>
	cmp	r7, #2			/* absolute fixup? */
3480011c:	e3570002 	cmp	r7, #2
	beq	fixabs
34800120:	0a000000 	beq	34800128 <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
34800124:	ea000006 	b	34800144 <fixnext>

34800128 <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
34800128:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
3480012c:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
34800130:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
34800134:	e0811009 	add	r1, r1, r9
	b	fixnext
34800138:	ea000001 	b	34800144 <fixnext>

3480013c <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]
3480013c:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
34800140:	e0811009 	add	r1, r1, r9

34800144 <fixnext>:
fixnext:
	str	r1, [r0]
34800144:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
34800148:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
3480014c:	e1520003 	cmp	r2, r3
	blo	fixloop
34800150:	3affffeb 	bcc	34800104 <fixloop>
	b	clear_bss
34800154:	ea000002 	b	34800164 <clear_bss>

34800158 <_rel_dyn_start_ofs>:
34800158:	00029854 	.word	0x00029854

3480015c <_rel_dyn_end_ofs>:
3480015c:	0002dabc 	.word	0x0002dabc

34800160 <_dynsym_start_ofs>:
34800160:	0002dabc 	.word	0x0002dabc

34800164 <clear_bss>:
	.word __rel_dyn_end - _start
_dynsym_start_ofs:
	.word __dynsym_start - _start

clear_bss:
	ldr	r0, _bss_start_ofs
34800164:	e51f0128 	ldr	r0, [pc, #-296]	; 34800044 <_bss_start_ofs>
	ldr	r1, _bss_end_ofs
34800168:	e51f1124 	ldr	r1, [pc, #-292]	; 3480004c <_bss_end_ofs>
	mov	r4, r6			/* reloc addr */
3480016c:	e1a04006 	mov	r4, r6
	add	r0, r0, r4
34800170:	e0800004 	add	r0, r0, r4
	add	r1, r1, r4
34800174:	e0811004 	add	r1, r1, r4
	mov	r2, #0x00000000		/* clear			    */
34800178:	e3a02000 	mov	r2, #0

3480017c <clbss_l>:

clbss_l:cmp	r0, r1			/* clear loop... */
3480017c:	e1500001 	cmp	r0, r1
	bhs	clbss_e			/* if reached end of bss, exit */
34800180:	2a000002 	bcs	34800190 <clbss_e>
	str	r2, [r0]
34800184:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
34800188:	e2800004 	add	r0, r0, #4
	b	clbss_l
3480018c:	eafffffa 	b	3480017c <clbss_l>

34800190 <clbss_e>:
jump_2_ram:
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
34800190:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
34800194:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
34800198:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
/*
 * Move vector table
 */
#if !defined(CONFIG_TEGRA20)
	/* Set vector address in CP15 VBAR register */
	ldr     r0, =_start
3480019c:	e59f0304 	ldr	r0, [pc, #772]	; 348004a8 <fiq+0x48>
	add     r0, r0, r9
348001a0:	e0800009 	add	r0, r0, r9
	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
348001a4:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif /* !Tegra20 */

	ldr	r0, _board_init_r_ofs
348001a8:	e59f0014 	ldr	r0, [pc, #20]	; 348001c4 <_board_init_r_ofs>
	adr	r1, _start
348001ac:	e24f1f6d 	sub	r1, pc, #436	; 0x1b4
	add	lr, r0, r1
348001b0:	e080e001 	add	lr, r0, r1
	add	lr, lr, r9
348001b4:	e08ee009 	add	lr, lr, r9
	/* setup parameters for board_init_r */
	mov	r0, r5		/* gd_t */
348001b8:	e1a00005 	mov	r0, r5
	mov	r1, r6		/* dest_addr */
348001bc:	e1a01006 	mov	r1, r6
	/* jump to it ... */
	mov	pc, lr
348001c0:	e1a0f00e 	mov	pc, lr

348001c4 <_board_init_r_ofs>:
348001c4:	00001ae0 	.word	0x00001ae0

348001c8 <save_boot_params>:
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)
	bx	lr			@ back to my caller
348001c8:	e12fff1e 	bx	lr

348001cc <cpu_init_cp15>:
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
348001cc:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
348001d0:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
348001d4:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
348001d8:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
348001dc:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001e0:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
348001e4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
348001e8:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
348001ec:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
348001f0:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
348001f4:	e3800b02 	orr	r0, r0, #2048	; 0x800
#ifdef CONFIG_SYS_ICACHE_OFF
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
348001f8:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
348001fc:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mov	pc, lr			@ back to my caller
34800200:	e1a0f00e 	mov	pc, lr

34800204 <cpu_init_crit>:
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory
34800204:	ea0000ae 	b	348004c4 <lowlevel_init>
34800208:	e320f000 	nop	{0}
3480020c:	e320f000 	nop	{0}
34800210:	e320f000 	nop	{0}
34800214:	e320f000 	nop	{0}
34800218:	e320f000 	nop	{0}
3480021c:	e320f000 	nop	{0}

34800220 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
34800220:	e51fd1d4 	ldr	sp, [pc, #-468]	; 34800054 <IRQ_STACK_START_IN>
34800224:	e58de000 	str	lr, [sp]
34800228:	e14fe000 	mrs	lr, SPSR
3480022c:	e58de004 	str	lr, [sp, #4]
34800230:	e3a0d013 	mov	sp, #19
34800234:	e169f00d 	msr	SPSR_fc, sp
34800238:	e1a0e00f 	mov	lr, pc
3480023c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800240:	e24dd048 	sub	sp, sp, #72	; 0x48
34800244:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800248:	e51f21fc 	ldr	r2, [pc, #-508]	; 34800054 <IRQ_STACK_START_IN>
3480024c:	e892000c 	ldm	r2, {r2, r3}
34800250:	e28d0048 	add	r0, sp, #72	; 0x48
34800254:	e28d5034 	add	r5, sp, #52	; 0x34
34800258:	e1a0100e 	mov	r1, lr
3480025c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800260:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
34800264:	eb000785 	bl	34802080 <do_undefined_instruction>
34800268:	e320f000 	nop	{0}
3480026c:	e320f000 	nop	{0}
34800270:	e320f000 	nop	{0}
34800274:	e320f000 	nop	{0}
34800278:	e320f000 	nop	{0}
3480027c:	e320f000 	nop	{0}

34800280 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
34800280:	e24dd004 	sub	sp, sp, #4
34800284:	e58d0000 	str	r0, [sp]
34800288:	e51f023c 	ldr	r0, [pc, #-572]	; 34800054 <IRQ_STACK_START_IN>
3480028c:	e580e000 	str	lr, [r0]
34800290:	e14f0000 	mrs	r0, SPSR
34800294:	e580e004 	str	lr, [r0, #4]
34800298:	e59d0000 	ldr	r0, [sp]
3480029c:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
348002a0:	e24dd048 	sub	sp, sp, #72	; 0x48
348002a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348002a8:	e51f225c 	ldr	r2, [pc, #-604]	; 34800054 <IRQ_STACK_START_IN>
348002ac:	e892000c 	ldm	r2, {r2, r3}
348002b0:	e28d0048 	add	r0, sp, #72	; 0x48
348002b4:	e28d5034 	add	r5, sp, #52	; 0x34
348002b8:	e1a0100e 	mov	r1, lr
348002bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348002c0:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
348002c4:	eb000776 	bl	348020a4 <do_software_interrupt>
348002c8:	e320f000 	nop	{0}
348002cc:	e320f000 	nop	{0}
348002d0:	e320f000 	nop	{0}
348002d4:	e320f000 	nop	{0}
348002d8:	e320f000 	nop	{0}
348002dc:	e320f000 	nop	{0}

348002e0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
348002e0:	e51fd294 	ldr	sp, [pc, #-660]	; 34800054 <IRQ_STACK_START_IN>
348002e4:	e58de000 	str	lr, [sp]
348002e8:	e14fe000 	mrs	lr, SPSR
348002ec:	e58de004 	str	lr, [sp, #4]
348002f0:	e3a0d013 	mov	sp, #19
348002f4:	e169f00d 	msr	SPSR_fc, sp
348002f8:	e1a0e00f 	mov	lr, pc
348002fc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800300:	e24dd048 	sub	sp, sp, #72	; 0x48
34800304:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800308:	e51f22bc 	ldr	r2, [pc, #-700]	; 34800054 <IRQ_STACK_START_IN>
3480030c:	e892000c 	ldm	r2, {r2, r3}
34800310:	e28d0048 	add	r0, sp, #72	; 0x48
34800314:	e28d5034 	add	r5, sp, #52	; 0x34
34800318:	e1a0100e 	mov	r1, lr
3480031c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800320:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
34800324:	eb000767 	bl	348020c8 <do_prefetch_abort>
34800328:	e320f000 	nop	{0}
3480032c:	e320f000 	nop	{0}
34800330:	e320f000 	nop	{0}
34800334:	e320f000 	nop	{0}
34800338:	e320f000 	nop	{0}
3480033c:	e320f000 	nop	{0}

34800340 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
34800340:	e51fd2f4 	ldr	sp, [pc, #-756]	; 34800054 <IRQ_STACK_START_IN>
34800344:	e58de000 	str	lr, [sp]
34800348:	e14fe000 	mrs	lr, SPSR
3480034c:	e58de004 	str	lr, [sp, #4]
34800350:	e3a0d013 	mov	sp, #19
34800354:	e169f00d 	msr	SPSR_fc, sp
34800358:	e1a0e00f 	mov	lr, pc
3480035c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800360:	e24dd048 	sub	sp, sp, #72	; 0x48
34800364:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800368:	e51f231c 	ldr	r2, [pc, #-796]	; 34800054 <IRQ_STACK_START_IN>
3480036c:	e892000c 	ldm	r2, {r2, r3}
34800370:	e28d0048 	add	r0, sp, #72	; 0x48
34800374:	e28d5034 	add	r5, sp, #52	; 0x34
34800378:	e1a0100e 	mov	r1, lr
3480037c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800380:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
34800384:	eb000758 	bl	348020ec <do_data_abort>
34800388:	e320f000 	nop	{0}
3480038c:	e320f000 	nop	{0}
34800390:	e320f000 	nop	{0}
34800394:	e320f000 	nop	{0}
34800398:	e320f000 	nop	{0}
3480039c:	e320f000 	nop	{0}

348003a0 <not_used>:

	.align	5
not_used:
	get_bad_stack
348003a0:	e51fd354 	ldr	sp, [pc, #-852]	; 34800054 <IRQ_STACK_START_IN>
348003a4:	e58de000 	str	lr, [sp]
348003a8:	e14fe000 	mrs	lr, SPSR
348003ac:	e58de004 	str	lr, [sp, #4]
348003b0:	e3a0d013 	mov	sp, #19
348003b4:	e169f00d 	msr	SPSR_fc, sp
348003b8:	e1a0e00f 	mov	lr, pc
348003bc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348003c0:	e24dd048 	sub	sp, sp, #72	; 0x48
348003c4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348003c8:	e51f237c 	ldr	r2, [pc, #-892]	; 34800054 <IRQ_STACK_START_IN>
348003cc:	e892000c 	ldm	r2, {r2, r3}
348003d0:	e28d0048 	add	r0, sp, #72	; 0x48
348003d4:	e28d5034 	add	r5, sp, #52	; 0x34
348003d8:	e1a0100e 	mov	r1, lr
348003dc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348003e0:	e1a0000d 	mov	r0, sp
	bl	do_not_used
348003e4:	eb000749 	bl	34802110 <do_not_used>
348003e8:	e320f000 	nop	{0}
348003ec:	e320f000 	nop	{0}
348003f0:	e320f000 	nop	{0}
348003f4:	e320f000 	nop	{0}
348003f8:	e320f000 	nop	{0}
348003fc:	e320f000 	nop	{0}

34800400 <irq>:

#else

	.align	5
irq:
	get_bad_stack
34800400:	e51fd3b4 	ldr	sp, [pc, #-948]	; 34800054 <IRQ_STACK_START_IN>
34800404:	e58de000 	str	lr, [sp]
34800408:	e14fe000 	mrs	lr, SPSR
3480040c:	e58de004 	str	lr, [sp, #4]
34800410:	e3a0d013 	mov	sp, #19
34800414:	e169f00d 	msr	SPSR_fc, sp
34800418:	e1a0e00f 	mov	lr, pc
3480041c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800420:	e24dd048 	sub	sp, sp, #72	; 0x48
34800424:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800428:	e51f23dc 	ldr	r2, [pc, #-988]	; 34800054 <IRQ_STACK_START_IN>
3480042c:	e892000c 	ldm	r2, {r2, r3}
34800430:	e28d0048 	add	r0, sp, #72	; 0x48
34800434:	e28d5034 	add	r5, sp, #52	; 0x34
34800438:	e1a0100e 	mov	r1, lr
3480043c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800440:	e1a0000d 	mov	r0, sp
	bl	do_irq
34800444:	eb000743 	bl	34802158 <do_irq>
34800448:	e320f000 	nop	{0}
3480044c:	e320f000 	nop	{0}
34800450:	e320f000 	nop	{0}
34800454:	e320f000 	nop	{0}
34800458:	e320f000 	nop	{0}
3480045c:	e320f000 	nop	{0}

34800460 <fiq>:

	.align	5
fiq:
	get_bad_stack
34800460:	e51fd414 	ldr	sp, [pc, #-1044]	; 34800054 <IRQ_STACK_START_IN>
34800464:	e58de000 	str	lr, [sp]
34800468:	e14fe000 	mrs	lr, SPSR
3480046c:	e58de004 	str	lr, [sp, #4]
34800470:	e3a0d013 	mov	sp, #19
34800474:	e169f00d 	msr	SPSR_fc, sp
34800478:	e1a0e00f 	mov	lr, pc
3480047c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800480:	e24dd048 	sub	sp, sp, #72	; 0x48
34800484:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800488:	e51f243c 	ldr	r2, [pc, #-1084]	; 34800054 <IRQ_STACK_START_IN>
3480048c:	e892000c 	ldm	r2, {r2, r3}
34800490:	e28d0048 	add	r0, sp, #72	; 0x48
34800494:	e28d5034 	add	r5, sp, #52	; 0x34
34800498:	e1a0100e 	mov	r1, lr
3480049c:	e885000f 	stm	r5, {r0, r1, r2, r3}
348004a0:	e1a0000d 	mov	r0, sp
	bl	do_fiq
348004a4:	eb000722 	bl	34802134 <do_fiq>
348004a8:	34800000 	.word	0x34800000
348004ac:	e320f000 	nop	{0}
348004b0:	e320f000 	nop	{0}
348004b4:	e320f000 	nop	{0}
348004b8:	e320f000 	nop	{0}
348004bc:	e320f000 	nop	{0}

348004c0 <_TEXT_BASE>:
348004c0:	34800000 	.word	0x34800000

348004c4 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE

	.globl lowlevel_init
lowlevel_init:
	mov	r11, lr
348004c4:	e1a0b00e 	mov	fp, lr

	/* r5 has always zero */
	mov	r5, #0
348004c8:	e3a05000 	mov	r5, #0

	ldr	r7, =S5PC100_GPIO_BASE
348004cc:	e59f75e8 	ldr	r7, [pc, #1512]	; 34800abc <display_addr+0x10>
	ldr	r8, =S5PC100_GPIO_BASE
348004d0:	e59f85e4 	ldr	r8, [pc, #1508]	; 34800abc <display_addr+0x10>
	/* Read CPU ID */
	ldr	r2, =S5PC110_PRO_ID
348004d4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
	ldr	r0, [r2]
348004d8:	e5920000 	ldr	r0, [r2]
	mov	r1, #0x00010000
348004dc:	e3a01801 	mov	r1, #65536	; 0x10000
	and	r0, r0, r1
348004e0:	e0000001 	and	r0, r0, r1
	cmp	r0, r5
348004e4:	e1500005 	cmp	r0, r5
	beq	100f
348004e8:	0a000000 	beq	348004f0 <lowlevel_init+0x2c>
	ldr	r8, =S5PC110_GPIO_BASE
348004ec:	e59f85cc 	ldr	r8, [pc, #1484]	; 34800ac0 <display_addr+0x14>
100:
	/* Turn on KEY_LED_ON [GPJ4(1)] XMSMWEN */
	cmp	r7, r8
348004f0:	e1570008 	cmp	r7, r8
	beq	skip_check_didle			@ Support C110 only
348004f4:	0a000005 	beq	34800510 <skip_check_didle>

	ldr	r0, =S5PC110_RST_STAT
348004f8:	e59f05c4 	ldr	r0, [pc, #1476]	; 34800ac4 <display_addr+0x18>
	ldr	r1, [r0]
348004fc:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #0x000D0000
34800500:	e201180d 	and	r1, r1, #851968	; 0xd0000
	cmp	r1, #(0x1 << 19)			@ DEEPIDLE_WAKEUP
34800504:	e3510702 	cmp	r1, #524288	; 0x80000
	beq	didle_wakeup
34800508:	0a000070 	beq	348006d0 <didle_wakeup>
	cmp	r7, r8
3480050c:	e1570008 	cmp	r7, r8

34800510 <skip_check_didle>:

skip_check_didle:
	addeq	r0, r8, #0x280				@ S5PC100_GPIO_J4
34800510:	02880d0a 	addeq	r0, r8, #640	; 0x280
	addne	r0, r8, #0x2C0				@ S5PC110_GPIO_J4
34800514:	12880d0b 	addne	r0, r8, #704	; 0x2c0
	ldr	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800518:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 4)			@ 1 * 4-bit
3480051c:	e3c110f0 	bic	r1, r1, #240	; 0xf0
	orr	r1, r1, #(0x1 << 4)
34800520:	e3811010 	orr	r1, r1, #16
	str	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800524:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800528:	e5901004 	ldr	r1, [r0, #4]
	bic	r1, r1, #(1 << 1)
3480052c:	e3c11002 	bic	r1, r1, #2
	str	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800530:	e5801004 	str	r1, [r0, #4]

	/* Don't setup at s5pc100 */
	beq	100f
34800534:	0a00002e 	beq	348005f4 <skip_check_didle+0xe4>
	 *	0xF1D0_0000
	 *	0xF1E0_0000
	 *	0xF1F0_0000
	 *	0xFAF0_0000
	 */
	ldr     r0, =0xe0f00000
34800538:	e59f0588 	ldr	r0, [pc, #1416]	; 34800ac8 <display_addr+0x1c>
	ldr     r1, [r0]
3480053c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800540:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800544:	e5801000 	str	r1, [r0]

	ldr     r0, =0xe1f00000
34800548:	e59f057c 	ldr	r0, [pc, #1404]	; 34800acc <display_addr+0x20>
	ldr     r1, [r0]
3480054c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800550:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800554:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1800000
34800558:	e59f0570 	ldr	r0, [pc, #1392]	; 34800ad0 <display_addr+0x24>
	ldr     r1, [r0]
3480055c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800560:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800564:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1900000
34800568:	e59f0564 	ldr	r0, [pc, #1380]	; 34800ad4 <display_addr+0x28>
	ldr     r1, [r0]
3480056c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800570:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800574:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1a00000
34800578:	e59f0558 	ldr	r0, [pc, #1368]	; 34800ad8 <display_addr+0x2c>
	ldr     r1, [r0]
3480057c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800580:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800584:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1b00000
34800588:	e59f054c 	ldr	r0, [pc, #1356]	; 34800adc <display_addr+0x30>
	ldr     r1, [r0]
3480058c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800590:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800594:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1c00000
34800598:	e59f0540 	ldr	r0, [pc, #1344]	; 34800ae0 <display_addr+0x34>
	ldr     r1, [r0]
3480059c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005a0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005a4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1d00000
348005a8:	e59f0534 	ldr	r0, [pc, #1332]	; 34800ae4 <display_addr+0x38>
	ldr     r1, [r0]
348005ac:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005b0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005b4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1e00000
348005b8:	e59f0528 	ldr	r0, [pc, #1320]	; 34800ae8 <display_addr+0x3c>
	ldr     r1, [r0]
348005bc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005c0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005c4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1f00000
348005c8:	e59f051c 	ldr	r0, [pc, #1308]	; 34800aec <display_addr+0x40>
	ldr     r1, [r0]
348005cc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005d0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005d4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xfaf00000
348005d8:	e59f0510 	ldr	r0, [pc, #1296]	; 34800af0 <display_addr+0x44>
	ldr     r1, [r0]
348005dc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005e0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005e4:	e5801000 	str	r1, [r0]

	/*
	 * Diable ABB block to reduce sleep current at low temperature
	 * Note that it's hidden register setup don't modify it
	 */
	ldr	r0, =0xE010C300
348005e8:	e59f0504 	ldr	r0, [pc, #1284]	; 34800af4 <display_addr+0x48>
	ldr	r1, =0x00800000
348005ec:	e3a01502 	mov	r1, #8388608	; 0x800000
	str	r1, [r0]
348005f0:	e5801000 	str	r1, [r0]

100:
	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
348005f4:	059f04fc 	ldreq	r0, [pc, #1276]	; 34800af8 <display_addr+0x4c>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
348005f8:	159f04fc 	ldrne	r0, [pc, #1276]	; 34800afc <display_addr+0x50>
	ldr	r1, [r0]
348005fc:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
34800600:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800604:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
34800608:	e1811002 	orr	r1, r1, r2
	/* Do not release retention here for S5PC110 */
	streq	r1, [r0]
3480060c:	05801000 	streq	r1, [r0]

	/* Disable Watchdog */
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
34800610:	059f04e8 	ldreq	r0, [pc, #1256]	; 34800b00 <display_addr+0x54>
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
34800614:	159f04e8 	ldrne	r0, [pc, #1256]	; 34800b04 <display_addr+0x58>
	str	r5, [r0]
34800618:	e5805000 	str	r5, [r0]

	/* setting SRAM */
	ldreq	r0, =S5PC100_SROMC_BASE
3480061c:	03a004e7 	moveq	r0, #-419430400	; 0xe7000000
	ldrne	r0, =S5PC110_SROMC_BASE
34800620:	13a0033a 	movne	r0, #-402653184	; 0xe8000000
	ldr	r1, =0x9
34800624:	e3a01009 	mov	r1, #9
	str	r1, [r0]
34800628:	e5801000 	str	r1, [r0]

	/* S5PC100 has 3 groups of interrupt sources */
	ldreq	r0, =S5PC100_VIC0_BASE			@ 0xE4000000
3480062c:	03a00339 	moveq	r0, #-469762048	; 0xe4000000
	ldrne	r0, =S5PC110_VIC0_BASE			@ 0xF2000000
34800630:	13a004f2 	movne	r0, #-234881024	; 0xf2000000
	add	r1, r0, #0x00100000
34800634:	e2801601 	add	r1, r0, #1048576	; 0x100000
	add	r2, r0, #0x00200000
34800638:	e2802602 	add	r2, r0, #2097152	; 0x200000
	add	r3, r0, #0x00300000
3480063c:	e2803603 	add	r3, r0, #3145728	; 0x300000
	/* Disable all interrupts (VIC0, VIC1 and VIC2) */
	mvn	r4, #0x0
34800640:	e3e04000 	mvn	r4, #0
	str	r4, [r0, #0x14]				@ INTENCLEAR
34800644:	e5804014 	str	r4, [r0, #20]
	str	r4, [r1, #0x14]				@ INTENCLEAR
34800648:	e5814014 	str	r4, [r1, #20]
	str	r4, [r2, #0x14]				@ INTENCLEAR
3480064c:	e5824014 	str	r4, [r2, #20]
	str	r4, [r3, #0x14]				@ INTENCLEAR
34800650:	e5834014 	str	r4, [r3, #20]

	/* Set all interrupts as IRQ */
	str	r5, [r0, #0xc]				@ INTSELECT
34800654:	e580500c 	str	r5, [r0, #12]
	str	r5, [r1, #0xc]				@ INTSELECT
34800658:	e581500c 	str	r5, [r1, #12]
	str	r5, [r2, #0xc]				@ INTSELECT
3480065c:	e582500c 	str	r5, [r2, #12]
	str	r5, [r3, #0xc]				@ INTSELECT
34800660:	e583500c 	str	r5, [r3, #12]

	/* Pending Interrupt Clear */
	str	r5, [r0, #0xf00]			@ INTADDRESS
34800664:	e5805f00 	str	r5, [r0, #3840]	; 0xf00
	str	r5, [r1, #0xf00]			@ INTADDRESS
34800668:	e5815f00 	str	r5, [r1, #3840]	; 0xf00
	str	r5, [r2, #0xf00]			@ INTADDRESS
3480066c:	e5825f00 	str	r5, [r2, #3840]	; 0xf00
	str	r5, [r3, #0xf00]			@ INTADDRESS
34800670:	e5835f00 	str	r5, [r3, #3840]	; 0xf00


	/*led_init*/
	ldr r1, =0xE0200280 					
34800674:	e59f148c 	ldr	r1, [pc, #1164]	; 34800b08 <display_addr+0x5c>
	ldr r0, =0x00001111
34800678:	e59f048c 	ldr	r0, [pc, #1164]	; 34800b0c <display_addr+0x60>
	str r0, [r1]
3480067c:	e5810000 	str	r0, [r1]
	/*led_on*/
	ldr r1, =0xE0200284 					
34800680:	e59f1488 	ldr	r1, [pc, #1160]	; 34800b10 <display_addr+0x64>
	mov r0, #0
34800684:	e3a00000 	mov	r0, #0
	str r0, [r1]
34800688:	e5810000 	str	r0, [r1]

	/* for UART */
	bl	uart_asm_init
3480068c:	eb000077 	bl	34800870 <uart_asm_init>

	bl	internal_ram_init
34800690:	eb000071 	bl	3480085c <internal_ram_init>

	/*for SDRAM*/
	bl sdram_init
34800694:	eb000086 	bl	348008b4 <sdram_init>

	/*for copy_sd_to_ddr*/

	bl copy_code_to_dram	
34800698:	eb00014b 	bl	34800bcc <copy_code_to_dram>
	
	/* init system clock */
	//bl system_clock_init


	cmp	r7, r8
3480069c:	e1570008 	cmp	r7, r8
	/* Clear wakeup status register */
	ldreq	r0, =S5PC100_WAKEUP_STAT	
348006a0:	059f046c 	ldreq	r0, [pc, #1132]	; 34800b14 <display_addr+0x68>
	ldrne	r0, =S5PC110_WAKEUP_STAT
348006a4:	159f046c 	ldrne	r0, [pc, #1132]	; 34800b18 <display_addr+0x6c>
	ldr	r1, [r0]
348006a8:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
348006ac:	e5801000 	str	r1, [r0]

	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
348006b0:	059f0440 	ldreq	r0, [pc, #1088]	; 34800af8 <display_addr+0x4c>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
348006b4:	159f0440 	ldrne	r0, [pc, #1088]	; 34800afc <display_addr+0x50>
	ldr	r1, [r0]
348006b8:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
348006bc:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
348006c0:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
348006c4:	e1811002 	orr	r1, r1, r2
	str	r1, [r0]
348006c8:	e5801000 	str	r1, [r0]

	b	1f
348006cc:	ea00000c 	b	34800704 <lockloop+0x30>

348006d0 <didle_wakeup>:

didle_wakeup:
	/* Wait when APLL is locked */
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
348006d0:	e59f0444 	ldr	r0, [pc, #1092]	; 34800b1c <display_addr+0x70>

348006d4 <lockloop>:
lockloop:
	ldr	r1, [r0]
348006d4:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #(1 << 29)
348006d8:	e2011202 	and	r1, r1, #536870912	; 0x20000000
	cmp	r1, #(1 << 29)
348006dc:	e3510202 	cmp	r1, #536870912	; 0x20000000
	bne	lockloop
348006e0:	1afffffb 	bne	348006d4 <lockloop>

	ldr	r0, =S5PC110_INFORM0
348006e4:	e59f0434 	ldr	r0, [pc, #1076]	; 34800b20 <display_addr+0x74>
	ldr	r1, [r0]
348006e8:	e5901000 	ldr	r1, [r0]
	mov	pc, r1
348006ec:	e1a0f001 	mov	pc, r1
	nop
348006f0:	e320f000 	nop	{0}
	nop
348006f4:	e320f000 	nop	{0}
	nop
348006f8:	e320f000 	nop	{0}
	nop
348006fc:	e320f000 	nop	{0}
	nop
34800700:	e320f000 	nop	{0}

1:

	mov r0, r11
34800704:	e1a0000b 	mov	r0, fp
	bl display_num_dat
34800708:	eb0000d1 	bl	34800a54 <display_num_dat>
	bl display_addr_dat
3480070c:	eb0000bb 	bl	34800a00 <display_addr_dat>
	
	mov	lr, r11
34800710:	e1a0e00b 	mov	lr, fp
	mov	pc, lr
34800714:	e1a0f00e 	mov	pc, lr

34800718 <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
34800718:	e59f0404 	ldr	r0, [pc, #1028]	; 34800b24 <display_addr+0x78>

	/* Check S5PC100 */
	cmp	r7, r8
3480071c:	e1570008 	cmp	r7, r8
	bne	110f
34800720:	1a00001b 	bne	34800794 <system_clock_init+0x7c>
100:
	/* Set Lock Time */
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
34800724:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x000]		@ S5PC100_APLL_LOCK
34800728:	e5801000 	str	r1, [r0]
	str	r1, [r0, #0x004]		@ S5PC100_MPLL_LOCK
3480072c:	e5801004 	str	r1, [r0, #4]
	str	r1, [r0, #0x008]		@ S5PC100_EPLL_LOCK
34800730:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x00C]		@ S5PC100_HPLL_LOCK
34800734:	e580100c 	str	r1, [r0, #12]

	/* S5P_APLL_CON */
	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
34800738:	e59f13e8 	ldr	r1, [pc, #1000]	; 34800b28 <display_addr+0x7c>
	str	r1, [r0, #0x100]
3480073c:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5P_MPLL_CON */
	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
34800740:	e59f13e4 	ldr	r1, [pc, #996]	; 34800b2c <display_addr+0x80>
	str	r1, [r0, #0x104]
34800744:	e5801104 	str	r1, [r0, #260]	; 0x104
	/* S5P_EPLL_CON */
	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
34800748:	e59f13e0 	ldr	r1, [pc, #992]	; 34800b30 <display_addr+0x84>
	str	r1, [r0, #0x108]
3480074c:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5P_HPLL_CON */
	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
34800750:	e59f13dc 	ldr	r1, [pc, #988]	; 34800b34 <display_addr+0x88>
	str	r1, [r0, #0x10C]
34800754:	e580110c 	str	r1, [r0, #268]	; 0x10c

	ldr     r1, [r0, #0x300]
34800758:	e5901300 	ldr	r1, [r0, #768]	; 0x300
	ldr     r2, =0x00003fff
3480075c:	e59f23d4 	ldr	r2, [pc, #980]	; 34800b38 <display_addr+0x8c>
	bic     r1, r1, r2
34800760:	e1c11002 	bic	r1, r1, r2
	ldr     r2, =0x00011301
34800764:	e59f23d0 	ldr	r2, [pc, #976]	; 34800b3c <display_addr+0x90>

	orr	r1, r1, r2
34800768:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #0x300]
3480076c:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr     r1, [r0, #0x304]
34800770:	e5901304 	ldr	r1, [r0, #772]	; 0x304
	ldr     r2, =0x00011110
34800774:	e59f23c4 	ldr	r2, [pc, #964]	; 34800b40 <display_addr+0x94>
	orr     r1, r1, r2
34800778:	e1811002 	orr	r1, r1, r2
	str     r1, [r0, #0x304]
3480077c:	e5801304 	str	r1, [r0, #772]	; 0x304
	ldr     r1, =0x00000001
34800780:	e3a01001 	mov	r1, #1
	str     r1, [r0, #0x308]
34800784:	e5801308 	str	r1, [r0, #776]	; 0x308

	/* Set Source Clock */
	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
34800788:	e59f137c 	ldr	r1, [pc, #892]	; 34800b0c <display_addr+0x60>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
3480078c:	e5801200 	str	r1, [r0, #512]	; 0x200

	b	200f
34800790:	ea00002d 	b	3480084c <system_clock_init+0x134>
110:
	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
34800794:	e59f03a8 	ldr	r0, [pc, #936]	; 34800b44 <display_addr+0x98>

	/* Set OSC_FREQ value */
	ldr	r1, =0xf
34800798:	e3a0100f 	mov	r1, #15
	str	r1, [r0, #0x100]		@ S5PC110_OSC_FREQ
3480079c:	e5801100 	str	r1, [r0, #256]	; 0x100

	/* Set MTC_STABLE value */
	ldr	r1, =0xffffffff
348007a0:	e3e01000 	mvn	r1, #0
	str	r1, [r0, #0x110]		@ S5PC110_MTC_STABLE
348007a4:	e5801110 	str	r1, [r0, #272]	; 0x110

	/* Set CLAMP_STABLE value */
	ldr	r1, =0x3ff03ff
348007a8:	e59f1398 	ldr	r1, [pc, #920]	; 34800b48 <display_addr+0x9c>
	str	r1, [r0, #0x114]		@ S5PC110_CLAMP_STABLE
348007ac:	e5801114 	str	r1, [r0, #276]	; 0x114

	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
348007b0:	e59f036c 	ldr	r0, [pc, #876]	; 34800b24 <display_addr+0x78>

	/* Set Clock divider */
	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
348007b4:	e59f1390 	ldr	r1, [pc, #912]	; 34800b4c <display_addr+0xa0>
	str	r1, [r0, #0x300]
348007b8:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
348007bc:	e59f138c 	ldr	r1, [pc, #908]	; 34800b50 <display_addr+0xa4>
	str	r1, [r0, #0x310]
348007c0:	e5801310 	str	r1, [r0, #784]	; 0x310

	/* Set Lock Time */
	ldr	r1, =0x2cf			@ Locktime : 30us
348007c4:	e59f1388 	ldr	r1, [pc, #904]	; 34800b54 <display_addr+0xa8>
	str	r1, [r0, #0x000]		@ S5PC110_APLL_LOCK
348007c8:	e5801000 	str	r1, [r0]
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
348007cc:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x008]		@ S5PC110_MPLL_LOCK
348007d0:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x010]		@ S5PC110_EPLL_LOCK
348007d4:	e5801010 	str	r1, [r0, #16]
	str	r1, [r0, #0x020]		@ S5PC110_VPLL_LOCK
348007d8:	e5801020 	str	r1, [r0, #32]

	/* S5PC110_APLL_CON */
	ldr	r1, =0x80C80601			@ 800MHz
348007dc:	e59f1374 	ldr	r1, [pc, #884]	; 34800b58 <display_addr+0xac>
	str	r1, [r0, #0x100]
348007e0:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5PC110_MPLL_CON */
	ldr	r1, =0x829B0C01			@ 667MHz
348007e4:	e59f1370 	ldr	r1, [pc, #880]	; 34800b5c <display_addr+0xb0>
	str	r1, [r0, #0x108]
348007e8:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5PC110_EPLL_CON */
	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
348007ec:	e59f136c 	ldr	r1, [pc, #876]	; 34800b60 <display_addr+0xb4>
	str	r1, [r0, #0x110]
348007f0:	e5801110 	str	r1, [r0, #272]	; 0x110
	/* S5PC110_VPLL_CON */
	ldr	r1, =0x806C0603			@  54MHz
348007f4:	e59f1368 	ldr	r1, [pc, #872]	; 34800b64 <display_addr+0xb8>
	str	r1, [r0, #0x120]
348007f8:	e5801120 	str	r1, [r0, #288]	; 0x120

	/* Set Source Clock */
	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
348007fc:	e59f1364 	ldr	r1, [pc, #868]	; 34800b68 <display_addr+0xbc>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
34800800:	e5801200 	str	r1, [r0, #512]	; 0x200

	/* OneDRAM(DMC0) clock setting */
	ldr	r1, =0x01000000			@ ONEDRAM_SEL[25:24] 1 SCLKMPLL
34800804:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #0x218]		@ S5PC110_CLK_SRC6
34800808:	e5801218 	str	r1, [r0, #536]	; 0x218
	ldr	r1, =0x30000000			@ ONEDRAM_RATIO[31:28] 3 + 1
3480080c:	e3a01203 	mov	r1, #805306368	; 0x30000000
	str	r1, [r0, #0x318]		@ S5PC110_CLK_DIV6
34800810:	e5801318 	str	r1, [r0, #792]	; 0x318

	/* XCLKOUT = XUSBXTI 24MHz */
	add	r2, r0, #0xE000			@ S5PC110_OTHERS
34800814:	e2802a0e 	add	r2, r0, #57344	; 0xe000
	ldr     r1, [r2]
34800818:	e5921000 	ldr	r1, [r2]
	orr	r1, r1, #(0x3 << 8)		@ CLKOUT[9:8] 3 XUSBXTI
3480081c:	e3811c03 	orr	r1, r1, #768	; 0x300
	str	r1, [r2]
34800820:	e5821000 	str	r1, [r2]

	/* CLK_IP0 */
	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
34800824:	e59f1340 	ldr	r1, [pc, #832]	; 34800b6c <display_addr+0xc0>
	str	r1, [r0, #0x460]		@ S5PC110_CLK_IP0
34800828:	e5801460 	str	r1, [r0, #1120]	; 0x460

	/* CLK_IP1 */
	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
3480082c:	e59f133c 	ldr	r1, [pc, #828]	; 34800b70 <display_addr+0xc4>
						@ NANDXL[24]
	str	r1, [r0, #0x464]		@ S5PC110_CLK_IP1
34800830:	e5801464 	str	r1, [r0, #1124]	; 0x464

	/* CLK_IP2 */
	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
34800834:	e59f1338 	ldr	r1, [pc, #824]	; 34800b74 <display_addr+0xc8>
						@ HOSTIF[10] HSMMC0[16]
						@ HSMMC2[18] VIC[27:24]
	str	r1, [r0, #0x468]		@ S5PC110_CLK_IP2
34800838:	e5801468 	str	r1, [r0, #1128]	; 0x468

	/* CLK_IP3 */
	ldr	r1, =0x8eff038c			@ I2C[8:6]
3480083c:	e59f1334 	ldr	r1, [pc, #820]	; 34800b78 <display_addr+0xcc>
						@ SYSTIMER[16] UART0[17]
						@ UART1[18] UART2[19]
						@ UART3[20] WDT[22]
						@ PWM[23] GPIO[26] SYSCON[27]
	str	r1, [r0, #0x46c]		@ S5PC110_CLK_IP3
34800840:	e580146c 	str	r1, [r0, #1132]	; 0x46c

	/* CLK_IP4 */
	ldr	r1, =0xfffffff1			@ CHIP_ID[0] TZPC[8:5]
34800844:	e3e0100e 	mvn	r1, #14
	str	r1, [r0, #0x470]		@ S5PC110_CLK_IP3
34800848:	e5801470 	str	r1, [r0, #1136]	; 0x470

200:
	/* wait at least 200us to stablize all clock */
	mov	r2, #0x10000
3480084c:	e3a02801 	mov	r2, #65536	; 0x10000
1:	subs	r2, r2, #1
34800850:	e2522001 	subs	r2, r2, #1
	bne	1b
34800854:	1afffffd 	bne	34800850 <system_clock_init+0x138>

	mov	pc, lr
34800858:	e1a0f00e 	mov	pc, lr

3480085c <internal_ram_init>:

internal_ram_init:
	ldreq	r0, =0xE3800000
3480085c:	059f0318 	ldreq	r0, [pc, #792]	; 34800b7c <display_addr+0xd0>
	ldrne	r0, =0xF1500000
34800860:	159f0318 	ldrne	r0, [pc, #792]	; 34800b80 <display_addr+0xd4>
	ldr	r1, =0x0
34800864:	e3a01000 	mov	r1, #0
	str	r1, [r0]
34800868:	e5801000 	str	r1, [r0]

	mov	pc, lr
3480086c:	e1a0f00e 	mov	pc, lr

34800870 <uart_asm_init>:

/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	ldr r0, =S5PC110_GPIO_BASE
34800870:	e59f0248 	ldr	r0, [pc, #584]	; 34800ac0 <display_addr+0x14>
	ldr r1, =0x22222222
34800874:	e59f1308 	ldr	r1, [pc, #776]	; 34800b84 <display_addr+0xd8>
	str r1, [r0, #0x0]			@GPAO=0x2222
34800878:	e5801000 	str	r1, [r0]

	ldr r0, =S5PC110_UART_BASE
3480087c:	e59f0304 	ldr	r0, [pc, #772]	; 34800b88 <display_addr+0xdc>
	ldr	r1, =3
34800880:	e3a01003 	mov	r1, #3
	str	r1, [r0, #0x0]			@ ULCON=3
34800884:	e5801000 	str	r1, [r0]

	ldr	r1, =0x305
34800888:	e59f12fc 	ldr	r1, [pc, #764]	; 34800b8c <display_addr+0xe0>
	str	r1, [r0, #0x4]			@ UCON=0x305
3480088c:	e5801004 	str	r1, [r0, #4]

	ldr	r1, =1
34800890:	e3a01001 	mov	r1, #1
	str	r1, [r0, #0x8]			@ UFCON=1
34800894:	e5801008 	str	r1, [r0, #8]
	ldr		r1, =0
34800898:	e3a01000 	mov	r1, #0
	str	r1, [r0, #0xC]			@ UMCON=0
3480089c:	e580100c 	str	r1, [r0, #12]

	ldr	r1, =34
348008a0:	e3a01022 	mov	r1, #34	; 0x22
	str	r1, [r0, #0x28]			@ UBRDIV0=34
348008a4:	e5801028 	str	r1, [r0, #40]	; 0x28
	ldr	r1, =0xDFDD
348008a8:	e59f12e0 	ldr	r1, [pc, #736]	; 34800b90 <display_addr+0xe4>
	str	r1, [r0, #0x2C]			@ UDIVSLOT0=0XDFDD
348008ac:	e580102c 	str	r1, [r0, #44]	; 0x2c

	
	mov	pc, lr
348008b0:	e1a0f00e 	mov	pc, lr

348008b4 <sdram_init>:

.globl sdram_init
sdram_init:
//step 2: Set the PhyControl0.ctrl_start_point, .ctrl_inc, .ctrl_dll_on
	ldr	r0, =APB_DMC_0_BASE
348008b4:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
	ldr	r1, =0x0010100A					
348008b8:	e59f12d4 	ldr	r1, [pc, #724]	; 34800b94 <display_addr+0xe8>
	str	r1, [r0, #DMC_PHYCONTROL0]
348008bc:	e5801018 	str	r1, [r0, #24]
	//step 3: Set the PhyControl1.ctrl_shiftc, .ctrl_offsetc
	ldr	r1, =0x00000086					
348008c0:	e3a01086 	mov	r1, #134	; 0x86
	str	r1, [r0, #DMC_PHYCONTROL1]
348008c4:	e580101c 	str	r1, [r0, #28]
	//step 4: PhyControl0 DLL start
	ldr	r1, =0x0010100B					
348008c8:	e59f12c8 	ldr	r1, [pc, #712]	; 34800b98 <display_addr+0xec>
	str	r1, [r0, #DMC_PHYCONTROL0]
348008cc:	e5801018 	str	r1, [r0, #24]

348008d0 <find_lock_val>:

find_lock_val:
	//step 11:Loop until DLL is locked
	ldr	r1, [r0, #DMC_PHYSTATUS]			
348008d0:	e5901040 	ldr	r1, [r0, #64]	; 0x40
	and	r2, r1, #0x7
348008d4:	e2012007 	and	r2, r1, #7
	cmp	r2, #0x7					
348008d8:	e3520007 	cmp	r2, #7
	bne	find_lock_val
348008dc:	1afffffb 	bne	348008d0 <find_lock_val>
	
	//step 12: Force Value locking
	and	r1, #0x3fc0
348008e0:	e2011dff 	and	r1, r1, #16320	; 0x3fc0
	mov	r2, r1, LSL #18
348008e4:	e1a02901 	lsl	r2, r1, #18
	orr	r2, r2, #0x100000
348008e8:	e3822601 	orr	r2, r2, #1048576	; 0x100000
	orr	r2 ,r2, #0x1000
348008ec:	e3822a01 	orr	r2, r2, #4096	; 0x1000
	orr	r1, r2, #0xB					
348008f0:	e382100b 	orr	r1, r2, #11
	str	r1, [r0, #DMC_PHYCONTROL0]
348008f4:	e5801018 	str	r1, [r0, #24]

	//step 5: ConControl auto refresh off
	ldr	r1, =0x0FFF1010					
348008f8:	e59f129c 	ldr	r1, [pc, #668]	; 34800b9c <display_addr+0xf0>
	str	r1, [r0, #DMC_CONCONTROL]
348008fc:	e5801000 	str	r1, [r0]
	//step 6: MemControl BL=4, 1 chip, DDR2 type, dynamic power down off
	ldr	r1, =0x00202400				
34800900:	e59f1298 	ldr	r1, [pc, #664]	; 34800ba0 <display_addr+0xf4>
	str	r1, [r0, #DMC_MEMCONTROL]
34800904:	e5801004 	str	r1, [r0, #4]
	//step 7: MemConfig0 512MB config, 8 banks,Mapping Method[12:15]0:linear 
	ldr	r1, =0x20E00323				
34800908:	e59f1294 	ldr	r1, [pc, #660]	; 34800ba4 <display_addr+0xf8>
	str	r1, [r0, #DMC_MEMCONFIG0]
3480090c:	e5801008 	str	r1, [r0, #8]
	//step 8:PrechConfig
	ldr	r1, =0xFF000000					
34800910:	e3a014ff 	mov	r1, #-16777216	; 0xff000000
	str	r1, [r0, #DMC_PRECHCONFIG]
34800914:	e5801014 	str	r1, [r0, #20]
	ldr	r1, =0xFFFF00FF					
34800918:	e3e01cff 	mvn	r1, #65280	; 0xff00
	str	r1, [r0, #DMC_PWRDNCONFIG]
3480091c:	e5801028 	str	r1, [r0, #40]	; 0x28

	//step 9:TimingAref	7.8us//133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
	ldr	r1, =0x0000040E				
34800920:	e59f1280 	ldr	r1, [pc, #640]	; 34800ba8 <display_addr+0xfc>
	str	r1, [r0, #DMC_TIMINGAREF]
34800924:	e5801030 	str	r1, [r0, #48]	; 0x30
	//TimingRow
	ldr	r1, =0x11122206				
34800928:	e59f127c 	ldr	r1, [pc, #636]	; 34800bac <display_addr+0x100>
	str	r1, [r0, #DMC_TIMINGROW]
3480092c:	e5801034 	str	r1, [r0, #52]	; 0x34
	//TimingData
	ldr	r1, =0x12240000				
34800930:	e59f1278 	ldr	r1, [pc, #632]	; 34800bb0 <display_addr+0x104>
	str	r1, [r0, #DMC_TIMINGDATA]
34800934:	e5801038 	str	r1, [r0, #56]	; 0x38
	//TimingPower
	ldr	r1, =0x05DC0343				
34800938:	e59f1274 	ldr	r1, [pc, #628]	; 34800bb4 <display_addr+0x108>
	str	r1, [r0, #DMC_TIMINGPOWER]
3480093c:	e580103c 	str	r1, [r0, #60]	; 0x3c

	//step 14:DirectCmd	chip0 NOP
	ldr	r1, =0x07000000					
34800940:	e3a01407 	mov	r1, #117440512	; 0x7000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800944:	e5801010 	str	r1, [r0, #16]
	//step 16:DirectCmd	chip0 PALL
	ldr	r1, =0x01000000					
34800948:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #DMC_DIRECTCMD]
3480094c:	e5801010 	str	r1, [r0, #16]
	//step 17:DirectCmd	chip0 EMRS2
	ldr	r1, =0x00020000					
34800950:	e3a01802 	mov	r1, #131072	; 0x20000
	str	r1, [r0, #DMC_DIRECTCMD]
34800954:	e5801010 	str	r1, [r0, #16]
	//step 18:DirectCmd	chip0 EMRS3
	ldr	r1, =0x00030000					
34800958:	e3a01803 	mov	r1, #196608	; 0x30000
	str	r1, [r0, #DMC_DIRECTCMD]
3480095c:	e5801010 	str	r1, [r0, #16]
	//step 19:DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
	ldr	r1, =0x00010000					
34800960:	e3a01801 	mov	r1, #65536	; 0x10000
	str	r1, [r0, #DMC_DIRECTCMD]
34800964:	e5801010 	str	r1, [r0, #16]
	//step 20:DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
	ldr	r1, =0x00000542					
34800968:	e59f1248 	ldr	r1, [pc, #584]	; 34800bb8 <display_addr+0x10c>
	str	r1, [r0, #DMC_DIRECTCMD]
3480096c:	e5801010 	str	r1, [r0, #16]
	//step 21:DirectCmd	chip0 PALL
	ldr	r1, =0x01000000					
34800970:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800974:	e5801010 	str	r1, [r0, #16]
	//step 22:DirectCmd	chip0 REFA
	ldr	r1, =0x05000000					
34800978:	e3a01405 	mov	r1, #83886080	; 0x5000000
	str	r1, [r0, #DMC_DIRECTCMD]
3480097c:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 REFA
	ldr	r1, =0x05000000					
34800980:	e3a01405 	mov	r1, #83886080	; 0x5000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800984:	e5801010 	str	r1, [r0, #16]
	//step 23:DirectCmd	chip0 MRS (MEM DLL unreset)
	ldr	r1, =0x00000442					
34800988:	e59f122c 	ldr	r1, [pc, #556]	; 34800bbc <display_addr+0x110>
	str	r1, [r0, #DMC_DIRECTCMD]
3480098c:	e5801010 	str	r1, [r0, #16]
	//step 25(1):DirectCmd	chip0 EMRS1 (OCD default)
	ldr	r1, =0x00010380					
34800990:	e59f1228 	ldr	r1, [pc, #552]	; 34800bc0 <display_addr+0x114>
	str	r1, [r0, #DMC_DIRECTCMD]
34800994:	e5801010 	str	r1, [r0, #16]
	//step 25(2)DirectCmd	chip0 EMRS1 (OCD exit)
	ldr	r1, =0x00010000					
34800998:	e3a01801 	mov	r1, #65536	; 0x10000
	str	r1, [r0, #DMC_DIRECTCMD]
3480099c:	e5801010 	str	r1, [r0, #16]
	
	//step 27:ConControl	auto refresh on
	ldr	r1, =0x0FF01030					
348009a0:	e59f121c 	ldr	r1, [pc, #540]	; 34800bc4 <display_addr+0x118>
	str	r1, [r0, #DMC_CONCONTROL]
348009a4:	e5801000 	str	r1, [r0]
	//step 28:MemControl	BL=4, 1 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	ldr	r1, =0x00202400					
348009a8:	e59f11f0 	ldr	r1, [pc, #496]	; 34800ba0 <display_addr+0xf4>
	str	r1, [r0, #DMC_MEMCONTROL]
348009ac:	e5801004 	str	r1, [r0, #4]


	ldr	r0,=0xE2900020
348009b0:	e59f0210 	ldr	r0, [pc, #528]	; 34800bc8 <display_addr+0x11c>
	ldr	r1,=0x44			@UTH0='D'
348009b4:	e3a01044 	mov	r1, #68	; 0x44
	str	r1,[r0]
348009b8:	e5801000 	str	r1, [r0]

	ldr	r1,=0x44			
348009bc:	e3a01044 	mov	r1, #68	; 0x44
	str	r1,[r0]				@UTH0='D'
348009c0:	e5801000 	str	r1, [r0]

	ldr	r1,=0x52			
348009c4:	e3a01052 	mov	r1, #82	; 0x52
	str	r1,[r0]				@UTH0='R'
348009c8:	e5801000 	str	r1, [r0]

	ldr	r1,=0x5F
348009cc:	e3a0105f 	mov	r1, #95	; 0x5f
	str	r1,[r0]				@UTH0='-'
348009d0:	e5801000 	str	r1, [r0]

	ldr	r1,=0x4F			
348009d4:	e3a0104f 	mov	r1, #79	; 0x4f
	str	r1,[r0]				@UTH0='O'
348009d8:	e5801000 	str	r1, [r0]

	ldr	r1,=0x6B
348009dc:	e3a0106b 	mov	r1, #107	; 0x6b
	str	r1,[r0]				@UTH0='k'
348009e0:	e5801000 	str	r1, [r0]

	ldr	r1,=0x21
348009e4:	e3a01021 	mov	r1, #33	; 0x21
	str	r1,[r0]				@UTH0='!'
348009e8:	e5801000 	str	r1, [r0]

	ldr	r1,=0xA
348009ec:	e3a0100a 	mov	r1, #10
	str	r1,[r0]				@UTH0='\r'
348009f0:	e5801000 	str	r1, [r0]

	ldr	r1,=0xD
348009f4:	e3a0100d 	mov	r1, #13
	str	r1,[r0]				@UTH0='\n'
348009f8:	e5801000 	str	r1, [r0]

	mov	pc, lr
348009fc:	e1a0f00e 	mov	pc, lr

34800a00 <display_addr_dat>:


.globl display_addr_dat
display_addr_dat:
	ldr r0, [r0]
34800a00:	e5900000 	ldr	r0, [r0]

	ldr r1, =0xE2900020
34800a04:	e59f11bc 	ldr	r1, [pc, #444]	; 34800bc8 <display_addr+0x11c>
	ldr r2, =0x30
34800a08:	e3a02030 	mov	r2, #48	; 0x30
	str r2, [r1]
34800a0c:	e5812000 	str	r2, [r1]
	ldr r2, =0x78
34800a10:	e3a02078 	mov	r2, #120	; 0x78
	str r2, [r1]		@dispaly  0x
34800a14:	e5812000 	str	r2, [r1]

	ldr r3, =28
34800a18:	e3a0301c 	mov	r3, #28

34800a1c <display_loop_cnt>:
display_loop_cnt:
	lsr 	r2, r0, r3
34800a1c:	e1a02330 	lsr	r2, r0, r3
	and 	r2, r2, #0xF
34800a20:	e202200f 	and	r2, r2, #15
	cmp 	r2, #10			@xian shi ascii ma
34800a24:	e352000a 	cmp	r2, #10
	addmi	r2, r2, #0x30
34800a28:	42822030 	addmi	r2, r2, #48	; 0x30
	addpl	r2, r2, #0x37
34800a2c:	52822037 	addpl	r2, r2, #55	; 0x37
	str 	r2, [r1]
34800a30:	e5812000 	str	r2, [r1]

	sub	r3, r3, #4
34800a34:	e2433004 	sub	r3, r3, #4
	cmp 	r3, #0
34800a38:	e3530000 	cmp	r3, #0
	bpl	display_loop_cnt
34800a3c:	5afffff6 	bpl	34800a1c <display_loop_cnt>

	ldr r2, =0xA
34800a40:	e3a0200a 	mov	r2, #10
	str r2, [r1]
34800a44:	e5812000 	str	r2, [r1]
	ldr r2, =0xD
34800a48:	e3a0200d 	mov	r2, #13
	str r2, [r1]
34800a4c:	e5812000 	str	r2, [r1]

	mov pc, lr
34800a50:	e1a0f00e 	mov	pc, lr

34800a54 <display_num_dat>:

.globl display_num_dat
display_num_dat:


	ldr r1, =0xE2900020
34800a54:	e59f116c 	ldr	r1, [pc, #364]	; 34800bc8 <display_addr+0x11c>
	ldr r2, =0x30
34800a58:	e3a02030 	mov	r2, #48	; 0x30
	str r2, [r1]
34800a5c:	e5812000 	str	r2, [r1]
	ldr r2, =0x78
34800a60:	e3a02078 	mov	r2, #120	; 0x78
	str r2, [r1]		@dispaly  0x
34800a64:	e5812000 	str	r2, [r1]

	ldr r3, =28
34800a68:	e3a0301c 	mov	r3, #28

34800a6c <display_loop_num>:
display_loop_num:
	lsr 	r2, r0, r3
34800a6c:	e1a02330 	lsr	r2, r0, r3
	and 	r2, r2, #0xF
34800a70:	e202200f 	and	r2, r2, #15
	cmp 	r2, #10			@xian shi ascii ma
34800a74:	e352000a 	cmp	r2, #10
	addmi	r2, r2, #0x30
34800a78:	42822030 	addmi	r2, r2, #48	; 0x30
	addpl	r2, r2, #0x37
34800a7c:	52822037 	addpl	r2, r2, #55	; 0x37
	str 	r2, [r1]
34800a80:	e5812000 	str	r2, [r1]

	sub	r3, r3, #4
34800a84:	e2433004 	sub	r3, r3, #4
	cmp 	r3, #0
34800a88:	e3530000 	cmp	r3, #0
	bpl	display_loop_num
34800a8c:	5afffff6 	bpl	34800a6c <display_loop_num>

	ldr r2, =0xA
34800a90:	e3a0200a 	mov	r2, #10
	str r2, [r1]
34800a94:	e5812000 	str	r2, [r1]
	ldr r2, =0xD
34800a98:	e3a0200d 	mov	r2, #13
	str r2, [r1]
34800a9c:	e5812000 	str	r2, [r1]

	mov pc, lr
34800aa0:	e1a0f00e 	mov	pc, lr

34800aa4 <display_put>:


.globl display_put
display_put:
	bl display_num_dat
34800aa4:	ebffffea 	bl	34800a54 <display_num_dat>
	mov pc, lr
34800aa8:	e1a0f00e 	mov	pc, lr

34800aac <display_addr>:

.globl display_addr
display_addr:
	mov r0, lr
34800aac:	e1a0000e 	mov	r0, lr
	//sub r0, #12
	bl display_num_dat
34800ab0:	ebffffe7 	bl	34800a54 <display_num_dat>
	bl display_addr_dat
34800ab4:	ebffffd1 	bl	34800a00 <display_addr_dat>
	mov pc, lr
34800ab8:	e1a0f00e 	mov	pc, lr
34800abc:	e0300000 	.word	0xe0300000
34800ac0:	e0200000 	.word	0xe0200000
34800ac4:	e010a000 	.word	0xe010a000
34800ac8:	e0f00000 	.word	0xe0f00000
34800acc:	e1f00000 	.word	0xe1f00000
34800ad0:	f1800000 	.word	0xf1800000
34800ad4:	f1900000 	.word	0xf1900000
34800ad8:	f1a00000 	.word	0xf1a00000
34800adc:	f1b00000 	.word	0xf1b00000
34800ae0:	f1c00000 	.word	0xf1c00000
34800ae4:	f1d00000 	.word	0xf1d00000
34800ae8:	f1e00000 	.word	0xf1e00000
34800aec:	f1f00000 	.word	0xf1f00000
34800af0:	faf00000 	.word	0xfaf00000
34800af4:	e010c300 	.word	0xe010c300
34800af8:	e0108200 	.word	0xe0108200
34800afc:	e010e000 	.word	0xe010e000
34800b00:	ea200000 	.word	0xea200000
34800b04:	e2700000 	.word	0xe2700000
34800b08:	e0200280 	.word	0xe0200280
34800b0c:	00001111 	.word	0x00001111
34800b10:	e0200284 	.word	0xe0200284
34800b14:	e0108304 	.word	0xe0108304
34800b18:	e010c200 	.word	0xe010c200
34800b1c:	e0100100 	.word	0xe0100100
34800b20:	e010f000 	.word	0xe010f000
34800b24:	e0100000 	.word	0xe0100000
34800b28:	81bc0400 	.word	0x81bc0400
34800b2c:	80590201 	.word	0x80590201
34800b30:	80870303 	.word	0x80870303
34800b34:	80600603 	.word	0x80600603
34800b38:	00003fff 	.word	0x00003fff
34800b3c:	00011301 	.word	0x00011301
34800b40:	00011110 	.word	0x00011110
34800b44:	e010c000 	.word	0xe010c000
34800b48:	03ff03ff 	.word	0x03ff03ff
34800b4c:	14131330 	.word	0x14131330
34800b50:	11110111 	.word	0x11110111
34800b54:	000002cf 	.word	0x000002cf
34800b58:	80c80601 	.word	0x80c80601
34800b5c:	829b0c01 	.word	0x829b0c01
34800b60:	80600602 	.word	0x80600602
34800b64:	806c0603 	.word	0x806c0603
34800b68:	10001111 	.word	0x10001111
34800b6c:	08fefeeb 	.word	0x08fefeeb
34800b70:	e9fdf0f9 	.word	0xe9fdf0f9
34800b74:	0f75f7fc 	.word	0x0f75f7fc
34800b78:	8eff038c 	.word	0x8eff038c
34800b7c:	e3800000 	.word	0xe3800000
34800b80:	f1500000 	.word	0xf1500000
34800b84:	22222222 	.word	0x22222222
34800b88:	e2900000 	.word	0xe2900000
34800b8c:	00000305 	.word	0x00000305
34800b90:	0000dfdd 	.word	0x0000dfdd
34800b94:	0010100a 	.word	0x0010100a
34800b98:	0010100b 	.word	0x0010100b
34800b9c:	0fff1010 	.word	0x0fff1010
34800ba0:	00202400 	.word	0x00202400
34800ba4:	20e00323 	.word	0x20e00323
34800ba8:	0000040e 	.word	0x0000040e
34800bac:	11122206 	.word	0x11122206
34800bb0:	12240000 	.word	0x12240000
34800bb4:	05dc0343 	.word	0x05dc0343
34800bb8:	00000542 	.word	0x00000542
34800bbc:	00000442 	.word	0x00000442
34800bc0:	00010380 	.word	0x00010380
34800bc4:	0ff01030 	.word	0x0ff01030
34800bc8:	e2900020 	.word	0xe2900020

34800bcc <copy_code_to_dram>:
	unsigned long dest = 0x34800000;
	unsigned int  sec_no = 49;

	unsigned int ret;

	ch = *(volatile unsigned int *)(0xD0037488);
34800bcc:	e59f3060 	ldr	r3, [pc, #96]	; 34800c34 <copy_code_to_dram+0x68>
typedef unsigned int (*copy_sd_mmc_to_mem) (unsigned int  channel, unsigned int  start_block, unsigned char block_size, unsigned int  *trg, unsigned int  init);


void copy_code_to_dram(void)
{
34800bd0:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	unsigned long dest = 0x34800000;
	unsigned int  sec_no = 49;

	unsigned int ret;

	ch = *(volatile unsigned int *)(0xD0037488);
34800bd4:	e5932488 	ldr	r2, [r3, #1160]	; 0x488

	copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem) (*(unsigned int *) (0xD0037F98));
34800bd8:	e5935f98 	ldr	r5, [r3, #3992]	; 0xf98
	
	if (ch == 0xEB000000)
34800bdc:	e35204eb 	cmp	r2, #-352321536	; 0xeb000000
34800be0:	1a000012 	bne	34800c30 <copy_code_to_dram+0x64>
	{
		// 0:channel 0
		// 49:secter num, 1 sector = 512 bytes
		ret = copy_bl2(0, sec_no,       128,(unsigned int *)dest, 0);
34800be4:	e3a04000 	mov	r4, #0
34800be8:	e3a01031 	mov	r1, #49	; 0x31
34800bec:	e3a02080 	mov	r2, #128	; 0x80
34800bf0:	e3a035d2 	mov	r3, #880803840	; 0x34800000
34800bf4:	e58d4000 	str	r4, [sp]
34800bf8:	e1a00004 	mov	r0, r4
34800bfc:	e12fff35 	blx	r5
		ret = copy_bl2(0, sec_no + 128, 128,(unsigned int *)(dest + 0x10000), 0);
34800c00:	e3a010b1 	mov	r1, #177	; 0xb1
34800c04:	e3a02080 	mov	r2, #128	; 0x80
34800c08:	e59f3028 	ldr	r3, [pc, #40]	; 34800c38 <copy_code_to_dram+0x6c>
34800c0c:	e58d4000 	str	r4, [sp]
34800c10:	e1a00004 	mov	r0, r4
34800c14:	e12fff35 	blx	r5
		ret = copy_bl2(0, sec_no + 256, 128,(unsigned int *)(dest + 0x20000), 0);
34800c18:	e58d4000 	str	r4, [sp]
34800c1c:	e1a00004 	mov	r0, r4
34800c20:	e3001131 	movw	r1, #305	; 0x131
34800c24:	e3a02080 	mov	r2, #128	; 0x80
34800c28:	e59f300c 	ldr	r3, [pc, #12]	; 34800c3c <copy_code_to_dram+0x70>
34800c2c:	e12fff35 	blx	r5
		/*
		for(i = 0; i < 18*1024; i++) 
			copy_bl2(0, fs_sec_no + i*2, 2, (unsigned int *)(fs_dest + i*1024), 0);
		*/
	}
}
34800c30:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34800c34:	d0037000 	.word	0xd0037000
34800c38:	34810000 	.word	0x34810000
34800c3c:	34820000 	.word	0x34820000

34800c40 <s5pc1xx_phy_control>:
}
#endif

#ifdef CONFIG_USB_GADGET
static int s5pc1xx_phy_control(int on)
{
34800c40:	e92d4070 	push	{r4, r5, r6, lr}
34800c44:	e1a06000 	mov	r6, r0
	int ret;
	static int status;
	struct pmic *p = get_pmic();
34800c48:	eb0041b6 	bl	34811328 <get_pmic>
34800c4c:	e1a05000 	mov	r5, r0

	if (pmic_probe(p))
34800c50:	eb004211 	bl	3481149c <pmic_probe>
34800c54:	e3500000 	cmp	r0, #0
34800c58:	1a00002c 	bne	34800d10 <s5pc1xx_phy_control+0xd0>
		return -1;

	if (on && !status) {
34800c5c:	e3560000 	cmp	r6, #0
34800c60:	e59f40b0 	ldr	r4, [pc, #176]	; 34800d18 <s5pc1xx_phy_control+0xd8>
34800c64:	0a000011 	beq	34800cb0 <s5pc1xx_phy_control+0x70>
34800c68:	e5943000 	ldr	r3, [r4]
34800c6c:	e3530000 	cmp	r3, #0
34800c70:	1a000022 	bne	34800d00 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800c74:	e3a01011 	mov	r1, #17
34800c78:	e3a02004 	mov	r2, #4
34800c7c:	e2833001 	add	r3, r3, #1
34800c80:	e1a00005 	mov	r0, r5
34800c84:	eb004191 	bl	348112d0 <pmic_set_output>
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800c88:	e3a03001 	mov	r3, #1
34800c8c:	e1a00005 	mov	r0, r5
34800c90:	e3a01012 	mov	r1, #18
34800c94:	e3a02020 	mov	r2, #32
34800c98:	eb00418c 	bl	348112d0 <pmic_set_output>
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800c9c:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
34800ca0:	03a03001 	moveq	r3, #1
34800ca4:	05843000 	streq	r3, [r4]
	if (on && !status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800ca8:	0a000014 	beq	34800d00 <s5pc1xx_phy_control+0xc0>
34800cac:	ea00000f 	b	34800cf0 <s5pc1xx_phy_control+0xb0>
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
	} else if (!on && status) {
34800cb0:	e5943000 	ldr	r3, [r4]
34800cb4:	e3530000 	cmp	r3, #0
34800cb8:	0a000010 	beq	34800d00 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800cbc:	e3a01011 	mov	r1, #17
34800cc0:	e3a02004 	mov	r2, #4
34800cc4:	e1a03006 	mov	r3, r6
34800cc8:	e1a00005 	mov	r0, r5
34800ccc:	eb00417f 	bl	348112d0 <pmic_set_output>
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800cd0:	e1a00005 	mov	r0, r5
34800cd4:	e3a01012 	mov	r1, #18
34800cd8:	e3a02020 	mov	r2, #32
34800cdc:	e1a03006 	mov	r3, r6
34800ce0:	eb00417a 	bl	348112d0 <pmic_set_output>
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800ce4:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 0;
34800ce8:	05840000 	streq	r0, [r4]
	} else if (!on && status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800cec:	0a000003 	beq	34800d00 <s5pc1xx_phy_control+0xc0>
			puts("MAX8998 LDO setting error!\n");
34800cf0:	e59f0024 	ldr	r0, [pc, #36]	; 34800d1c <s5pc1xx_phy_control+0xdc>
34800cf4:	eb002369 	bl	34809aa0 <puts>
			return -1;
34800cf8:	e3e00000 	mvn	r0, #0
34800cfc:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
		status = 0;
	}
	udelay(10000);
34800d00:	e3020710 	movw	r0, #10000	; 0x2710
34800d04:	eb006ef2 	bl	3481c8d4 <udelay>

	return 0;
34800d08:	e3a00000 	mov	r0, #0
34800d0c:	e8bd8070 	pop	{r4, r5, r6, pc}
	int ret;
	static int status;
	struct pmic *p = get_pmic();

	if (pmic_probe(p))
		return -1;
34800d10:	e3e00000 	mvn	r0, #0
		status = 0;
	}
	udelay(10000);

	return 0;
}
34800d14:	e8bd8070 	pop	{r4, r5, r6, pc}
34800d18:	34829854 	.word	0x34829854
34800d1c:	348227f4 	.word	0x348227f4

34800d20 <board_init>:
DECLARE_GLOBAL_DATA_PTR;

static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
34800d20:	e92d4008 	push	{r3, lr}
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800d24:	e59f2028 	ldr	r2, [pc, #40]	; 34800d54 <board_init+0x34>
34800d28:	e59f3028 	ldr	r3, [pc, #40]	; 34800d58 <board_init+0x38>

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d2c:	e3001b2e 	movw	r1, #2862	; 0xb2e
static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800d30:	e5832004 	str	r2, [r3, #4]

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d34:	e5982000 	ldr	r2, [r8]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800d38:	e5983000 	ldr	r3, [r8]
int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d3c:	e5821004 	str	r1, [r2, #4]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800d40:	e59f2014 	ldr	r2, [pc, #20]	; 34800d5c <board_init+0x3c>
34800d44:	e5832008 	str	r2, [r3, #8]

#if defined(CONFIG_PMIC)
	pmic_init();
34800d48:	eb0041e1 	bl	348114d4 <pmic_init>
#endif
	return 0;
}
34800d4c:	e3a00000 	mov	r0, #0
34800d50:	e8bd8008 	pop	{r3, pc}
34800d54:	e0200000 	.word	0xe0200000
34800d58:	34829854 	.word	0x34829854
34800d5c:	20000100 	.word	0x20000100

34800d60 <dram_init>:

int dram_init(void)
{
	gd->ram_size = PHYS_SDRAM_1_SIZE;
34800d60:	e3a02202 	mov	r2, #536870912	; 0x20000000
34800d64:	e5882038 	str	r2, [r8, #56]	; 0x38

	return 0;
}
34800d68:	e3a00000 	mov	r0, #0
34800d6c:	e12fff1e 	bx	lr

34800d70 <dram_init_banksize>:

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800d70:	e5981000 	ldr	r1, [r8]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800d74:	e5982000 	ldr	r2, [r8]
	return 0;
}

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800d78:	e3a03202 	mov	r3, #536870912	; 0x20000000
34800d7c:	e5813018 	str	r3, [r1, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800d80:	e582301c 	str	r3, [r2, #28]
}
34800d84:	e12fff1e 	bx	lr

34800d88 <checkboard>:

#ifdef CONFIG_DISPLAY_BOARDINFO
int checkboard(void)
{
34800d88:	e92d4008 	push	{r3, lr}
	puts("Board:\tGoni\n");
34800d8c:	e59f0008 	ldr	r0, [pc, #8]	; 34800d9c <checkboard+0x14>
34800d90:	eb002342 	bl	34809aa0 <puts>
	return 0;
}
34800d94:	e3a00000 	mov	r0, #0
34800d98:	e8bd8008 	pop	{r3, pc}
34800d9c:	34822810 	.word	0x34822810

34800da0 <board_mmc_init>:
#endif

#ifdef CONFIG_GENERIC_MMC
int board_mmc_init(bd_t *bis)
{
34800da0:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	/* MASSMEMORY_EN: XMSMDATA7: GPJ2[7] output high */
	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
34800da4:	e59f5098 	ldr	r5, [pc, #152]	; 34800e44 <board_mmc_init+0xa4>
34800da8:	e3a01007 	mov	r1, #7
34800dac:	e5950004 	ldr	r0, [r5, #4]
34800db0:	e3a02001 	mov	r2, #1
34800db4:	e2800d0a 	add	r0, r0, #640	; 0x280
34800db8:	eb003de1 	bl	34810544 <s5p_gpio_direction_output>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800dbc:	e3a04000 	mov	r4, #0
		if (i == 2)
34800dc0:	e3540002 	cmp	r4, #2
34800dc4:	0a00000e 	beq	34800e04 <board_mmc_init+0x64>
			continue;
		/* GPG0[0:6] special function 2 */
		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
34800dc8:	e5950004 	ldr	r0, [r5, #4]
34800dcc:	e1a01004 	mov	r1, r4
34800dd0:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800dd4:	e3a02002 	mov	r2, #2
34800dd8:	eb003dd2 	bl	34810528 <s5p_gpio_cfg_pin>
		/* GPG0[0:6] pull disable */
		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
34800ddc:	e5950004 	ldr	r0, [r5, #4]
34800de0:	e1a01004 	mov	r1, r4
34800de4:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800de8:	e3a02000 	mov	r2, #0
34800dec:	eb003df2 	bl	348105bc <s5p_gpio_set_pull>
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
34800df0:	e5950004 	ldr	r0, [r5, #4]
34800df4:	e1a01004 	mov	r1, r4
34800df8:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800dfc:	e3a02003 	mov	r2, #3
34800e00:	eb003df6 	bl	348105e0 <s5p_gpio_set_drv>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800e04:	e2844001 	add	r4, r4, #1
34800e08:	e3540007 	cmp	r4, #7
34800e0c:	1affffeb 	bne	34800dc0 <board_mmc_init+0x20>
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800e10:	e59f3030 	ldr	r3, [pc, #48]	; 34800e48 <board_mmc_init+0xa8>
34800e14:	e5933000 	ldr	r3, [r3]
}

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
34800e18:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800e1c:	059f0028 	ldreq	r0, [pc, #40]	; 34800e4c <board_mmc_init+0xac>
34800e20:	0a000003 	beq	34800e34 <board_mmc_init+0x94>
34800e24:	e30c0110 	movw	r0, #49424	; 0xc110
34800e28:	e1530000 	cmp	r3, r0
34800e2c:	03a004eb 	moveq	r0, #-352321536	; 0xeb000000
34800e30:	13a00000 	movne	r0, #0
int s5p_sdhci_init(u32 regbase, int index, int bus_width);

static inline unsigned int s5p_mmc_init(int index, int bus_width)
{
	unsigned int base = samsung_get_base_mmc() + (0x10000 * index);
	return s5p_sdhci_init(base, index, bus_width);
34800e34:	e3a01000 	mov	r1, #0
34800e38:	e3a02004 	mov	r2, #4
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
	}

	return s5p_mmc_init(0, 4);
}
34800e3c:	e8bd4070 	pop	{r4, r5, r6, lr}
34800e40:	ea004984 	b	34813458 <s5p_sdhci_init>
34800e44:	34829854 	.word	0x34829854
34800e48:	34828288 	.word	0x34828288
34800e4c:	ed800000 	.word	0xed800000

34800e50 <onenand_board_init>:
#include <linux/mtd/samsung_onenand.h>
#include <onenand_uboot.h>

void onenand_board_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34800e50:	e5903094 	ldr	r3, [r0, #148]	; 0x94

	this->base = (void *)CONFIG_SYS_ONENAND_BASE;
34800e54:	e3a0220b 	mov	r2, #-1342177280	; 0xb0000000
34800e58:	e5832000 	str	r2, [r3]
	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34800e5c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
34800e60:	e3822c02 	orr	r2, r2, #512	; 0x200
34800e64:	e583202c 	str	r2, [r3, #44]	; 0x2c
	this->chip_probe = s5pc110_chip_probe;
34800e68:	e59f2004 	ldr	r2, [pc, #4]	; 34800e74 <onenand_board_init+0x24>
34800e6c:	e5832070 	str	r2, [r3, #112]	; 0x70
}
34800e70:	e12fff1e 	bx	lr
34800e74:	348183e8 	.word	0x348183e8

34800e78 <v7_maint_dcache_all>:
						   way_shift, log2_line_len);
	}
}

static void v7_maint_dcache_all(u32 operation)
{
34800e78:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800e7c:	ee301f30 	mrc	15, 1, r1, cr0, cr0, {1}
	}
}

static void v7_maint_dcache_all(u32 operation)
{
	u32 level, cache_type, level_start_bit = 0;
34800e80:	e3a03000 	mov	r3, #0
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800e84:	e58d1004 	str	r1, [sp, #4]
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800e88:	e1a0c003 	mov	ip, r3
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800e8c:	e1a05003 	mov	r5, r3
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
34800e90:	e59d1004 	ldr	r1, [sp, #4]
34800e94:	e1a02331 	lsr	r2, r1, r3
34800e98:	e2022007 	and	r2, r2, #7
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
34800e9c:	e2422002 	sub	r2, r2, #2

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
34800ea0:	e3520002 	cmp	r2, #2
34800ea4:	8a00002a 	bhi	34800f54 <v7_maint_dcache_all+0xdc>
/*
 * Write the level and type you want to Cache Size Selection Register(CSSELR)
 * to get size details from Current Cache Size ID Register(CCSIDR)
 */
static void set_csselr(u32 level, u32 type)
{	u32 csselr = level << 1 | type;
34800ea8:	e1a0408c 	lsl	r4, ip, #1

	/* Write to Cache Size Selection Register(CSSELR) */
	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
34800eac:	ee404f10 	mcr	15, 2, r4, cr0, cr0, {0}
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800eb0:	ee307f10 	mrc	15, 1, r7, cr0, cr0, {0}
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800eb4:	e7e921d7 	ubfx	r2, r7, #3, #10

	set_csselr(level, ARMV7_CSSELR_IND_DATA_UNIFIED);

	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800eb8:	e2076007 	and	r6, r7, #7
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800ebc:	e2829001 	add	r9, r2, #1
	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;
34800ec0:	e2866004 	add	r6, r6, #4

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
			CCSIDR_ASSOCIATIVITY_OFFSET) + 1;
	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
34800ec4:	e7ee76d7 	ubfx	r7, r7, #13, #15
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800ec8:	e1a01009 	mov	r1, r9
#ifndef _UTILS_H_
#define _UTILS_H_

static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
34800ecc:	e3e0a000 	mvn	sl, #0
	u32 temp = n;

	while (temp) {
34800ed0:	e1b010a1 	lsrs	r1, r1, #1
		log2n++;
34800ed4:	e28aa001 	add	sl, sl, #1
static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
	u32 temp = n;

	while (temp) {
34800ed8:	1afffffc 	bne	34800ed0 <v7_maint_dcache_all+0x58>
		log2n++;
		temp >>= 1;
	}

	if (n & (n - 1))
34800edc:	e1190002 	tst	r9, r2
		return log2n + 1; /* not power of 2 - round up */
34800ee0:	128aa001 	addne	sl, sl, #1
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800ee4:	e3500001 	cmp	r0, #1
	 * According to ARMv7 ARM number of sets and number of ways need
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
34800ee8:	e26aa020 	rsb	sl, sl, #32
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800eec:	1a00000b 	bne	34800f20 <v7_maint_dcache_all+0xa8>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800ef0:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800ef4:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800ef8:	e1a09004 	mov	r9, r4
34800efc:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/* Invalidate data/unified cache line by set/way */
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
34800f00:	ee074f56 	mcr	15, 0, r4, cr7, cr6, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800f04:	e2511001 	subs	r1, r1, #1
34800f08:	2afffffb 	bcs	34800efc <v7_maint_dcache_all+0x84>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800f0c:	e2522001 	subs	r2, r2, #1
34800f10:	e1a04009 	mov	r4, r9
34800f14:	2afffff5 	bcs	34800ef0 <v7_maint_dcache_all+0x78>
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800f18:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
34800f1c:	ea00000c 	b	34800f54 <v7_maint_dcache_all+0xdc>

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
		v7_inval_dcache_level_setway(level, num_sets, num_ways,
				      way_shift, log2_line_len);
	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
34800f20:	e3500002 	cmp	r0, #2
34800f24:	1a00000a 	bne	34800f54 <v7_maint_dcache_all+0xdc>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800f28:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800f2c:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800f30:	e1a09004 	mov	r9, r4
34800f34:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/*
			 * Clean & Invalidate data/unified
			 * cache line by set/way
			 */
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
34800f38:	ee074f5e 	mcr	15, 0, r4, cr7, cr14, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800f3c:	e2511001 	subs	r1, r1, #1
34800f40:	2afffffb 	bcs	34800f34 <v7_maint_dcache_all+0xbc>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800f44:	e2522001 	subs	r2, r2, #1
34800f48:	e1a04009 	mov	r4, r9
34800f4c:	2afffff5 	bcs	34800f28 <v7_maint_dcache_all+0xb0>
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800f50:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800f54:	e3530012 	cmp	r3, #18
34800f58:	e28cc001 	add	ip, ip, #1
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
			v7_maint_dcache_level_setway(level, operation);
		level_start_bit += 3;
34800f5c:	12833003 	addne	r3, r3, #3
34800f60:	1affffca 	bne	34800e90 <v7_maint_dcache_all+0x18>
	}
}
34800f64:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34800f68 <v7_dcache_maint_range>:
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
	}
}

static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
34800f68:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34800f6c:	e1a04000 	mov	r4, r0
34800f70:	e1a06001 	mov	r6, r1
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800f74:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
	u32 line_len, ccsidr;

	ccsidr = get_ccsidr();
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800f78:	e2055007 	and	r5, r5, #7
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
34800f7c:	e2855004 	add	r5, r5, #4
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34800f80:	e3a03001 	mov	r3, #1

	switch (range_op) {
34800f84:	e3520003 	cmp	r2, #3
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34800f88:	e1a05513 	lsl	r5, r3, r5

	switch (range_op) {
34800f8c:	0a000009 	beq	34800fb8 <v7_dcache_maint_range+0x50>
34800f90:	e3520004 	cmp	r2, #4
					u32 stop, u32 line_len)
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
34800f94:	02653000 	rsbeq	r3, r5, #0
34800f98:	00034000 	andeq	r4, r3, r0
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;

	switch (range_op) {
34800f9c:	1a00001d 	bne	34801018 <v7_dcache_maint_range+0xb0>
34800fa0:	ea000001 	b	34800fac <v7_dcache_maint_range+0x44>

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCCIMVAC - Clean & Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
34800fa4:	ee074f3e 	mcr	15, 0, r4, cr7, cr14, {1}
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
34800fa8:	e0844005 	add	r4, r4, r5
34800fac:	e1540006 	cmp	r4, r6
34800fb0:	3afffffb 	bcc	34800fa4 <v7_dcache_maint_range+0x3c>
34800fb4:	ea000017 	b	34801018 <v7_dcache_maint_range+0xb0>

	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
34800fb8:	e2457001 	sub	r7, r5, #1
34800fbc:	e1170000 	tst	r7, r0
34800fc0:	0a000007 	beq	34800fe4 <v7_dcache_maint_range+0x7c>
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34800fc4:	e1a02004 	mov	r2, r4
34800fc8:	e59f0054 	ldr	r0, [pc, #84]	; 34801024 <v7_dcache_maint_range+0xbc>
34800fcc:	e59f1054 	ldr	r1, [pc, #84]	; 34801028 <v7_dcache_maint_range+0xc0>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34800fd0:	e2444001 	sub	r4, r4, #1
	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34800fd4:	eb0022bb 	bl	34809ac8 <printf>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34800fd8:	e0844005 	add	r4, r4, r5
34800fdc:	e2653000 	rsb	r3, r5, #0
34800fe0:	e0034004 	and	r4, r3, r4

	/*
	 * If stop address is not aligned to cache-line do not
	 * invalidate the last cache-line
	 */
	if (stop & (line_len - 1)) {
34800fe4:	e1170006 	tst	r7, r6
34800fe8:	0a000008 	beq	34801010 <v7_dcache_maint_range+0xa8>
		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
34800fec:	e1a02006 	mov	r2, r6
34800ff0:	e59f0034 	ldr	r0, [pc, #52]	; 3480102c <v7_dcache_maint_range+0xc4>
34800ff4:	e59f102c 	ldr	r1, [pc, #44]	; 34801028 <v7_dcache_maint_range+0xc0>
34800ff8:	eb0022b2 	bl	34809ac8 <printf>
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
34800ffc:	e2653000 	rsb	r3, r5, #0
34801000:	e0066003 	and	r6, r6, r3
34801004:	ea000001 	b	34801010 <v7_dcache_maint_range+0xa8>
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCIMVAC - Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
34801008:	ee074f36 	mcr	15, 0, r4, cr7, cr6, {1}
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
3480100c:	e0844005 	add	r4, r4, r5
34801010:	e1540006 	cmp	r4, r6
34801014:	3afffffb 	bcc	34801008 <v7_dcache_maint_range+0xa0>
		v7_dcache_inval_range(start, stop, line_len);
		break;
	}

	/* DSB to make sure the operation is complete */
	CP15DSB;
34801018:	e3a03000 	mov	r3, #0
3480101c:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
34801020:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34801024:	3482281d 	.word	0x3482281d
34801028:	34820078 	.word	0x34820078
3480102c:	34822850 	.word	0x34822850

34801030 <invalidate_dcache_all>:
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
}

void invalidate_dcache_all(void)
{
34801030:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
34801034:	e3a00001 	mov	r0, #1
34801038:	ebffff8e 	bl	34800e78 <v7_maint_dcache_all>

	v7_outer_cache_inval_all();
}
3480103c:	e8bd4010 	pop	{r4, lr}

void invalidate_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);

	v7_outer_cache_inval_all();
34801040:	ea00002b 	b	348010f4 <__v7_outer_cache_inval_all>

34801044 <flush_dcache_all>:
/*
 * Performs a clean & invalidation of the entire data cache
 * at all levels
 */
void flush_dcache_all(void)
{
34801044:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
34801048:	e3a00002 	mov	r0, #2
3480104c:	ebffff89 	bl	34800e78 <v7_maint_dcache_all>

	v7_outer_cache_flush_all();
}
34801050:	e8bd4010 	pop	{r4, lr}
 */
void flush_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);

	v7_outer_cache_flush_all();
34801054:	ea000025 	b	348010f0 <__v7_outer_cache_flush_all>

34801058 <invalidate_dcache_range>:
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34801058:	e92d4070 	push	{r4, r5, r6, lr}

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
3480105c:	e3a02003 	mov	r2, #3
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34801060:	e1a05000 	mov	r5, r0
34801064:	e1a04001 	mov	r4, r1

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34801068:	ebffffbe 	bl	34800f68 <v7_dcache_maint_range>

	v7_outer_cache_inval_range(start, stop);
3480106c:	e1a00005 	mov	r0, r5
34801070:	e1a01004 	mov	r1, r4
}
34801074:	e8bd4070 	pop	{r4, r5, r6, lr}
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);

	v7_outer_cache_inval_range(start, stop);
34801078:	ea00001f 	b	348010fc <__v7_outer_cache_inval_range>

3480107c <flush_dcache_range>:
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
3480107c:	e92d4070 	push	{r4, r5, r6, lr}
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
34801080:	e3a02004 	mov	r2, #4
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
34801084:	e1a05000 	mov	r5, r0
34801088:	e1a04001 	mov	r4, r1
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
3480108c:	ebffffb5 	bl	34800f68 <v7_dcache_maint_range>

	v7_outer_cache_flush_range(start, stop);
34801090:	e1a00005 	mov	r0, r5
34801094:	e1a01004 	mov	r1, r4
}
34801098:	e8bd4070 	pop	{r4, r5, r6, lr}
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);

	v7_outer_cache_flush_range(start, stop);
3480109c:	ea000015 	b	348010f8 <__v7_outer_cache_flush_range>

348010a0 <arm_init_before_mmu>:
}

void arm_init_before_mmu(void)
{
348010a0:	e92d4008 	push	{r3, lr}
	v7_outer_cache_enable();
348010a4:	eb00023d 	bl	348019a0 <v7_outer_cache_enable>
	invalidate_dcache_all();
348010a8:	ebffffe0 	bl	34801030 <invalidate_dcache_all>

/* Invalidate TLB */
static void v7_inval_tlb(void)
{
	/* Invalidate entire unified TLB */
	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
348010ac:	e3a03000 	mov	r3, #0
348010b0:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
	/* Invalidate entire data TLB */
	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
348010b4:	ee083f16 	mcr	15, 0, r3, cr8, cr6, {0}
	/* Invalidate entire instruction TLB */
	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
348010b8:	ee083f15 	mcr	15, 0, r3, cr8, cr5, {0}
	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
348010bc:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
348010c0:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
void arm_init_before_mmu(void)
{
	v7_outer_cache_enable();
	invalidate_dcache_all();
	v7_inval_tlb();
}
348010c4:	e8bd8008 	pop	{r3, pc}

348010c8 <flush_cache>:
 * Flush range from all levels of d-cache/unified-cache used:
 * Affects the range [start, start + size - 1]
 */
void  flush_cache(unsigned long start, unsigned long size)
{
	flush_dcache_range(start, start + size);
348010c8:	e0811000 	add	r1, r1, r0
348010cc:	eaffffea 	b	3480107c <flush_dcache_range>

348010d0 <invalidate_icache_all>:
{
	/*
	 * Invalidate all instruction caches to PoU.
	 * Also flushes branch target cache.
	 */
	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
348010d0:	e3a03000 	mov	r3, #0
348010d4:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}

	/* Invalidate entire branch predictor array */
	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
348010d8:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}

	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
348010dc:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}

	/* ISB - make sure the instruction stream sees it */
	CP15ISB;
348010e0:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
}
348010e4:	e12fff1e 	bx	lr

348010e8 <__v7_outer_cache_enable>:
/*
 * Stub implementations for outer cache operations
 */
void __v7_outer_cache_enable(void)
{
}
348010e8:	e12fff1e 	bx	lr

348010ec <__v7_outer_cache_disable>:
void v7_outer_cache_enable(void)
	__attribute__((weak, alias("__v7_outer_cache_enable")));

void __v7_outer_cache_disable(void)
{
}
348010ec:	e12fff1e 	bx	lr

348010f0 <__v7_outer_cache_flush_all>:
void v7_outer_cache_disable(void)
	__attribute__((weak, alias("__v7_outer_cache_disable")));

void __v7_outer_cache_flush_all(void)
{
}
348010f0:	e12fff1e 	bx	lr

348010f4 <__v7_outer_cache_inval_all>:
void v7_outer_cache_flush_all(void)
	__attribute__((weak, alias("__v7_outer_cache_flush_all")));

void __v7_outer_cache_inval_all(void)
{
}
348010f4:	e12fff1e 	bx	lr

348010f8 <__v7_outer_cache_flush_range>:
void v7_outer_cache_inval_all(void)
	__attribute__((weak, alias("__v7_outer_cache_inval_all")));

void __v7_outer_cache_flush_range(u32 start, u32 end)
{
}
348010f8:	e12fff1e 	bx	lr

348010fc <__v7_outer_cache_inval_range>:
void v7_outer_cache_flush_range(u32 start, u32 end)
	__attribute__((weak, alias("__v7_outer_cache_flush_range")));

void __v7_outer_cache_inval_range(u32 start, u32 end)
{
}
348010fc:	e12fff1e 	bx	lr

34801100 <cpu_cache_initialization>:
#include <asm/system.h>
#include <asm/cache.h>
#include <asm/armv7.h>
#include <linux/compiler.h>

void __weak cpu_cache_initialization(void){}
34801100:	e12fff1e 	bx	lr

34801104 <cleanup_before_linux>:

int cleanup_before_linux(void)
{
34801104:	e92d4008 	push	{r3, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */
#ifndef CONFIG_SPL_BUILD
	disable_interrupts();
34801108:	eb000386 	bl	34801f28 <disable_interrupts>
#endif

	/*
	 * Turn off I-cache and invalidate it
	 */
	icache_disable();
3480110c:	eb000476 	bl	348022ec <icache_disable>
	invalidate_icache_all();
34801110:	ebffffee 	bl	348010d0 <invalidate_icache_all>

	/*
	 * turn off D-cache
	 * dcache_disable() in turn flushes the d-cache and disables MMU
	 */
	dcache_disable();
34801114:	eb00047b 	bl	34802308 <dcache_disable>
	v7_outer_cache_disable();
34801118:	eb000225 	bl	348019b4 <v7_outer_cache_disable>
	 * is all we did during this. We have not pushed anything on to the
	 * stack. Neither have we affected any static data)
	 * So just invalidate the entire d-cache again to avoid coherency
	 * problems for kernel
	 */
	invalidate_dcache_all();
3480111c:	ebffffc3 	bl	34801030 <invalidate_dcache_all>

	/*
	 * Some CPU need more cache attention before starting the kernel.
	 */
	cpu_cache_initialization();
34801120:	ebfffff6 	bl	34801100 <cpu_cache_initialization>

	return 0;
}
34801124:	e3a00000 	mov	r0, #0
34801128:	e8bd8008 	pop	{r3, pc}

3480112c <sdelay>:
 *
 *  not inline to increase chances its in cache when called
 *************************************************************/
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
3480112c:	e2500001 	subs	r0, r0, #1
34801130:	1afffffd 	bne	3480112c <sdelay>
			  "bne 1b":"=r" (loops):"0"(loops));
}
34801134:	e12fff1e 	bx	lr

34801138 <sr32>:
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34801138:	e3a0c001 	mov	ip, #1

/*****************************************************************
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
3480113c:	e92d4010 	push	{r4, lr}
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34801140:	e1a0c21c 	lsl	ip, ip, r2
	--msk;
	tmp = readl((u32)addr) & ~(msk << start_bit);
34801144:	e5904000 	ldr	r4, [r0]
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
34801148:	e24cc001 	sub	ip, ip, #1
	tmp = readl((u32)addr) & ~(msk << start_bit);
3480114c:	e1c4c11c 	bic	ip, r4, ip, lsl r1
	tmp |= value << start_bit;
34801150:	e18c1113 	orr	r1, ip, r3, lsl r1
	writel(tmp, (u32)addr);
34801154:	e5801000 	str	r1, [r0]
}
34801158:	e8bd8010 	pop	{r4, pc}

3480115c <wait_on_value>:
 * wait_on_value() - common routine to allow waiting for changes in
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
3480115c:	e92d4010 	push	{r4, lr}
	u32 i = 0, val;
34801160:	e3a0c000 	mov	ip, #0
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
34801164:	e5924000 	ldr	r4, [r2]
34801168:	e0044000 	and	r4, r4, r0
		if (val == match_value)
3480116c:	e1540001 	cmp	r4, r1
34801170:	0a000004 	beq	34801188 <wait_on_value+0x2c>
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
	u32 i = 0, val;
	do {
		++i;
34801174:	e28cc001 	add	ip, ip, #1
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
		if (i == bound)
34801178:	e15c0003 	cmp	ip, r3
3480117c:	1afffff8 	bne	34801164 <wait_on_value+0x8>
			return 0;
34801180:	e3a00000 	mov	r0, #0
34801184:	e8bd8010 	pop	{r4, pc}
	u32 i = 0, val;
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
34801188:	e3a00001 	mov	r0, #1
		if (i == bound)
			return 0;
	} while (1);
}
3480118c:	e8bd8010 	pop	{r4, pc}

34801190 <arch_cpu_init>:
/* CPU detection macros */
extern unsigned int s5p_cpu_id;

static inline void s5p_set_cpu_id(void)
{
	s5p_cpu_id = readl(S5PC100_PRO_ID);
34801190:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
34801194:	e5932000 	ldr	r2, [r3]
	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
34801198:	e59f3010 	ldr	r3, [pc, #16]	; 348011b0 <arch_cpu_init+0x20>
3480119c:	e7eb2652 	ubfx	r2, r2, #12, #12
348011a0:	e3822903 	orr	r2, r2, #49152	; 0xc000
348011a4:	e5832000 	str	r2, [r3]
int arch_cpu_init(void)
{
	s5p_set_cpu_id();

	return 0;
}
348011a8:	e3a00000 	mov	r0, #0
348011ac:	e12fff1e 	bx	lr
348011b0:	34828288 	.word	0x34828288

348011b4 <get_device_type>:
#endif

u32 get_device_type(void)
{
	return s5p_cpu_id;
}
348011b4:	e59f3004 	ldr	r3, [pc, #4]	; 348011c0 <get_device_type+0xc>
348011b8:	e5930000 	ldr	r0, [r3]
348011bc:	e12fff1e 	bx	lr
348011c0:	34828288 	.word	0x34828288

348011c4 <print_cpuinfo>:

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
348011c4:	e92d4010 	push	{r4, lr}
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
348011c8:	e59f3034 	ldr	r3, [pc, #52]	; 34801204 <print_cpuinfo+0x40>
	return s5p_cpu_id;
}

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
348011cc:	e24dd020 	sub	sp, sp, #32
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
348011d0:	e5934000 	ldr	r4, [r3]
348011d4:	eb0001c5 	bl	348018f0 <get_arm_clk>
348011d8:	e1a01000 	mov	r1, r0
348011dc:	e1a0000d 	mov	r0, sp
348011e0:	eb006da0 	bl	3481c868 <strmhz>
348011e4:	e59f101c 	ldr	r1, [pc, #28]	; 34801208 <print_cpuinfo+0x44>
348011e8:	e1a03000 	mov	r3, r0
348011ec:	e1a02004 	mov	r2, r4
348011f0:	e59f0014 	ldr	r0, [pc, #20]	; 3480120c <print_cpuinfo+0x48>
348011f4:	eb002233 	bl	34809ac8 <printf>
			s5p_get_cpu_name(), s5p_cpu_id,
			strmhz(buf, get_arm_clk()));

	return 0;
}
348011f8:	e3a00000 	mov	r0, #0
348011fc:	e28dd020 	add	sp, sp, #32
34801200:	e8bd8010 	pop	{r4, pc}
34801204:	34828288 	.word	0x34828288
34801208:	34822893 	.word	0x34822893
3480120c:	34822882 	.word	0x34822882

34801210 <s5p_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801210:	e59f3028 	ldr	r3, [pc, #40]	; 34801240 <s5p_get_base_timer+0x30>
34801214:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34801218:	e3530cc1 	cmp	r3, #49408	; 0xc100
3480121c:	0a000005 	beq	34801238 <s5p_get_base_timer+0x28>
34801220:	e30c0110 	movw	r0, #49424	; 0xc110
34801224:	e59f2018 	ldr	r2, [pc, #24]	; 34801244 <s5p_get_base_timer+0x34>
34801228:	e1530000 	cmp	r3, r0
3480122c:	01a00002 	moveq	r0, r2
34801230:	13a00000 	movne	r0, #0
34801234:	e12fff1e 	bx	lr
34801238:	e3a004ea 	mov	r0, #-369098752	; 0xea000000

/* macro to read the 16 bit timer */
static inline struct s5p_timer *s5p_get_base_timer(void)
{
	return (struct s5p_timer *)samsung_get_base_timer();
}
3480123c:	e12fff1e 	bx	lr
34801240:	34828288 	.word	0x34828288
34801244:	e2500000 	.word	0xe2500000

34801248 <reset_timer_masked>:
	while (get_current_tick() < tmo)
		;	/* nop */
}

void reset_timer_masked(void)
{
34801248:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
3480124c:	ebffffef 	bl	34801210 <s5p_get_base_timer>

	/* reset time */
	gd->lastinc = readl(&timer->tcnto4);
34801250:	e5902040 	ldr	r2, [r0, #64]	; 0x40
34801254:	e5882030 	str	r2, [r8, #48]	; 0x30
	gd->tbl = 0;
34801258:	e3a02000 	mov	r2, #0
3480125c:	e5882020 	str	r2, [r8, #32]
}
34801260:	e8bd8008 	pop	{r3, pc}

34801264 <timer_init>:
{
	return (struct s5p_timer *)samsung_get_base_timer();
}

int timer_init(void)
{
34801264:	e92d4008 	push	{r3, lr}
	/* PWM Timer 4 */
	pwm_init(4, MUX_DIV_2, 0);
34801268:	e3a01001 	mov	r1, #1
3480126c:	e3a02000 	mov	r2, #0
34801270:	e3a00004 	mov	r0, #4
34801274:	eb0000f2 	bl	34801644 <pwm_init>
	pwm_config(4, 0, 0);
34801278:	e3a01000 	mov	r1, #0
3480127c:	e1a02001 	mov	r2, r1
34801280:	e3a00004 	mov	r0, #4
34801284:	eb0000a3 	bl	34801518 <pwm_config>
	pwm_enable(4);
34801288:	e3a00004 	mov	r0, #4
3480128c:	eb000088 	bl	348014b4 <pwm_enable>

	reset_timer_masked();
34801290:	ebffffec 	bl	34801248 <reset_timer_masked>

	return 0;
}
34801294:	e3a00000 	mov	r0, #0
34801298:	e8bd8008 	pop	{r3, pc}

3480129c <get_current_tick>:

	return get_current_tick() / count_value;
}

unsigned long get_current_tick(void)
{
3480129c:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348012a0:	ebffffda 	bl	34801210 <s5p_get_base_timer>
	unsigned long now = readl(&timer->tcnto4);
348012a4:	e5902040 	ldr	r2, [r0, #64]	; 0x40
	unsigned long count_value = readl(&timer->tcntb4);
348012a8:	e590103c 	ldr	r1, [r0, #60]	; 0x3c

	if (gd->lastinc >= now)
348012ac:	e5980030 	ldr	r0, [r8, #48]	; 0x30
348012b0:	e1500002 	cmp	r0, r2
		gd->tbl += gd->lastinc - now;
	else
		gd->tbl += gd->lastinc + count_value - now;
348012b4:	3598c020 	ldrcc	ip, [r8, #32]
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
348012b8:	25981020 	ldrcs	r1, [r8, #32]
	else
		gd->tbl += gd->lastinc + count_value - now;
348012bc:	35980030 	ldrcc	r0, [r8, #48]	; 0x30
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
348012c0:	25980030 	ldrcs	r0, [r8, #48]	; 0x30
	else
		gd->tbl += gd->lastinc + count_value - now;
348012c4:	308c1001 	addcc	r1, ip, r1
348012c8:	e0811000 	add	r1, r1, r0
348012cc:	e0621001 	rsb	r1, r2, r1
348012d0:	e5881020 	str	r1, [r8, #32]

	gd->lastinc = now;
348012d4:	e5882030 	str	r2, [r8, #48]	; 0x30

	return gd->tbl;
348012d8:	e5980020 	ldr	r0, [r8, #32]
}
348012dc:	e8bd8008 	pop	{r3, pc}

348012e0 <get_timer_masked>:
	gd->lastinc = readl(&timer->tcnto4);
	gd->tbl = 0;
}

unsigned long get_timer_masked(void)
{
348012e0:	e92d4010 	push	{r4, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348012e4:	ebffffc9 	bl	34801210 <s5p_get_base_timer>
	unsigned long count_value = readl(&timer->tcntb4);
348012e8:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	return get_current_tick() / count_value;
348012ec:	ebffffea 	bl	3480129c <get_current_tick>
348012f0:	e1a01004 	mov	r1, r4
348012f4:	eb007a33 	bl	3481fbc8 <__udivsi3>
}
348012f8:	e8bd8010 	pop	{r4, pc}

348012fc <get_timer>:

/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
348012fc:	e92d4010 	push	{r4, lr}
34801300:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
34801304:	ebfffff5 	bl	348012e0 <get_timer_masked>
}
34801308:	e0640000 	rsb	r0, r4, r0
3480130c:	e8bd8010 	pop	{r4, pc}

34801310 <__udelay>:

/* delay x useconds */
void __udelay(unsigned long usec)
{
34801310:	e92d4038 	push	{r3, r4, r5, lr}
34801314:	e1a05000 	mov	r5, r0
	struct s5p_timer *const timer = s5p_get_base_timer();
34801318:	ebffffbc 	bl	34801210 <s5p_get_base_timer>
	unsigned long tmo, tmp, count_value;

	count_value = readl(&timer->tcntb4);
3480131c:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	if (usec >= 1000) {
34801320:	e3550ffa 	cmp	r5, #1000	; 0x3e8
34801324:	3a000006 	bcc	34801344 <__udelay+0x34>
		 * to seconds
		 * 1. start to normalize for usec to ticks per sec
		 * 2. find number of "ticks" to wait to achieve target
		 * 3. finish normalize.
		 */
		tmo = usec / 1000;
34801328:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3480132c:	e1a00005 	mov	r0, r5
34801330:	eb007a24 	bl	3481fbc8 <__udivsi3>
		tmo *= (CONFIG_SYS_HZ * count_value);
34801334:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34801338:	e0040491 	mul	r4, r1, r4
		tmo /= 1000;
3480133c:	e0000490 	mul	r0, r0, r4
34801340:	ea000003 	b	34801354 <__udelay+0x44>
	} else {
		/* else small number, don't kill it prior to HZ multiply */
		tmo = usec * CONFIG_SYS_HZ * count_value;
34801344:	e3a03ffa 	mov	r3, #1000	; 0x3e8
34801348:	e0040493 	mul	r4, r3, r4
		tmo /= (1000 * 1000);
3480134c:	e0000495 	mul	r0, r5, r4
34801350:	e59f1030 	ldr	r1, [pc, #48]	; 34801388 <__udelay+0x78>
34801354:	eb007a1b 	bl	3481fbc8 <__udivsi3>
34801358:	e1a05000 	mov	r5, r0
	}

	/* get current timestamp */
	tmp = get_current_tick();
3480135c:	ebffffce 	bl	3480129c <get_current_tick>

	/* if setting this fordward will roll time stamp */
	/* reset "advancing" timestamp to 0, set lastinc value */
	/* else, set advancing stamp wake up time */
	if ((tmo + tmp + 1) < tmp)
34801360:	e0804005 	add	r4, r0, r5
34801364:	e2843001 	add	r3, r4, #1
34801368:	e1530000 	cmp	r3, r0
3480136c:	2a000001 	bcs	34801378 <__udelay+0x68>
		reset_timer_masked();
34801370:	ebffffb4 	bl	34801248 <reset_timer_masked>
34801374:	e1a04005 	mov	r4, r5
	else
		tmo += tmp;

	/* loop till event */
	while (get_current_tick() < tmo)
34801378:	ebffffc7 	bl	3480129c <get_current_tick>
3480137c:	e1500004 	cmp	r0, r4
34801380:	3afffffc 	bcc	34801378 <__udelay+0x68>
		;	/* nop */
}
34801384:	e8bd8038 	pop	{r3, r4, r5, pc}
34801388:	000f4240 	.word	0x000f4240

3480138c <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
3480138c:	e92d4008 	push	{r3, lr}
/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
	return get_timer_masked() - base;
34801390:	ebffffd2 	bl	348012e0 <get_timer_masked>
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
	return get_timer(0);
}
34801394:	e3a01000 	mov	r1, #0
34801398:	e8bd8008 	pop	{r3, pc}

3480139c <get_tbclk>:
 * On ARM it returns the number of timer ticks per second.
 */
unsigned long get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
3480139c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348013a0:	e12fff1e 	bx	lr

348013a4 <s5p_config_sromc>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348013a4:	e59f3040 	ldr	r3, [pc, #64]	; 348013ec <s5p_config_sromc+0x48>
 * srom_bank	- SROM
 * srom_bw_conf  - SMC Band witdh reg configuration value
 * srom_bc_conf  - SMC Bank Control reg configuration value
 */
void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf)
{
348013a8:	e92d4010 	push	{r4, lr}
348013ac:	e5933000 	ldr	r3, [r3]

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
348013b0:	e3530cc1 	cmp	r3, #49408	; 0xc100
348013b4:	03a034e7 	moveq	r3, #-419430400	; 0xe7000000
348013b8:	0a000003 	beq	348013cc <s5p_config_sromc+0x28>
348013bc:	e30cc110 	movw	ip, #49424	; 0xc110
348013c0:	e153000c 	cmp	r3, ip
348013c4:	03a0333a 	moveq	r3, #-402653184	; 0xe8000000
348013c8:	13a03000 	movne	r3, #0
	u32 tmp;
	struct s5p_sromc *srom =
		(struct s5p_sromc *)samsung_get_base_sromc();

	/* Configure SMC_BW register to handle proper SROMC bank */
	tmp = srom->bw;
348013cc:	e593c000 	ldr	ip, [r3]
	tmp &= ~(0xF << (srom_bank * 4));
348013d0:	e1a00100 	lsl	r0, r0, #2
348013d4:	e3a0400f 	mov	r4, #15
348013d8:	e1ccc014 	bic	ip, ip, r4, lsl r0
	tmp |= srom_bw_conf;
348013dc:	e18c1001 	orr	r1, ip, r1
	srom->bw = tmp;
348013e0:	e6831000 	str	r1, [r3], r0

	/* Configure SMC_BC register */
	srom->bc[srom_bank] = srom_bc_conf;
348013e4:	e5832004 	str	r2, [r3, #4]
}
348013e8:	e8bd8010 	pop	{r4, pc}
348013ec:	34828288 	.word	0x34828288

348013f0 <samsung_get_base_watchdog>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348013f0:	e59f3028 	ldr	r3, [pc, #40]	; 34801420 <samsung_get_base_watchdog+0x30>
348013f4:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
348013f8:	e3530cc1 	cmp	r3, #49408	; 0xc100
348013fc:	0a000005 	beq	34801418 <samsung_get_base_watchdog+0x28>
34801400:	e30c0110 	movw	r0, #49424	; 0xc110
34801404:	e59f2018 	ldr	r2, [pc, #24]	; 34801424 <samsung_get_base_watchdog+0x34>
34801408:	e1530000 	cmp	r3, r0
3480140c:	01a00002 	moveq	r0, r2
34801410:	13a00000 	movne	r0, #0
34801414:	e12fff1e 	bx	lr
34801418:	e59f0008 	ldr	r0, [pc, #8]	; 34801428 <samsung_get_base_watchdog+0x38>
3480141c:	e12fff1e 	bx	lr
34801420:	34828288 	.word	0x34828288
34801424:	e2700000 	.word	0xe2700000
34801428:	ea200000 	.word	0xea200000

3480142c <wdt_stop>:
#include <asm/arch/watchdog.h>

#define PRESCALER_VAL 255

void wdt_stop(void)
{
3480142c:	e92d4008 	push	{r3, lr}
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
34801430:	ebffffee 	bl	348013f0 <samsung_get_base_watchdog>
	unsigned int wtcon;

	wtcon = readl(&wdt->wtcon);
34801434:	e5903000 	ldr	r3, [r0]
	wtcon &= ~(WTCON_EN | WTCON_INT | WTCON_RESET);
34801438:	e3c33025 	bic	r3, r3, #37	; 0x25

	writel(wtcon, &wdt->wtcon);
3480143c:	e5803000 	str	r3, [r0]
}
34801440:	e8bd8008 	pop	{r3, pc}

34801444 <wdt_start>:

void wdt_start(unsigned int timeout)
{
34801444:	e92d4038 	push	{r3, r4, r5, lr}
34801448:	e1a04000 	mov	r4, r0
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
3480144c:	ebffffe7 	bl	348013f0 <samsung_get_base_watchdog>
34801450:	e1a05000 	mov	r5, r0
	unsigned int wtcon;

	wdt_stop();
34801454:	ebfffff4 	bl	3480142c <wdt_stop>

	wtcon = readl(&wdt->wtcon);
34801458:	e5953000 	ldr	r3, [r5]
	wtcon |= (WTCON_EN | WTCON_CLK(WTCON_CLK_128));
3480145c:	e3833038 	orr	r3, r3, #56	; 0x38
	wtcon &= ~WTCON_INT;
34801460:	e3c33004 	bic	r3, r3, #4
	wtcon |= WTCON_RESET;
	wtcon |= WTCON_PRESCALER(PRESCALER_VAL);
34801464:	e3833cff 	orr	r3, r3, #65280	; 0xff00
34801468:	e3833001 	orr	r3, r3, #1

	writel(timeout, &wdt->wtdat);
3480146c:	e5854004 	str	r4, [r5, #4]
	writel(timeout, &wdt->wtcnt);
34801470:	e5854008 	str	r4, [r5, #8]
	writel(wtcon, &wdt->wtcon);
34801474:	e5853000 	str	r3, [r5]
}
34801478:	e8bd8038 	pop	{r3, r4, r5, pc}

3480147c <samsung_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
3480147c:	e59f3028 	ldr	r3, [pc, #40]	; 348014ac <samsung_get_base_timer+0x30>
34801480:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34801484:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801488:	0a000005 	beq	348014a4 <samsung_get_base_timer+0x28>
3480148c:	e30c0110 	movw	r0, #49424	; 0xc110
34801490:	e59f2018 	ldr	r2, [pc, #24]	; 348014b0 <samsung_get_base_timer+0x34>
34801494:	e1530000 	cmp	r3, r0
34801498:	01a00002 	moveq	r0, r2
3480149c:	13a00000 	movne	r0, #0
348014a0:	e12fff1e 	bx	lr
348014a4:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
348014a8:	e12fff1e 	bx	lr
348014ac:	34828288 	.word	0x34828288
348014b0:	e2500000 	.word	0xe2500000

348014b4 <pwm_enable>:
#include <asm/io.h>
#include <asm/arch/pwm.h>
#include <asm/arch/clk.h>

int pwm_enable(int pwm_id)
{
348014b4:	e92d4010 	push	{r4, lr}
348014b8:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348014bc:	ebffffee 	bl	3480147c <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
348014c0:	e5903008 	ldr	r3, [r0, #8]
	tcon |= TCON_START(pwm_id);
348014c4:	e3540000 	cmp	r4, #0
348014c8:	12844001 	addne	r4, r4, #1
348014cc:	03a04000 	moveq	r4, #0
348014d0:	e3a02001 	mov	r2, #1
348014d4:	e1a04104 	lsl	r4, r4, #2
348014d8:	e1834412 	orr	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
348014dc:	e5804008 	str	r4, [r0, #8]

	return 0;
}
348014e0:	e3a00000 	mov	r0, #0
348014e4:	e8bd8010 	pop	{r4, pc}

348014e8 <pwm_disable>:

void pwm_disable(int pwm_id)
{
348014e8:	e92d4010 	push	{r4, lr}
348014ec:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348014f0:	ebffffe1 	bl	3480147c <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
348014f4:	e5903008 	ldr	r3, [r0, #8]
	tcon &= ~TCON_START(pwm_id);
348014f8:	e3540000 	cmp	r4, #0
348014fc:	12844001 	addne	r4, r4, #1
34801500:	03a04000 	moveq	r4, #0
34801504:	e3a02001 	mov	r2, #1
34801508:	e1a04104 	lsl	r4, r4, #2
3480150c:	e1c34412 	bic	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
34801510:	e5804008 	str	r4, [r0, #8]
}
34801514:	e8bd8010 	pop	{r4, pc}

34801518 <pwm_config>:
}

#define NS_IN_HZ (1000000000UL)

int pwm_config(int pwm_id, int duty_ns, int period_ns)
{
34801518:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480151c:	e1a05001 	mov	r5, r1
34801520:	e1a07002 	mov	r7, r2
34801524:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801528:	ebffffd3 	bl	3480147c <samsung_get_base_timer>
3480152c:	e1a06000 	mov	r6, r0
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34801530:	e59f0108 	ldr	r0, [pc, #264]	; 34801640 <pwm_config+0x128>
34801534:	e1550000 	cmp	r5, r0
34801538:	91570000 	cmpls	r7, r0
		return -ERANGE;
3480153c:	83e00021 	mvnhi	r0, #33	; 0x21
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34801540:	8a00003d 	bhi	3480163c <pwm_config+0x124>
		return -ERANGE;

	if (duty_ns > period_ns)
34801544:	e1550007 	cmp	r5, r7
		return -EINVAL;
34801548:	c3e00015 	mvngt	r0, #21
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
		return -ERANGE;

	if (duty_ns > period_ns)
3480154c:	ca00003a 	bgt	3480163c <pwm_config+0x124>
		return -EINVAL;

	period = NS_IN_HZ / period_ns;
34801550:	e1a01007 	mov	r1, r7
34801554:	eb00799b 	bl	3481fbc8 <__udivsi3>
34801558:	e58d0004 	str	r0, [sp, #4]
static unsigned long pwm_calc_tin(int pwm_id, unsigned long freq)
{
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();
3480155c:	eb0000fd 	bl	34801958 <get_pwm_clk>
34801560:	e3a0b004 	mov	fp, #4
34801564:	e1a09000 	mov	r9, r0

	for (div = 2; div <= 16; div *= 2) {
34801568:	e3a0a002 	mov	sl, #2
		if ((tin_parent_rate / (div << 16)) < freq)
3480156c:	e1a00009 	mov	r0, r9
34801570:	e1a0180a 	lsl	r1, sl, #16
34801574:	eb007993 	bl	3481fbc8 <__udivsi3>
34801578:	e59d3004 	ldr	r3, [sp, #4]
3480157c:	e1500003 	cmp	r0, r3
34801580:	2a000004 	bcs	34801598 <pwm_config+0x80>
			return tin_parent_rate / div;
34801584:	e1a0100a 	mov	r1, sl
34801588:	e1a00009 	mov	r0, r9
3480158c:	eb00798d 	bl	3481fbc8 <__udivsi3>
34801590:	e1a01000 	mov	r1, r0
34801594:	ea000003 	b	348015a8 <pwm_config+0x90>
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();

	for (div = 2; div <= 16; div *= 2) {
34801598:	e25bb001 	subs	fp, fp, #1
3480159c:	e1a0a08a 	lsl	sl, sl, #1
348015a0:	1afffff1 	bne	3480156c <pwm_config+0x54>
		if ((tin_parent_rate / (div << 16)) < freq)
			return tin_parent_rate / div;
	}

	return tin_parent_rate / 16;
348015a4:	e1a01229 	lsr	r1, r9, #4
	period = NS_IN_HZ / period_ns;

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
348015a8:	e59f0090 	ldr	r0, [pc, #144]	; 34801640 <pwm_config+0x128>
348015ac:	eb007985 	bl	3481fbc8 <__udivsi3>
348015b0:	e1a0a000 	mov	sl, r0
	tcnt = period_ns / tin_ns;
348015b4:	e1a0100a 	mov	r1, sl
348015b8:	e1a00007 	mov	r0, r7
348015bc:	eb007981 	bl	3481fbc8 <__udivsi3>

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
348015c0:	e1a0100a 	mov	r1, sl

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
	tcnt = period_ns / tin_ns;
348015c4:	e1a07000 	mov	r7, r0

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
348015c8:	e1a00005 	mov	r0, r5
348015cc:	eb00797d 	bl	3481fbc8 <__udivsi3>
	tcmp = tcnt - tcmp;
348015d0:	e0600007 	rsb	r0, r0, r7

	/*
	 * the pwm hw only checks the compare register after a decrement,
	 * so the pin never toggles if tcmp = tcnt
	 */
	if (tcmp == tcnt)
348015d4:	e1500007 	cmp	r0, r7
		tcmp--;
348015d8:	02400001 	subeq	r0, r0, #1
	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
	if (pwm_id < 4) {
348015dc:	e3540003 	cmp	r4, #3
348015e0:	ca000004 	bgt	348015f8 <pwm_config+0xe0>

	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
348015e4:	e0843084 	add	r3, r4, r4, lsl #1
	if (pwm_id < 4) {
		writel(tcnt, &pwm->tcntb0 + offset);
348015e8:	e286200c 	add	r2, r6, #12
348015ec:	e7827103 	str	r7, [r2, r3, lsl #2]
		writel(tcmp, &pwm->tcmpb0 + offset);
348015f0:	e2862010 	add	r2, r6, #16
348015f4:	e7820103 	str	r0, [r2, r3, lsl #2]
	}

	tcon = readl(&pwm->tcon);
348015f8:	e5961008 	ldr	r1, [r6, #8]
	tcon |= TCON_UPDATE(pwm_id);
348015fc:	e3540000 	cmp	r4, #0
34801600:	1284c001 	addne	ip, r4, #1
34801604:	03a0c000 	moveq	ip, #0
34801608:	e1a0c10c 	lsl	ip, ip, #2
3480160c:	e3a00001 	mov	r0, #1
34801610:	e28c2001 	add	r2, ip, #1
34801614:	e1a02210 	lsl	r2, r0, r2
	if (pwm_id < 4)
34801618:	e3540003 	cmp	r4, #3
		writel(tcnt, &pwm->tcntb0 + offset);
		writel(tcmp, &pwm->tcmpb0 + offset);
	}

	tcon = readl(&pwm->tcon);
	tcon |= TCON_UPDATE(pwm_id);
3480161c:	e1821001 	orr	r1, r2, r1
	if (pwm_id < 4)
		tcon |= TCON_AUTO_RELOAD(pwm_id);
34801620:	d28c3003 	addle	r3, ip, #3
34801624:	d1813310 	orrle	r3, r1, r0, lsl r3
	else
		tcon |= TCON4_AUTO_RELOAD;
34801628:	c3813501 	orrgt	r3, r1, #4194304	; 0x400000
	writel(tcon, &pwm->tcon);
3480162c:	e5863008 	str	r3, [r6, #8]

	tcon &= ~TCON_UPDATE(pwm_id);
34801630:	e1c33002 	bic	r3, r3, r2
	writel(tcon, &pwm->tcon);

	return 0;
34801634:	e3a00000 	mov	r0, #0
	else
		tcon |= TCON4_AUTO_RELOAD;
	writel(tcon, &pwm->tcon);

	tcon &= ~TCON_UPDATE(pwm_id);
	writel(tcon, &pwm->tcon);
34801638:	e5863008 	str	r3, [r6, #8]

	return 0;
}
3480163c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34801640:	3b9aca00 	.word	0x3b9aca00

34801644 <pwm_init>:

int pwm_init(int pwm_id, int div, int invert)
{
34801644:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
34801648:	e1a04000 	mov	r4, r0
3480164c:	e1a07001 	mov	r7, r1
34801650:	e1a0a002 	mov	sl, r2
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801654:	ebffff88 	bl	3480147c <samsung_get_base_timer>
	/*
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
34801658:	e5903000 	ldr	r3, [r0]

int pwm_init(int pwm_id, int div, int invert)
{
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
3480165c:	e1a05000 	mov	r5, r0
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
34801660:	e3540001 	cmp	r4, #1
		prescaler = PRESCALER_0;
		val &= ~0xff;
34801664:	d3c330ff 	bicle	r3, r3, #255	; 0xff
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
34801668:	c3c33cff 	bicgt	r3, r3, #65280	; 0xff00

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
3480166c:	d3833007 	orrle	r3, r3, #7
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
34801670:	d3a09007 	movle	r9, #7
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
34801674:	c3833c0f 	orrgt	r3, r3, #3840	; 0xf00
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
34801678:	c3a0900f 	movgt	r9, #15
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
	}
	writel(val, &pwm->tcfg0);
3480167c:	e5803000 	str	r3, [r0]
	val = readl(&pwm->tcfg1);
34801680:	e5902004 	ldr	r2, [r0, #4]
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
34801684:	e3a0600f 	mov	r6, #15
34801688:	e1a03104 	lsl	r3, r4, #2
3480168c:	e1c22316 	bic	r2, r2, r6, lsl r3
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
34801690:	e0071006 	and	r1, r7, r6
34801694:	e1823311 	orr	r3, r2, r1, lsl r3
	writel(val, &pwm->tcfg1);
34801698:	e5803004 	str	r3, [r0, #4]

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
3480169c:	eb0000ad 	bl	34801958 <get_pwm_clk>
348016a0:	e2899001 	add	r9, r9, #1
			(div + 1));
348016a4:	e2871001 	add	r1, r7, #1
	val = readl(&pwm->tcfg1);
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
	writel(val, &pwm->tcfg1);

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
348016a8:	e0010991 	mul	r1, r1, r9
348016ac:	eb007945 	bl	3481fbc8 <__udivsi3>
			(div + 1));

	timer_rate_hz = timer_rate_hz / CONFIG_SYS_HZ;
348016b0:	e3a01ffa 	mov	r1, #1000	; 0x3e8
348016b4:	eb007943 	bl	3481fbc8 <__udivsi3>

	/* set count value */
	offset = pwm_id * 3;
348016b8:	e0842084 	add	r2, r4, r4, lsl #1
	writel(timer_rate_hz, &pwm->tcntb0 + offset);
348016bc:	e285300c 	add	r3, r5, #12
348016c0:	e7830102 	str	r0, [r3, r2, lsl #2]

	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
348016c4:	e5952008 	ldr	r2, [r5, #8]
348016c8:	e3540000 	cmp	r4, #0
348016cc:	12843001 	addne	r3, r4, #1
348016d0:	03a03000 	moveq	r3, #0
348016d4:	e1a03103 	lsl	r3, r3, #2
348016d8:	e1c26316 	bic	r6, r2, r6, lsl r3
	if (invert && (pwm_id < 4))
348016dc:	e25aa000 	subs	sl, sl, #0
348016e0:	13a0a001 	movne	sl, #1
348016e4:	e3540003 	cmp	r4, #3
348016e8:	c3a0a000 	movgt	sl, #0
348016ec:	e35a0000 	cmp	sl, #0
		val |= TCON_INVERTER(pwm_id);
348016f0:	12833002 	addne	r3, r3, #2
348016f4:	13a02001 	movne	r2, #1
348016f8:	11866312 	orrne	r6, r6, r2, lsl r3
	writel(val, &pwm->tcon);
348016fc:	e5856008 	str	r6, [r5, #8]

	pwm_enable(pwm_id);
34801700:	e1a00004 	mov	r0, r4
34801704:	ebffff6a 	bl	348014b4 <pwm_enable>

	return 0;
}
34801708:	e3a00000 	mov	r0, #0
3480170c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	...

34801720 <samsung_get_base_clock>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801720:	e59f3028 	ldr	r3, [pc, #40]	; 34801750 <samsung_get_base_clock+0x30>
34801724:	e5933000 	ldr	r3, [r3]
		return S5PC110_##base;				\
	else							\
		return 0;					\
}

SAMSUNG_BASE(clock, CLOCK_BASE)
34801728:	e3530cc1 	cmp	r3, #49408	; 0xc100
3480172c:	0a000005 	beq	34801748 <samsung_get_base_clock+0x28>
34801730:	e30c0110 	movw	r0, #49424	; 0xc110
34801734:	e59f2018 	ldr	r2, [pc, #24]	; 34801754 <samsung_get_base_clock+0x34>
34801738:	e1530000 	cmp	r3, r0
3480173c:	01a00002 	moveq	r0, r2
34801740:	13a00000 	movne	r0, #0
34801744:	e12fff1e 	bx	lr
34801748:	e59f0004 	ldr	r0, [pc, #4]	; 34801754 <samsung_get_base_clock+0x34>
3480174c:	e12fff1e 	bx	lr
34801750:	34828288 	.word	0x34828288
34801754:	e0100000 	.word	0xe0100000

34801758 <get_pll_clk>:
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
34801758:	e92d4038 	push	{r3, r4, r5, lr}
	if (cpu_is_s5pc110())
3480175c:	e59f3114 	ldr	r3, [pc, #276]	; 34801878 <get_pll_clk+0x120>
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
34801760:	e1a05000 	mov	r5, r0
	if (cpu_is_s5pc110())
34801764:	e5932000 	ldr	r2, [r3]
34801768:	e30c3110 	movw	r3, #49424	; 0xc110
3480176c:	e1520003 	cmp	r2, r3
34801770:	1a000020 	bne	348017f8 <get_pll_clk+0xa0>

/* s5pc100: return pll clock frequency */
static unsigned long s5pc110_get_pll_clk(int pllreg)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801774:	ebffffe9 	bl	34801720 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
34801778:	e3550004 	cmp	r5, #4
3480177c:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34801780:	ea00002d 	b	3480183c <get_pll_clk+0xe4>
34801784:	34801798 	.word	0x34801798
34801788:	348017a0 	.word	0x348017a0
3480178c:	348017a8 	.word	0x348017a8
34801790:	3480183c 	.word	0x3480183c
34801794:	348017b0 	.word	0x348017b0
	case APLL:
		r = readl(&clk->apll_con);
34801798:	e5903100 	ldr	r3, [r0, #256]	; 0x100
3480179c:	ea000004 	b	348017b4 <get_pll_clk+0x5c>
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
348017a0:	e5903108 	ldr	r3, [r0, #264]	; 0x108
348017a4:	ea000002 	b	348017b4 <get_pll_clk+0x5c>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
348017a8:	e5903110 	ldr	r3, [r0, #272]	; 0x110
348017ac:	ea000000 	b	348017b4 <get_pll_clk+0x5c>
		break;
	case VPLL:
		r = readl(&clk->vpll_con);
348017b0:	e5903120 	ldr	r3, [r0, #288]	; 0x120
	 * MPLL_CON: MIDV [25:16]
	 * EPLL_CON: MIDV [24:16]
	 * VPLL_CON: MIDV [24:16]
	 */
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
348017b4:	e3550001 	cmp	r5, #1
348017b8:	e30023ff 	movw	r2, #1023	; 0x3ff
348017bc:	e30041ff 	movw	r4, #511	; 0x1ff
348017c0:	91a04002 	movls	r4, r2
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
348017c4:	e3550000 	cmp	r5, #0
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
	else
		mask = 0x1ff;

	m = (r >> 16) & mask;
348017c8:	e0044823 	and	r4, r4, r3, lsr #16

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
348017cc:	e7e51453 	ubfx	r1, r3, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;
348017d0:	e2033007 	and	r3, r3, #7

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
348017d4:	1a000002 	bne	348017e4 <get_pll_clk+0x8c>
		if (s < 1)
			s = 1;
348017d8:	e3530000 	cmp	r3, #0
348017dc:	03a03001 	moveq	r3, #1
		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
		fout = m * (freq / (p * (1 << (s - 1))));
348017e0:	e2433001 	sub	r3, r3, #1
	} else
		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
		fout = m * (freq / (p * (1 << s)));
348017e4:	e59f0090 	ldr	r0, [pc, #144]	; 3480187c <get_pll_clk+0x124>
348017e8:	e1a01311 	lsl	r1, r1, r3
348017ec:	eb0078f5 	bl	3481fbc8 <__udivsi3>
348017f0:	e0000490 	mul	r0, r0, r4
348017f4:	e8bd8038 	pop	{r3, r4, r5, pc}

/* s5pc110: return pll clock frequency */
static unsigned long s5pc100_get_pll_clk(int pllreg)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
348017f8:	ebffffc8 	bl	34801720 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
348017fc:	e3550003 	cmp	r5, #3
34801800:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34801804:	ea00000c 	b	3480183c <get_pll_clk+0xe4>
34801808:	34801818 	.word	0x34801818
3480180c:	34801824 	.word	0x34801824
34801810:	3480182c 	.word	0x3480182c
34801814:	34801834 	.word	0x34801834
	case APLL:
		r = readl(&clk->apll_con);
34801818:	e5904100 	ldr	r4, [r0, #256]	; 0x100
	 * MPLL_CON: MIDV [23:16]
	 * EPLL_CON: MIDV [23:16]
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
3480181c:	e30053ff 	movw	r5, #1023	; 0x3ff
34801820:	ea00000a 	b	34801850 <get_pll_clk+0xf8>
	switch (pllreg) {
	case APLL:
		r = readl(&clk->apll_con);
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34801824:	e5904104 	ldr	r4, [r0, #260]	; 0x104
34801828:	ea000010 	b	34801870 <get_pll_clk+0x118>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
3480182c:	e5904108 	ldr	r4, [r0, #264]	; 0x108
34801830:	ea00000e 	b	34801870 <get_pll_clk+0x118>
		break;
	case HPLL:
		r = readl(&clk->hpll_con);
34801834:	e590410c 	ldr	r4, [r0, #268]	; 0x10c
34801838:	ea00000c 	b	34801870 <get_pll_clk+0x118>
		break;
	default:
		printf("Unsupported PLL (%d)\n", pllreg);
3480183c:	e59f003c 	ldr	r0, [pc, #60]	; 34801880 <get_pll_clk+0x128>
34801840:	e1a01005 	mov	r1, r5
34801844:	eb00209f 	bl	34809ac8 <printf>
		return 0;
34801848:	e3a00000 	mov	r0, #0
3480184c:	e8bd8038 	pop	{r3, r4, r5, pc}
	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;
34801850:	e2043007 	and	r3, r4, #7
		mask = 0x0ff;

	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
34801854:	e7e51454 	ubfx	r1, r4, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
34801858:	e1a01311 	lsl	r1, r1, r3
3480185c:	e59f0020 	ldr	r0, [pc, #32]	; 34801884 <get_pll_clk+0x12c>
34801860:	eb0078d8 	bl	3481fbc8 <__udivsi3>
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;

	m = (r >> 16) & mask;
34801864:	e0054824 	and	r4, r5, r4, lsr #16
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
34801868:	e0000094 	mul	r0, r4, r0
{
	if (cpu_is_s5pc110())
		return s5pc110_get_pll_clk(pllreg);
	else
		return s5pc100_get_pll_clk(pllreg);
}
3480186c:	e8bd8038 	pop	{r3, r4, r5, pc}
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;
34801870:	e3a050ff 	mov	r5, #255	; 0xff
34801874:	eafffff5 	b	34801850 <get_pll_clk+0xf8>
34801878:	34828288 	.word	0x34828288
3480187c:	016e3600 	.word	0x016e3600
34801880:	34822897 	.word	0x34822897
34801884:	00b71b00 	.word	0x00b71b00

34801888 <s5pc100_get_pclk>:
	return get_pclk_sys(CLK_P);
}

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
34801888:	e92d4010 	push	{r4, lr}

/* s5pc100: return PCLKD1 frequency */
static unsigned long get_pclkd1(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
3480188c:	ebffffa3 	bl	34801720 <samsung_get_base_clock>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
34801890:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801894:	e3a00001 	mov	r0, #1
34801898:	ebffffae 	bl	34801758 <get_pll_clk>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
3480189c:	e7e21654 	ubfx	r1, r4, #12, #3
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
348018a0:	e2811001 	add	r1, r1, #1
348018a4:	eb0078c7 	bl	3481fbc8 <__udivsi3>

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;
348018a8:	e7e21854 	ubfx	r1, r4, #16, #3

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
	pclkd1 = d1_bus / (pclkd1_ratio + 1);
348018ac:	e2811001 	add	r1, r1, #1
348018b0:	eb0078c4 	bl	3481fbc8 <__udivsi3>

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
	return get_pclkd1();
}
348018b4:	e8bd8010 	pop	{r4, pc}

348018b8 <s5pc110_get_pclk>:
	return pclk;
}

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
348018b8:	e92d4038 	push	{r3, r4, r5, lr}

/* s5pc110: return PCLKs frequency */
static unsigned long get_pclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
348018bc:	ebffff97 	bl	34801720 <samsung_get_base_clock>
	unsigned long pclk;
	unsigned int div;
	unsigned int offset;
	unsigned int pclk_sys_ratio;

	div = readl(&clk->div0);
348018c0:	e5904300 	ldr	r4, [r0, #768]	; 0x300

/* s5pc110: return HCLKs frequency */
static unsigned long get_hclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
348018c4:	ebffff95 	bl	34801720 <samsung_get_base_clock>
	unsigned int hclk_sys_ratio;

	if (dom == CLK_M)
		return get_hclk();

	div = readl(&clk->div0);
348018c8:	e5905300 	ldr	r5, [r0, #768]	; 0x300
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
348018cc:	e3a00001 	mov	r0, #1
348018d0:	ebffffa0 	bl	34801758 <get_pll_clk>
	 * HCLK_DSYS_RATIO: [19:16]
	 * HCLK_PSYS_RATIO: [27:24]
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;
348018d4:	e7e31c55 	ubfx	r1, r5, #24, #4

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
348018d8:	e2811001 	add	r1, r1, #1
348018dc:	eb0078b9 	bl	3481fbc8 <__udivsi3>
	 * PCLK_DSYS_RATIO: [22:20]
	 * PCLK_PSYS_RATIO: [30:28]
	 */
	offset = 12 + (dom << 0x3);

	pclk_sys_ratio = (div >> offset) & 0x7;
348018e0:	e7e21e54 	ubfx	r1, r4, #28, #3

	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
348018e4:	e2811001 	add	r1, r1, #1
348018e8:	eb0078b6 	bl	3481fbc8 <__udivsi3>

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
	return get_pclk_sys(CLK_P);
}
348018ec:	e8bd8038 	pop	{r3, r4, r5, pc}

348018f0 <get_arm_clk>:
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
348018f0:	e59f305c 	ldr	r3, [pc, #92]	; 34801954 <get_arm_clk+0x64>
	else
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
348018f4:	e92d4010 	push	{r4, lr}
	if (cpu_is_s5pc110())
348018f8:	e5932000 	ldr	r2, [r3]
348018fc:	e30c3110 	movw	r3, #49424	; 0xc110
34801900:	e1520003 	cmp	r2, r3
34801904:	1a000007 	bne	34801928 <get_arm_clk+0x38>

/* s5pc110: return ARM clock frequency */
static unsigned long s5pc110_get_arm_clk(void)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801908:	ebffff84 	bl	34801720 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio;

	div = readl(&clk->div0);
3480190c:	e5904300 	ldr	r4, [r0, #768]	; 0x300

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34801910:	e3a00000 	mov	r0, #0
34801914:	ebffff8f 	bl	34801758 <get_pll_clk>
	unsigned int apll_ratio;

	div = readl(&clk->div0);

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;
34801918:	e2041007 	and	r1, r4, #7

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
3480191c:	e2811001 	add	r1, r1, #1
34801920:	eb0078a8 	bl	3481fbc8 <__udivsi3>
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
34801924:	e8bd8010 	pop	{r4, pc}

/* s5pc100: return ARM clock frequency */
static unsigned long s5pc100_get_arm_clk(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34801928:	ebffff7c 	bl	34801720 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);
3480192c:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34801930:	e3a00000 	mov	r0, #0
34801934:	ebffff87 	bl	34801758 <get_pll_clk>
	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;
34801938:	e2041001 	and	r1, r4, #1

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
3480193c:	e2811001 	add	r1, r1, #1
34801940:	eb0078a0 	bl	3481fbc8 <__udivsi3>
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
34801944:	e7e21254 	ubfx	r1, r4, #4, #3
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
	armclk = dout_apll / (arm_ratio + 1);
34801948:	e2811001 	add	r1, r1, #1
3480194c:	eb00789d 	bl	3481fbc8 <__udivsi3>
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
	else
		return s5pc100_get_arm_clk();
}
34801950:	e8bd8010 	pop	{r4, pc}
34801954:	34828288 	.word	0x34828288

34801958 <get_pwm_clk>:
}

/* s5pc1xx: return pwm clock frequency */
static unsigned long s5pc1xx_get_pwm_clk(void)
{
	if (cpu_is_s5pc110())
34801958:	e59f3014 	ldr	r3, [pc, #20]	; 34801974 <get_pwm_clk+0x1c>
3480195c:	e5932000 	ldr	r2, [r3]
34801960:	e30c3110 	movw	r3, #49424	; 0xc110
34801964:	e1520003 	cmp	r2, r3
34801968:	1a000000 	bne	34801970 <get_pwm_clk+0x18>
		return s5pc110_get_pclk();
3480196c:	eaffffd1 	b	348018b8 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34801970:	eaffffc4 	b	34801888 <s5pc100_get_pclk>
34801974:	34828288 	.word	0x34828288

34801978 <get_uart_clk>:
}

/* s5pc1xx: return uart clock frequency */
static unsigned long s5pc1xx_get_uart_clk(int dev_index)
{
	if (cpu_is_s5pc110())
34801978:	e59f3014 	ldr	r3, [pc, #20]	; 34801994 <get_uart_clk+0x1c>
3480197c:	e5932000 	ldr	r2, [r3]
34801980:	e30c3110 	movw	r3, #49424	; 0xc110
34801984:	e1520003 	cmp	r2, r3
34801988:	1a000000 	bne	34801990 <get_uart_clk+0x18>
		return s5pc110_get_pclk();
3480198c:	eaffffc9 	b	348018b8 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34801990:	eaffffbc 	b	34801888 <s5pc100_get_pclk>
34801994:	34828288 	.word	0x34828288

34801998 <set_mmc_clk>:
}

void set_mmc_clk(int dev_index, unsigned int div)
{
	/* Do NOTHING */
}
34801998:	e12fff1e 	bx	lr
3480199c:	00000000 	andeq	r0, r0, r0

348019a0 <v7_outer_cache_enable>:

#include <linux/linkage.h>

#ifndef CONFIG_SYS_L2CACHE_OFF
ENTRY(v7_outer_cache_enable)
	push	{r0, r1, r2, lr}
348019a0:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
348019a4:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	orr	r3, r3, #2
348019a8:	e3833002 	orr	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
348019ac:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
348019b0:	e8bd800e 	pop	{r1, r2, r3, pc}

348019b4 <v7_outer_cache_disable>:
ENDPROC(v7_outer_cache_enable)

ENTRY(v7_outer_cache_disable)
	push	{r0, r1, r2, lr}
348019b4:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
348019b8:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	bic	r3, r3, #2
348019bc:	e3c33002 	bic	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
348019c0:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
348019c4:	e8bd800e 	pop	{r1, r2, r3, pc}
348019c8:	e320f000 	nop	{0}
348019cc:	e320f000 	nop	{0}
348019d0:	e320f000 	nop	{0}
348019d4:	e320f000 	nop	{0}
348019d8:	e320f000 	nop	{0}
348019dc:	e320f000 	nop	{0}

348019e0 <reset_cpu>:

#define S5PC100_SWRESET			0xE0200000
#define S5PC110_SWRESET			0xE0102000

ENTRY(reset_cpu)
	ldr	r1, =S5PC100_PRO_ID
348019e0:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	ldr	r2, [r1]
348019e4:	e5912000 	ldr	r2, [r1]
	ldr	r4, =0x00010000
348019e8:	e3a04801 	mov	r4, #65536	; 0x10000
	and	r4, r2, r4
348019ec:	e0024004 	and	r4, r2, r4
	cmp	r4, #0
348019f0:	e3540000 	cmp	r4, #0
	bne	110f
348019f4:	1a000002 	bne	34801a04 <reset_cpu+0x24>
	/* S5PC100 */
	ldr	r1, =S5PC100_SWRESET
348019f8:	e59f1014 	ldr	r1, [pc, #20]	; 34801a14 <_loop_forever+0x4>
	ldr	r2, =0xC100
348019fc:	e3a02cc1 	mov	r2, #49408	; 0xc100
	b	200f
34801a00:	ea000001 	b	34801a0c <reset_cpu+0x2c>
110:	/* S5PC110 */
	ldr	r1, =S5PC110_SWRESET
34801a04:	e59f100c 	ldr	r1, [pc, #12]	; 34801a18 <_loop_forever+0x8>
	mov	r2, #1
34801a08:	e3a02001 	mov	r2, #1
200:
	str	r2, [r1]
34801a0c:	e5812000 	str	r2, [r1]

34801a10 <_loop_forever>:
_loop_forever:
	b	_loop_forever
34801a10:	eafffffe 	b	34801a10 <_loop_forever>
34801a14:	e0200000 	.word	0xe0200000
34801a18:	e0102000 	.word	0xe0102000

34801a1c <init_func_i2c>:
	return (0);
}

#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
static int init_func_i2c(void)
{
34801a1c:	e92d4008 	push	{r3, lr}
	puts("I2C:   ");
34801a20:	e59f001c 	ldr	r0, [pc, #28]	; 34801a44 <init_func_i2c+0x28>
34801a24:	eb00201d 	bl	34809aa0 <puts>
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
34801a28:	e3a010fe 	mov	r1, #254	; 0xfe
34801a2c:	e30c0350 	movw	r0, #50000	; 0xc350
34801a30:	eb003b9c 	bl	348108a8 <i2c_init>
	puts("ready\n");
34801a34:	e59f000c 	ldr	r0, [pc, #12]	; 34801a48 <init_func_i2c+0x2c>
34801a38:	eb002018 	bl	34809aa0 <puts>
	return (0);
}
34801a3c:	e3a00000 	mov	r0, #0
34801a40:	e8bd8008 	pop	{r3, pc}
34801a44:	348228ad 	.word	0x348228ad
34801a48:	34826f25 	.word	0x34826f25

34801a4c <display_banner>:
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
	return 0;
}

static int display_banner(void)
{
34801a4c:	e92d4008 	push	{r3, lr}
	printf("\n\n%s\n\n", version_string);
34801a50:	e59f100c 	ldr	r1, [pc, #12]	; 34801a64 <display_banner+0x18>
34801a54:	e59f000c 	ldr	r0, [pc, #12]	; 34801a68 <display_banner+0x1c>
34801a58:	eb00201a 	bl	34809ac8 <printf>
	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
34801a5c:	e3a00000 	mov	r0, #0
34801a60:	e8bd8008 	pop	{r3, pc}
34801a64:	34820260 	.word	0x34820260
34801a68:	348228b5 	.word	0x348228b5

34801a6c <init_baudrate>:
#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
#define CONFIG_BAUDRATE 115200
#endif

static int init_baudrate(void)
{
34801a6c:	e92d4010 	push	{r4, lr}
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
34801a70:	e3a0100a 	mov	r1, #10
34801a74:	e59f2014 	ldr	r2, [pc, #20]	; 34801a90 <init_baudrate+0x24>
34801a78:	e59f0014 	ldr	r0, [pc, #20]	; 34801a94 <init_baudrate+0x28>
34801a7c:	e1a04008 	mov	r4, r8
34801a80:	eb00193d 	bl	34807f7c <getenv_ulong>
34801a84:	e5840008 	str	r0, [r4, #8]
	return 0;
}
34801a88:	e3a00000 	mov	r0, #0
34801a8c:	e8bd8010 	pop	{r4, pc}
34801a90:	0001c200 	.word	0x0001c200
34801a94:	348228bc 	.word	0x348228bc

34801a98 <__coloured_LED_init>:
/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
inline void __coloured_LED_init(void) {}
34801a98:	e12fff1e 	bx	lr

34801a9c <__red_led_on>:
void coloured_LED_init(void)
	__attribute__((weak, alias("__coloured_LED_init")));
inline void __red_led_on(void) {}
34801a9c:	e12fff1e 	bx	lr

34801aa0 <__red_led_off>:
void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
inline void __red_led_off(void) {}
34801aa0:	e12fff1e 	bx	lr

34801aa4 <__green_led_on>:
void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
inline void __green_led_on(void) {}
34801aa4:	e12fff1e 	bx	lr

34801aa8 <__green_led_off>:
void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
inline void __green_led_off(void) {}
34801aa8:	e12fff1e 	bx	lr

34801aac <__yellow_led_on>:
void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
inline void __yellow_led_on(void) {}
34801aac:	e12fff1e 	bx	lr

34801ab0 <__yellow_led_off>:
void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
inline void __yellow_led_off(void) {}
34801ab0:	e12fff1e 	bx	lr

34801ab4 <__blue_led_on>:
void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
inline void __blue_led_on(void) {}
34801ab4:	e12fff1e 	bx	lr

34801ab8 <__blue_led_off>:
void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
inline void __blue_led_off(void) {}
34801ab8:	e12fff1e 	bx	lr

34801abc <__dram_init_banksize>:

int print_cpuinfo(void);

void __dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
34801abc:	e5982000 	ldr	r2, [r8]
34801ac0:	e3a01202 	mov	r1, #536870912	; 0x20000000
34801ac4:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size =  gd->ram_size;
34801ac8:	e5982000 	ldr	r2, [r8]
34801acc:	e5983038 	ldr	r3, [r8, #56]	; 0x38
34801ad0:	e582301c 	str	r3, [r2, #28]
}
34801ad4:	e12fff1e 	bx	lr

34801ad8 <__arch_cpu_init>:
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
}
34801ad8:	e3a00000 	mov	r0, #0
34801adc:	e12fff1e 	bx	lr

34801ae0 <board_init_r>:
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd = id;
34801ae0:	e1a08000 	mov	r8, r0
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
34801ae4:	e92d4008 	push	{r3, lr}
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801ae8:	e5983004 	ldr	r3, [r8, #4]
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
34801aec:	e1a04001 	mov	r4, r1
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801af0:	e3833001 	orr	r3, r3, #1
34801af4:	e5883004 	str	r3, [r8, #4]
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
34801af8:	e59f306c 	ldr	r3, [pc, #108]	; 34801b6c <board_init_r+0x8c>
34801afc:	e5932000 	ldr	r2, [r3]
34801b00:	e59f3068 	ldr	r3, [pc, #104]	; 34801b70 <board_init_r+0x90>
34801b04:	e5832000 	str	r2, [r3]

	/* Enable caches */
	enable_caches();
34801b08:	eb0001aa 	bl	348021b8 <__enable_caches>

	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init();	/* Setup chipselects */
34801b0c:	ebfffc83 	bl	34800d20 <board_init>
	 */
#ifdef CONFIG_CLOCKS
	set_cpu_clk_info(); /* Setup clock information */
#endif
#ifdef CONFIG_SERIAL_MULTI
	serial_initialize();
34801b10:	eb003489 	bl	3480ed3c <serial_initialize>
	post_output_backlog();
#endif

	/* The Malloc area is immediately below the monitor copy in DRAM */
	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
34801b14:	e3a01706 	mov	r1, #1572864	; 0x180000
34801b18:	e2440706 	sub	r0, r4, #1572864	; 0x180000
34801b1c:	eb0020eb 	bl	34809ed0 <mem_malloc_init>
	puts("NAND:  ");
	nand_init();		/* go init the NAND */
#endif

#if defined(CONFIG_CMD_ONENAND)
	onenand_init();
34801b20:	eb004a4d 	bl	3481445c <onenand_init>
#endif

#ifdef CONFIG_GENERIC_MMC
       puts("MMC:   ");
34801b24:	e59f0048 	ldr	r0, [pc, #72]	; 34801b74 <board_init_r+0x94>
34801b28:	eb001fdc 	bl	34809aa0 <puts>
       mmc_initialize(gd->bd);
34801b2c:	e5980000 	ldr	r0, [r8]
34801b30:	eb00440d 	bl	34812b6c <mmc_initialize>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate();
34801b34:	eb00256e 	bl	3480b0f4 <env_relocate>

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif

	stdio_init();	/* get the devices list going. */
34801b38:	eb0034fb 	bl	3480ef2c <stdio_init>

	jumptable_init();
34801b3c:	eb00257b 	bl	3480b130 <jumptable_init>
#if defined(CONFIG_API)
	/* Initialize API */
	api_init();
#endif

	console_init_r();	/* fully init console as a device */
34801b40:	eb002076 	bl	34809d20 <console_init_r>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801b44:	e59f402c 	ldr	r4, [pc, #44]	; 34801b78 <board_init_r+0x98>
	/* miscellaneous platform dependent initialisations */
	misc_init_r();
#endif

	 /* set up exceptions */
	interrupt_init();
34801b48:	eb0000ee 	bl	34801f08 <interrupt_init>
	/* enable exceptions */
	enable_interrupts();
34801b4c:	eb0000f4 	bl	34801f24 <enable_interrupts>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801b50:	e59f0024 	ldr	r0, [pc, #36]	; 34801b7c <board_init_r+0x9c>
34801b54:	e3a01010 	mov	r1, #16
34801b58:	e5942000 	ldr	r2, [r4]
34801b5c:	eb001906 	bl	34807f7c <getenv_ulong>
34801b60:	e5840000 	str	r0, [r4]
	}
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop();
34801b64:	eb0032cd 	bl	3480e6a0 <main_loop>
34801b68:	eafffffd 	b	34801b64 <board_init_r+0x84>
34801b6c:	34800050 	.word	0x34800050
34801b70:	3482985c 	.word	0x3482985c
34801b74:	348228c5 	.word	0x348228c5
34801b78:	34828438 	.word	0x34828438
34801b7c:	348228cd 	.word	0x348228cd

34801b80 <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang(void)
{
34801b80:	e92d4008 	push	{r3, lr}
	puts("### ERROR ### Please RESET the board ###\n");
34801b84:	e59f0004 	ldr	r0, [pc, #4]	; 34801b90 <hang+0x10>
34801b88:	eb001fc4 	bl	34809aa0 <puts>
34801b8c:	eafffffe 	b	34801b8c <hang+0xc>
34801b90:	348228d6 	.word	0x348228d6

34801b94 <board_init_f>:
	dram_init,		/* configure available RAM banks */
	NULL,
};

void board_init_f(ulong bootflag)
{
34801b94:	e92d4080 	push	{r7, lr}
34801b98:	e3a0400a 	mov	r4, #10
#endif

	int i = 0;
	ulong j = 0x34800000;
	for(i;i<10;i++){	
		display_addr(j);
34801b9c:	e3a005d2 	mov	r0, #880803840	; 0x34800000
34801ba0:	ebfffbc1 	bl	34800aac <display_addr>
	ulong reg;
#endif

	int i = 0;
	ulong j = 0x34800000;
	for(i;i<10;i++){	
34801ba4:	e2544001 	subs	r4, r4, #1
34801ba8:	1afffffb 	bne	34801b9c <board_init_f+0x8>
	}	
	
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
34801bac:	e3a08423 	mov	r8, #587202560	; 0x23000000
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));
34801bb0:	e3a02078 	mov	r2, #120	; 0x78
34801bb4:	e1a01004 	mov	r1, r4
34801bb8:	e1a00008 	mov	r0, r8
34801bbc:	eb006a95 	bl	3481c618 <memset>

	gd->mon_len = _bss_end_ofs;
34801bc0:	e59f30e8 	ldr	r3, [pc, #232]	; 34801cb0 <board_init_f+0x11c>
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801bc4:	e59f00e8 	ldr	r0, [pc, #232]	; 34801cb4 <board_init_f+0x120>
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801bc8:	e5933000 	ldr	r3, [r3]
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801bcc:	e3a01010 	mov	r1, #16
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801bd0:	e588303c 	str	r3, [r8, #60]	; 0x3c
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);
34801bd4:	e5982050 	ldr	r2, [r8, #80]	; 0x50
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801bd8:	e1a04008 	mov	r4, r8
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801bdc:	eb0018e6 	bl	34807f7c <getenv_ulong>
34801be0:	e5840050 	str	r0, [r4, #80]	; 0x50
34801be4:	e59f40cc 	ldr	r4, [pc, #204]	; 34801cb8 <board_init_f+0x124>
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801be8:	ea000003 	b	34801bfc <board_init_f+0x68>
		if ((*init_fnc_ptr)() != 0) {
34801bec:	e12fff37 	blx	r7
34801bf0:	e3500000 	cmp	r0, #0
34801bf4:	0a000000 	beq	34801bfc <board_init_f+0x68>
			hang ();
34801bf8:	ebffffe0 	bl	34801b80 <hang>
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801bfc:	e5b47004 	ldr	r7, [r4, #4]!
34801c00:	e3570000 	cmp	r7, #0
34801c04:	1afffff8 	bne	34801bec <board_init_f+0x58>
	 * get fixed.
	 */
	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
#endif

	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
34801c08:	e5984038 	ldr	r4, [r8, #56]	; 0x38
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	/* reserve TLB table */
	addr -= (4096 * 4);
34801c0c:	e284457f 	add	r4, r4, #532676608	; 0x1fc00000
34801c10:	e28449ff 	add	r4, r4, #4177920	; 0x3fc000

	/* round down to next 64 kB limit */
	addr &= ~(0x10000 - 1);
34801c14:	e1a04824 	lsr	r4, r4, #16
34801c18:	e1a04804 	lsl	r4, r4, #16

	gd->tlb_addr = addr;
34801c1c:	e588404c 	str	r4, [r8, #76]	; 0x4c

	/*
	 * reserve memory for U-Boot code, data & bss
	 * round down to next 4 kB limit
	 */
	addr -= gd->mon_len;
34801c20:	e598203c 	ldr	r2, [r8, #60]	; 0x3c
34801c24:	e0624004 	rsb	r4, r2, r4
	addr &= ~(4096 - 1);
34801c28:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34801c2c:	e3c4400f 	bic	r4, r4, #15
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
34801c30:	e2446706 	sub	r6, r4, #1572864	; 0x180000

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
#endif

	addr_sp -= sizeof (gd_t);
34801c34:	e2465098 	sub	r5, r6, #152	; 0x98
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
34801c38:	e2462020 	sub	r2, r6, #32
	bd = (bd_t *) addr_sp;
	gd->bd = bd;
34801c3c:	e5882000 	str	r2, [r8]
	id = (gd_t *) addr_sp;
	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
			sizeof (gd_t), addr_sp);

	/* setup stackpointer for exeptions */
	gd->irq_sp = addr_sp;
34801c40:	e5885040 	str	r5, [r8, #64]	; 0x40
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801c44:	e5982000 	ldr	r2, [r8]
34801c48:	e5983008 	ldr	r3, [r8, #8]
#endif
	/* leave 3 words for abort-stack    */
	addr_sp -= 12;

	/* 8-byte alignment for ABI compliance */
	addr_sp &= ~0x07;
34801c4c:	e24660a8 	sub	r6, r6, #168	; 0xa8
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801c50:	e5823000 	str	r3, [r2]
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
34801c54:	ebfffc45 	bl	34800d70 <dram_init_banksize>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
34801c58:	e5983000 	ldr	r3, [r8]

	puts("DRAM:  ");
34801c5c:	e59f0058 	ldr	r0, [pc, #88]	; 34801cbc <board_init_f+0x128>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
34801c60:	e593a01c 	ldr	sl, [r3, #28]

	puts("DRAM:  ");
34801c64:	eb001f8d 	bl	34809aa0 <puts>
	print_size(size, "\n");
34801c68:	e1a0000a 	mov	r0, sl
34801c6c:	e1a01007 	mov	r1, r7
34801c70:	e59f2048 	ldr	r2, [pc, #72]	; 34801cc0 <board_init_f+0x12c>
34801c74:	eb006321 	bl	3481a900 <print_size>
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801c78:	e59f3044 	ldr	r3, [pc, #68]	; 34801cc4 <board_init_f+0x130>
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
34801c7c:	e5884034 	str	r4, [r8, #52]	; 0x34
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801c80:	e5933000 	ldr	r3, [r3]
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
34801c84:	e1a01008 	mov	r1, r8
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801c88:	e0633004 	rsb	r3, r3, r4
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
34801c8c:	e5886044 	str	r6, [r8, #68]	; 0x44
	gd->reloc_off = addr - _TEXT_BASE;
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
34801c90:	e3a02078 	mov	r2, #120	; 0x78
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801c94:	e5883048 	str	r3, [r8, #72]	; 0x48
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
34801c98:	e1a00005 	mov	r0, r5
34801c9c:	eb006a81 	bl	3481c6a8 <memcpy>

	relocate_code(addr_sp, id, addr);
34801ca0:	e1a00006 	mov	r0, r6
34801ca4:	e1a01005 	mov	r1, r5
34801ca8:	e1a02004 	mov	r2, r4
34801cac:	ebfff8fd 	bl	348000a8 <relocate_code>
34801cb0:	3480004c 	.word	0x3480004c
34801cb4:	34822900 	.word	0x34822900
34801cb8:	3482828c 	.word	0x3482828c
34801cbc:	3482290f 	.word	0x3482290f
34801cc0:	34826197 	.word	0x34826197
34801cc4:	34800040 	.word	0x34800040

34801cc8 <boot_prep_linux>:
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
34801cc8:	e92d4070 	push	{r4, r5, r6, lr}
34801ccc:	e1a05000 	mov	r5, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
34801cd0:	e59f0128 	ldr	r0, [pc, #296]	; 34801e00 <boot_prep_linux+0x138>
34801cd4:	eb00188d 	bl	34807f10 <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
34801cd8:	e5983000 	ldr	r3, [r8]

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
34801cdc:	e59f1120 	ldr	r1, [pc, #288]	; 34801e04 <boot_prep_linux+0x13c>
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;
34801ce0:	e5934008 	ldr	r4, [r3, #8]

	params->hdr.tag = ATAG_CORE;
34801ce4:	e59f311c 	ldr	r3, [pc, #284]	; 34801e08 <boot_prep_linux+0x140>
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801ce8:	e3500000 	cmp	r0, #0
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
34801cec:	e5843004 	str	r3, [r4, #4]
	params->hdr.size = tag_size (tag_core);
34801cf0:	e3a03005 	mov	r3, #5
34801cf4:	e5843000 	str	r3, [r4]

	params->u.core.flags = 0;
34801cf8:	e3a03000 	mov	r3, #0
34801cfc:	e5843008 	str	r3, [r4, #8]
	params->u.core.pagesize = 0;
34801d00:	e584300c 	str	r3, [r4, #12]
	params->u.core.rootdev = 0;
34801d04:	e5843010 	str	r3, [r4, #16]

	params = tag_next (params);
34801d08:	e2843014 	add	r3, r4, #20
34801d0c:	e5813000 	str	r3, [r1]
		setup_start_tag(gd->bd);
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
34801d10:	e5982000 	ldr	r2, [r8]
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801d14:	0a000015 	beq	34801d70 <boot_prep_linux+0xa8>
34801d18:	e1a06000 	mov	r6, r0
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
34801d1c:	e4d02001 	ldrb	r2, [r0], #1
34801d20:	e3520020 	cmp	r2, #32
34801d24:	0afffffb 	beq	34801d18 <boot_prep_linux+0x50>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
34801d28:	e3520000 	cmp	r2, #0
34801d2c:	0a00000f 	beq	34801d70 <boot_prep_linux+0xa8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801d30:	e59f20d4 	ldr	r2, [pc, #212]	; 34801e0c <boot_prep_linux+0x144>
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801d34:	e1a00006 	mov	r0, r6
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801d38:	e5832004 	str	r2, [r3, #4]
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801d3c:	eb006995 	bl	3481c398 <strlen>
34801d40:	e280000d 	add	r0, r0, #13
34801d44:	e1a00120 	lsr	r0, r0, #2
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
34801d48:	e5840014 	str	r0, [r4, #20]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
34801d4c:	e59f40b0 	ldr	r4, [pc, #176]	; 34801e04 <boot_prep_linux+0x13c>
34801d50:	e1a01006 	mov	r1, r6
34801d54:	e5940000 	ldr	r0, [r4]
34801d58:	e2800008 	add	r0, r0, #8
34801d5c:	eb006928 	bl	3481c204 <strcpy>

	params = tag_next (params);
34801d60:	e5943000 	ldr	r3, [r4]
34801d64:	e5932000 	ldr	r2, [r3]
34801d68:	e0833102 	add	r3, r3, r2, lsl #2
34801d6c:	e5843000 	str	r3, [r4]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801d70:	e59f008c 	ldr	r0, [pc, #140]	; 34801e04 <boot_prep_linux+0x13c>
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801d74:	e5982000 	ldr	r2, [r8]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801d78:	e5903000 	ldr	r3, [r0]
34801d7c:	e59fc08c 	ldr	ip, [pc, #140]	; 34801e10 <boot_prep_linux+0x148>
		params->hdr.size = tag_size (tag_mem32);
34801d80:	e3a06004 	mov	r6, #4
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801d84:	e583c004 	str	ip, [r3, #4]
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
34801d88:	e592c018 	ldr	ip, [r2, #24]
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801d8c:	e1a01008 	mov	r1, r8

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
34801d90:	e583c00c 	str	ip, [r3, #12]
		params->u.mem.size = bd->bi_dram[i].size;
34801d94:	e592201c 	ldr	r2, [r2, #28]
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);
34801d98:	e5836000 	str	r6, [r3]

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;
34801d9c:	e5832008 	str	r2, [r3, #8]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801da0:	e595c064 	ldr	ip, [r5, #100]	; 0x64
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
34801da4:	e2832010 	add	r2, r3, #16
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801da8:	e35c0000 	cmp	ip, #0
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
34801dac:	e5802000 	str	r2, [r0]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801db0:	0a00000b 	beq	34801de4 <boot_prep_linux+0x11c>
34801db4:	e5954068 	ldr	r4, [r5, #104]	; 0x68
34801db8:	e3540000 	cmp	r4, #0
34801dbc:	0a000008 	beq	34801de4 <boot_prep_linux+0x11c>
			setup_initrd_tag(gd->bd, images->rd_start,
34801dc0:	e5985000 	ldr	r5, [r8]
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801dc4:	e59f5048 	ldr	r5, [pc, #72]	; 34801e14 <boot_prep_linux+0x14c>
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
34801dc8:	e582c008 	str	ip, [r2, #8]
	params->u.initrd.size = initrd_end - initrd_start;
34801dcc:	e06cc004 	rsb	ip, ip, r4
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801dd0:	e5825004 	str	r5, [r2, #4]
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
34801dd4:	e582c00c 	str	ip, [r2, #12]

	params = tag_next (params);
34801dd8:	e2822010 	add	r2, r2, #16
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);
34801ddc:	e5836010 	str	r6, [r3, #16]

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
34801de0:	e5802000 	str	r2, [r0]
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
			setup_initrd_tag(gd->bd, images->rd_start,
			images->rd_end);
#endif
		setup_end_tag(gd->bd);
34801de4:	e5913000 	ldr	r3, [r1]
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_end_tag(bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
34801de8:	e59f3014 	ldr	r3, [pc, #20]	; 34801e04 <boot_prep_linux+0x13c>
34801dec:	e3a02000 	mov	r2, #0
34801df0:	e5933000 	ldr	r3, [r3]
34801df4:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
34801df8:	e5832000 	str	r2, [r3]
#else /* all tags */
		printf("FDT and ATAGS support not compiled in - hanging\n");
		hang();
#endif /* all tags */
	}
}
34801dfc:	e8bd8070 	pop	{r4, r5, r6, pc}
34801e00:	34822917 	.word	0x34822917
34801e04:	34829860 	.word	0x34829860
34801e08:	54410001 	.word	0x54410001
34801e0c:	54410009 	.word	0x54410009
34801e10:	54410002 	.word	0x54410002
34801e14:	54420005 	.word	0x54420005

34801e18 <boot_jump_linux.clone.5>:

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801e18:	e92d4013 	push	{r0, r1, r4, lr}
{
	unsigned long machid = gd->bd->bi_arch_number;
34801e1c:	e5983000 	ldr	r3, [r8]
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801e20:	e1a04000 	mov	r4, r0
{
	unsigned long machid = gd->bd->bi_arch_number;
34801e24:	e5933004 	ldr	r3, [r3, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801e28:	e59f0050 	ldr	r0, [pc, #80]	; 34801e80 <boot_jump_linux.clone.5+0x68>
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
34801e2c:	e58d3004 	str	r3, [sp, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801e30:	eb001836 	bl	34807f10 <getenv>
	if (s) {
34801e34:	e3500000 	cmp	r0, #0
34801e38:	0a000005 	beq	34801e54 <boot_jump_linux.clone.5+0x3c>
		strict_strtoul(s, 16, &machid);
34801e3c:	e3a01010 	mov	r1, #16
34801e40:	e28d2004 	add	r2, sp, #4
34801e44:	eb006d11 	bl	3481d290 <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
34801e48:	e59f0034 	ldr	r0, [pc, #52]	; 34801e84 <boot_jump_linux.clone.5+0x6c>
34801e4c:	e59d1004 	ldr	r1, [sp, #4]
34801e50:	eb001f1c 	bl	34809ac8 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801e54:	e3a0000f 	mov	r0, #15
34801e58:	eb002f91 	bl	3480dca4 <__show_boot_progress>
}
#endif

static void announce_and_cleanup(void)
{
	printf("\nStarting kernel ...\n\n");
34801e5c:	e59f0024 	ldr	r0, [pc, #36]	; 34801e88 <boot_jump_linux.clone.5+0x70>
34801e60:	eb001f18 	bl	34809ac8 <printf>
#endif

#ifdef CONFIG_USB_DEVICE
	udc_disconnect();
#endif
	cleanup_before_linux();
34801e64:	ebfffca6 	bl	34801104 <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
34801e68:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
34801e6c:	e3a00000 	mov	r0, #0
34801e70:	e59d1004 	ldr	r1, [sp, #4]
34801e74:	e5932008 	ldr	r2, [r3, #8]
34801e78:	e12fff34 	blx	r4
}
34801e7c:	e8bd801c 	pop	{r2, r3, r4, pc}
34801e80:	34822920 	.word	0x34822920
34801e84:	34822927 	.word	0x34822927
34801e88:	3482294c 	.word	0x3482294c

34801e8c <arch_lmb_reserve>:
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801e8c:	e598c000 	ldr	ip, [r8]
34801e90:	e5983000 	ldr	r3, [r8]

static ulong get_sp(void)
{
	ulong ret;

	asm("mov %0, sp" : "=r"(ret) : );
34801e94:	e1a0100d 	mov	r1, sp
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801e98:	e593201c 	ldr	r2, [r3, #28]
34801e9c:	e59c3018 	ldr	r3, [ip, #24]
	 */
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
34801ea0:	e2411a01 	sub	r1, r1, #4096	; 0x1000
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801ea4:	e0822003 	add	r2, r2, r3
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
34801ea8:	e0612002 	rsb	r2, r1, r2
34801eac:	ea0067f0 	b	3481be74 <lmb_reserve>

34801eb0 <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801eb0:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801eb4:	e2105030 	ands	r5, r0, #48	; 0x30
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801eb8:	e1a04003 	mov	r4, r3
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;
34801ebc:	13e05000 	mvnne	r5, #0
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801ec0:	1a00000e 	bne	34801f00 <do_bootm_linux+0x50>
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
34801ec4:	e2106040 	ands	r6, r0, #64	; 0x40
34801ec8:	0a000002 	beq	34801ed8 <do_bootm_linux+0x28>
		boot_prep_linux(images);
34801ecc:	e1a00003 	mov	r0, r3
34801ed0:	ebffff7c 	bl	34801cc8 <boot_prep_linux>
		return 0;
34801ed4:	ea000009 	b	34801f00 <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
34801ed8:	e2105080 	ands	r5, r0, #128	; 0x80
34801edc:	0a000003 	beq	34801ef0 <do_bootm_linux+0x40>
		boot_jump_linux(images);
34801ee0:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34801ee4:	ebffffcb 	bl	34801e18 <boot_jump_linux.clone.5>
		return 0;
34801ee8:	e1a05006 	mov	r5, r6
34801eec:	ea000003 	b	34801f00 <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
34801ef0:	e1a00003 	mov	r0, r3
34801ef4:	ebffff73 	bl	34801cc8 <boot_prep_linux>
	boot_jump_linux(images);
34801ef8:	e5940060 	ldr	r0, [r4, #96]	; 0x60
34801efc:	ebffffc5 	bl	34801e18 <boot_jump_linux.clone.5>
	return 0;
}
34801f00:	e1a00005 	mov	r0, r5
34801f04:	e8bd8070 	pop	{r4, r5, r6, pc}

34801f08 <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801f08:	e5982040 	ldr	r2, [r8, #64]	; 0x40
34801f0c:	e59f300c 	ldr	r3, [pc, #12]	; 34801f20 <interrupt_init+0x18>
34801f10:	e2822008 	add	r2, r2, #8
34801f14:	e5832000 	str	r2, [r3]

	return 0;
}
34801f18:	e3a00000 	mov	r0, #0
34801f1c:	e12fff1e 	bx	lr
34801f20:	34800054 	.word	0x34800054

34801f24 <enable_interrupts>:

void enable_interrupts (void)
{
	return;
}
34801f24:	e12fff1e 	bx	lr

34801f28 <disable_interrupts>:
int disable_interrupts (void)
{
	return 0;
}
34801f28:	e3a00000 	mov	r0, #0
34801f2c:	e12fff1e 	bx	lr

34801f30 <bad_mode>:
#endif


void bad_mode (void)
{
34801f30:	e92d4008 	push	{r3, lr}
	panic ("Resetting CPU ...\n");
34801f34:	e59f0000 	ldr	r0, [pc, #0]	; 34801f3c <bad_mode+0xc>
34801f38:	eb006d58 	bl	3481d4a0 <panic>
34801f3c:	34822963 	.word	0x34822963

34801f40 <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
34801f40:	e92d4070 	push	{r4, r5, r6, lr}
34801f44:	e24dd088 	sub	sp, sp, #136	; 0x88
34801f48:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
34801f4c:	e59f1104 	ldr	r1, [pc, #260]	; 34802058 <show_regs+0x118>
34801f50:	e28d0008 	add	r0, sp, #8
34801f54:	e3a02080 	mov	r2, #128	; 0x80
34801f58:	eb0069d2 	bl	3481c6a8 <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801f5c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34801f60:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34801f64:	e58d3000 	str	r3, [sp]
34801f68:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34801f6c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
34801f70:	e58d3004 	str	r3, [sp, #4]
34801f74:	e59f00e0 	ldr	r0, [pc, #224]	; 3480205c <show_regs+0x11c>
34801f78:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
34801f7c:	e5945040 	ldr	r5, [r4, #64]	; 0x40

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801f80:	eb001ed0 	bl	34809ac8 <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
34801f84:	e5941028 	ldr	r1, [r4, #40]	; 0x28
34801f88:	e5942024 	ldr	r2, [r4, #36]	; 0x24
34801f8c:	e5943020 	ldr	r3, [r4, #32]
34801f90:	e59f00c8 	ldr	r0, [pc, #200]	; 34802060 <show_regs+0x120>
34801f94:	eb001ecb 	bl	34809ac8 <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
34801f98:	e5943010 	ldr	r3, [r4, #16]
34801f9c:	e594101c 	ldr	r1, [r4, #28]
34801fa0:	e58d3000 	str	r3, [sp]
34801fa4:	e5942018 	ldr	r2, [r4, #24]
34801fa8:	e5943014 	ldr	r3, [r4, #20]
34801fac:	e59f00b0 	ldr	r0, [pc, #176]	; 34802064 <show_regs+0x124>
34801fb0:	eb001ec4 	bl	34809ac8 <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
34801fb4:	e5943000 	ldr	r3, [r4]
34801fb8:	e594100c 	ldr	r1, [r4, #12]
34801fbc:	e58d3000 	str	r3, [sp]
34801fc0:	e5942008 	ldr	r2, [r4, #8]
34801fc4:	e5943004 	ldr	r3, [r4, #4]
34801fc8:	e59f0098 	ldr	r0, [pc, #152]	; 34802068 <show_regs+0x128>
34801fcc:	eb001ebd 	bl	34809ac8 <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801fd0:	e3150101 	tst	r5, #1073741824	; 0x40000000
34801fd4:	03a0207a 	moveq	r2, #122	; 0x7a
34801fd8:	13a0205a 	movne	r2, #90	; 0x5a
34801fdc:	e3150202 	tst	r5, #536870912	; 0x20000000
34801fe0:	03a03063 	moveq	r3, #99	; 0x63
34801fe4:	13a03043 	movne	r3, #67	; 0x43
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
34801fe8:	e205620f 	and	r6, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801fec:	e3150201 	tst	r5, #268435456	; 0x10000000
34801ff0:	03a01076 	moveq	r1, #118	; 0x76
34801ff4:	13a01056 	movne	r1, #86	; 0x56
34801ff8:	e3560000 	cmp	r6, #0
34801ffc:	e58d1000 	str	r1, [sp]
34802000:	e59f0064 	ldr	r0, [pc, #100]	; 3480206c <show_regs+0x12c>
34802004:	a3a0106e 	movge	r1, #110	; 0x6e
34802008:	b3a0104e 	movlt	r1, #78	; 0x4e
3480200c:	eb001ead 	bl	34809ac8 <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
34802010:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34802014:	e59fc054 	ldr	ip, [pc, #84]	; 34802070 <show_regs+0x130>
34802018:	e59f2054 	ldr	r2, [pc, #84]	; 34802074 <show_regs+0x134>
3480201c:	e3130080 	tst	r3, #128	; 0x80
34802020:	01a0100c 	moveq	r1, ip
34802024:	11a01002 	movne	r1, r2
34802028:	e28d0088 	add	r0, sp, #136	; 0x88
3480202c:	e3130040 	tst	r3, #64	; 0x40
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
34802030:	e203301f 	and	r3, r3, #31
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34802034:	e0803103 	add	r3, r0, r3, lsl #2
34802038:	e59f0038 	ldr	r0, [pc, #56]	; 34802078 <show_regs+0x138>
3480203c:	01a0200c 	moveq	r2, ip
34802040:	e58d0000 	str	r0, [sp]
34802044:	e5133080 	ldr	r3, [r3, #-128]	; 0x80
34802048:	e59f002c 	ldr	r0, [pc, #44]	; 3480207c <show_regs+0x13c>
3480204c:	eb001e9d 	bl	34809ac8 <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
34802050:	e28dd088 	add	sp, sp, #136	; 0x88
34802054:	e8bd8070 	pop	{r4, r5, r6, pc}
34802058:	34820090 	.word	0x34820090
3480205c:	34822976 	.word	0x34822976
34802060:	348229bb 	.word	0x348229bb
34802064:	348229df 	.word	0x348229df
34802068:	34822a0f 	.word	0x34822a0f
3480206c:	34822a3f 	.word	0x34822a3f
34802070:	3482820e 	.word	0x3482820e
34802074:	34822c61 	.word	0x34822c61
34802078:	34823d17 	.word	0x34823d17
3480207c:	34822a4f 	.word	0x34822a4f

34802080 <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
34802080:	e92d4010 	push	{r4, lr}
34802084:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
34802088:	e59f0010 	ldr	r0, [pc, #16]	; 348020a0 <do_undefined_instruction+0x20>
3480208c:	eb001e8d 	bl	34809ac8 <printf>
	show_regs (pt_regs);
34802090:	e1a00004 	mov	r0, r4
34802094:	ebffffa9 	bl	34801f40 <show_regs>
	bad_mode ();
}
34802098:	e8bd4010 	pop	{r4, lr}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
3480209c:	eaffffa3 	b	34801f30 <bad_mode>
348020a0:	34822a6e 	.word	0x34822a6e

348020a4 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
348020a4:	e92d4010 	push	{r4, lr}
348020a8:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
348020ac:	e59f0010 	ldr	r0, [pc, #16]	; 348020c4 <do_software_interrupt+0x20>
348020b0:	eb001e84 	bl	34809ac8 <printf>
	show_regs (pt_regs);
348020b4:	e1a00004 	mov	r0, r4
348020b8:	ebffffa0 	bl	34801f40 <show_regs>
	bad_mode ();
}
348020bc:	e8bd4010 	pop	{r4, lr}

void do_software_interrupt (struct pt_regs *pt_regs)
{
	printf ("software interrupt\n");
	show_regs (pt_regs);
	bad_mode ();
348020c0:	eaffff9a 	b	34801f30 <bad_mode>
348020c4:	34822a85 	.word	0x34822a85

348020c8 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
348020c8:	e92d4010 	push	{r4, lr}
348020cc:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
348020d0:	e59f0010 	ldr	r0, [pc, #16]	; 348020e8 <do_prefetch_abort+0x20>
348020d4:	eb001e7b 	bl	34809ac8 <printf>
	show_regs (pt_regs);
348020d8:	e1a00004 	mov	r0, r4
348020dc:	ebffff97 	bl	34801f40 <show_regs>
	bad_mode ();
}
348020e0:	e8bd4010 	pop	{r4, lr}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
	printf ("prefetch abort\n");
	show_regs (pt_regs);
	bad_mode ();
348020e4:	eaffff91 	b	34801f30 <bad_mode>
348020e8:	34822a99 	.word	0x34822a99

348020ec <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
348020ec:	e92d4010 	push	{r4, lr}
348020f0:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
348020f4:	e59f0010 	ldr	r0, [pc, #16]	; 3480210c <do_data_abort+0x20>
348020f8:	eb001e72 	bl	34809ac8 <printf>
	show_regs (pt_regs);
348020fc:	e1a00004 	mov	r0, r4
34802100:	ebffff8e 	bl	34801f40 <show_regs>
	bad_mode ();
}
34802104:	e8bd4010 	pop	{r4, lr}

void do_data_abort (struct pt_regs *pt_regs)
{
	printf ("data abort\n");
	show_regs (pt_regs);
	bad_mode ();
34802108:	eaffff88 	b	34801f30 <bad_mode>
3480210c:	34822aa9 	.word	0x34822aa9

34802110 <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
34802110:	e92d4010 	push	{r4, lr}
34802114:	e1a04000 	mov	r4, r0
	printf ("not used\n");
34802118:	e59f0010 	ldr	r0, [pc, #16]	; 34802130 <do_not_used+0x20>
3480211c:	eb001e69 	bl	34809ac8 <printf>
	show_regs (pt_regs);
34802120:	e1a00004 	mov	r0, r4
34802124:	ebffff85 	bl	34801f40 <show_regs>
	bad_mode ();
}
34802128:	e8bd4010 	pop	{r4, lr}

void do_not_used (struct pt_regs *pt_regs)
{
	printf ("not used\n");
	show_regs (pt_regs);
	bad_mode ();
3480212c:	eaffff7f 	b	34801f30 <bad_mode>
34802130:	34822ab5 	.word	0x34822ab5

34802134 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
34802134:	e92d4010 	push	{r4, lr}
34802138:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
3480213c:	e59f0010 	ldr	r0, [pc, #16]	; 34802154 <do_fiq+0x20>
34802140:	eb001e60 	bl	34809ac8 <printf>
	show_regs (pt_regs);
34802144:	e1a00004 	mov	r0, r4
34802148:	ebffff7c 	bl	34801f40 <show_regs>
	bad_mode ();
}
3480214c:	e8bd4010 	pop	{r4, lr}

void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
34802150:	eaffff76 	b	34801f30 <bad_mode>
34802154:	34822abf 	.word	0x34822abf

34802158 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
34802158:	e92d4010 	push	{r4, lr}
3480215c:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
34802160:	e59f0010 	ldr	r0, [pc, #16]	; 34802178 <do_irq+0x20>
34802164:	eb001e57 	bl	34809ac8 <printf>
	show_regs (pt_regs);
34802168:	e1a00004 	mov	r0, r4
3480216c:	ebffff73 	bl	34801f40 <show_regs>
	bad_mode ();
}
34802170:	e8bd4010 	pop	{r4, lr}
#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
	printf ("interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
34802174:	eaffff6d 	b	34801f30 <bad_mode>
34802178:	34822ac4 	.word	0x34822ac4

3480217c <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480217c:	e92d4008 	push	{r3, lr}
	puts ("resetting ...\n");
34802180:	e59f001c 	ldr	r0, [pc, #28]	; 348021a4 <do_reset+0x28>
34802184:	eb001e45 	bl	34809aa0 <puts>

	udelay (50000);				/* wait 50 ms */
34802188:	e30c0350 	movw	r0, #50000	; 0xc350
3480218c:	eb0069d0 	bl	3481c8d4 <udelay>

	disable_interrupts();
34802190:	ebffff64 	bl	34801f28 <disable_interrupts>
	reset_cpu(0);
34802194:	e3a00000 	mov	r0, #0
34802198:	ebfffe10 	bl	348019e0 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
3480219c:	e3a00000 	mov	r0, #0
348021a0:	e8bd8008 	pop	{r3, pc}
348021a4:	34822bc3 	.word	0x34822bc3

348021a8 <__flush_cache>:
	asm("0: mrc p15, 0, r15, c7, c10, 3\n\t" "bne 0b\n" : : : "memory");
	/* disable write buffer as well (page 2-22) */
	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
#endif
	return;
}
348021a8:	e12fff1e 	bx	lr

348021ac <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
348021ac:	e3a00000 	mov	r0, #0
348021b0:	e3e01000 	mvn	r1, #0
348021b4:	eafffbc3 	b	348010c8 <flush_cache>

348021b8 <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
348021b8:	e59f0000 	ldr	r0, [pc, #0]	; 348021c0 <__enable_caches+0x8>
348021bc:	ea001e37 	b	34809aa0 <puts>
348021c0:	34822bd2 	.word	0x34822bd2

348021c4 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
348021c4:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
348021c8:	e3a03000 	mov	r3, #0
348021cc:	ea000002 	b	348021dc <cp_delay+0x18>
		nop();
348021d0:	e1a00000 	nop			; (mov r0, r0)
static void cp_delay (void)
{
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
348021d4:	e59d3004 	ldr	r3, [sp, #4]
348021d8:	e2833001 	add	r3, r3, #1
348021dc:	e58d3004 	str	r3, [sp, #4]
348021e0:	e59d3004 	ldr	r3, [sp, #4]
348021e4:	e3530063 	cmp	r3, #99	; 0x63
348021e8:	dafffff8 	ble	348021d0 <cp_delay+0xc>
		nop();
	asm volatile("" : : : "memory");
}
348021ec:	e28dd008 	add	sp, sp, #8
348021f0:	e12fff1e 	bx	lr

348021f4 <cache_enable>:
static void cache_enable(uint32_t cache_bit)
{
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
348021f4:	e3500004 	cmp	r0, #4
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
{
348021f8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348021fc:	e1a05000 	mov	r5, r0
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
34802200:	1a000024 	bne	34802298 <cache_enable+0xa4>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802204:	ee117f10 	mrc	15, 0, r7, cr1, cr0, {0}
34802208:	e2177001 	ands	r7, r7, #1
3480220c:	1a000021 	bne	34802298 <cache_enable+0xa4>
}

/* to activate the MMU we need to set up virtual memory: use 1M areas */
static inline void mmu_setup(void)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
34802210:	e598404c 	ldr	r4, [r8, #76]	; 0x4c
34802214:	e1a06004 	mov	r6, r4
	int i;
	u32 reg;

	arm_init_before_mmu();
34802218:	ebfffba0 	bl	348010a0 <arm_init_before_mmu>
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;
3480221c:	e1a03a07 	lsl	r3, r7, #20
34802220:	e3833ec1 	orr	r3, r3, #3088	; 0xc10
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34802224:	e2877001 	add	r7, r7, #1
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34802228:	e3833002 	orr	r3, r3, #2
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
3480222c:	e3570a01 	cmp	r7, #4096	; 0x1000
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34802230:	e4843004 	str	r3, [r4], #4
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34802234:	1afffff8 	bne	3480221c <cache_enable+0x28>
	asm volatile("" : : : "memory");
}

static inline void dram_bank_mmu_setup(int bank)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
34802238:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
	bd_t *bd = gd->bd;
3480223c:	e5980000 	ldr	r0, [r8]
{
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
34802240:	e2422004 	sub	r2, r2, #4
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34802244:	e5901018 	ldr	r1, [r0, #24]
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34802248:	e590001c 	ldr	r0, [r0, #28]
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
3480224c:	e1a03a21 	lsr	r3, r1, #20
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34802250:	e0811000 	add	r1, r1, r0
34802254:	e1a01a21 	lsr	r1, r1, #20
34802258:	e0822103 	add	r2, r2, r3, lsl #2
3480225c:	ea000004 	b	34802274 <cache_enable+0x80>
	     i++) {
		page_table[i] = i << 20 | (3 << 10) | CACHE_SETUP;
34802260:	e1a00a03 	lsl	r0, r3, #20
34802264:	e3800ec1 	orr	r0, r0, #3088	; 0xc10
34802268:	e380000e 	orr	r0, r0, #14
3480226c:	e5a20004 	str	r0, [r2, #4]!
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
34802270:	e2833001 	add	r3, r3, #1
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34802274:	e1530001 	cmp	r3, r1
34802278:	3afffff8 	bcc	34802260 <cache_enable+0x6c>
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
3480227c:	ee026f10 	mcr	15, 0, r6, cr2, cr0, {0}
		     : : "r" (page_table) : "memory");
	/* Set the access control to all-supervisor */
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
34802280:	e3e03000 	mvn	r3, #0
34802284:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
		     : : "r" (~0));
	/* and enable the mmu */
	reg = get_cr();	/* get control reg. */
	cp_delay();
34802288:	ebffffcd 	bl	348021c4 <cp_delay>
3480228c:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
34802290:	e3844001 	orr	r4, r4, #1
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802294:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802298:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
		mmu_setup();
	reg = get_cr();	/* get control reg. */
	cp_delay();
3480229c:	ebffffc8 	bl	348021c4 <cp_delay>
	set_cr(reg | cache_bit);
348022a0:	e1845005 	orr	r5, r4, r5
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
348022a4:	ee015f10 	mcr	15, 0, r5, cr1, cr0, {0}
}
348022a8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

348022ac <cache_disable>:

/* cache_bit must be either CR_I or CR_C */
static void cache_disable(uint32_t cache_bit)
{
348022ac:	e92d4038 	push	{r3, r4, r5, lr}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348022b0:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
348022b4:	e1a04000 	mov	r4, r0
	uint32_t reg;

	reg = get_cr();
	cp_delay();
348022b8:	ebffffc1 	bl	348021c4 <cp_delay>

	if (cache_bit == CR_C) {
348022bc:	e3540004 	cmp	r4, #4
348022c0:	1a000003 	bne	348022d4 <cache_disable+0x28>
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
348022c4:	e3150004 	tst	r5, #4
348022c8:	08bd8038 	popeq	{r3, r4, r5, pc}
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
		flush_dcache_all();
348022cc:	ebfffb5c 	bl	34801044 <flush_dcache_all>
	if (cache_bit == CR_C) {
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
348022d0:	e2844001 	add	r4, r4, #1
		flush_dcache_all();
	}
	set_cr(reg & ~cache_bit);
348022d4:	e1c54004 	bic	r4, r5, r4
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
348022d8:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
348022dc:	e8bd8038 	pop	{r3, r4, r5, pc}

348022e0 <__arm_init_before_mmu>:

DECLARE_GLOBAL_DATA_PTR;

void __arm_init_before_mmu(void)
{
}
348022e0:	e12fff1e 	bx	lr

348022e4 <icache_enable>:
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
	cache_enable(CR_I);
348022e4:	e3a00a01 	mov	r0, #4096	; 0x1000
348022e8:	eaffffc1 	b	348021f4 <cache_enable>

348022ec <icache_disable>:
}

void icache_disable(void)
{
	cache_disable(CR_I);
348022ec:	e3a00a01 	mov	r0, #4096	; 0x1000
348022f0:	eaffffed 	b	348022ac <cache_disable>

348022f4 <icache_status>:
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348022f4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
}
348022f8:	e7e00650 	ubfx	r0, r0, #12, #1
348022fc:	e12fff1e 	bx	lr

34802300 <dcache_enable>:
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
	cache_enable(CR_C);
34802300:	e3a00004 	mov	r0, #4
34802304:	eaffffba 	b	348021f4 <cache_enable>

34802308 <dcache_disable>:
}

void dcache_disable(void)
{
	cache_disable(CR_C);
34802308:	e3a00004 	mov	r0, #4
3480230c:	eaffffe6 	b	348022ac <cache_disable>

34802310 <dcache_status>:
34802310:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
}
34802314:	e7e00150 	ubfx	r0, r0, #2, #1
34802318:	e12fff1e 	bx	lr

3480231c <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480231c:	e92d4038 	push	{r3, r4, r5, lr}
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802320:	e59f40c4 	ldr	r4, [pc, #196]	; 348023ec <do_bdinfo+0xd0>
#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	bd_t *bd = gd->bd;
34802324:	e5985000 	ldr	r5, [r8]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802328:	e1a00004 	mov	r0, r4
3480232c:	e5952004 	ldr	r2, [r5, #4]
34802330:	e59f10b8 	ldr	r1, [pc, #184]	; 348023f0 <do_bdinfo+0xd4>
34802334:	eb001de3 	bl	34809ac8 <printf>
34802338:	e5952008 	ldr	r2, [r5, #8]
3480233c:	e1a00004 	mov	r0, r4
34802340:	e59f10ac 	ldr	r1, [pc, #172]	; 348023f4 <do_bdinfo+0xd8>
34802344:	eb001ddf 	bl	34809ac8 <printf>
34802348:	e1a00004 	mov	r0, r4
3480234c:	e59f10a4 	ldr	r1, [pc, #164]	; 348023f8 <do_bdinfo+0xdc>
34802350:	e3a02000 	mov	r2, #0
34802354:	eb001ddb 	bl	34809ac8 <printf>
34802358:	e5952018 	ldr	r2, [r5, #24]
3480235c:	e1a00004 	mov	r0, r4
34802360:	e59f1094 	ldr	r1, [pc, #148]	; 348023fc <do_bdinfo+0xe0>
34802364:	eb001dd7 	bl	34809ac8 <printf>
34802368:	e595201c 	ldr	r2, [r5, #28]
3480236c:	e1a00004 	mov	r0, r4
34802370:	e59f1088 	ldr	r1, [pc, #136]	; 34802400 <do_bdinfo+0xe4>
34802374:	eb001dd3 	bl	34809ac8 <printf>

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
34802378:	e5951000 	ldr	r1, [r5]
3480237c:	e59f0080 	ldr	r0, [pc, #128]	; 34802404 <do_bdinfo+0xe8>
34802380:	eb001dd0 	bl	34809ac8 <printf>
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802384:	e1a00004 	mov	r0, r4
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
34802388:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480238c:	e59f1074 	ldr	r1, [pc, #116]	; 34802408 <do_bdinfo+0xec>
34802390:	eb001dcc 	bl	34809ac8 <printf>
34802394:	e1a00004 	mov	r0, r4
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
34802398:	e5982034 	ldr	r2, [r8, #52]	; 0x34
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480239c:	e59f1068 	ldr	r1, [pc, #104]	; 3480240c <do_bdinfo+0xf0>
348023a0:	eb001dc8 	bl	34809ac8 <printf>
348023a4:	e1a00004 	mov	r0, r4
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
348023a8:	e5982048 	ldr	r2, [r8, #72]	; 0x48
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348023ac:	e59f105c 	ldr	r1, [pc, #92]	; 34802410 <do_bdinfo+0xf4>
348023b0:	eb001dc4 	bl	34809ac8 <printf>
348023b4:	e1a00004 	mov	r0, r4
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
348023b8:	e5982040 	ldr	r2, [r8, #64]	; 0x40
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348023bc:	e59f1050 	ldr	r1, [pc, #80]	; 34802414 <do_bdinfo+0xf8>
348023c0:	eb001dc0 	bl	34809ac8 <printf>
348023c4:	e1a00004 	mov	r0, r4
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
348023c8:	e5982044 	ldr	r2, [r8, #68]	; 0x44
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348023cc:	e59f1044 	ldr	r1, [pc, #68]	; 34802418 <do_bdinfo+0xfc>
348023d0:	eb001dbc 	bl	34809ac8 <printf>
348023d4:	e1a00004 	mov	r0, r4
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
	print_num("FB base  ", gd->fb_base);
348023d8:	e5982018 	ldr	r2, [r8, #24]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348023dc:	e59f1038 	ldr	r1, [pc, #56]	; 3480241c <do_bdinfo+0x100>
348023e0:	eb001db8 	bl	34809ac8 <printf>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
348023e4:	e3a00000 	mov	r0, #0
348023e8:	e8bd8038 	pop	{r3, r4, r5, pc}
348023ec:	34822bef 	.word	0x34822bef
348023f0:	34822bff 	.word	0x34822bff
348023f4:	34822c0b 	.word	0x34822c0b
348023f8:	34822c17 	.word	0x34822c17
348023fc:	34822c21 	.word	0x34822c21
34802400:	34822c2a 	.word	0x34822c2a
34802404:	34822c32 	.word	0x34822c32
34802408:	34822c48 	.word	0x34822c48
3480240c:	34822c51 	.word	0x34822c51
34802410:	34822c5b 	.word	0x34822c5b
34802414:	34822c65 	.word	0x34822c65
34802418:	34822c6c 	.word	0x34822c6c
3480241c:	34822c76 	.word	0x34822c76

34802420 <do_go_exec>:
#ifdef CONFIG_CMD_GO

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
{
34802420:	e92d4008 	push	{r3, lr}
34802424:	e1a03000 	mov	r3, r0
	return entry (argc, argv);
34802428:	e1a00001 	mov	r0, r1
3480242c:	e1a01002 	mov	r1, r2
34802430:	e12fff33 	blx	r3
}
34802434:	e8bd8008 	pop	{r3, pc}

34802438 <do_go>:
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34802438:	e3520001 	cmp	r2, #1
{
	return entry (argc, argv);
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480243c:	e92d4070 	push	{r4, r5, r6, lr}
34802440:	e1a04002 	mov	r4, r2
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
		return CMD_RET_USAGE;
34802444:	d3e04000 	mvnle	r4, #0
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34802448:	da000011 	ble	34802494 <do_go+0x5c>
		return CMD_RET_USAGE;

	addr = simple_strtoul(argv[1], NULL, 16);
3480244c:	e5930004 	ldr	r0, [r3, #4]
34802450:	e3a02010 	mov	r2, #16
34802454:	e3a01000 	mov	r1, #0
34802458:	e2835004 	add	r5, r3, #4
3480245c:	eb006b60 	bl	3481d1e4 <simple_strtoul>
34802460:	e1a06000 	mov	r6, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
34802464:	e1a01006 	mov	r1, r6
34802468:	e59f002c 	ldr	r0, [pc, #44]	; 3480249c <do_go+0x64>
3480246c:	eb001d95 	bl	34809ac8 <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
34802470:	e2441001 	sub	r1, r4, #1
34802474:	e1a00006 	mov	r0, r6
34802478:	e1a02005 	mov	r2, r5
3480247c:	ebffffe7 	bl	34802420 <do_go_exec>
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;
34802480:	e1a01000 	mov	r1, r0
34802484:	e2504000 	subs	r4, r0, #0
34802488:	13a04001 	movne	r4, #1
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
	if (rc != 0) rcode = 1;

	printf ("## Application terminated, rc = 0x%lX\n", rc);
3480248c:	e59f000c 	ldr	r0, [pc, #12]	; 348024a0 <do_go+0x68>
34802490:	eb001d8c 	bl	34809ac8 <printf>
	return rcode;
}
34802494:	e1a00004 	mov	r0, r4
34802498:	e8bd8070 	pop	{r4, r5, r6, pc}
3480249c:	34822ca2 	.word	0x34822ca2
348024a0:	34822cca 	.word	0x34822cca

348024a4 <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
348024a4:	e6bf0f30 	rev	r0, r0
348024a8:	e12fff1e 	bx	lr

348024ac <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348024ac:	e92d4010 	push	{r4, lr}
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
348024b0:	e59f0014 	ldr	r0, [pc, #20]	; 348024cc <do_bootd+0x20>
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348024b4:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
348024b8:	eb001694 	bl	34807f10 <getenv>
348024bc:	e1a01004 	mov	r1, r4
348024c0:	eb00305d 	bl	3480e63c <run_command>
		rcode = 1;
	return rcode;
}
348024c4:	e1a00fa0 	lsr	r0, r0, #31
348024c8:	e8bd8010 	pop	{r4, pc}
348024cc:	34822d91 	.word	0x34822d91

348024d0 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348024d0:	e3500080 	cmp	r0, #128	; 0x80
348024d4:	13500000 	cmpne	r0, #0
#endif /* CONFIG_LYNXKDI */

#ifdef CONFIG_BOOTM_RTEMS
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
348024d8:	e92d4010 	push	{r4, lr}
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348024dc:	1a000007 	bne	34802500 <do_bootm_rtems+0x30>
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
348024e0:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
348024e4:	e59f001c 	ldr	r0, [pc, #28]	; 34802508 <do_bootm_rtems+0x38>
348024e8:	e1a01004 	mov	r1, r4
348024ec:	eb001d75 	bl	34809ac8 <printf>
348024f0:	e3a0000f 	mov	r0, #15
348024f4:	eb002dea 	bl	3480dca4 <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
348024f8:	e5980000 	ldr	r0, [r8]
348024fc:	e12fff34 	blx	r4

	return 1;
}
34802500:	e3a00001 	mov	r0, #1
34802504:	e8bd8010 	pop	{r4, pc}
34802508:	34822d99 	.word	0x34822d99

3480250c <do_bootm_netbsd>:
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
3480250c:	e3500080 	cmp	r0, #128	; 0x80
34802510:	13500000 	cmpne	r0, #0
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
34802514:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34802518:	e1a05001 	mov	r5, r1
3480251c:	e1a07002 	mov	r7, r2
34802520:	e1a04003 	mov	r4, r3
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34802524:	03a00000 	moveq	r0, #0
34802528:	13a00001 	movne	r0, #1
3480252c:	1a00003e 	bne	3480262c <do_bootm_netbsd+0x120>
	if (!images->legacy_hdr_valid) {
		fit_unsupported_reset("NetBSD");
		return 1;
	}
#endif
	hdr = images->legacy_hdr_os;
34802530:	e5936000 	ldr	r6, [r3]
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34802534:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
34802538:	e3530004 	cmp	r3, #4
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
3480253c:	11a06000 	movne	r6, r0
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34802540:	1a000007 	bne	34802564 <do_bootm_netbsd+0x58>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
34802544:	e1a00006 	mov	r0, r6
34802548:	e28d3008 	add	r3, sp, #8
3480254c:	e3a01001 	mov	r1, #1
34802550:	e28d200c 	add	r2, sp, #12
34802554:	eb002b6c 	bl	3480d30c <image_multi_getimg>
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
34802558:	e59d3008 	ldr	r3, [sp, #8]
3480255c:	e3530000 	cmp	r3, #0
34802560:	03a06000 	moveq	r6, #0
	consdev = "scc2";
#elif defined(CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
34802564:	e3550002 	cmp	r5, #2
34802568:	da00001f 	ble	348025ec <do_bootm_netbsd+0xe0>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
3480256c:	e287b004 	add	fp, r7, #4
34802570:	e3a09002 	mov	r9, #2
34802574:	e3a0a000 	mov	sl, #0
	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
34802578:	e5bb0004 	ldr	r0, [fp, #4]!
3480257c:	eb006785 	bl	3481c398 <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802580:	e2899001 	add	r9, r9, #1
			len += strlen(argv[i]) + 1;
34802584:	e080a00a 	add	sl, r0, sl

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802588:	e1590005 	cmp	r9, r5
			len += strlen(argv[i]) + 1;
3480258c:	e28aa001 	add	sl, sl, #1

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802590:	bafffff8 	blt	34802578 <do_bootm_netbsd+0x6c>
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34802594:	e1a0000a 	mov	r0, sl
34802598:	eb001f11 	bl	3480a1e4 <malloc>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
3480259c:	e2877008 	add	r7, r7, #8
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
348025a0:	e1a0a000 	mov	sl, r0

		for (i = 2, len = 0; i < argc; i += 1) {
348025a4:	e3a0b002 	mov	fp, #2
348025a8:	e3a09000 	mov	r9, #0
			if (i > 2)
				cmdline[len++] = ' ';
348025ac:	e3a03020 	mov	r3, #32
348025b0:	ea000002 	b	348025c0 <do_bootm_netbsd+0xb4>
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
348025b4:	e0809009 	add	r9, r0, r9
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
			if (i > 2)
				cmdline[len++] = ' ';
348025b8:	e7ca3009 	strb	r3, [sl, r9]
348025bc:	e2899001 	add	r9, r9, #1
			strcpy(&cmdline[len], argv[i]);
348025c0:	e5971000 	ldr	r1, [r7]
348025c4:	e08a0009 	add	r0, sl, r9
348025c8:	e58d3004 	str	r3, [sp, #4]

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
348025cc:	e28bb001 	add	fp, fp, #1
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
348025d0:	eb00670b 	bl	3481c204 <strcpy>
			len += strlen(argv[i]);
348025d4:	e4970004 	ldr	r0, [r7], #4
348025d8:	eb00676e 	bl	3481c398 <strlen>

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
348025dc:	e15b0005 	cmp	fp, r5
348025e0:	e59d3004 	ldr	r3, [sp, #4]
348025e4:	bafffff2 	blt	348025b4 <do_bootm_netbsd+0xa8>
348025e8:	ea000004 	b	34802600 <do_bootm_netbsd+0xf4>
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
348025ec:	e59f0044 	ldr	r0, [pc, #68]	; 34802638 <do_bootm_netbsd+0x12c>
348025f0:	eb001646 	bl	34807f10 <getenv>
		cmdline = "";
348025f4:	e3500000 	cmp	r0, #0
348025f8:	e59fa03c 	ldr	sl, [pc, #60]	; 3480263c <do_bootm_netbsd+0x130>
348025fc:	11a0a000 	movne	sl, r0
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
34802600:	e5944060 	ldr	r4, [r4, #96]	; 0x60

	printf("## Transferring control to NetBSD stage-2 loader "
34802604:	e59f0034 	ldr	r0, [pc, #52]	; 34802640 <do_bootm_netbsd+0x134>
34802608:	e1a01004 	mov	r1, r4
3480260c:	eb001d2d 	bl	34809ac8 <printf>
34802610:	e3a0000f 	mov	r0, #15
34802614:	eb002da2 	bl	3480dca4 <__show_boot_progress>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
34802618:	e1a01006 	mov	r1, r6
3480261c:	e5980000 	ldr	r0, [r8]
34802620:	e59f2014 	ldr	r2, [pc, #20]	; 3480263c <do_bootm_netbsd+0x130>
34802624:	e1a0300a 	mov	r3, sl
34802628:	e12fff34 	blx	r4

	return 1;
}
3480262c:	e3a00001 	mov	r0, #1
34802630:	e28dd010 	add	sp, sp, #16
34802634:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34802638:	34822917 	.word	0x34822917
3480263c:	34823d17 	.word	0x34823d17
34802640:	34822dd2 	.word	0x34822dd2

34802644 <image_check_magic.clone.9>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
34802644:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34802648:	ebffff95 	bl	348024a4 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480264c:	e59f300c 	ldr	r3, [pc, #12]	; 34802660 <image_check_magic.clone.9+0x1c>
34802650:	e1500003 	cmp	r0, r3
34802654:	13a00000 	movne	r0, #0
34802658:	03a00001 	moveq	r0, #1
3480265c:	e8bd8008 	pop	{r3, pc}
34802660:	27051956 	.word	0x27051956

34802664 <image_info>:
	}
	return rcode;
}

static int image_info(ulong addr)
{
34802664:	e92d4038 	push	{r3, r4, r5, lr}
34802668:	e1a04000 	mov	r4, r0
	void *hdr = (void *)addr;

	printf("\n## Checking Image at %08lx ...\n", addr);
3480266c:	e1a01004 	mov	r1, r4
34802670:	e59f0094 	ldr	r0, [pc, #148]	; 3480270c <image_info+0xa8>
34802674:	eb001d13 	bl	34809ac8 <printf>

	switch (genimg_get_format(hdr)) {
34802678:	e1a00004 	mov	r0, r4
3480267c:	eb002c37 	bl	3480d760 <genimg_get_format>
34802680:	e3500001 	cmp	r0, #1
34802684:	e1a05000 	mov	r5, r0
34802688:	1a00001a 	bne	348026f8 <image_info+0x94>
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
3480268c:	e59f007c 	ldr	r0, [pc, #124]	; 34802710 <image_info+0xac>
34802690:	eb001d02 	bl	34809aa0 <puts>
		if (!image_check_magic(hdr)) {
34802694:	e5940000 	ldr	r0, [r4]
34802698:	ebffffe9 	bl	34802644 <image_check_magic.clone.9>
3480269c:	e3500000 	cmp	r0, #0
			puts("   Bad Magic Number\n");
348026a0:	059f006c 	ldreq	r0, [pc, #108]	; 34802714 <image_info+0xb0>
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
348026a4:	0a000004 	beq	348026bc <image_info+0x58>
			puts("   Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
348026a8:	e1a00004 	mov	r0, r4
348026ac:	eb002aea 	bl	3480d25c <image_check_hcrc>
348026b0:	e3500000 	cmp	r0, #0
348026b4:	1a000002 	bne	348026c4 <image_info+0x60>
			puts("   Bad Header Checksum\n");
348026b8:	e59f0058 	ldr	r0, [pc, #88]	; 34802718 <image_info+0xb4>
348026bc:	eb001cf7 	bl	34809aa0 <puts>
			return 1;
348026c0:	ea00000f 	b	34802704 <image_info+0xa0>
		}

		image_print_contents(hdr);
348026c4:	e1a00004 	mov	r0, r4
348026c8:	eb002b9b 	bl	3480d53c <image_print_contents>

		puts("   Verifying Checksum ... ");
348026cc:	e59f0048 	ldr	r0, [pc, #72]	; 3480271c <image_info+0xb8>
348026d0:	eb001cf2 	bl	34809aa0 <puts>
		if (!image_check_dcrc(hdr)) {
348026d4:	e1a00004 	mov	r0, r4
348026d8:	eb002af3 	bl	3480d2ac <image_check_dcrc>
348026dc:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
348026e0:	059f0038 	ldreq	r0, [pc, #56]	; 34802720 <image_info+0xbc>
		}

		image_print_contents(hdr);

		puts("   Verifying Checksum ... ");
		if (!image_check_dcrc(hdr)) {
348026e4:	0afffff4 	beq	348026bc <image_info+0x58>
			puts("   Bad Data CRC\n");
			return 1;
		}
		puts("OK\n");
348026e8:	e59f0034 	ldr	r0, [pc, #52]	; 34802724 <image_info+0xc0>
348026ec:	eb001ceb 	bl	34809aa0 <puts>
		return 0;
348026f0:	e3a05000 	mov	r5, #0
348026f4:	ea000002 	b	34802704 <image_info+0xa0>
		}

		return 0;
#endif
	default:
		puts("Unknown image format!\n");
348026f8:	e59f0028 	ldr	r0, [pc, #40]	; 34802728 <image_info+0xc4>
348026fc:	eb001ce7 	bl	34809aa0 <puts>
		break;
	}

	return 1;
34802700:	e3a05001 	mov	r5, #1
}
34802704:	e1a00005 	mov	r0, r5
34802708:	e8bd8038 	pop	{r3, r4, r5, pc}
3480270c:	34822e1b 	.word	0x34822e1b
34802710:	34822e3c 	.word	0x34822e3c
34802714:	34822e53 	.word	0x34822e53
34802718:	34822e68 	.word	0x34822e68
3480271c:	34822e80 	.word	0x34822e80
34802720:	34822e9b 	.word	0x34822e9b
34802724:	34822eac 	.word	0x34822eac
34802728:	34822eb0 	.word	0x34822eb0

3480272c <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
3480272c:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* iminfo - print header info for a requested image */
/*******************************************************************/
#if defined(CONFIG_CMD_IMI)
int do_iminfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802730:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
34802734:	e1a04002 	mov	r4, r2
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34802738:	c1a07003 	movgt	r7, r3
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
3480273c:	c3a05000 	movgt	r5, #0
34802740:	c3a06001 	movgt	r6, #1
34802744:	ca000003 	bgt	34802758 <do_iminfo+0x2c>
		return image_info(load_addr);
34802748:	e59f3038 	ldr	r3, [pc, #56]	; 34802788 <do_iminfo+0x5c>
3480274c:	e5930000 	ldr	r0, [r3]
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802750:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34802754:	eaffffc2 	b	34802664 <image_info>
	}

	for (arg = 1; arg < argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
34802758:	e3a01000 	mov	r1, #0
3480275c:	e3a02010 	mov	r2, #16
34802760:	e5b70004 	ldr	r0, [r7, #4]!
34802764:	eb006a9e 	bl	3481d1e4 <simple_strtoul>
		if (image_info(addr) != 0)
34802768:	ebffffbd 	bl	34802664 <image_info>

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
3480276c:	e2866001 	add	r6, r6, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
34802770:	e3500000 	cmp	r0, #0
34802774:	13a05001 	movne	r5, #1

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34802778:	e1560004 	cmp	r6, r4
3480277c:	bafffff5 	blt	34802758 <do_iminfo+0x2c>
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802780:	e1a00005 	mov	r0, r5
34802784:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
34802788:	34828438 	.word	0x34828438

3480278c <image_get_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480278c:	eaffff44 	b	348024a4 <__fswab32>

34802790 <bootm_load_os.clone.18>:
}

#define BOOTM_ERR_RESET		-1
#define BOOTM_ERR_OVERLAP	-2
#define BOOTM_ERR_UNIMPLEMENTED	-3
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
34802790:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34802794:	e1a07000 	mov	r7, r0
34802798:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
3480279c:	e1a09001 	mov	r9, r1
348027a0:	e5dd602c 	ldrb	r6, [sp, #44]	; 0x2c
348027a4:	e1a0a002 	mov	sl, r2
348027a8:	e59d4028 	ldr	r4, [sp, #40]	; 0x28
348027ac:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
	uint8_t comp = os.comp;
	ulong load = os.load;
	ulong blob_start = os.start;
	ulong blob_end = os.end;
	ulong image_start = os.image_start;
	ulong image_len = os.image_len;
348027b0:	e58d3004 	str	r3, [sp, #4]
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
348027b4:	eb002b54 	bl	3480d50c <genimg_get_type_name>

	switch (comp) {
348027b8:	e3560000 	cmp	r6, #0
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
348027bc:	e1a01000 	mov	r1, r0

	switch (comp) {
348027c0:	0a000002 	beq	348027d0 <bootm_load_os.clone.18+0x40>
348027c4:	e3560001 	cmp	r6, #1
348027c8:	1a00002a 	bne	34802878 <bootm_load_os.clone.18+0xe8>
348027cc:	ea000015 	b	34802828 <bootm_load_os.clone.18+0x98>
	case IH_COMP_NONE:
		if (load == blob_start || load == image_start) {
348027d0:	e1540007 	cmp	r4, r7
348027d4:	1154000a 	cmpne	r4, sl
348027d8:	13a06000 	movne	r6, #0
348027dc:	03a06001 	moveq	r6, #1
348027e0:	1a000003 	bne	348027f4 <bootm_load_os.clone.18+0x64>
			printf("   XIP %s ... ", type_name);
348027e4:	e59f00f8 	ldr	r0, [pc, #248]	; 348028e4 <bootm_load_os.clone.18+0x154>
348027e8:	eb001cb6 	bl	34809ac8 <printf>
			no_overlap = 1;
348027ec:	e3a06001 	mov	r6, #1
348027f0:	ea000006 	b	34802810 <bootm_load_os.clone.18+0x80>
		} else {
			printf("   Loading %s ... ", type_name);
348027f4:	e59f00ec 	ldr	r0, [pc, #236]	; 348028e8 <bootm_load_os.clone.18+0x158>
348027f8:	eb001cb2 	bl	34809ac8 <printf>
			memmove_wd((void *)load, (void *)image_start,
348027fc:	e1a00004 	mov	r0, r4
34802800:	e1a0100a 	mov	r1, sl
34802804:	e59d2004 	ldr	r2, [sp, #4]
34802808:	e3a03801 	mov	r3, #65536	; 0x10000
3480280c:	eb002b18 	bl	3480d474 <memmove_wd>
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34802810:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
34802814:	e59f00d0 	ldr	r0, [pc, #208]	; 348028ec <bootm_load_os.clone.18+0x15c>
		} else {
			printf("   Loading %s ... ", type_name);
			memmove_wd((void *)load, (void *)image_start,
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34802818:	e0843003 	add	r3, r4, r3
3480281c:	e5853000 	str	r3, [r5]
		puts("OK\n");
34802820:	eb001c9e 	bl	34809aa0 <puts>
34802824:	ea000018 	b	3480288c <bootm_load_os.clone.18+0xfc>
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
34802828:	e59f00c0 	ldr	r0, [pc, #192]	; 348028f0 <bootm_load_os.clone.18+0x160>
3480282c:	eb001ca5 	bl	34809ac8 <printf>
		if (gunzip((void *)load, unc_len,
34802830:	e28d3004 	add	r3, sp, #4
34802834:	e1a00004 	mov	r0, r4
34802838:	e3a01502 	mov	r1, #8388608	; 0x800000
3480283c:	e1a0200a 	mov	r2, sl
34802840:	eb00615c 	bl	3481adb8 <gunzip>
34802844:	e2506000 	subs	r6, r0, #0
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
		}

		*load_end = load + image_len;
34802848:	059d3004 	ldreq	r3, [sp, #4]
3480284c:	00843003 	addeq	r3, r4, r3
34802850:	05853000 	streq	r3, [r5]
		puts("OK\n");
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
		if (gunzip((void *)load, unc_len,
34802854:	0a00000c 	beq	3480288c <bootm_load_os.clone.18+0xfc>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
34802858:	e59f0094 	ldr	r0, [pc, #148]	; 348028f4 <bootm_load_os.clone.18+0x164>
3480285c:	eb001c8f 	bl	34809aa0 <puts>
				"error - must RESET board to recover\n");
			if (boot_progress)
34802860:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34802864:	e3530000 	cmp	r3, #0
34802868:	0a00001b 	beq	348028dc <bootm_load_os.clone.18+0x14c>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480286c:	e3e00005 	mvn	r0, #5
34802870:	eb002d0b 	bl	3480dca4 <__show_boot_progress>
34802874:	ea000018 	b	348028dc <bootm_load_os.clone.18+0x14c>

		*load_end = load + unc_len;
		break;
#endif /* CONFIG_LZO */
	default:
		printf("Unimplemented compression type %d\n", comp);
34802878:	e59f0078 	ldr	r0, [pc, #120]	; 348028f8 <bootm_load_os.clone.18+0x168>
3480287c:	e1a01006 	mov	r1, r6
34802880:	eb001c90 	bl	34809ac8 <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
34802884:	e3e00002 	mvn	r0, #2
34802888:	ea000014 	b	348028e0 <bootm_load_os.clone.18+0x150>
	}

	flush_cache(load, (*load_end - load) * sizeof(ulong));
3480288c:	e5951000 	ldr	r1, [r5]
34802890:	e1a00004 	mov	r0, r4
34802894:	e0641001 	rsb	r1, r4, r1
34802898:	e1a01101 	lsl	r1, r1, #2
3480289c:	ebfffa09 	bl	348010c8 <flush_cache>

	puts("OK\n");
348028a0:	e59f0044 	ldr	r0, [pc, #68]	; 348028ec <bootm_load_os.clone.18+0x15c>
348028a4:	eb001c7d 	bl	34809aa0 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348028a8:	e3a00007 	mov	r0, #7
348028ac:	eb002cfc 	bl	3480dca4 <__show_boot_progress>
	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);

	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
348028b0:	e2760001 	rsbs	r0, r6, #1
348028b4:	33a00000 	movcc	r0, #0
348028b8:	e1540009 	cmp	r4, r9
348028bc:	23a00000 	movcs	r0, #0
348028c0:	e3500000 	cmp	r0, #0
348028c4:	0a000005 	beq	348028e0 <bootm_load_os.clone.18+0x150>
348028c8:	e5953000 	ldr	r3, [r5]
348028cc:	e1530007 	cmp	r3, r7
			*load_end);

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
348028d0:	83e00001 	mvnhi	r0, #1
348028d4:	93a00000 	movls	r0, #0
348028d8:	ea000000 	b	348028e0 <bootm_load_os.clone.18+0x150>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
				"error - must RESET board to recover\n");
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
348028dc:	e3e00000 	mvn	r0, #0

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
}
348028e0:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
348028e4:	34822ec7 	.word	0x34822ec7
348028e8:	34822ed6 	.word	0x34822ed6
348028ec:	34822eac 	.word	0x34822eac
348028f0:	34822ee9 	.word	0x34822ee9
348028f4:	34822f02 	.word	0x34822f02
348028f8:	34822f53 	.word	0x34822f53

348028fc <bootm_start.clone.17>:
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348028fc:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34802900:	e59f4358 	ldr	r4, [pc, #856]	; 34802c60 <bootm_start.clone.17+0x364>
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34802904:	e1a07001 	mov	r7, r1
34802908:	e1a0a000 	mov	sl, r0
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
3480290c:	e3a01000 	mov	r1, #0
34802910:	e1a00004 	mov	r0, r4
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34802914:	e1a06002 	mov	r6, r2
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34802918:	e3a02f4b 	mov	r2, #300	; 0x12c
3480291c:	eb00673d 	bl	3481c618 <memset>
	images.verify = getenv_yesno("verify");
34802920:	e59f033c 	ldr	r0, [pc, #828]	; 34802c64 <bootm_start.clone.17+0x368>
34802924:	eb002a99 	bl	3480d390 <getenv_yesno>
34802928:	e5840084 	str	r0, [r4, #132]	; 0x84
static void boot_start_lmb(bootm_headers_t *images)
{
	ulong		mem_start;
	phys_size_t	mem_size;

	lmb_init(&images->lmb);
3480292c:	e284008c 	add	r0, r4, #140	; 0x8c
34802930:	eb0064fa 	bl	3481bd20 <lmb_init>

	mem_start = getenv_bootm_low();
34802934:	eb002a9f 	bl	3480d3b8 <getenv_bootm_low>
34802938:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
3480293c:	eb002aa9 	bl	3480d3e8 <getenv_bootm_size>

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802940:	e1a01005 	mov	r1, r5
	phys_size_t	mem_size;

	lmb_init(&images->lmb);

	mem_start = getenv_bootm_low();
	mem_size = getenv_bootm_size();
34802944:	e1a02000 	mov	r2, r0

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802948:	e284008c 	add	r0, r4, #140	; 0x8c
3480294c:	eb0064fd 	bl	3481bd48 <lmb_add>

	arch_lmb_reserve(&images->lmb);
34802950:	e284008c 	add	r0, r4, #140	; 0x8c
34802954:	ebfffd4c 	bl	34801e8c <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
34802958:	e284008c 	add	r0, r4, #140	; 0x8c
3480295c:	eb0065ce 	bl	3481c09c <__board_lmb_reserve>
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34802960:	e3570001 	cmp	r7, #1
		img_addr = load_addr;
34802964:	d59f32fc 	ldrle	r3, [pc, #764]	; 34802c68 <bootm_start.clone.17+0x36c>
34802968:	d5934000 	ldrle	r4, [r3]
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
3480296c:	da000004 	ble	34802984 <bootm_start.clone.17+0x88>
							&fit_uname_kernel)) {
		debug("*  kernel: subimage '%s' from image at 0x%08lx\n",
				fit_uname_kernel, img_addr);
#endif
	} else {
		img_addr = simple_strtoul(argv[1], NULL, 16);
34802970:	e5960004 	ldr	r0, [r6, #4]
34802974:	e3a01000 	mov	r1, #0
34802978:	e3a02010 	mov	r2, #16
3480297c:	eb006a18 	bl	3481d1e4 <simple_strtoul>
34802980:	e1a04000 	mov	r4, r0
34802984:	e3a00001 	mov	r0, #1
34802988:	eb002cc5 	bl	3480dca4 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
3480298c:	e1a00004 	mov	r0, r4
34802990:	eb002b78 	bl	3480d778 <genimg_get_image>

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
34802994:	e59fb2c4 	ldr	fp, [pc, #708]	; 34802c60 <bootm_start.clone.17+0x364>
34802998:	e3a09000 	mov	r9, #0
3480299c:	e58b9054 	str	r9, [fp, #84]	; 0x54
348029a0:	e58b9050 	str	r9, [fp, #80]	; 0x50
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
348029a4:	e1a04000 	mov	r4, r0

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
348029a8:	e1a05000 	mov	r5, r0
348029ac:	eb002b6b 	bl	3480d760 <genimg_get_format>
348029b0:	e3500001 	cmp	r0, #1
348029b4:	1a00005c 	bne	34802b2c <bootm_start.clone.17+0x230>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
348029b8:	e1a01004 	mov	r1, r4
348029bc:	e59f02a8 	ldr	r0, [pc, #680]	; 34802c6c <bootm_start.clone.17+0x370>
348029c0:	eb001c40 	bl	34809ac8 <printf>
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
348029c4:	e5940000 	ldr	r0, [r4]
348029c8:	ebffff1d 	bl	34802644 <image_check_magic.clone.9>
348029cc:	e3500000 	cmp	r0, #0
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
348029d0:	e59b9084 	ldr	r9, [fp, #132]	; 0x84
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
348029d4:	1a000003 	bne	348029e8 <bootm_start.clone.17+0xec>
		puts("Bad Magic Number\n");
348029d8:	e59f0290 	ldr	r0, [pc, #656]	; 34802c70 <bootm_start.clone.17+0x374>
348029dc:	eb001c2f 	bl	34809aa0 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348029e0:	e3e00000 	mvn	r0, #0
348029e4:	ea000023 	b	34802a78 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348029e8:	e3a00002 	mov	r0, #2
348029ec:	eb002cac 	bl	3480dca4 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_MAGIC);
		return NULL;
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_HEADER);

	if (!image_check_hcrc(hdr)) {
348029f0:	e1a00004 	mov	r0, r4
348029f4:	eb002a18 	bl	3480d25c <image_check_hcrc>
348029f8:	e3500000 	cmp	r0, #0
348029fc:	1a000003 	bne	34802a10 <bootm_start.clone.17+0x114>
		puts("Bad Header Checksum\n");
34802a00:	e59f026c 	ldr	r0, [pc, #620]	; 34802c74 <bootm_start.clone.17+0x378>
34802a04:	eb001c25 	bl	34809aa0 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802a08:	e3e00001 	mvn	r0, #1
34802a0c:	ea000019 	b	34802a78 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802a10:	e3a00003 	mov	r0, #3
34802a14:	eb002ca2 	bl	3480dca4 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_HEADER);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_CHECKSUM);
	image_print_contents(hdr);
34802a18:	e1a00004 	mov	r0, r4
34802a1c:	eb002ac6 	bl	3480d53c <image_print_contents>

	if (verify) {
34802a20:	e3590000 	cmp	r9, #0
34802a24:	0a00000b 	beq	34802a58 <bootm_start.clone.17+0x15c>
		puts("   Verifying Checksum ... ");
34802a28:	e59f0248 	ldr	r0, [pc, #584]	; 34802c78 <bootm_start.clone.17+0x37c>
34802a2c:	eb001c1b 	bl	34809aa0 <puts>
		if (!image_check_dcrc(hdr)) {
34802a30:	e1a00004 	mov	r0, r4
34802a34:	eb002a1c 	bl	3480d2ac <image_check_dcrc>
34802a38:	e3500000 	cmp	r0, #0
34802a3c:	1a000003 	bne	34802a50 <bootm_start.clone.17+0x154>
			printf("Bad Data CRC\n");
34802a40:	e59f0234 	ldr	r0, [pc, #564]	; 34802c7c <bootm_start.clone.17+0x380>
34802a44:	eb001c1f 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802a48:	e3e00002 	mvn	r0, #2
34802a4c:	ea000009 	b	34802a78 <bootm_start.clone.17+0x17c>
			bootstage_error(BOOTSTAGE_ID_CHECK_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
34802a50:	e59f0228 	ldr	r0, [pc, #552]	; 34802c80 <bootm_start.clone.17+0x384>
34802a54:	eb001c11 	bl	34809aa0 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802a58:	e3a00004 	mov	r0, #4
34802a5c:	eb002c90 	bl	3480dca4 <__show_boot_progress>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802a60:	e5d4101d 	ldrb	r1, [r4, #29]
		}
		puts("OK\n");
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_ARCH);

	if (!image_check_target_arch(hdr)) {
34802a64:	e3510002 	cmp	r1, #2
34802a68:	0a000005 	beq	34802a84 <bootm_start.clone.17+0x188>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
34802a6c:	e59f0210 	ldr	r0, [pc, #528]	; 34802c84 <bootm_start.clone.17+0x388>
34802a70:	eb001c14 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802a74:	e3e00003 	mvn	r0, #3
34802a78:	eb002c89 	bl	3480dca4 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
		if (!hdr)
			return NULL;
34802a7c:	e3a05000 	mov	r5, #0
34802a80:	ea00002f 	b	34802b44 <bootm_start.clone.17+0x248>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802a84:	e3a00005 	mov	r0, #5
34802a88:	eb002c85 	bl	3480dca4 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);

		/* get os_data and os_len */
		switch (image_get_type(hdr)) {
34802a8c:	e5d4301e 	ldrb	r3, [r4, #30]
34802a90:	e3530002 	cmp	r3, #2
34802a94:	0a00000d 	beq	34802ad0 <bootm_start.clone.17+0x1d4>
34802a98:	8a000001 	bhi	34802aa4 <bootm_start.clone.17+0x1a8>
34802a9c:	e3530001 	cmp	r3, #1
34802aa0:	ea000002 	b	34802ab0 <bootm_start.clone.17+0x1b4>
34802aa4:	e3530004 	cmp	r3, #4
34802aa8:	0a000002 	beq	34802ab8 <bootm_start.clone.17+0x1bc>
34802aac:	e353000e 	cmp	r3, #14
34802ab0:	1a00000d 	bne	34802aec <bootm_start.clone.17+0x1f0>
34802ab4:	ea000005 	b	34802ad0 <bootm_start.clone.17+0x1d4>
		case IH_TYPE_KERNEL_NOLOAD:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
			break;
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
34802ab8:	e59f21c8 	ldr	r2, [pc, #456]	; 34802c88 <bootm_start.clone.17+0x38c>
34802abc:	e1a00004 	mov	r0, r4
34802ac0:	e3a01000 	mov	r1, #0
34802ac4:	e2823004 	add	r3, r2, #4
34802ac8:	eb002a0f 	bl	3480d30c <image_multi_getimg>
34802acc:	ea00000b 	b	34802b00 <bootm_start.clone.17+0x204>
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
34802ad0:	e59fa188 	ldr	sl, [pc, #392]	; 34802c60 <bootm_start.clone.17+0x364>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34802ad4:	e2843040 	add	r3, r4, #64	; 0x40
	return (char *)hdr->ih_name;
}

static inline uint32_t image_get_data_size(const image_header_t *hdr)
{
	return image_get_size(hdr);
34802ad8:	e594000c 	ldr	r0, [r4, #12]
34802adc:	e58a3050 	str	r3, [sl, #80]	; 0x50
34802ae0:	ebffff29 	bl	3480278c <image_get_size.clone.10>
			*os_len = image_get_data_size(hdr);
34802ae4:	e58a0054 	str	r0, [sl, #84]	; 0x54
34802ae8:	ea000004 	b	34802b00 <bootm_start.clone.17+0x204>
			break;
		default:
			printf("Wrong Image Type for %s command\n",
34802aec:	e59f0198 	ldr	r0, [pc, #408]	; 34802c8c <bootm_start.clone.17+0x390>
34802af0:	e59a1000 	ldr	r1, [sl]
34802af4:	eb001bf3 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802af8:	e3e00004 	mvn	r0, #4
34802afc:	eaffffdd 	b	34802a78 <bootm_start.clone.17+0x17c>

		/*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
34802b00:	e59fa158 	ldr	sl, [pc, #344]	; 34802c60 <bootm_start.clone.17+0x364>
34802b04:	e1a01004 	mov	r1, r4
34802b08:	e28a0004 	add	r0, sl, #4
34802b0c:	e3a02040 	mov	r2, #64	; 0x40
34802b10:	eb006701 	bl	3481c71c <memmove>
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;

		images->legacy_hdr_valid = 1;
34802b14:	e3a03001 	mov	r3, #1
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;
34802b18:	e58a4000 	str	r4, [sl]

		images->legacy_hdr_valid = 1;
34802b1c:	e58a3044 	str	r3, [sl, #68]	; 0x44
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802b20:	e3a00006 	mov	r0, #6
34802b24:	eb002c5e 	bl	3480dca4 <__show_boot_progress>
34802b28:	ea000005 	b	34802b44 <bootm_start.clone.17+0x248>
		images->fit_uname_os = fit_uname_kernel;
		images->fit_noffset_os = os_noffset;
		break;
#endif
	default:
		printf("Wrong Image Format for %s command\n", cmdtp->name);
34802b2c:	e59a1000 	ldr	r1, [sl]
34802b30:	e59f0158 	ldr	r0, [pc, #344]	; 34802c90 <bootm_start.clone.17+0x394>
34802b34:	eb001be3 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802b38:	e3e0006b 	mvn	r0, #107	; 0x6b
34802b3c:	eb002c58 	bl	3480dca4 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
		return NULL;
34802b40:	e1a05009 	mov	r5, r9
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802b44:	e59f4114 	ldr	r4, [pc, #276]	; 34802c60 <bootm_start.clone.17+0x364>
34802b48:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34802b4c:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
34802b50:	059f013c 	ldreq	r0, [pc, #316]	; 34802c94 <bootm_start.clone.17+0x398>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802b54:	0a000017 	beq	34802bb8 <bootm_start.clone.17+0x2bc>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802b58:	e1a00005 	mov	r0, r5
34802b5c:	eb002aff 	bl	3480d760 <genimg_get_format>
34802b60:	e3500001 	cmp	r0, #1
34802b64:	e1a0b000 	mov	fp, r0
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802b68:	159f0128 	ldrne	r0, [pc, #296]	; 34802c98 <bootm_start.clone.17+0x39c>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802b6c:	1a000011 	bne	34802bb8 <bootm_start.clone.17+0x2bc>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802b70:	e5d5a01e 	ldrb	sl, [r5, #30]
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
34802b74:	e5c4a05d 	strb	sl, [r4, #93]	; 0x5d
		images.os.comp = image_get_comp(os_hdr);
34802b78:	e5d5301f 	ldrb	r3, [r5, #31]
34802b7c:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802b80:	e5d5901c 	ldrb	r9, [r5, #28]
	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);
34802b84:	e5c4905e 	strb	r9, [r4, #94]	; 0x5e
	return ((ulong)hdr + image_get_header_size());
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
34802b88:	e595000c 	ldr	r0, [r5, #12]
34802b8c:	ebfffefe 	bl	3480278c <image_get_size.clone.10>
34802b90:	e2853040 	add	r3, r5, #64	; 0x40
}
static inline ulong image_get_image_end(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_image_size(hdr));
34802b94:	e0833000 	add	r3, r3, r0

		images.os.end = image_get_image_end(os_hdr);
34802b98:	e584304c 	str	r3, [r4, #76]	; 0x4c
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
34802b9c:	e5950010 	ldr	r0, [r5, #16]
34802ba0:	ebfffe3f 	bl	348024a4 <__fswab32>
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802ba4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
		images.os.load = image_get_load(os_hdr);
34802ba8:	e5840058 	str	r0, [r4, #88]	; 0x58
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802bac:	e3530000 	cmp	r3, #0
34802bb0:	1a000003 	bne	34802bc4 <bootm_start.clone.17+0x2c8>
34802bb4:	ea000008 	b	34802bdc <bootm_start.clone.17+0x2e0>
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802bb8:	eb001bb8 	bl	34809aa0 <puts>
		return 1;
34802bbc:	e3a00001 	mov	r0, #1
34802bc0:	ea000025 	b	34802c5c <bootm_start.clone.17+0x360>
image_get_hdr_l(ep)		/* image_get_ep */
34802bc4:	e5940018 	ldr	r0, [r4, #24]
34802bc8:	ebfffe35 	bl	348024a4 <__fswab32>
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802bcc:	e35a000e 	cmp	sl, #14
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
34802bd0:	e5840060 	str	r0, [r4, #96]	; 0x60
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802bd4:	1a000008 	bne	34802bfc <bootm_start.clone.17+0x300>
34802bd8:	ea000003 	b	34802bec <bootm_start.clone.17+0x2f0>
			puts("Can't get entry point property!\n");
			return 1;
		}
#endif
	} else {
		puts("Could not find kernel entry point!\n");
34802bdc:	e59f00b8 	ldr	r0, [pc, #184]	; 34802c9c <bootm_start.clone.17+0x3a0>
34802be0:	eb001bae 	bl	34809aa0 <puts>
		return 1;
34802be4:	e1a0000b 	mov	r0, fp
34802be8:	ea00001b 	b	34802c5c <bootm_start.clone.17+0x360>
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
34802bec:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34802bf0:	e5843058 	str	r3, [r4, #88]	; 0x58
		images.ep += images.os.load;
34802bf4:	e0803003 	add	r3, r0, r3
34802bf8:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	if (((images.os.type == IH_TYPE_KERNEL) ||
34802bfc:	e35a0002 	cmp	sl, #2
34802c00:	135a000e 	cmpne	sl, #14
34802c04:	0a000001 	beq	34802c10 <bootm_start.clone.17+0x314>
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
34802c08:	e35a0004 	cmp	sl, #4
34802c0c:	1a00000d 	bne	34802c48 <bootm_start.clone.17+0x34c>
	     (images.os.type == IH_TYPE_MULTI)) &&
34802c10:	e3590005 	cmp	r9, #5
34802c14:	1a00000b 	bne	34802c48 <bootm_start.clone.17+0x34c>
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
34802c18:	e59f3080 	ldr	r3, [pc, #128]	; 34802ca0 <bootm_start.clone.17+0x3a4>
34802c1c:	e1a00007 	mov	r0, r7
34802c20:	e58d3000 	str	r3, [sp]
34802c24:	e2833004 	add	r3, r3, #4
34802c28:	e58d3004 	str	r3, [sp, #4]
34802c2c:	e1a01006 	mov	r1, r6
34802c30:	e59f2028 	ldr	r2, [pc, #40]	; 34802c60 <bootm_start.clone.17+0x364>
34802c34:	e3a03002 	mov	r3, #2
34802c38:	eb002ad1 	bl	3480d784 <boot_get_ramdisk>
				&images.rd_start, &images.rd_end);
		if (ret) {
34802c3c:	e3500000 	cmp	r0, #0
			puts("Ramdisk image is corrupt or invalid\n");
34802c40:	159f005c 	ldrne	r0, [pc, #92]	; 34802ca4 <bootm_start.clone.17+0x3a8>
	     (images.os.type == IH_TYPE_MULTI)) &&
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
				&images.rd_start, &images.rd_end);
		if (ret) {
34802c44:	1affffdb 	bne	34802bb8 <bootm_start.clone.17+0x2bc>

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802c48:	e59f3010 	ldr	r3, [pc, #16]	; 34802c60 <bootm_start.clone.17+0x364>
	images.state = BOOTM_STATE_START;
34802c4c:	e3a02001 	mov	r2, #1

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802c50:	e5835048 	str	r5, [r3, #72]	; 0x48
	images.state = BOOTM_STATE_START;
34802c54:	e5832088 	str	r2, [r3, #136]	; 0x88

	return 0;
34802c58:	e3a00000 	mov	r0, #0
}
34802c5c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34802c60:	34829868 	.word	0x34829868
34802c64:	34822f76 	.word	0x34822f76
34802c68:	34828438 	.word	0x34828438
34802c6c:	34822f7d 	.word	0x34822f7d
34802c70:	34822e56 	.word	0x34822e56
34802c74:	34822e6b 	.word	0x34822e6b
34802c78:	34822e80 	.word	0x34822e80
34802c7c:	34822e9e 	.word	0x34822e9e
34802c80:	34822eac 	.word	0x34822eac
34802c84:	34822faf 	.word	0x34822faf
34802c88:	348298b8 	.word	0x348298b8
34802c8c:	34822fce 	.word	0x34822fce
34802c90:	34822fef 	.word	0x34822fef
34802c94:	34823012 	.word	0x34823012
34802c98:	34823032 	.word	0x34823032
34802c9c:	34823055 	.word	0x34823055
34802ca0:	348298cc 	.word	0x348298cc
34802ca4:	34823079 	.word	0x34823079

34802ca8 <__arch_preboot_os>:

/* Allow for arch specific config before we boot */
void __arch_preboot_os(void)
{
	/* please define platform specific arch_preboot_os() */
}
34802ca8:	e12fff1e 	bx	lr

34802cac <do_bootm_subcommand>:
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802cac:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802cb0:	e59f1218 	ldr	r1, [pc, #536]	; 34802ed0 <do_bootm_subcommand+0x224>
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802cb4:	e24dd030 	sub	sp, sp, #48	; 0x30
34802cb8:	e1a04000 	mov	r4, r0
34802cbc:	e1a05002 	mov	r5, r2
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802cc0:	e5930004 	ldr	r0, [r3, #4]
34802cc4:	e3a02007 	mov	r2, #7
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802cc8:	e1a07003 	mov	r7, r3
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802ccc:	e2836004 	add	r6, r3, #4
34802cd0:	eb0019f4 	bl	348094a8 <find_cmd_tbl>

	if (c) {
34802cd4:	e3500000 	cmp	r0, #0
34802cd8:	0a000076 	beq	34802eb8 <do_bootm_subcommand+0x20c>
		state = (long)c->cmd;
34802cdc:	e590a00c 	ldr	sl, [r0, #12]

		/* treat start special since it resets the state machine */
		if (state == BOOTM_STATE_START) {
34802ce0:	e35a0001 	cmp	sl, #1
34802ce4:	1a000005 	bne	34802d00 <do_bootm_subcommand+0x54>
			argc--;
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
34802ce8:	e2451001 	sub	r1, r5, #1
34802cec:	e1a00004 	mov	r0, r4
34802cf0:	e1a02006 	mov	r2, r6
34802cf4:	ebffff00 	bl	348028fc <bootm_start.clone.17>
34802cf8:	e1a05000 	mov	r5, r0
34802cfc:	ea000070 	b	34802ec4 <do_bootm_subcommand+0x218>
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
	}

	if (images.state >= state) {
34802d00:	e59f41cc 	ldr	r4, [pc, #460]	; 34802ed4 <do_bootm_subcommand+0x228>
34802d04:	e5943088 	ldr	r3, [r4, #136]	; 0x88
34802d08:	e153000a 	cmp	r3, sl
34802d0c:	ba000002 	blt	34802d1c <do_bootm_subcommand+0x70>
		printf("Trying to execute a command out of order\n");
34802d10:	e59f01c0 	ldr	r0, [pc, #448]	; 34802ed8 <do_bootm_subcommand+0x22c>
34802d14:	eb001b6b 	bl	34809ac8 <printf>
34802d18:	ea000066 	b	34802eb8 <do_bootm_subcommand+0x20c>
		return CMD_RET_USAGE;
	}

	images.state |= state;
34802d1c:	e18a3003 	orr	r3, sl, r3
34802d20:	e5843088 	str	r3, [r4, #136]	; 0x88
	boot_fn = boot_os[images.os.os];
34802d24:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802d28:	e59f31ac 	ldr	r3, [pc, #428]	; 34802edc <do_bootm_subcommand+0x230>

	switch (state) {
34802d2c:	e35a0010 	cmp	sl, #16
		printf("Trying to execute a command out of order\n");
		return CMD_RET_USAGE;
	}

	images.state |= state;
	boot_fn = boot_os[images.os.os];
34802d30:	e7936102 	ldr	r6, [r3, r2, lsl #2]

	switch (state) {
34802d34:	0a00003b 	beq	34802e28 <do_bootm_subcommand+0x17c>
34802d38:	ca000004 	bgt	34802d50 <do_bootm_subcommand+0xa4>
34802d3c:	e35a0002 	cmp	sl, #2
34802d40:	0a000009 	beq	34802d6c <do_bootm_subcommand+0xc0>
34802d44:	e35a0004 	cmp	sl, #4
34802d48:	1a00005c 	bne	34802ec0 <do_bootm_subcommand+0x214>
34802d4c:	ea00001b 	b	34802dc0 <do_bootm_subcommand+0x114>
34802d50:	e35a0040 	cmp	sl, #64	; 0x40
34802d54:	0a000045 	beq	34802e70 <do_bootm_subcommand+0x1c4>
34802d58:	e35a0080 	cmp	sl, #128	; 0x80
34802d5c:	0a00004d 	beq	34802e98 <do_bootm_subcommand+0x1ec>
34802d60:	e35a0020 	cmp	sl, #32
34802d64:	1a000055 	bne	34802ec0 <do_bootm_subcommand+0x214>
34802d68:	ea000037 	b	34802e4c <do_bootm_subcommand+0x1a0>
		ulong load_end;
		case BOOTM_STATE_START:
			/* should never occur */
			break;
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
34802d6c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802d70:	e58d3000 	str	r3, [sp]
34802d74:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802d78:	e58d3004 	str	r3, [sp, #4]
34802d7c:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802d80:	e58d3008 	str	r3, [sp, #8]
34802d84:	e28d302c 	add	r3, sp, #44	; 0x2c
34802d88:	e58d300c 	str	r3, [sp, #12]
34802d8c:	e3a03000 	mov	r3, #0
34802d90:	e58d3010 	str	r3, [sp, #16]
34802d94:	e2840048 	add	r0, r4, #72	; 0x48
34802d98:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802d9c:	ebfffe7b 	bl	34802790 <bootm_load_os.clone.18>
			if (ret)
34802da0:	e2505000 	subs	r5, r0, #0
34802da4:	1a000046 	bne	34802ec4 <do_bootm_subcommand+0x218>
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
					(load_end - images.os.load));
34802da8:	e5941058 	ldr	r1, [r4, #88]	; 0x58
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
34802dac:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34802db0:	e284008c 	add	r0, r4, #140	; 0x8c
34802db4:	e0612002 	rsb	r2, r1, r2
34802db8:	eb00642d 	bl	3481be74 <lmb_reserve>
					(load_end - images.os.load));
			break;
34802dbc:	ea000040 	b	34802ec4 <do_bootm_subcommand+0x218>
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		case BOOTM_STATE_RAMDISK:
		{
			ulong rd_len = images.rd_end - images.rd_start;
34802dc0:	e5941064 	ldr	r1, [r4, #100]	; 0x64
34802dc4:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			char str[17];

			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802dc8:	e2843074 	add	r3, r4, #116	; 0x74
34802dcc:	e58d3000 	str	r3, [sp]
34802dd0:	e284008c 	add	r0, r4, #140	; 0x8c
34802dd4:	e0612002 	rsb	r2, r1, r2
34802dd8:	e2843070 	add	r3, r4, #112	; 0x70
34802ddc:	eb002af4 	bl	3480d9b4 <boot_ramdisk_high>
				rd_len, &images.initrd_start, &images.initrd_end);
			if (ret)
34802de0:	e2505000 	subs	r5, r0, #0
34802de4:	1a000036 	bne	34802ec4 <do_bootm_subcommand+0x218>
				return ret;

			sprintf(str, "%lx", images.initrd_start);
34802de8:	e28d6018 	add	r6, sp, #24
34802dec:	e5942070 	ldr	r2, [r4, #112]	; 0x70
34802df0:	e1a00006 	mov	r0, r6
34802df4:	e59f10e4 	ldr	r1, [pc, #228]	; 34802ee0 <do_bootm_subcommand+0x234>
34802df8:	eb00699f 	bl	3481d47c <sprintf>
			setenv("initrd_start", str);
34802dfc:	e1a01006 	mov	r1, r6
34802e00:	e59f00dc 	ldr	r0, [pc, #220]	; 34802ee4 <do_bootm_subcommand+0x238>
34802e04:	eb001339 	bl	34807af0 <setenv>
			sprintf(str, "%lx", images.initrd_end);
34802e08:	e1a00006 	mov	r0, r6
34802e0c:	e59f10cc 	ldr	r1, [pc, #204]	; 34802ee0 <do_bootm_subcommand+0x234>
34802e10:	e5942074 	ldr	r2, [r4, #116]	; 0x74
34802e14:	eb006998 	bl	3481d47c <sprintf>
			setenv("initrd_end", str);
34802e18:	e1a01006 	mov	r1, r6
34802e1c:	e59f00c4 	ldr	r0, [pc, #196]	; 34802ee8 <do_bootm_subcommand+0x23c>
34802e20:	eb001332 	bl	34807af0 <setenv>
		}
			break;
34802e24:	ea000026 	b	34802ec4 <do_bootm_subcommand+0x218>
				&images.ft_addr, &images.ft_len);
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
34802e28:	e1a01005 	mov	r1, r5
34802e2c:	e1a0000a 	mov	r0, sl
34802e30:	e1a02007 	mov	r2, r7
34802e34:	e1a03004 	mov	r3, r4
34802e38:	e12fff36 	blx	r6
			if (ret)
34802e3c:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
34802e40:	159f00a4 	ldrne	r0, [pc, #164]	; 34802eec <do_bootm_subcommand+0x240>
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
			if (ret)
34802e44:	0a00001e 	beq	34802ec4 <do_bootm_subcommand+0x218>
34802e48:	ea000010 	b	34802e90 <do_bootm_subcommand+0x1e4>
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
34802e4c:	e1a01005 	mov	r1, r5
34802e50:	e1a0000a 	mov	r0, sl
34802e54:	e1a02007 	mov	r2, r7
34802e58:	e1a03004 	mov	r3, r4
34802e5c:	e12fff36 	blx	r6
			if (ret)
34802e60:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
34802e64:	159f0084 	ldrne	r0, [pc, #132]	; 34802ef0 <do_bootm_subcommand+0x244>
			if (ret)
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
			if (ret)
34802e68:	0a000015 	beq	34802ec4 <do_bootm_subcommand+0x218>
34802e6c:	ea000007 	b	34802e90 <do_bootm_subcommand+0x1e4>
				printf("bdt subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_PREP:
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
34802e70:	e1a01005 	mov	r1, r5
34802e74:	e1a0000a 	mov	r0, sl
34802e78:	e1a02007 	mov	r2, r7
34802e7c:	e1a03004 	mov	r3, r4
34802e80:	e12fff36 	blx	r6
			if (ret)
34802e84:	e2505000 	subs	r5, r0, #0
34802e88:	0a00000d 	beq	34802ec4 <do_bootm_subcommand+0x218>
				printf("prep subcommand not supported\n");
34802e8c:	e59f0060 	ldr	r0, [pc, #96]	; 34802ef4 <do_bootm_subcommand+0x248>
34802e90:	eb001b0c 	bl	34809ac8 <printf>
34802e94:	ea00000a 	b	34802ec4 <do_bootm_subcommand+0x218>
			break;
		case BOOTM_STATE_OS_GO:
			disable_interrupts();
34802e98:	ebfffc22 	bl	34801f28 <disable_interrupts>
			 * Stop the ethernet stack if NetConsole could have
			 * left it up
			 */
			eth_halt();
#endif
			arch_preboot_os();
34802e9c:	ebffff81 	bl	34802ca8 <__arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
34802ea0:	e1a0000a 	mov	r0, sl
34802ea4:	e1a01005 	mov	r1, r5
34802ea8:	e1a02007 	mov	r2, r7
34802eac:	e1a03004 	mov	r3, r4
34802eb0:	e12fff36 	blx	r6
34802eb4:	ea000001 	b	34802ec0 <do_bootm_subcommand+0x214>
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
		}
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
34802eb8:	e3e05000 	mvn	r5, #0
34802ebc:	ea000000 	b	34802ec4 <do_bootm_subcommand+0x218>
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int ret = 0;
34802ec0:	e3a05000 	mov	r5, #0
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
			break;
	}

	return ret;
}
34802ec4:	e1a00005 	mov	r0, r5
34802ec8:	e28dd030 	add	sp, sp, #48	; 0x30
34802ecc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34802ed0:	348282c0 	.word	0x348282c0
34802ed4:	34829868 	.word	0x34829868
34802ed8:	3482309e 	.word	0x3482309e
34802edc:	34820110 	.word	0x34820110
34802ee0:	348230c8 	.word	0x348230c8
34802ee4:	348230cc 	.word	0x348230cc
34802ee8:	348230d9 	.word	0x348230d9
34802eec:	348230e4 	.word	0x348230e4
34802ef0:	34823106 	.word	0x34823106
34802ef4:	34823124 	.word	0x34823124

34802ef8 <do_bootm>:
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ef8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
34802efc:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802f00:	e24dd040 	sub	sp, sp, #64	; 0x40
34802f04:	e1a05003 	mov	r5, r3
	ulong		iflag;
	ulong		load_end = 0;
34802f08:	e3a03000 	mov	r3, #0
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802f0c:	e1a07000 	mov	r7, r0
34802f10:	e1a09001 	mov	r9, r1
34802f14:	e1a06002 	mov	r6, r2
	ulong		iflag;
	ulong		load_end = 0;
34802f18:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
34802f1c:	da000010 	ble	34802f64 <do_bootm+0x6c>
		char *endp;

		simple_strtoul(argv[1], &endp, 16);
34802f20:	e5950004 	ldr	r0, [r5, #4]
34802f24:	e28d1038 	add	r1, sp, #56	; 0x38
34802f28:	e3a02010 	mov	r2, #16
34802f2c:	eb0068ac 	bl	3481d1e4 <simple_strtoul>
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
34802f30:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34802f34:	e5d33000 	ldrb	r3, [r3]
34802f38:	e353003a 	cmp	r3, #58	; 0x3a
34802f3c:	13530000 	cmpne	r3, #0
34802f40:	0a000007 	beq	34802f64 <do_bootm+0x6c>
34802f44:	e3530023 	cmp	r3, #35	; 0x23
34802f48:	0a000005 	beq	34802f64 <do_bootm+0x6c>
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
34802f4c:	e1a00007 	mov	r0, r7
34802f50:	e1a01009 	mov	r1, r9
34802f54:	e1a02006 	mov	r2, r6
34802f58:	e1a03005 	mov	r3, r5
34802f5c:	ebffff52 	bl	34802cac <do_bootm_subcommand>
34802f60:	ea00007f 	b	34803164 <do_bootm+0x26c>
	}

	if (bootm_start(cmdtp, flag, argc, argv))
34802f64:	e1a00007 	mov	r0, r7
34802f68:	e1a01006 	mov	r1, r6
34802f6c:	e1a02005 	mov	r2, r5
34802f70:	ebfffe61 	bl	348028fc <bootm_start.clone.17>
34802f74:	e3500000 	cmp	r0, #0
34802f78:	1a000078 	bne	34803160 <do_bootm+0x268>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
34802f7c:	ebfffbe9 	bl	34801f28 <disable_interrupts>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802f80:	e59f41e4 	ldr	r4, [pc, #484]	; 3480316c <do_bootm+0x274>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
34802f84:	e1a0b000 	mov	fp, r0
	 * details see the OpenHCI specification.
	 */
	usb_stop();
#endif

	ret = bootm_load_os(images.os, &load_end, 1);
34802f88:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802f8c:	e58d3000 	str	r3, [sp]
34802f90:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802f94:	e58d3004 	str	r3, [sp, #4]
34802f98:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802f9c:	e58d3008 	str	r3, [sp, #8]
34802fa0:	e28d303c 	add	r3, sp, #60	; 0x3c
34802fa4:	e58d300c 	str	r3, [sp, #12]
34802fa8:	e3a03001 	mov	r3, #1
34802fac:	e58d3010 	str	r3, [sp, #16]
34802fb0:	e2840048 	add	r0, r4, #72	; 0x48
34802fb4:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802fb8:	ebfffdf4 	bl	34802790 <bootm_load_os.clone.18>

	if (ret < 0) {
34802fbc:	e3500000 	cmp	r0, #0
34802fc0:	aa00001d 	bge	3480303c <do_bootm+0x144>
		if (ret == BOOTM_ERR_RESET)
34802fc4:	e3700001 	cmn	r0, #1
34802fc8:	0a00000e 	beq	34803008 <do_bootm+0x110>
			do_reset(cmdtp, flag, argc, argv);
		if (ret == BOOTM_ERR_OVERLAP) {
34802fcc:	e3700002 	cmn	r0, #2
34802fd0:	1a000012 	bne	34803020 <do_bootm+0x128>
			if (images.legacy_hdr_valid) {
34802fd4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34802fd8:	e3530000 	cmp	r3, #0
34802fdc:	0a000005 	beq	34802ff8 <do_bootm+0x100>
				image_header_t *hdr;
				hdr = &images.legacy_hdr_os_copy;
				if (image_get_type(hdr) == IH_TYPE_MULTI)
34802fe0:	e5d43022 	ldrb	r3, [r4, #34]	; 0x22
34802fe4:	e3530004 	cmp	r3, #4
34802fe8:	1a000013 	bne	3480303c <do_bootm+0x144>
					puts("WARNING: legacy format multi "
34802fec:	e59f017c 	ldr	r0, [pc, #380]	; 34803170 <do_bootm+0x278>
34802ff0:	eb001aaa 	bl	34809aa0 <puts>
34802ff4:	ea000010 	b	3480303c <do_bootm+0x144>
						"component image "
						"overwritten\n");
			} else {
				puts("ERROR: new format image overwritten - "
34802ff8:	e59f0174 	ldr	r0, [pc, #372]	; 34803174 <do_bootm+0x27c>
34802ffc:	eb001aa7 	bl	34809aa0 <puts>
34803000:	e3e00070 	mvn	r0, #112	; 0x70
34803004:	eb002b26 	bl	3480dca4 <__show_boot_progress>
					"must RESET the board to recover\n");
				bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
				do_reset(cmdtp, flag, argc, argv);
34803008:	e1a00007 	mov	r0, r7
3480300c:	e1a01009 	mov	r1, r9
34803010:	e1a02006 	mov	r2, r6
34803014:	e1a03005 	mov	r3, r5
34803018:	ebfffc57 	bl	3480217c <do_reset>
3480301c:	ea000006 	b	3480303c <do_bootm+0x144>
			}
		}
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
34803020:	e3700003 	cmn	r0, #3
34803024:	1a000004 	bne	3480303c <do_bootm+0x144>
			if (iflag)
34803028:	e35b0000 	cmp	fp, #0
3480302c:	0a000000 	beq	34803034 <do_bootm+0x13c>
				enable_interrupts();
34803030:	ebfffbbb 	bl	34801f24 <enable_interrupts>
34803034:	e3e00006 	mvn	r0, #6
34803038:	ea000039 	b	34803124 <do_bootm+0x22c>
			bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
			return 1;
		}
	}

	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
3480303c:	e59fa128 	ldr	sl, [pc, #296]	; 3480316c <do_bootm+0x274>
34803040:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
34803044:	e59a1058 	ldr	r1, [sl, #88]	; 0x58
34803048:	e28a008c 	add	r0, sl, #140	; 0x8c
3480304c:	e0612002 	rsb	r2, r1, r2
34803050:	eb006387 	bl	3481be74 <lmb_reserve>

	if (images.os.type == IH_TYPE_STANDALONE) {
34803054:	e5da305d 	ldrb	r3, [sl, #93]	; 0x5d
34803058:	e3530001 	cmp	r3, #1
3480305c:	1a00001e 	bne	348030dc <do_bootm+0x1e4>
		if (iflag)
34803060:	e35b0000 	cmp	fp, #0
34803064:	0a000000 	beq	3480306c <do_bootm+0x174>
			enable_interrupts();
34803068:	ebfffbad 	bl	34801f24 <enable_interrupts>
{
	char  *s;
	int   (*appl)(int, char * const []);

	/* Don't start if "autostart" is set to "no" */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
3480306c:	e59f0104 	ldr	r0, [pc, #260]	; 34803178 <do_bootm+0x280>
34803070:	eb0013a6 	bl	34807f10 <getenv>
34803074:	e3500000 	cmp	r0, #0
34803078:	0a00000e 	beq	348030b8 <do_bootm+0x1c0>
3480307c:	e59f10f8 	ldr	r1, [pc, #248]	; 3480317c <do_bootm+0x284>
34803080:	eb006490 	bl	3481c2c8 <strcmp>
34803084:	e2507000 	subs	r7, r0, #0
34803088:	1a00000a 	bne	348030b8 <do_bootm+0x1c0>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
3480308c:	e59f30d8 	ldr	r3, [pc, #216]	; 3480316c <do_bootm+0x274>
34803090:	e28d4018 	add	r4, sp, #24
34803094:	e59f10e4 	ldr	r1, [pc, #228]	; 34803180 <do_bootm+0x288>
34803098:	e5932054 	ldr	r2, [r3, #84]	; 0x54
3480309c:	e1a00004 	mov	r0, r4
348030a0:	eb0068f5 	bl	3481d47c <sprintf>
		setenv("filesize", buf);
348030a4:	e59f00d8 	ldr	r0, [pc, #216]	; 34803184 <do_bootm+0x28c>
348030a8:	e1a01004 	mov	r1, r4
348030ac:	eb00128f 	bl	34807af0 <setenv>
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
348030b0:	e1a00007 	mov	r0, r7
348030b4:	ea00002a 	b	34803164 <do_bootm+0x26c>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
348030b8:	e59f30ac 	ldr	r3, [pc, #172]	; 3480316c <do_bootm+0x274>
348030bc:	e5930060 	ldr	r0, [r3, #96]	; 0x60
348030c0:	ebfffcf7 	bl	348024a4 <__fswab32>
	(*appl)(argc-1, &argv[1]);
348030c4:	e2851004 	add	r1, r5, #4
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
348030c8:	e1a03000 	mov	r3, r0
	(*appl)(argc-1, &argv[1]);
348030cc:	e2460001 	sub	r0, r6, #1
348030d0:	e12fff33 	blx	r3
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
348030d4:	e3a00000 	mov	r0, #0
348030d8:	ea000021 	b	34803164 <do_bootm+0x26c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348030dc:	e3a00008 	mov	r0, #8
348030e0:	eb002aef 	bl	3480dca4 <__show_boot_progress>
#ifdef CONFIG_SILENT_CONSOLE
	if (images.os.os == IH_OS_LINUX)
		fixup_silent_linux();
#endif

	boot_fn = boot_os[images.os.os];
348030e4:	e5da205e 	ldrb	r2, [sl, #94]	; 0x5e
348030e8:	e59f3098 	ldr	r3, [pc, #152]	; 34803188 <do_bootm+0x290>
348030ec:	e7934102 	ldr	r4, [r3, r2, lsl #2]

	if (boot_fn == NULL) {
348030f0:	e3540000 	cmp	r4, #0
348030f4:	1a00000c 	bne	3480312c <do_bootm+0x234>
		if (iflag)
348030f8:	e35b0000 	cmp	fp, #0
348030fc:	0a000000 	beq	34803104 <do_bootm+0x20c>
			enable_interrupts();
34803100:	ebfffb87 	bl	34801f24 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
34803104:	e59f4060 	ldr	r4, [pc, #96]	; 3480316c <do_bootm+0x274>
34803108:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
3480310c:	eb0028f2 	bl	3480d4dc <genimg_get_os_name>
34803110:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34803114:	e1a01000 	mov	r1, r0
34803118:	e59f006c 	ldr	r0, [pc, #108]	; 3480318c <do_bootm+0x294>
3480311c:	eb001a69 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34803120:	e3e00007 	mvn	r0, #7
34803124:	eb002ade 	bl	3480dca4 <__show_boot_progress>
34803128:	ea00000c 	b	34803160 <do_bootm+0x268>
			genimg_get_os_name(images.os.os), images.os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	arch_preboot_os();
3480312c:	ebfffedd 	bl	34802ca8 <__arch_preboot_os>

	boot_fn(0, argc, argv, &images);
34803130:	e1a01006 	mov	r1, r6
34803134:	e1a02005 	mov	r2, r5
34803138:	e1a0300a 	mov	r3, sl
3480313c:	e3a00000 	mov	r0, #0
34803140:	e12fff34 	blx	r4
34803144:	e3e00008 	mvn	r0, #8
34803148:	eb002ad5 	bl	3480dca4 <__show_boot_progress>

	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);
#ifdef DEBUG
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);
3480314c:	e1a00007 	mov	r0, r7
34803150:	e1a01009 	mov	r1, r9
34803154:	e1a02006 	mov	r2, r6
34803158:	e1a03005 	mov	r3, r5
3480315c:	ebfffc06 	bl	3480217c <do_reset>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
		return 1;
34803160:	e3a00001 	mov	r0, #1
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);

	return 1;
}
34803164:	e28dd040 	add	sp, sp, #64	; 0x40
34803168:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480316c:	34829868 	.word	0x34829868
34803170:	34823143 	.word	0x34823143
34803174:	3482317d 	.word	0x3482317d
34803178:	348231c4 	.word	0x348231c4
3480317c:	348231ce 	.word	0x348231ce
34803180:	348231d1 	.word	0x348231d1
34803184:	348231d5 	.word	0x348231d5
34803188:	34820110 	.word	0x34820110
3480318c:	348231de 	.word	0x348231de

34803190 <bootm_maybe_autostart>:

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
34803190:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
34803194:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
34803198:	e59f0054 	ldr	r0, [pc, #84]	; 348031f4 <bootm_maybe_autostart+0x64>

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
3480319c:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
348031a0:	eb00135a 	bl	34807f10 <getenv>

	if (ep && !strcmp(ep, "yes")) {
348031a4:	e2503000 	subs	r3, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
348031a8:	01a00003 	moveq	r0, r3

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
348031ac:	0a00000f 	beq	348031f0 <bootm_maybe_autostart+0x60>
348031b0:	e59f1040 	ldr	r1, [pc, #64]	; 348031f8 <bootm_maybe_autostart+0x68>
348031b4:	eb006443 	bl	3481c2c8 <strcmp>
348031b8:	e2504000 	subs	r4, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
348031bc:	13a00000 	movne	r0, #0

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
348031c0:	1a00000a 	bne	348031f0 <bootm_maybe_autostart+0x60>
		char *local_args[2];
		local_args[0] = (char *)cmd;
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
348031c4:	e59f3030 	ldr	r3, [pc, #48]	; 348031fc <bootm_maybe_autostart+0x6c>
348031c8:	e59f0030 	ldr	r0, [pc, #48]	; 34803200 <bootm_maybe_autostart+0x70>
348031cc:	e5931000 	ldr	r1, [r3]
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
		char *local_args[2];
		local_args[0] = (char *)cmd;
348031d0:	e58d6000 	str	r6, [sp]
		local_args[1] = NULL;
348031d4:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
348031d8:	eb001a3a 	bl	34809ac8 <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
348031dc:	e1a00005 	mov	r0, r5
348031e0:	e1a01004 	mov	r1, r4
348031e4:	e3a02001 	mov	r2, #1
348031e8:	e1a0300d 	mov	r3, sp
348031ec:	ebffff41 	bl	34802ef8 <do_bootm>
	}

	return 0;
}
348031f0:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
348031f4:	348231c4 	.word	0x348231c4
348031f8:	3482320c 	.word	0x3482320c
348031fc:	34828438 	.word	0x34828438
34803200:	34823210 	.word	0x34823210

34803204 <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
34803204:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "flush") == 0)
34803208:	e59f1044 	ldr	r1, [pc, #68]	; 34803254 <parse_argv+0x50>
	}
	return 0;
}

static int parse_argv(const char *s)
{
3480320c:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
34803210:	eb00642c 	bl	3481c2c8 <strcmp>
34803214:	e3500000 	cmp	r0, #0
		return 2;
34803218:	03a00002 	moveq	r0, #2
	return 0;
}

static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
3480321c:	08bd8010 	popeq	{r4, pc}
		return 2;
	else if (strcmp(s, "on") == 0)
34803220:	e1a00004 	mov	r0, r4
34803224:	e59f102c 	ldr	r1, [pc, #44]	; 34803258 <parse_argv+0x54>
34803228:	eb006426 	bl	3481c2c8 <strcmp>
3480322c:	e3500000 	cmp	r0, #0
34803230:	0a000005 	beq	3480324c <parse_argv+0x48>
		return 1;
	else if (strcmp(s, "off") == 0)
34803234:	e1a00004 	mov	r0, r4
34803238:	e59f101c 	ldr	r1, [pc, #28]	; 3480325c <parse_argv+0x58>
3480323c:	eb006421 	bl	3481c2c8 <strcmp>
34803240:	e3500000 	cmp	r0, #0
		return 0;
34803244:	13e00000 	mvnne	r0, #0
34803248:	e8bd8010 	pop	{r4, pc}
static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
		return 2;
	else if (strcmp(s, "on") == 0)
		return 1;
3480324c:	e3a00001 	mov	r0, #1
	else if (strcmp(s, "off") == 0)
		return 0;

	return -1;
}
34803250:	e8bd8010 	pop	{r4, pc}
34803254:	348235c2 	.word	0x348235c2
34803258:	3482820e 	.word	0x3482820e
3480325c:	34822c61 	.word	0x34822c61
static int parse_argv(const char *);

void __weak invalidate_icache_all(void)
{
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
34803260:	e59f0000 	ldr	r0, [pc, #0]	; 34803268 <parse_argv+0x64>
34803264:	ea001a0d 	b	34809aa0 <puts>
34803268:	348235c8 	.word	0x348235c8

3480326c <do_icache>:
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
3480326c:	e3520001 	cmp	r2, #1
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803270:	e92d4010 	push	{r4, lr}
	switch (argc) {
34803274:	0a000012 	beq	348032c4 <do_icache+0x58>
34803278:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
3480327c:	13e00000 	mvnne	r0, #0
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34803280:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
34803284:	e5930004 	ldr	r0, [r3, #4]
34803288:	ebffffdd 	bl	34803204 <parse_argv>
3480328c:	e3500001 	cmp	r0, #1
34803290:	e1a04000 	mov	r4, r0
34803294:	0a000006 	beq	348032b4 <do_icache+0x48>
34803298:	e3500002 	cmp	r0, #2
3480329c:	0a000006 	beq	348032bc <do_icache+0x50>
348032a0:	e3500000 	cmp	r0, #0
348032a4:	1a00000f 	bne	348032e8 <do_icache+0x7c>
		case 0:
			icache_disable();
348032a8:	ebfffc0f 	bl	348022ec <icache_disable>
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348032ac:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
		case 0:
			icache_disable();
			break;
348032b0:	e8bd8010 	pop	{r4, pc}
		case 1:
			icache_enable();
348032b4:	ebfffc0a 	bl	348022e4 <icache_enable>
348032b8:	ea000008 	b	348032e0 <do_icache+0x74>
			break;
		case 2:
			invalidate_icache_all();
348032bc:	ebfff783 	bl	348010d0 <invalidate_icache_all>
348032c0:	ea000006 	b	348032e0 <do_icache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
348032c4:	ebfffc0a 	bl	348022f4 <icache_status>
			invalidate_icache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
348032c8:	e59f3020 	ldr	r3, [pc, #32]	; 348032f0 <do_icache+0x84>
348032cc:	e3500000 	cmp	r0, #0
348032d0:	e59f101c 	ldr	r1, [pc, #28]	; 348032f4 <do_icache+0x88>
348032d4:	e59f001c 	ldr	r0, [pc, #28]	; 348032f8 <do_icache+0x8c>
348032d8:	11a01003 	movne	r1, r3
348032dc:	eb0019f9 	bl	34809ac8 <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
348032e0:	e3a00000 	mov	r0, #0
348032e4:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348032e8:	e3a00000 	mov	r0, #0
}
348032ec:	e8bd8010 	pop	{r4, pc}
348032f0:	3482622d 	.word	0x3482622d
348032f4:	348235fb 	.word	0x348235fb
348032f8:	348235ff 	.word	0x348235ff

void __weak flush_dcache_all(void)
{
	puts("No arch specific flush_dcache_all available!\n");
348032fc:	e59f0000 	ldr	r0, [pc, #0]	; 34803304 <do_icache+0x98>
34803300:	ea0019e6 	b	34809aa0 <puts>
34803304:	34823618 	.word	0x34823618

34803308 <do_dcache>:
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34803308:	e3520001 	cmp	r2, #1
	puts("No arch specific flush_dcache_all available!\n");
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480330c:	e92d4010 	push	{r4, lr}
	switch (argc) {
34803310:	0a000012 	beq	34803360 <do_dcache+0x58>
34803314:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
34803318:	13e00000 	mvnne	r0, #0
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
3480331c:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
34803320:	e5930004 	ldr	r0, [r3, #4]
34803324:	ebffffb6 	bl	34803204 <parse_argv>
34803328:	e3500001 	cmp	r0, #1
3480332c:	e1a04000 	mov	r4, r0
34803330:	0a000006 	beq	34803350 <do_dcache+0x48>
34803334:	e3500002 	cmp	r0, #2
34803338:	0a000006 	beq	34803358 <do_dcache+0x50>
3480333c:	e3500000 	cmp	r0, #0
34803340:	1a00000f 	bne	34803384 <do_dcache+0x7c>
		case 0:
			dcache_disable();
34803344:	ebfffbef 	bl	34802308 <dcache_disable>
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803348:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
		case 0:
			dcache_disable();
			break;
3480334c:	e8bd8010 	pop	{r4, pc}
		case 1:
			dcache_enable();
34803350:	ebfffbea 	bl	34802300 <dcache_enable>
34803354:	ea000008 	b	3480337c <do_dcache+0x74>
			break;
		case 2:
			flush_dcache_all();
34803358:	ebfff739 	bl	34801044 <flush_dcache_all>
3480335c:	ea000006 	b	3480337c <do_dcache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
34803360:	ebfffbea 	bl	34802310 <dcache_status>
			flush_dcache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
34803364:	e59f3020 	ldr	r3, [pc, #32]	; 3480338c <do_dcache+0x84>
34803368:	e3500000 	cmp	r0, #0
3480336c:	e59f101c 	ldr	r1, [pc, #28]	; 34803390 <do_dcache+0x88>
34803370:	e59f001c 	ldr	r0, [pc, #28]	; 34803394 <do_dcache+0x8c>
34803374:	11a01003 	movne	r1, r3
34803378:	eb0019d2 	bl	34809ac8 <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
3480337c:	e3a00000 	mov	r0, #0
34803380:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803384:	e3a00000 	mov	r0, #0
}
34803388:	e8bd8010 	pop	{r4, pc}
3480338c:	3482622d 	.word	0x3482622d
34803390:	348235fb 	.word	0x348235fb
34803394:	34823646 	.word	0x34823646

34803398 <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char * const argv[])
{
34803398:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
3480339c:	eb002ea7 	bl	3480ee40 <stdio_get_list>
348033a0:	e1a05000 	mov	r5, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
348033a4:	e59f0090 	ldr	r0, [pc, #144]	; 3480343c <do_coninfo+0xa4>
348033a8:	eb0019bc 	bl	34809aa0 <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
348033ac:	e59f708c 	ldr	r7, [pc, #140]	; 34803440 <do_coninfo+0xa8>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
348033b0:	e5954000 	ldr	r4, [r5]
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
348033b4:	e59fa088 	ldr	sl, [pc, #136]	; 34803444 <do_coninfo+0xac>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
348033b8:	ea00001b 	b	3480342c <do_coninfo+0x94>
		dev = list_entry(pos, struct stdio_dev, list);

		printf ("%-8s %08x %c%c%c ",
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
348033bc:	e5142034 	ldr	r2, [r4, #-52]	; 0x34
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
348033c0:	e2446034 	sub	r6, r4, #52	; 0x34

		printf ("%-8s %08x %c%c%c ",
348033c4:	e3120001 	tst	r2, #1
348033c8:	03a0102e 	moveq	r1, #46	; 0x2e
348033cc:	13a01049 	movne	r1, #73	; 0x49
348033d0:	e3120002 	tst	r2, #2
348033d4:	03a0302e 	moveq	r3, #46	; 0x2e
348033d8:	13a0304f 	movne	r3, #79	; 0x4f
348033dc:	e3520000 	cmp	r2, #0
348033e0:	e88d000a 	stm	sp, {r1, r3}
348033e4:	e59f005c 	ldr	r0, [pc, #92]	; 34803448 <do_coninfo+0xb0>
348033e8:	e2861008 	add	r1, r6, #8
348033ec:	a3a0302e 	movge	r3, #46	; 0x2e
348033f0:	b3a03053 	movlt	r3, #83	; 0x53
348033f4:	eb0019b3 	bl	34809ac8 <printf>
348033f8:	e3a09000 	mov	r9, #0
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
348033fc:	e7993007 	ldr	r3, [r9, r7]
34803400:	e1530006 	cmp	r3, r6
34803404:	1a000002 	bne	34803414 <do_coninfo+0x7c>
				printf ("%s ", stdio_names[l]);
34803408:	e59f003c 	ldr	r0, [pc, #60]	; 3480344c <do_coninfo+0xb4>
3480340c:	e799100a 	ldr	r1, [r9, sl]
34803410:	eb0019ac 	bl	34809ac8 <printf>
34803414:	e2899004 	add	r9, r9, #4
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
34803418:	e359000c 	cmp	r9, #12
3480341c:	1afffff6 	bne	348033fc <do_coninfo+0x64>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
34803420:	e3a0000a 	mov	r0, #10
34803424:	eb001993 	bl	34809a78 <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34803428:	e5944000 	ldr	r4, [r4]
3480342c:	e1540005 	cmp	r4, r5
34803430:	1affffe1 	bne	348033bc <do_coninfo+0x24>
			}
		}
		putc ('\n');
	}
	return 0;
}
34803434:	e3a00000 	mov	r0, #0
34803438:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480343c:	34823744 	.word	0x34823744
34803440:	3482b524 	.word	0x3482b524
34803444:	348289c0 	.word	0x348289c0
34803448:	34823760 	.word	0x34823760
3480344c:	34825f04 	.word	0x34825f04

34803450 <do_echo>:

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803450:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
34803454:	e3a07001 	mov	r7, #1

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803458:	e1a04002 	mov	r4, r2
3480345c:	e1a0a003 	mov	sl, r3
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34803460:	e1a06007 	mov	r6, r7
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803464:	e3a0b000 	mov	fp, #0
				puts(prenls);
				*nls = '\\';
34803468:	e3a0905c 	mov	r9, #92	; 0x5c
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
3480346c:	ea00001e 	b	348034ec <do_echo+0x9c>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
34803470:	e3560001 	cmp	r6, #1
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i];
34803474:	e5ba5004 	ldr	r5, [sl, #4]!
		char *nls; /* new-line suppression */

		if (i > 1)
34803478:	da000001 	ble	34803484 <do_echo+0x34>
			putc(' ');
3480347c:	e3a00020 	mov	r0, #32
34803480:	eb00197c 	bl	34809a78 <putc>

		nls = strstr(p, "\\c");
34803484:	e1a00005 	mov	r0, r5
34803488:	e59f107c 	ldr	r1, [pc, #124]	; 3480350c <do_echo+0xbc>
3480348c:	eb0064d0 	bl	3481c7d4 <strstr>
		if (nls) {
34803490:	e2503000 	subs	r3, r0, #0
34803494:	0a000011 	beq	348034e0 <do_echo+0x90>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803498:	e5c3b000 	strb	fp, [r3]
				puts(prenls);
3480349c:	e1a00005 	mov	r0, r5
348034a0:	e58d3004 	str	r3, [sp, #4]
348034a4:	eb00197d 	bl	34809aa0 <puts>
				*nls = '\\';
348034a8:	e59d3004 	ldr	r3, [sp, #4]
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
348034ac:	e59f1058 	ldr	r1, [pc, #88]	; 3480350c <do_echo+0xbc>
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
				puts(prenls);
				*nls = '\\';
348034b0:	e1a05003 	mov	r5, r3
348034b4:	e4c59002 	strb	r9, [r5], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
348034b8:	e1a00005 	mov	r0, r5
348034bc:	eb0064c4 	bl	3481c7d4 <strstr>
			putnl = 0;
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
348034c0:	e2503000 	subs	r3, r0, #0
348034c4:	1afffff3 	bne	34803498 <do_echo+0x48>
				puts(prenls);
				*nls = '\\';
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
348034c8:	e1a00005 	mov	r0, r5
348034cc:	e58d3004 	str	r3, [sp, #4]
348034d0:	eb001972 	bl	34809aa0 <puts>

		nls = strstr(p, "\\c");
		if (nls) {
			char *prenls = p;

			putnl = 0;
348034d4:	e59d3004 	ldr	r3, [sp, #4]
348034d8:	e1a07003 	mov	r7, r3
348034dc:	ea000001 	b	348034e8 <do_echo+0x98>
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
		} else {
			puts(p);
348034e0:	e1a00005 	mov	r0, r5
348034e4:	eb00196d 	bl	34809aa0 <puts>
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
348034e8:	e2866001 	add	r6, r6, #1
348034ec:	e1560004 	cmp	r6, r4
348034f0:	baffffde 	blt	34803470 <do_echo+0x20>
		} else {
			puts(p);
		}
	}

	if (putnl)
348034f4:	e3570000 	cmp	r7, #0
348034f8:	0a000001 	beq	34803504 <do_echo+0xb4>
		putc('\n');
348034fc:	e3a0000a 	mov	r0, #10
34803500:	eb00195c 	bl	34809a78 <putc>

	return 0;
}
34803504:	e3a00000 	mov	r0, #0
34803508:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480350c:	348237a0 	.word	0x348237a0

34803510 <do_exit>:
int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
34803510:	e3520001 	cmp	r2, #1

#include <common.h>
#include <command.h>

int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803514:	e92d4008 	push	{r3, lr}
	int r;

	r = 0;
34803518:	d3a03000 	movle	r3, #0
	if (argc > 1)
3480351c:	da000004 	ble	34803534 <do_exit+0x24>
		r = simple_strtoul(argv[1], NULL, 10);
34803520:	e5930004 	ldr	r0, [r3, #4]
34803524:	e3a01000 	mov	r1, #0
34803528:	e3a0200a 	mov	r2, #10
3480352c:	eb00672c 	bl	3481d1e4 <simple_strtoul>
34803530:	e1a03000 	mov	r3, r0

	return -r - 2;
}
34803534:	e3e00001 	mvn	r0, #1
34803538:	e0630000 	rsb	r0, r3, r0
3480353c:	e8bd8008 	pop	{r3, pc}

34803540 <do_help>:

#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34803540:	e92d4007 	push	{r0, r1, r2, lr}
34803544:	e1a0c001 	mov	ip, r1
34803548:	e1a0e000 	mov	lr, r0
	return _do_help(&__u_boot_cmd_start,
			&__u_boot_cmd_end - &__u_boot_cmd_start,
3480354c:	e59f1028 	ldr	r1, [pc, #40]	; 3480357c <do_help+0x3c>
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34803550:	e59f0028 	ldr	r0, [pc, #40]	; 34803580 <do_help+0x40>
34803554:	e58d3004 	str	r3, [sp, #4]
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34803558:	e0601001 	rsb	r1, r0, r1
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
3480355c:	e59f3020 	ldr	r3, [pc, #32]	; 34803584 <do_help+0x44>
34803560:	e1a011c1 	asr	r1, r1, #3
34803564:	e58d2000 	str	r2, [sp]
34803568:	e0010193 	mul	r1, r3, r1
3480356c:	e1a0200e 	mov	r2, lr
34803570:	e1a0300c 	mov	r3, ip
34803574:	eb001813 	bl	348095c8 <_do_help>
			&__u_boot_cmd_end - &__u_boot_cmd_start,
			cmdtp, flag, argc, argv);
}
34803578:	e8bd800e 	pop	{r1, r2, r3, pc}
	...
34803584:	aaaaaaab 	.word	0xaaaaaaab

34803588 <evalstr>:
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
34803588:	e5d02000 	ldrb	r2, [r0]
3480358c:	e352002a 	cmp	r2, #42	; 0x2a
34803590:	112fff1e 	bxne	lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
34803594:	e2800001 	add	r0, r0, #1
34803598:	e3a01000 	mov	r1, #0
3480359c:	e3a02010 	mov	r2, #16
348035a0:	ea00670f 	b	3481d1e4 <simple_strtoul>

348035a4 <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
348035a4:	e92d4010 	push	{r4, lr}
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
348035a8:	e5d02000 	ldrb	r2, [r0]
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
348035ac:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
348035b0:	e352002a 	cmp	r2, #42	; 0x2a
348035b4:	1a00000d 	bne	348035f0 <evalexp+0x4c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
348035b8:	e2800001 	add	r0, r0, #1
348035bc:	e3a01000 	mov	r1, #0
348035c0:	e3a02010 	mov	r2, #16
348035c4:	eb006706 	bl	3481d1e4 <simple_strtoul>
		switch (w) {
348035c8:	e3540002 	cmp	r4, #2
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
348035cc:	01d000b0 	ldrheq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348035d0:	08bd8010 	popeq	{r4, pc}
348035d4:	e3540004 	cmp	r4, #4
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
348035d8:	05900000 	ldreq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348035dc:	08bd8010 	popeq	{r4, pc}
348035e0:	e3540001 	cmp	r4, #1
		case 1: return((long)(*(unsigned char *)p));
348035e4:	05d00000 	ldrbeq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348035e8:	1a000004 	bne	34803600 <evalexp+0x5c>
348035ec:	e8bd8010 	pop	{r4, pc}
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
348035f0:	e3a01000 	mov	r1, #0
348035f4:	e3a02010 	mov	r2, #16
348035f8:	eb0066f9 	bl	3481d1e4 <simple_strtoul>
348035fc:	ea000000 	b	34803604 <evalexp+0x60>
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
	long l = 0;
34803600:	e3a00000 	mov	r0, #0
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
	}

	return (l & ((1 << (w * 8)) - 1));
34803604:	e1a04184 	lsl	r4, r4, #3
34803608:	e3e03000 	mvn	r3, #0
3480360c:	e1c00413 	bic	r0, r0, r3, lsl r4
}
34803610:	e8bd8010 	pop	{r4, pc}

34803614 <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
34803614:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34803618:	e1a09000 	mov	r9, r0
3480361c:	e1a05001 	mov	r5, r1
34803620:	e1a04002 	mov	r4, r2
34803624:	e1a07003 	mov	r7, r3
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34803628:	eb00635a 	bl	3481c398 <strlen>
	case GE: return (l >= r);
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
3480362c:	e59fb190 	ldr	fp, [pc, #400]	; 348037c4 <binary_test+0x1b0>
{
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34803630:	e1a0a000 	mov	sl, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
34803634:	e59f618c 	ldr	r6, [pc, #396]	; 348037c8 <binary_test+0x1b4>
34803638:	ea000058 	b	348037a0 <binary_test+0x18c>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
3480363c:	e1a00009 	mov	r0, r9
34803640:	e5961000 	ldr	r1, [r6]
34803644:	e1a0200a 	mov	r2, sl
34803648:	eb00632a 	bl	3481c2f8 <strncmp>
3480364c:	e3500000 	cmp	r0, #0
34803650:	1a000051 	bne	3480379c <binary_test+0x188>
34803654:	e5960000 	ldr	r0, [r6]
34803658:	eb00634e 	bl	3481c398 <strlen>
3480365c:	e15a0000 	cmp	sl, r0
34803660:	1a00004d 	bne	3480379c <binary_test+0x188>
			if (w == 0) {
34803664:	e3570000 	cmp	r7, #0
34803668:	e5966004 	ldr	r6, [r6, #4]
3480366c:	1a000023 	bne	34803700 <binary_test+0xec>
static int stringcomp(char *s, char *t, int op)
{
	int p;
	char *l, *r;

	l = evalstr(s);
34803670:	e1a00005 	mov	r0, r5
34803674:	ebffffc3 	bl	34803588 <evalstr>
34803678:	e1a05000 	mov	r5, r0
	r = evalstr(t);
3480367c:	e1a00004 	mov	r0, r4
34803680:	ebffffc0 	bl	34803588 <evalstr>
34803684:	e1a01000 	mov	r1, r0

	p = strcmp(l, r);
34803688:	e1a00005 	mov	r0, r5
3480368c:	eb00630d 	bl	3481c2c8 <strcmp>
	switch (op) {
34803690:	e3560005 	cmp	r6, #5
34803694:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34803698:	ea000045 	b	348037b4 <binary_test+0x1a0>
3480369c:	348036b4 	.word	0x348036b4
348036a0:	348036c0 	.word	0x348036c0
348036a4:	348036cc 	.word	0x348036cc
348036a8:	348036d4 	.word	0x348036d4
348036ac:	348036e4 	.word	0x348036e4
348036b0:	348036f4 	.word	0x348036f4
	case EQ: return (p == 0);
348036b4:	e2700001 	rsbs	r0, r0, #1
348036b8:	33a00000 	movcc	r0, #0
348036bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
348036c0:	e2500000 	subs	r0, r0, #0
348036c4:	13a00001 	movne	r0, #1
348036c8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
348036cc:	e1a00fa0 	lsr	r0, r0, #31
348036d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
348036d4:	e3500000 	cmp	r0, #0
348036d8:	d3a00000 	movle	r0, #0
348036dc:	c3a00001 	movgt	r0, #1
348036e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
348036e4:	e3500000 	cmp	r0, #0
348036e8:	c3a00000 	movgt	r0, #0
348036ec:	d3a00001 	movle	r0, #1
348036f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
348036f4:	e1e00000 	mvn	r0, r0
348036f8:	e1a00fa0 	lsr	r0, r0, #31
348036fc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
34803700:	e1a00005 	mov	r0, r5
34803704:	e1a01007 	mov	r1, r7
34803708:	ebffffa5 	bl	348035a4 <evalexp>
	r = evalexp (t, w);
3480370c:	e1a01007 	mov	r1, r7

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
34803710:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
34803714:	e1a00004 	mov	r0, r4
34803718:	ebffffa1 	bl	348035a4 <evalexp>

	switch (op) {
3480371c:	e3560005 	cmp	r6, #5
34803720:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34803724:	ea000024 	b	348037bc <binary_test+0x1a8>
34803728:	34803740 	.word	0x34803740
3480372c:	34803750 	.word	0x34803750
34803730:	3480375c 	.word	0x3480375c
34803734:	3480376c 	.word	0x3480376c
34803738:	3480377c 	.word	0x3480377c
3480373c:	3480378c 	.word	0x3480378c
	case EQ: return (l == r);
34803740:	e1550000 	cmp	r5, r0
34803744:	13a00000 	movne	r0, #0
34803748:	03a00001 	moveq	r0, #1
3480374c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
34803750:	e0550000 	subs	r0, r5, r0
34803754:	13a00001 	movne	r0, #1
34803758:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
3480375c:	e1550000 	cmp	r5, r0
34803760:	a3a00000 	movge	r0, #0
34803764:	b3a00001 	movlt	r0, #1
34803768:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
3480376c:	e1550000 	cmp	r5, r0
34803770:	d3a00000 	movle	r0, #0
34803774:	c3a00001 	movgt	r0, #1
34803778:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
3480377c:	e1550000 	cmp	r5, r0
34803780:	c3a00000 	movgt	r0, #0
34803784:	d3a00001 	movle	r0, #1
34803788:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
3480378c:	e1550000 	cmp	r5, r0
34803790:	b3a00000 	movlt	r0, #0
34803794:	a3a00001 	movge	r0, #1
34803798:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {
3480379c:	e2866008 	add	r6, r6, #8
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
348037a0:	e156000b 	cmp	r6, fp
348037a4:	1affffa4 	bne	3480363c <binary_test+0x28>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
348037a8:	e59f001c 	ldr	r0, [pc, #28]	; 348037cc <binary_test+0x1b8>
348037ac:	e1a01009 	mov	r1, r9
348037b0:	eb0018c4 	bl	34809ac8 <printf>
	case LT: return (p < 0);
	case GT: return (p > 0);
	case LE: return (p <= 0);
	case GE: return (p >= 0);
	}
	return (0);
348037b4:	e3a00000 	mov	r0, #0
348037b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
	case GT: return (l > r);
	case LE: return (l <= r);
	case GE: return (l >= r);
	}
	return (0);
348037bc:	e3a00000 	mov	r0, #0
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
}
348037c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348037c4:	348201c4 	.word	0x348201c4
348037c8:	3482015c 	.word	0x3482015c
348037cc:	3482389e 	.word	0x3482389e

348037d0 <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
348037d0:	e3520004 	cmp	r2, #4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
348037d4:	e92d4010 	push	{r4, lr}
348037d8:	e1a04003 	mov	r4, r3
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
348037dc:	1a00001e 	bne	3480385c <do_itest+0x8c>

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
348037e0:	e5930000 	ldr	r0, [r3]
348037e4:	e1a01002 	mov	r1, r2
348037e8:	eb0017d8 	bl	34809750 <cmd_get_data_size>
348037ec:	e2802002 	add	r2, r0, #2
348037f0:	e1a03000 	mov	r3, r0
348037f4:	e3520006 	cmp	r2, #6
348037f8:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
348037fc:	ea000010 	b	34803844 <do_itest+0x74>
34803800:	3480382c 	.word	0x3480382c
34803804:	34803844 	.word	0x34803844
34803808:	34803844 	.word	0x34803844
3480380c:	3480381c 	.word	0x3480381c
34803810:	3480381c 	.word	0x3480381c
34803814:	34803844 	.word	0x34803844
34803818:	3480381c 	.word	0x3480381c
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
3480381c:	e5940008 	ldr	r0, [r4, #8]
34803820:	e5941004 	ldr	r1, [r4, #4]
34803824:	e594200c 	ldr	r2, [r4, #12]
34803828:	ea000003 	b	3480383c <do_itest+0x6c>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
3480382c:	e5940008 	ldr	r0, [r4, #8]
34803830:	e5941004 	ldr	r1, [r4, #4]
34803834:	e594200c 	ldr	r2, [r4, #12]
34803838:	e3a03000 	mov	r3, #0
3480383c:	ebffff74 	bl	34803614 <binary_test>
		break;
34803840:	ea000002 	b	34803850 <do_itest+0x80>
	case -1:
	default:
		puts("Invalid data width specifier\n");
34803844:	e59f0018 	ldr	r0, [pc, #24]	; 34803864 <do_itest+0x94>
34803848:	eb001894 	bl	34809aa0 <puts>
		value = 0;
3480384c:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
34803850:	e2700001 	rsbs	r0, r0, #1
34803854:	33a00000 	movcc	r0, #0
34803858:	e8bd8010 	pop	{r4, pc}
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
		return CMD_RET_USAGE;
3480385c:	e3e00000 	mvn	r0, #0
		value = 0;
		break;
	}

	return !value;
}
34803860:	e8bd8010 	pop	{r4, pc}
34803864:	348238b5 	.word	0x348238b5

34803868 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init (void)
{
	os_data_state = 0;
34803868:	e59f3010 	ldr	r3, [pc, #16]	; 34803880 <bin_data_init+0x18>
3480386c:	e3a02000 	mov	r2, #0
34803870:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
34803874:	e5932008 	ldr	r2, [r3, #8]
34803878:	e5832004 	str	r2, [r3, #4]
}
3480387c:	e12fff1e 	bx	lr
34803880:	34829994 	.word	0x34829994

34803884 <bin_data_char>:
	os_data_addr = os_data_addr_saved;
}

static void bin_data_char (char new_char)
{
	switch (os_data_state) {
34803884:	e59f3014 	ldr	r3, [pc, #20]	; 348038a0 <bin_data_char+0x1c>
34803888:	e5932000 	ldr	r2, [r3]
3480388c:	e3520000 	cmp	r2, #0
	case 0:					/* data */
		*os_data_addr++ = new_char;
34803890:	05932004 	ldreq	r2, [r3, #4]
34803894:	04c20001 	strbeq	r0, [r2], #1
34803898:	05832004 	streq	r2, [r3, #4]
3480389c:	e12fff1e 	bx	lr
348038a0:	34829994 	.word	0x34829994

348038a4 <load_serial_ymodem>:
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
348038a4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
348038a8:	e24dde43 	sub	sp, sp, #1072	; 0x430
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
348038ac:	e28dae42 	add	sl, sp, #1056	; 0x420
348038b0:	e28aa00c 	add	sl, sl, #12
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
348038b4:	e3a03002 	mov	r3, #2
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
348038b8:	e1a06000 	mov	r6, r0
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
348038bc:	e1a0100a 	mov	r1, sl
348038c0:	e28d0e42 	add	r0, sp, #1056	; 0x420
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
348038c4:	e58d3424 	str	r3, [sp, #1060]	; 0x424
	res = xyzModem_stream_open (&info, &err);
348038c8:	eb002ec8 	bl	3480f3f0 <xyzModem_stream_open>
	if (!res) {
348038cc:	e2505000 	subs	r5, r0, #0
348038d0:	01a04005 	moveq	r4, r5

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
348038d4:	01a0700d 	moveq	r7, sp
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {
348038d8:	0a000005 	beq	348038f4 <load_serial_ymodem+0x50>
348038dc:	ea00000b 	b	34803910 <load_serial_ymodem+0x6c>

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
348038e0:	e0850006 	add	r0, r5, r6
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
348038e4:	e1a0100d 	mov	r1, sp
	if (!res) {

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
			size += res;
348038e8:	e0844002 	add	r4, r4, r2
			addr += res;
348038ec:	e0855002 	add	r5, r5, r2
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
348038f0:	eb00636c 	bl	3481c6a8 <memcpy>
	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {

		while ((res =
348038f4:	e1a0200a 	mov	r2, sl
348038f8:	e1a0000d 	mov	r0, sp
348038fc:	e3a01b01 	mov	r1, #1024	; 0x400
34803900:	eb002f0c 	bl	3480f538 <xyzModem_stream_read>
34803904:	e2502000 	subs	r2, r0, #0
34803908:	cafffff4 	bgt	348038e0 <load_serial_ymodem+0x3c>
3480390c:	ea000005 	b	34803928 <load_serial_ymodem+0x84>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
34803910:	e59d042c 	ldr	r0, [sp, #1068]	; 0x42c
34803914:	eb002fd4 	bl	3480f86c <xyzModem_error>
34803918:	e1a01000 	mov	r1, r0
3480391c:	e59f0064 	ldr	r0, [pc, #100]	; 34803988 <load_serial_ymodem+0xe4>
34803920:	eb001868 	bl	34809ac8 <printf>
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
34803924:	e3a04000 	mov	r4, #0
		}
	} else {
		printf ("%s\n", xyzModem_error (err));
	}

	xyzModem_stream_close (&err);
34803928:	e28d0e42 	add	r0, sp, #1056	; 0x420
3480392c:	e280000c 	add	r0, r0, #12
34803930:	eb002f94 	bl	3480f788 <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
34803934:	e3a00000 	mov	r0, #0
34803938:	e59f104c 	ldr	r1, [pc, #76]	; 3480398c <load_serial_ymodem+0xe8>
3480393c:	eb002fa5 	bl	3480f7d8 <xyzModem_stream_terminate>


	flush_cache (offset, size);
34803940:	e1a00006 	mov	r0, r6
34803944:	e1a01004 	mov	r1, r4
34803948:	ebfff5de 	bl	348010c8 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf (buf, "%X", size);
3480394c:	e28d5b01 	add	r5, sp, #1024	; 0x400
	xyzModem_stream_terminate (false, &getcxmodem);


	flush_cache (offset, size);

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34803950:	e1a01004 	mov	r1, r4
34803954:	e1a02004 	mov	r2, r4
34803958:	e59f0030 	ldr	r0, [pc, #48]	; 34803990 <load_serial_ymodem+0xec>
3480395c:	eb001859 	bl	34809ac8 <printf>
	sprintf (buf, "%X", size);
34803960:	e1a02004 	mov	r2, r4
34803964:	e1a00005 	mov	r0, r5
34803968:	e59f1024 	ldr	r1, [pc, #36]	; 34803994 <load_serial_ymodem+0xf0>
3480396c:	eb0066c2 	bl	3481d47c <sprintf>
	setenv ("filesize", buf);
34803970:	e1a01005 	mov	r1, r5
34803974:	e59f001c 	ldr	r0, [pc, #28]	; 34803998 <load_serial_ymodem+0xf4>
34803978:	eb00105c 	bl	34807af0 <setenv>

	return offset;
}
3480397c:	e1a00006 	mov	r0, r6
34803980:	e28dde43 	add	sp, sp, #1072	; 0x430
34803984:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34803988:	34825e78 	.word	0x34825e78
3480398c:	3480399c 	.word	0x3480399c
34803990:	34823951 	.word	0x34823951
34803994:	34823979 	.word	0x34823979
34803998:	348231d5 	.word	0x348231d5

3480399c <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
3480399c:	e92d4010 	push	{r4, lr}
	if (tstc())
348039a0:	eb00182b 	bl	34809a54 <tstc>
348039a4:	e3500000 	cmp	r0, #0
348039a8:	0a000001 	beq	348039b4 <getcxmodem+0x18>
		return (getc());
	return -1;
}
348039ac:	e8bd4010 	pop	{r4, lr}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
	if (tstc())
		return (getc());
348039b0:	ea00181e 	b	34809a30 <getc>
	return -1;
}
348039b4:	e3e00000 	mvn	r0, #0
348039b8:	e8bd8010 	pop	{r4, pc}

348039bc <load_serial>:
	return rcode;
}

static ulong
load_serial (long offset)
{
348039bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;
348039c0:	e3a05000 	mov	r5, #0
	return rcode;
}

static ulong
load_serial (long offset)
{
348039c4:	e24ddd0d 	sub	sp, sp, #832	; 0x340
348039c8:	e58d000c 	str	r0, [sp, #12]
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
348039cc:	e1a07005 	mov	r7, r5
	int	type;				/* return code for record type	*/
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
348039d0:	e3e04000 	mvn	r4, #0
#endif
	return rcode;
}

static ulong
load_serial (long offset)
348039d4:	e28d9f85 	add	r9, sp, #532	; 0x214

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
		if (do_echo)
348039d8:	e59f61dc 	ldr	r6, [pc, #476]	; 34803bbc <load_serial+0x200>
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
348039dc:	e1a0b005 	mov	fp, r5
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
348039e0:	ea000044 	b	34803af8 <load_serial+0x13c>
		type = srec_decode (record, &binlen, &addr, binbuf);
348039e4:	e28d0010 	add	r0, sp, #16
348039e8:	e28d1fcf 	add	r1, sp, #828	; 0x33c
348039ec:	e28d2fce 	add	r2, sp, #824	; 0x338
348039f0:	e28d3f86 	add	r3, sp, #536	; 0x218
348039f4:	eb002be8 	bl	3480e99c <srec_decode>

		if (type < 0) {
348039f8:	e3500000 	cmp	r0, #0
348039fc:	ba00006b 	blt	34803bb0 <load_serial+0x1f4>
			return (~0);		/* Invalid S-Record		*/
		}

		switch (type) {
34803a00:	e2400001 	sub	r0, r0, #1
34803a04:	e3500008 	cmp	r0, #8
34803a08:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
34803a0c:	ea00002e 	b	34803acc <load_serial+0x110>
34803a10:	34803a34 	.word	0x34803a34
34803a14:	34803a34 	.word	0x34803a34
34803a18:	34803a34 	.word	0x34803a34
34803a1c:	34803acc 	.word	0x34803acc
34803a20:	34803acc 	.word	0x34803acc
34803a24:	34803acc 	.word	0x34803acc
34803a28:	34803a70 	.word	0x34803a70
34803a2c:	34803a70 	.word	0x34803a70
34803a30:	34803a70 	.word	0x34803a70
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
34803a34:	e59d200c 	ldr	r2, [sp, #12]
34803a38:	e59da338 	ldr	sl, [sp, #824]	; 0x338
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803a3c:	e28d1f86 	add	r1, sp, #536	; 0x218

		switch (type) {
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
34803a40:	e082a00a 	add	sl, r2, sl
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803a44:	e1a0000a 	mov	r0, sl
34803a48:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
34803a4c:	eb006315 	bl	3481c6a8 <memcpy>
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803a50:	e59d333c 	ldr	r3, [sp, #828]	; 0x33c
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803a54:	e154000a 	cmp	r4, sl
34803a58:	21a0400a 	movcs	r4, sl
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803a5c:	e2433001 	sub	r3, r3, #1
34803a60:	e083a00a 	add	sl, r3, sl
34803a64:	e157000a 	cmp	r7, sl
34803a68:	31a0700a 	movcc	r7, sl
34803a6c:	ea000016 	b	34803acc <load_serial+0x110>
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
		    size = end_addr - start_addr + 1;
34803a70:	e2875001 	add	r5, r7, #1
34803a74:	e0645005 	rsb	r5, r4, r5
			end_addr = store_addr + binlen - 1;
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
34803a78:	e3020710 	movw	r0, #10000	; 0x2710
34803a7c:	eb006394 	bl	3481c8d4 <udelay>
		    size = end_addr - start_addr + 1;
		    printf ("\n"
34803a80:	e1a03005 	mov	r3, r5
34803a84:	e1a01004 	mov	r1, r4
34803a88:	e1a02007 	mov	r2, r7
34803a8c:	e59f012c 	ldr	r0, [pc, #300]	; 34803bc0 <load_serial+0x204>
34803a90:	e58d5000 	str	r5, [sp]
34803a94:	eb00180b 	bl	34809ac8 <printf>
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803a98:	e1a00004 	mov	r0, r4
34803a9c:	e1a01005 	mov	r1, r5
		    sprintf(buf, "%lX", size);
34803aa0:	e28d4fc6 	add	r4, sp, #792	; 0x318
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803aa4:	ebfff587 	bl	348010c8 <flush_cache>
		    sprintf(buf, "%lX", size);
34803aa8:	e59f1114 	ldr	r1, [pc, #276]	; 34803bc4 <load_serial+0x208>
34803aac:	e1a02005 	mov	r2, r5
34803ab0:	e1a00004 	mov	r0, r4
34803ab4:	eb006670 	bl	3481d47c <sprintf>
		    setenv("filesize", buf);
34803ab8:	e59f0108 	ldr	r0, [pc, #264]	; 34803bc8 <load_serial+0x20c>
34803abc:	e1a01004 	mov	r1, r4
34803ac0:	eb00100a 	bl	34807af0 <setenv>
		    return (addr);
34803ac4:	e59d0338 	ldr	r0, [sp, #824]	; 0x338
34803ac8:	ea000039 	b	34803bb4 <load_serial+0x1f8>
		case SREC_START:
		    break;
		default:
		    break;
		}
		if (!do_echo) {	/* print a '.' every 100 lines */
34803acc:	e5963000 	ldr	r3, [r6]
34803ad0:	e3530000 	cmp	r3, #0
34803ad4:	1a000007 	bne	34803af8 <load_serial+0x13c>
			if ((++line_count % 100) == 0)
34803ad8:	e2855001 	add	r5, r5, #1
34803adc:	e1a00005 	mov	r0, r5
34803ae0:	e3a01064 	mov	r1, #100	; 0x64
34803ae4:	eb007142 	bl	3481fff4 <__aeabi_idivmod>
34803ae8:	e3510000 	cmp	r1, #0
34803aec:	1a000001 	bne	34803af8 <load_serial+0x13c>
				putc ('.');
34803af0:	e3a0002e 	mov	r0, #46	; 0x2e
34803af4:	eb0017df 	bl	34809a78 <putc>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803af8:	e28d3010 	add	r3, sp, #16
34803afc:	e58d5008 	str	r5, [sp, #8]
34803b00:	e1a05004 	mov	r5, r4
34803b04:	e1a04003 	mov	r4, r3
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803b08:	eb0017c8 	bl	34809a30 <getc>
		if (do_echo)
34803b0c:	e5963000 	ldr	r3, [r6]
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803b10:	e6efa070 	uxtb	sl, r0
		if (do_echo)
34803b14:	e3530000 	cmp	r3, #0
34803b18:	0a000001 	beq	34803b24 <load_serial+0x168>
			putc (c);	/* ... and echo it		*/
34803b1c:	e1a0000a 	mov	r0, sl
34803b20:	eb0017d4 	bl	34809a78 <putc>

		switch (c) {
34803b24:	e35a0003 	cmp	sl, #3
34803b28:	0a000020 	beq	34803bb0 <load_serial+0x1f4>
34803b2c:	8a000002 	bhi	34803b3c <load_serial+0x180>
34803b30:	e35a0000 	cmp	sl, #0
34803b34:	0a00001d 	beq	34803bb0 <load_serial+0x1f4>
34803b38:	ea00000a 	b	34803b68 <load_serial+0x1ac>
34803b3c:	e35a000a 	cmp	sl, #10
34803b40:	0a000001 	beq	34803b4c <load_serial+0x190>
34803b44:	e35a000d 	cmp	sl, #13
34803b48:	1a000006 	bne	34803b68 <load_serial+0x1ac>
34803b4c:	e1a03004 	mov	r3, r4
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803b50:	e28d2010 	add	r2, sp, #16
34803b54:	e1a04005 	mov	r4, r5
34803b58:	e59d5008 	ldr	r5, [sp, #8]
			putc (c);	/* ... and echo it		*/

		switch (c) {
		case '\r':
		case '\n':
			*p = '\0';
34803b5c:	e5c3b000 	strb	fp, [r3]
			return (p - buf);
34803b60:	e0623003 	rsb	r3, r2, r3
34803b64:	ea00000f 	b	34803ba8 <load_serial+0x1ec>
		case '\0':
		case 0x03:			/* ^C - Control C		*/
			return (-1);
		default:
			*p = c;
34803b68:	e4c4a001 	strb	sl, [r4], #1
		}

	    /* Check for the console hangup (if any different from serial) */
	    if (gd->jt[XF_getc] != getc) {
34803b6c:	e5983054 	ldr	r3, [r8, #84]	; 0x54
34803b70:	e59f2054 	ldr	r2, [pc, #84]	; 34803bcc <load_serial+0x210>
34803b74:	e5933004 	ldr	r3, [r3, #4]
34803b78:	e1530002 	cmp	r3, r2
34803b7c:	0a000002 	beq	34803b8c <load_serial+0x1d0>
		if (ctrlc()) {
34803b80:	eb0017f5 	bl	34809b5c <ctrlc>
34803b84:	e3500000 	cmp	r0, #0
34803b88:	1a000008 	bne	34803bb0 <load_serial+0x1f4>
	char *p;
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
34803b8c:	e1540009 	cmp	r4, r9
34803b90:	1affffdc 	bne	34803b08 <load_serial+0x14c>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803b94:	e28d3010 	add	r3, sp, #16
34803b98:	e1a04005 	mov	r4, r5
	    }
	}

	/* line too long - truncate */
	*p = '\0';
	return (p - buf);
34803b9c:	e0633009 	rsb	r3, r3, r9
34803ba0:	e59d5008 	ldr	r5, [sp, #8]
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803ba4:	e5c9b000 	strb	fp, [r9]
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803ba8:	e3530000 	cmp	r3, #0
34803bac:	aaffff8c 	bge	348039e4 <load_serial+0x28>
			if ((++line_count % 100) == 0)
				putc ('.');
		}
	}

	return (~0);			/* Download aborted		*/
34803bb0:	e3e00000 	mvn	r0, #0
}
34803bb4:	e28ddd0d 	add	sp, sp, #832	; 0x340
34803bb8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803bbc:	34828368 	.word	0x34828368
34803bc0:	3482397c 	.word	0x3482397c
34803bc4:	348231d1 	.word	0x348231d1
34803bc8:	348231d5 	.word	0x348231d5
34803bcc:	34809a30 	.word	0x34809a30

34803bd0 <do_load_serial>:

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803bd0:	e92d4038 	push	{r3, r4, r5, lr}
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803bd4:	e59f00b8 	ldr	r0, [pc, #184]	; 34803c94 <do_load_serial+0xc4>

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803bd8:	e1a04002 	mov	r4, r2
34803bdc:	e1a05003 	mov	r5, r3
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803be0:	eb0010ca 	bl	34807f10 <getenv>
34803be4:	e3500000 	cmp	r0, #0
34803be8:	0a000003 	beq	34803bfc <do_load_serial+0x2c>
34803bec:	e5d03000 	ldrb	r3, [r0]
34803bf0:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
34803bf4:	03a02001 	moveq	r2, #1
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803bf8:	0a000000 	beq	34803c00 <do_load_serial+0x30>
		do_echo = 1;
	} else {
		do_echo = 0;
34803bfc:	e3a02000 	mov	r2, #0
34803c00:	e59f3090 	ldr	r3, [pc, #144]	; 34803c98 <do_load_serial+0xc8>
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803c04:	e3540002 	cmp	r4, #2
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
		do_echo = 1;
	} else {
		do_echo = 0;
34803c08:	e5832000 	str	r2, [r3]
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	long offset = 0;
34803c0c:	13a04000 	movne	r4, #0
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803c10:	1a000004 	bne	34803c28 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
34803c14:	e5950004 	ldr	r0, [r5, #4]
34803c18:	e3a01000 	mov	r1, #0
34803c1c:	e3a02010 	mov	r2, #16
34803c20:	eb0065b8 	bl	3481d308 <simple_strtol>
34803c24:	e1a04000 	mov	r4, r0
	}
#endif	/* CONFIG_SYS_LOADS_BAUD_CHANGE */

	printf ("## Ready for S-Record download ...\n");
34803c28:	e59f006c 	ldr	r0, [pc, #108]	; 34803c9c <do_load_serial+0xcc>
34803c2c:	eb0017a5 	bl	34809ac8 <printf>

	addr = load_serial (offset);
34803c30:	e1a00004 	mov	r0, r4
34803c34:	ebffff60 	bl	348039bc <load_serial>
34803c38:	e3a04064 	mov	r4, #100	; 0x64
34803c3c:	e1a05000 	mov	r5, r0
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34803c40:	eb001783 	bl	34809a54 <tstc>
34803c44:	e3500000 	cmp	r0, #0
34803c48:	0a000000 	beq	34803c50 <do_load_serial+0x80>
			(void) getc();
34803c4c:	eb001777 	bl	34809a30 <getc>
		}
		udelay(1000);
34803c50:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34803c54:	eb00631e 	bl	3481c8d4 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
34803c58:	e2544001 	subs	r4, r4, #1
34803c5c:	1afffff7 	bne	34803c40 <do_load_serial+0x70>
			(void) getc();
		}
		udelay(1000);
	}

	if (addr == ~0) {
34803c60:	e3750001 	cmn	r5, #1
34803c64:	1a000003 	bne	34803c78 <do_load_serial+0xa8>
		printf ("## S-Record download aborted\n");
34803c68:	e59f0030 	ldr	r0, [pc, #48]	; 34803ca0 <do_load_serial+0xd0>
34803c6c:	eb001795 	bl	34809ac8 <printf>
		rcode = 1;
34803c70:	e3a00001 	mov	r0, #1
34803c74:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
34803c78:	e1a01005 	mov	r1, r5
34803c7c:	e59f0020 	ldr	r0, [pc, #32]	; 34803ca4 <do_load_serial+0xd4>
34803c80:	eb001790 	bl	34809ac8 <printf>
		load_addr = addr;
34803c84:	e59f301c 	ldr	r3, [pc, #28]	; 34803ca8 <do_load_serial+0xd8>
{
	long offset = 0;
	ulong addr;
	int i;
	char *env_echo;
	int rcode = 0;
34803c88:	e1a00004 	mov	r0, r4
	if (addr == ~0) {
		printf ("## S-Record download aborted\n");
		rcode = 1;
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
		load_addr = addr;
34803c8c:	e5835000 	str	r5, [r3]
				break;
		}
	}
#endif
	return rcode;
}
34803c90:	e8bd8038 	pop	{r3, r4, r5, pc}
34803c94:	348239e1 	.word	0x348239e1
34803c98:	34828368 	.word	0x34828368
34803c9c:	348239ec 	.word	0x348239ec
34803ca0:	34823a10 	.word	0x34823a10
34803ca4:	34823a2e 	.word	0x34823a2e
34803ca8:	34828438 	.word	0x34828438

34803cac <send_pad>:

	return offset;
}

void send_pad (void)
{
34803cac:	e92d4038 	push	{r3, r4, r5, lr}
34803cb0:	e59f501c 	ldr	r5, [pc, #28]	; 34803cd4 <send_pad+0x28>
34803cb4:	e595400c 	ldr	r4, [r5, #12]
	int count = his_pad_count;

	while (count-- > 0)
34803cb8:	ea000002 	b	34803cc8 <send_pad+0x1c>
		putc (his_pad_char);
34803cbc:	e5d50010 	ldrb	r0, [r5, #16]
34803cc0:	eb00176c 	bl	34809a78 <putc>
34803cc4:	e2444001 	sub	r4, r4, #1

void send_pad (void)
{
	int count = his_pad_count;

	while (count-- > 0)
34803cc8:	e3540000 	cmp	r4, #0
34803ccc:	cafffffa 	bgt	34803cbc <send_pad+0x10>
		putc (his_pad_char);
}
34803cd0:	e8bd8038 	pop	{r3, r4, r5, pc}
34803cd4:	34829994 	.word	0x34829994

34803cd8 <ktrans>:

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803cd8:	e2003060 	and	r3, r0, #96	; 0x60
34803cdc:	e3530040 	cmp	r3, #64	; 0x40
		return (char) (in & ~0x40);
34803ce0:	020000bf 	andeq	r0, r0, #191	; 0xbf
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803ce4:	012fff1e 	bxeq	lr
		return (char) (in & ~0x40);
	} else if ((in & 0x7f) == 0x3f) {
34803ce8:	e200307f 	and	r3, r0, #127	; 0x7f
34803cec:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
34803cf0:	03800040 	orreq	r0, r0, #64	; 0x40
	} else
		return in;
}
34803cf4:	e12fff1e 	bx	lr

34803cf8 <chk1>:

int chk1 (char *buffer)
{
	int total = 0;
34803cf8:	e3a03000 	mov	r3, #0

	while (*buffer) {
34803cfc:	ea000000 	b	34803d04 <chk1+0xc>
		total += *buffer++;
34803d00:	e0833002 	add	r3, r3, r2

int chk1 (char *buffer)
{
	int total = 0;

	while (*buffer) {
34803d04:	e4d02001 	ldrb	r2, [r0], #1
34803d08:	e3520000 	cmp	r2, #0
34803d0c:	1afffffb 	bne	34803d00 <chk1+0x8>
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
34803d10:	e7e12353 	ubfx	r2, r3, #6, #2
34803d14:	e0823003 	add	r3, r2, r3
}
34803d18:	e203003f 	and	r0, r3, #63	; 0x3f
34803d1c:	e12fff1e 	bx	lr

34803d20 <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
34803d20:	e92d4010 	push	{r4, lr}
34803d24:	e1a04000 	mov	r4, r0
	send_pad ();
34803d28:	ebffffdf 	bl	34803cac <send_pad>
	while (*packet) {
34803d2c:	ea000000 	b	34803d34 <s1_sendpacket+0x14>
		putc (*packet++);
34803d30:	eb001750 	bl	34809a78 <putc>
}

void s1_sendpacket (char *packet)
{
	send_pad ();
	while (*packet) {
34803d34:	e4d40001 	ldrb	r0, [r4], #1
34803d38:	e3500000 	cmp	r0, #0
34803d3c:	1afffffb 	bne	34803d30 <s1_sendpacket+0x10>
		putc (*packet++);
	}
}
34803d40:	e8bd8010 	pop	{r4, pc}

34803d44 <send_ack>:

static char a_b[24];
void send_ack (int n)
{
34803d44:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803d48:	e59f404c 	ldr	r4, [pc, #76]	; 34803d9c <send_ack+0x58>
34803d4c:	e3a03001 	mov	r3, #1
34803d50:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803d54:	e2800020 	add	r0, r0, #32

static char a_b[24];
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803d58:	e2833022 	add	r3, r3, #34	; 0x22
34803d5c:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803d60:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = ACK_TYPE;
34803d64:	e2833036 	add	r3, r3, #54	; 0x36
	a_b[4] = '\0';
34803d68:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d6c:	e2840015 	add	r0, r4, #21
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34803d70:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803d74:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d78:	ebffffde 	bl	34803cf8 <chk1>
34803d7c:	e2800020 	add	r0, r0, #32
34803d80:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803d84:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803d88:	e59f0010 	ldr	r0, [pc, #16]	; 34803da0 <send_ack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803d8c:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803d90:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803d94:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803d98:	eaffffe0 	b	34803d20 <s1_sendpacket>
34803d9c:	34829994 	.word	0x34829994
34803da0:	348299a8 	.word	0x348299a8

34803da4 <send_nack>:
}

void send_nack (int n)
{
34803da4:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803da8:	e59f404c 	ldr	r4, [pc, #76]	; 34803dfc <send_nack+0x58>
34803dac:	e3a03001 	mov	r3, #1
34803db0:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803db4:	e2800020 	add	r0, r0, #32
}

void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803db8:	e2833022 	add	r3, r3, #34	; 0x22
34803dbc:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803dc0:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = NACK_TYPE;
34803dc4:	e283302b 	add	r3, r3, #43	; 0x2b
	a_b[4] = '\0';
34803dc8:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803dcc:	e2840015 	add	r0, r4, #21
void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
34803dd0:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803dd4:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803dd8:	ebffffc6 	bl	34803cf8 <chk1>
34803ddc:	e2800020 	add	r0, r0, #32
34803de0:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803de4:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803de8:	e59f0010 	ldr	r0, [pc, #16]	; 34803e00 <send_nack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803dec:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803df0:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803df4:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803df8:	eaffffc8 	b	34803d20 <s1_sendpacket>
34803dfc:	34829994 	.word	0x34829994
34803e00:	348299a8 	.word	0x348299a8

34803e04 <k_data_init>:


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
34803e04:	e92d4008 	push	{r3, lr}
	k_data_escape = 0;
34803e08:	e59f3010 	ldr	r3, [pc, #16]	; 34803e20 <k_data_init+0x1c>
34803e0c:	e3a02000 	mov	r2, #0
34803e10:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_init ();
34803e14:	e5933034 	ldr	r3, [r3, #52]	; 0x34
34803e18:	e12fff33 	blx	r3
}
34803e1c:	e8bd8008 	pop	{r3, pc}
34803e20:	34829994 	.word	0x34829994

34803e24 <k_data_save>:

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
34803e24:	e59f3018 	ldr	r3, [pc, #24]	; 34803e44 <k_data_save+0x20>
34803e28:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34803e2c:	e5832038 	str	r2, [r3, #56]	; 0x38
	os_data_addr = bin_start_address;
}

static void os_data_save (void)
{
	os_data_state_saved = os_data_state;
34803e30:	e5932000 	ldr	r2, [r3]
34803e34:	e583203c 	str	r2, [r3, #60]	; 0x3c
	os_data_addr_saved = os_data_addr;
34803e38:	e5932004 	ldr	r2, [r3, #4]
34803e3c:	e5832040 	str	r2, [r3, #64]	; 0x40

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
	os_data_save ();
}
34803e40:	e12fff1e 	bx	lr
34803e44:	34829994 	.word	0x34829994

34803e48 <k_data_restore>:

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
34803e48:	e59f3018 	ldr	r3, [pc, #24]	; 34803e68 <k_data_restore+0x20>
34803e4c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
34803e50:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_addr_saved = os_data_addr;
}

static void os_data_restore (void)
{
	os_data_state = os_data_state_saved;
34803e54:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
34803e58:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
34803e5c:	e5932040 	ldr	r2, [r3, #64]	; 0x40
34803e60:	e5832004 	str	r2, [r3, #4]

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
	os_data_restore ();
}
34803e64:	e12fff1e 	bx	lr
34803e68:	34829994 	.word	0x34829994

34803e6c <k_data_char>:

void k_data_char (char new_char)
{
34803e6c:	e92d4010 	push	{r4, lr}
	if (k_data_escape) {
34803e70:	e59f4040 	ldr	r4, [pc, #64]	; 34803eb8 <k_data_char+0x4c>
34803e74:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34803e78:	e3520000 	cmp	r2, #0
34803e7c:	0a000004 	beq	34803e94 <k_data_char+0x28>
		/* last char was escape - translate this character */
		os_data_char (ktrans (new_char));
34803e80:	ebffff94 	bl	34803cd8 <ktrans>
34803e84:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803e88:	e12fff33 	blx	r3
		k_data_escape = 0;
34803e8c:	e3a03000 	mov	r3, #0
34803e90:	ea000003 	b	34803ea4 <k_data_char+0x38>
	} else {
		if (new_char == his_quote) {
34803e94:	e5d42048 	ldrb	r2, [r4, #72]	; 0x48
34803e98:	e1520000 	cmp	r2, r0
34803e9c:	1a000002 	bne	34803eac <k_data_char+0x40>
			/* this char is escape - remember */
			k_data_escape = 1;
34803ea0:	e3a03001 	mov	r3, #1
34803ea4:	e5843030 	str	r3, [r4, #48]	; 0x30
34803ea8:	e8bd8010 	pop	{r4, pc}
		} else {
			/* otherwise send this char as-is */
			os_data_char (new_char);
34803eac:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803eb0:	e12fff33 	blx	r3
34803eb4:	e8bd8010 	pop	{r4, pc}
34803eb8:	34829994 	.word	0x34829994

34803ebc <handle_send_packet>:
{
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803ebc:	e59f31b8 	ldr	r3, [pc, #440]	; 3480407c <handle_send_packet+0x1c0>
34803ec0:	e3a0200d 	mov	r2, #13
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803ec4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803ec8:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	his_pad_count = 0;
34803ecc:	e3a02000 	mov	r2, #0
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803ed0:	e593104c 	ldr	r1, [r3, #76]	; 0x4c
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34803ed4:	e583200c 	str	r2, [r3, #12]
	his_pad_char = '\0';
34803ed8:	e5c32010 	strb	r2, [r3, #16]
	his_quote = K_ESCAPE;
34803edc:	e2822023 	add	r2, r2, #35	; 0x23
34803ee0:	e5c32048 	strb	r2, [r3, #72]	; 0x48

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803ee4:	e2832063 	add	r2, r3, #99	; 0x63
34803ee8:	e1510002 	cmp	r1, r2
		--send_ptr;
34803eec:	02832062 	addeq	r2, r3, #98	; 0x62
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803ef0:	e59f4184 	ldr	r4, [pc, #388]	; 3480407c <handle_send_packet+0x1c0>
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
34803ef4:	0583204c 	streq	r2, [r3, #76]	; 0x4c
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803ef8:	e594504c 	ldr	r5, [r4, #76]	; 0x4c
34803efc:	e2843050 	add	r3, r4, #80	; 0x50
34803f00:	e0635005 	rsb	r5, r3, r5
	do {
		if (bytes-- <= 0)
34803f04:	e3550000 	cmp	r5, #0
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803f08:	e1a07000 	mov	r7, r0
	int length = 3;
34803f0c:	d3a06003 	movle	r6, #3
	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
	do {
		if (bytes-- <= 0)
34803f10:	da000040 	ble	34804018 <handle_send_packet+0x15c>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34803f14:	e3a0307e 	mov	r3, #126	; 0x7e
		if (bytes-- <= 0)
34803f18:	e2555001 	subs	r5, r5, #1
	do {
		if (bytes-- <= 0)
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34803f1c:	e5c43018 	strb	r3, [r4, #24]
34803f20:	03a06004 	moveq	r6, #4
		if (bytes-- <= 0)
34803f24:	0a00003b 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34803f28:	e3a03021 	mov	r3, #33	; 0x21
		if (bytes-- <= 0)
34803f2c:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (94);
		if (bytes-- <= 0)
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34803f30:	e5c43019 	strb	r3, [r4, #25]
34803f34:	03a06005 	moveq	r6, #5
		if (bytes-- <= 0)
34803f38:	0a000036 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
34803f3c:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34803f40:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (1);
		if (bytes-- <= 0)
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
34803f44:	e2433020 	sub	r3, r3, #32
34803f48:	e20330ff 	and	r3, r3, #255	; 0xff
34803f4c:	e584300c 	str	r3, [r4, #12]
		a_b[++length] = tochar (0);
34803f50:	e3a03020 	mov	r3, #32
34803f54:	e5c4301a 	strb	r3, [r4, #26]
34803f58:	03a06006 	moveq	r6, #6
		if (bytes-- <= 0)
34803f5c:	0a00002d 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34803f60:	e5d40053 	ldrb	r0, [r4, #83]	; 0x53
34803f64:	ebffff5b 	bl	34803cd8 <ktrans>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34803f68:	e2455001 	sub	r5, r5, #1
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
		a_b[++length] = 0x40;	/* He should ignore this */
34803f6c:	e3a03040 	mov	r3, #64	; 0x40
		if (bytes-- <= 0)
34803f70:	e3550000 	cmp	r5, #0
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34803f74:	e5c40010 	strb	r0, [r4, #16]
		a_b[++length] = 0x40;	/* He should ignore this */
34803f78:	e5c4301b 	strb	r3, [r4, #27]
34803f7c:	03a06007 	moveq	r6, #7
		if (bytes-- <= 0)
34803f80:	0a000024 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
34803f84:	e5d43054 	ldrb	r3, [r4, #84]	; 0x54
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
34803f88:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 0x40;	/* He should ignore this */
		if (bytes-- <= 0)
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
34803f8c:	e2433020 	sub	r3, r3, #32
34803f90:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
		a_b[++length] = tochar (END_CHAR);
34803f94:	e3a0302d 	mov	r3, #45	; 0x2d
34803f98:	e5c4301c 	strb	r3, [r4, #28]
34803f9c:	03a06008 	moveq	r6, #8
		if (bytes-- <= 0)
34803fa0:	0a00001c 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34803fa4:	e5d43055 	ldrb	r3, [r4, #85]	; 0x55
		a_b[++length] = '#';
		if (bytes-- <= 0)
34803fa8:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34803fac:	e5c43048 	strb	r3, [r4, #72]	; 0x48
		a_b[++length] = '#';
34803fb0:	e3a03023 	mov	r3, #35	; 0x23
34803fb4:	e5c4301d 	strb	r3, [r4, #29]
34803fb8:	03a06009 	moveq	r6, #9
		if (bytes-- <= 0)
34803fbc:	0a000015 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803fc0:	e283302b 	add	r3, r3, #43	; 0x2b
		if (bytes-- <= 0)
34803fc4:	e2555001 	subs	r5, r5, #1
		a_b[++length] = '#';
		if (bytes-- <= 0)
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803fc8:	e5c4301e 	strb	r3, [r4, #30]
34803fcc:	03a0600a 	moveq	r6, #10
		if (bytes-- <= 0)
34803fd0:	0a000010 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
34803fd4:	e3a02031 	mov	r2, #49	; 0x31
		if (bytes-- <= 0)
34803fd8:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 'N';
		if (bytes-- <= 0)
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
34803fdc:	e5c4201f 	strb	r2, [r4, #31]
34803fe0:	03a0600b 	moveq	r6, #11
		if (bytes-- <= 0)
34803fe4:	0a00000b 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
		if (bytes-- <= 0)
34803fe8:	e3550001 	cmp	r5, #1
		a_b[++length] = '1';
		if (bytes-- <= 0)
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
34803fec:	e5c43020 	strb	r3, [r4, #32]
34803ff0:	03a0600c 	moveq	r6, #12
		if (bytes-- <= 0)
34803ff4:	0a000007 	beq	34804018 <handle_send_packet+0x15c>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar (2);	/* only long packets */
34803ff8:	e3a02022 	mov	r2, #34	; 0x22
34803ffc:	e5c42021 	strb	r2, [r4, #33]	; 0x21
		a_b[++length] = tochar (0);	/* no windows */
34804000:	e3a02020 	mov	r2, #32
34804004:	e5c42022 	strb	r2, [r4, #34]	; 0x22
		a_b[++length] = tochar (94);	/* large packet msb */
34804008:	e282205e 	add	r2, r2, #94	; 0x5e
3480400c:	e5c42023 	strb	r2, [r4, #35]	; 0x23
		a_b[++length] = tochar (94);	/* large packet lsb */
34804010:	e5c42024 	strb	r2, [r4, #36]	; 0x24
34804014:	e3a06010 	mov	r6, #16
	} while (0);

	a_b[0] = START_CHAR;
34804018:	e59f405c 	ldr	r4, [pc, #92]	; 3480407c <handle_send_packet+0x1c0>
3480401c:	e3a03001 	mov	r3, #1
34804020:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
34804024:	e2877020 	add	r7, r7, #32
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34804028:	e2863020 	add	r3, r6, #32
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
3480402c:	e2866001 	add	r6, r6, #1
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34804030:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34804034:	e5c47016 	strb	r7, [r4, #22]
	a_b[3] = ACK_TYPE;
34804038:	e3a03059 	mov	r3, #89	; 0x59
	a_b[++length] = '\0';
3480403c:	e0847006 	add	r7, r4, r6
34804040:	e3a05000 	mov	r5, #0
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34804044:	e5c43017 	strb	r3, [r4, #23]
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804048:	e2840015 	add	r0, r4, #21

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
3480404c:	e5c75014 	strb	r5, [r7, #20]
	a_b[length] = tochar (chk1 (&a_b[1]));
34804050:	ebffff28 	bl	34803cf8 <chk1>
	a_b[++length] = his_eol;
34804054:	e2866001 	add	r6, r6, #1
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804058:	e2800020 	add	r0, r0, #32
	a_b[++length] = his_eol;
3480405c:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804060:	e5c70014 	strb	r0, [r7, #20]
	a_b[++length] = his_eol;
34804064:	e0846006 	add	r6, r4, r6
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804068:	e2840014 	add	r0, r4, #20
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
3480406c:	e5c63014 	strb	r3, [r6, #20]
	a_b[++length] = '\0';
34804070:	e5c65015 	strb	r5, [r6, #21]
	s1_sendpacket (a_b);
}
34804074:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804078:	eaffff28 	b	34803d20 <s1_sendpacket>
3480407c:	34829994 	.word	0x34829994

34804080 <do_load_serial_bin>:
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804080:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804084:	e59f0404 	ldr	r0, [pc, #1028]	; 34804490 <do_load_serial_bin+0x410>
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804088:	e24dd028 	sub	sp, sp, #40	; 0x28
3480408c:	e1a05002 	mov	r5, r2
34804090:	e1a06003 	mov	r6, r3

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804094:	eb000f9d 	bl	34807f10 <getenv>
34804098:	e3500000 	cmp	r0, #0
	int load_baudrate, current_baudrate;
	int rcode = 0;
	char *s;

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;
3480409c:	03a04309 	moveq	r4, #603979776	; 0x24000000

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
348040a0:	0a000003 	beq	348040b4 <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
348040a4:	e3a01000 	mov	r1, #0
348040a8:	e3a02010 	mov	r2, #16
348040ac:	eb00644c 	bl	3481d1e4 <simple_strtoul>
348040b0:	e1a04000 	mov	r4, r0
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
348040b4:	e3550001 	cmp	r5, #1
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
348040b8:	e5987008 	ldr	r7, [r8, #8]

	if (argc >= 2) {
348040bc:	da0000eb 	ble	34804470 <do_load_serial_bin+0x3f0>
		offset = simple_strtoul(argv[1], NULL, 16);
348040c0:	e5960004 	ldr	r0, [r6, #4]
348040c4:	e3a01000 	mov	r1, #0
348040c8:	e3a02010 	mov	r2, #16
348040cc:	eb006444 	bl	3481d1e4 <simple_strtoul>
	}
	if (argc == 3) {
348040d0:	e3550003 	cmp	r5, #3
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
		offset = simple_strtoul(argv[1], NULL, 16);
348040d4:	e1a04000 	mov	r4, r0
	}
	if (argc == 3) {
348040d8:	1a0000e4 	bne	34804470 <do_load_serial_bin+0x3f0>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
348040dc:	e5960008 	ldr	r0, [r6, #8]
348040e0:	e3a01000 	mov	r1, #0
348040e4:	e3a0200a 	mov	r2, #10
348040e8:	eb00643d 	bl	3481d1e4 <simple_strtoul>

		/* default to current baudrate */
		if (load_baudrate == 0)
348040ec:	e2505000 	subs	r5, r0, #0
348040f0:	0a0000de 	beq	34804470 <do_load_serial_bin+0x3f0>
			load_baudrate = current_baudrate;
	}

	if (load_baudrate != current_baudrate) {
348040f4:	e1550007 	cmp	r5, r7
348040f8:	0a00000b 	beq	3480412c <do_load_serial_bin+0xac>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
348040fc:	e1a01005 	mov	r1, r5
34804100:	e59f038c 	ldr	r0, [pc, #908]	; 34804494 <do_load_serial_bin+0x414>
34804104:	eb00166f 	bl	34809ac8 <printf>
			load_baudrate);
		udelay(50000);
34804108:	e30c0350 	movw	r0, #50000	; 0xc350
3480410c:	eb0061f0 	bl	3481c8d4 <udelay>
		gd->baudrate = load_baudrate;
34804110:	e5885008 	str	r5, [r8, #8]
		serial_setbrg ();
34804114:	eb002b2c 	bl	3480edcc <serial_setbrg>
		udelay(50000);
34804118:	e30c0350 	movw	r0, #50000	; 0xc350
3480411c:	eb0061ec 	bl	3481c8d4 <udelay>
		for (;;) {
			if (getc() == '\r')
34804120:	eb001642 	bl	34809a30 <getc>
34804124:	e350000d 	cmp	r0, #13
34804128:	1afffffc 	bne	34804120 <do_load_serial_bin+0xa0>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
3480412c:	e5960000 	ldr	r0, [r6]
34804130:	e59f1360 	ldr	r1, [pc, #864]	; 34804498 <do_load_serial_bin+0x418>
34804134:	eb006063 	bl	3481c2c8 <strcmp>
34804138:	e2509000 	subs	r9, r0, #0
3480413c:	1a000006 	bne	3480415c <do_load_serial_bin+0xdc>
		printf ("## Ready for binary (ymodem) download "
34804140:	e1a01004 	mov	r1, r4
34804144:	e1a02005 	mov	r2, r5
34804148:	e59f034c 	ldr	r0, [pc, #844]	; 3480449c <do_load_serial_bin+0x41c>
3480414c:	eb00165d 	bl	34809ac8 <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem (offset);
34804150:	e1a00004 	mov	r0, r4
34804154:	ebfffdd2 	bl	348038a4 <load_serial_ymodem>
34804158:	ea0000b3 	b	3480442c <do_load_serial_bin+0x3ac>

	} else {

		printf ("## Ready for binary (kermit) download "
3480415c:	e1a02005 	mov	r2, r5
34804160:	e1a01004 	mov	r1, r4
34804164:	e59f0334 	ldr	r0, [pc, #820]	; 348044a0 <do_load_serial_bin+0x420>
34804168:	eb001656 	bl	34809ac8 <printf>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
3480416c:	e59fa330 	ldr	sl, [pc, #816]	; 348044a4 <do_load_serial_bin+0x424>
	os_data_init = bin_data_init;
34804170:	e59f3330 	ldr	r3, [pc, #816]	; 348044a8 <do_load_serial_bin+0x428>
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34804174:	e3a06000 	mov	r6, #0
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
	os_data_init = bin_data_init;
34804178:	e58a3034 	str	r3, [sl, #52]	; 0x34
	os_data_char = bin_data_char;
3480417c:	e59f3328 	ldr	r3, [pc, #808]	; 348044ac <do_load_serial_bin+0x42c>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
34804180:	e58a4008 	str	r4, [sl, #8]
	os_data_init = bin_data_init;
	os_data_char = bin_data_char;
34804184:	e58a3044 	str	r3, [sl, #68]	; 0x44
	int length;
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34804188:	e3a0300d 	mov	r3, #13
3480418c:	e5ca302c 	strb	r3, [sl, #44]	; 0x2c
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
34804190:	e2833016 	add	r3, r3, #22
34804194:	e5ca3048 	strb	r3, [sl, #72]	; 0x48
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34804198:	e58a600c 	str	r6, [sl, #12]
	his_pad_char = '\0';
3480419c:	e5ca6010 	strb	r6, [sl, #16]
	his_quote = K_ESCAPE;

	/* initialize the k_recv and k_data state machine */
	done = 0;
	k_state = 0;
	k_data_init ();
348041a0:	ebffff17 	bl	34803e04 <k_data_init>
	k_state_saved = k_state;
	k_data_save ();
348041a4:	ebffff1e 	bl	34803e24 <k_data_save>
	n = 0;				/* just to get rid of a warning */
	last_n = -1;
348041a8:	e3e09000 	mvn	r9, #0
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
348041ac:	e58d5004 	str	r5, [sp, #4]
348041b0:	e1a05004 	mov	r5, r4
	 */

	/* enter main loop */
	while (!done) {
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
348041b4:	e59f12f4 	ldr	r1, [pc, #756]	; 348044b0 <do_load_serial_bin+0x430>
348041b8:	e58a104c 	str	r1, [sl, #76]	; 0x4c
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
348041bc:	eb00161b 	bl	34809a30 <getc>
348041c0:	e3500001 	cmp	r0, #1
348041c4:	0a000002 	beq	348041d4 <do_load_serial_bin+0x154>
348041c8:	e3500003 	cmp	r0, #3
348041cc:	1afffffa 	bne	348041bc <do_load_serial_bin+0x13c>
348041d0:	ea00006e 	b	34804390 <do_load_serial_bin+0x310>
			}
		}
START:
		/* get length of packet */
		sum = 0;
		new_char = getc ();
348041d4:	eb001615 	bl	34809a30 <getc>
		if ((new_char & 0xE0) == 0)
348041d8:	e6ef4070 	uxtb	r4, r0
348041dc:	e31400e0 	tst	r4, #224	; 0xe0
348041e0:	0a000057 	beq	34804344 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
348041e4:	eb001611 	bl	34809a30 <getc>
		if ((new_char & 0xE0) == 0)
348041e8:	e6efb070 	uxtb	fp, r0
348041ec:	e31b00e0 	tst	fp, #224	; 0xe0
348041f0:	0a000053 	beq	34804344 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348041f4:	e24b6020 	sub	r6, fp, #32
348041f8:	e20660ff 	and	r6, r6, #255	; 0xff
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
348041fc:	e1560009 	cmp	r6, r9
34804200:	1a000001 	bne	3480420c <do_load_serial_bin+0x18c>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
			k_data_restore ();
34804204:	ebffff0f 	bl	34803e48 <k_data_restore>
34804208:	ea000000 	b	34804210 <do_load_serial_bin+0x190>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
			k_state_saved = k_state;
			k_data_save ();
3480420c:	ebffff04 	bl	34803e24 <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc ();
34804210:	eb001606 	bl	34809a30 <getc>
34804214:	e6ef9070 	uxtb	r9, r0
		if ((new_char & 0xE0) == 0)
34804218:	e31900e0 	tst	r9, #224	; 0xe0
3480421c:	0a000047 	beq	34804340 <do_load_serial_bin+0x2c0>
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
34804220:	e08bb004 	add	fp, fp, r4
		sum = 0;
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
34804224:	e2444020 	sub	r4, r4, #32
34804228:	e20440ff 	and	r4, r4, #255	; 0xff
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		k_state = new_char;
		--length;
3480422c:	e2444002 	sub	r4, r4, #2
		/* check for extended length */
		if (length == -2) {
34804230:	e3740002 	cmn	r4, #2

		/* get packet type */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
34804234:	e08bb009 	add	fp, fp, r9
		k_state = new_char;
		--length;
		/* check for extended length */
		if (length == -2) {
34804238:	1a000030 	bne	34804300 <do_load_serial_bin+0x280>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
3480423c:	eb0015fb 	bl	34809a30 <getc>
			if ((new_char & 0xE0) == 0)
34804240:	e6ef4070 	uxtb	r4, r0
34804244:	e31400e0 	tst	r4, #224	; 0xe0
34804248:	0a00003c 	beq	34804340 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
			new_char = getc ();
3480424c:	eb0015f7 	bl	34809a30 <getc>
			if ((new_char & 0xE0) == 0)
34804250:	e6ef3070 	uxtb	r3, r0
34804254:	e31300e0 	tst	r3, #224	; 0xe0
34804258:	0a000038 	beq	34804340 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
3480425c:	e58d3000 	str	r3, [sp]
34804260:	eb0015f2 	bl	34809a30 <getc>
34804264:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
34804268:	e31000e0 	tst	r0, #224	; 0xe0
3480426c:	e59d3000 	ldr	r3, [sp]
34804270:	0a000032 	beq	34804340 <do_load_serial_bin+0x2c0>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804274:	e084b00b 	add	fp, r4, fp
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804278:	e08bb003 	add	fp, fp, r3
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
3480427c:	e7e1235b 	ubfx	r2, fp, #6, #2
34804280:	e082200b 	add	r2, r2, fp
34804284:	e202203f 	and	r2, r2, #63	; 0x3f
34804288:	e2822020 	add	r2, r2, #32
3480428c:	e1500002 	cmp	r0, r2
34804290:	1a00002a 	bne	34804340 <do_load_serial_bin+0x2c0>
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
34804294:	e2444020 	sub	r4, r4, #32
34804298:	e20440ff 	and	r4, r4, #255	; 0xff
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
3480429c:	e3a0205f 	mov	r2, #95	; 0x5f
348042a0:	e0040492 	mul	r4, r2, r4
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
348042a4:	e2433020 	sub	r3, r3, #32
			length = len_hi * 95 + len_lo;
348042a8:	e6e44073 	uxtab	r4, r4, r3
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
				goto packet_error;
			sum += new_char & 0xff;
348042ac:	e080b00b 	add	fp, r0, fp
348042b0:	ea000012 	b	34804300 <do_load_serial_bin+0x280>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
348042b4:	eb0015dd 	bl	34809a30 <getc>
348042b8:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
348042bc:	e31000e0 	tst	r0, #224	; 0xe0
348042c0:	0a00001e 	beq	34804340 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
348042c4:	e3590044 	cmp	r9, #68	; 0x44
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
348042c8:	e08bb000 	add	fp, fp, r0
			--length;
348042cc:	e2444001 	sub	r4, r4, #1
			if (k_state == DATA_TYPE) {
348042d0:	1a000001 	bne	348042dc <do_load_serial_bin+0x25c>
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
348042d4:	ebfffee4 	bl	34803e6c <k_data_char>
348042d8:	ea000008 	b	34804300 <do_load_serial_bin+0x280>
			} else if (k_state == SEND_TYPE) {
348042dc:	e3590053 	cmp	r9, #83	; 0x53
348042e0:	1a000006 	bne	34804300 <do_load_serial_bin+0x280>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
348042e4:	e59a204c 	ldr	r2, [sl, #76]	; 0x4c
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348042e8:	e59f11c4 	ldr	r1, [pc, #452]	; 348044b4 <do_load_serial_bin+0x434>
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
348042ec:	e1a03002 	mov	r3, r2
348042f0:	e4c30001 	strb	r0, [r3], #1
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348042f4:	e1530001 	cmp	r3, r1
					--send_ptr;
348042f8:	21a03002 	movcs	r3, r2
348042fc:	e58a304c 	str	r3, [sl, #76]	; 0x4c
				goto packet_error;
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
34804300:	e3540001 	cmp	r4, #1
34804304:	caffffea 	bgt	348042b4 <do_load_serial_bin+0x234>
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc ();
34804308:	eb0015c8 	bl	34809a30 <getc>
3480430c:	e6ef0070 	uxtb	r0, r0
		if ((new_char & 0xE0) == 0)
34804310:	e31000e0 	tst	r0, #224	; 0xe0
34804314:	0a000009 	beq	34804340 <do_load_serial_bin+0x2c0>
			goto packet_error;
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34804318:	e7e1335b 	ubfx	r3, fp, #6, #2
3480431c:	e083b00b 	add	fp, r3, fp
34804320:	e20bb03f 	and	fp, fp, #63	; 0x3f
34804324:	e28bb020 	add	fp, fp, #32
34804328:	e150000b 	cmp	r0, fp
3480432c:	1a000003 	bne	34804340 <do_load_serial_bin+0x2c0>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc ();
34804330:	eb0015be 	bl	34809a30 <getc>
		if (new_char != END_CHAR) {
34804334:	e6ef0070 	uxtb	r0, r0
34804338:	e350000d 	cmp	r0, #13
3480433c:	0a000006 	beq	3480435c <do_load_serial_bin+0x2dc>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34804340:	e1a09006 	mov	r9, r6
		new_char = getc ();
		if (new_char != END_CHAR) {
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore ();
34804344:	ebfffebf 	bl	34803e48 <k_data_restore>
			/* send a negative acknowledge packet in */
			send_nack (n);
34804348:	e1a00006 	mov	r0, r6
3480434c:	ebfffe94 	bl	34803da4 <send_nack>
34804350:	e1a03006 	mov	r3, r6
34804354:	e1a06009 	mov	r6, r9
34804358:	ea000009 	b	34804384 <do_load_serial_bin+0x304>
		} else if (k_state == SEND_TYPE) {
3480435c:	e3590053 	cmp	r9, #83	; 0x53
34804360:	1a000002 	bne	34804370 <do_load_serial_bin+0x2f0>
			/* crack the protocol parms, build an appropriate ack packet */
			handle_send_packet (n);
34804364:	e1a00006 	mov	r0, r6
34804368:	ebfffed3 	bl	34803ebc <handle_send_packet>
3480436c:	ea000003 	b	34804380 <do_load_serial_bin+0x300>
		} else {
			/* send simple acknowledge packet in */
			send_ack (n);
34804370:	e1a00006 	mov	r0, r6
34804374:	ebfffe72 	bl	34803d44 <send_ack>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
34804378:	e3590042 	cmp	r9, #66	; 0x42
3480437c:	0a00003d 	beq	34804478 <do_load_serial_bin+0x3f8>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34804380:	e1a03006 	mov	r3, r6
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804384:	e1a09006 	mov	r9, r6
34804388:	e1a06003 	mov	r6, r3
3480438c:	eaffff88 	b	348041b4 <do_load_serial_bin+0x134>
34804390:	e1a04005 	mov	r4, r5
34804394:	e59d5004 	ldr	r5, [sp, #4]
		for (;;) {
			switch (getc ()) {
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
34804398:	e3a06000 	mov	r6, #0
3480439c:	e3a09064 	mov	r9, #100	; 0x64
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
348043a0:	eb0015ab 	bl	34809a54 <tstc>
348043a4:	e3500000 	cmp	r0, #0
348043a8:	0a000000 	beq	348043b0 <do_load_serial_bin+0x330>
			(void) getc();
348043ac:	eb00159f 	bl	34809a30 <getc>
		}
		udelay(1000);
348043b0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348043b4:	eb006146 	bl	3481c8d4 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
348043b8:	e2599001 	subs	r9, r9, #1
348043bc:	1afffff7 	bne	348043a0 <do_load_serial_bin+0x320>
			(void) getc();
		}
		udelay(1000);
	}

	flush_cache (offset, size);
348043c0:	e1a01006 	mov	r1, r6
348043c4:	e1a00004 	mov	r0, r4
348043c8:	ebfff33e 	bl	348010c8 <flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
348043cc:	e28da008 	add	sl, sp, #8
		udelay(1000);
	}

	flush_cache (offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
348043d0:	e1a01006 	mov	r1, r6
348043d4:	e1a02006 	mov	r2, r6
348043d8:	e59f00d8 	ldr	r0, [pc, #216]	; 348044b8 <do_load_serial_bin+0x438>
348043dc:	eb0015b9 	bl	34809ac8 <printf>
	sprintf(buf, "%X", size);
348043e0:	e1a02006 	mov	r2, r6
348043e4:	e59f10d0 	ldr	r1, [pc, #208]	; 348044bc <do_load_serial_bin+0x43c>
348043e8:	e1a0000a 	mov	r0, sl
348043ec:	eb006422 	bl	3481d47c <sprintf>
	setenv("filesize", buf);
348043f0:	e59f00c8 	ldr	r0, [pc, #200]	; 348044c0 <do_load_serial_bin+0x440>
348043f4:	e1a0100a 	mov	r1, sl
348043f8:	eb000dbc 	bl	34807af0 <setenv>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin (offset);

		if (addr == ~0) {
348043fc:	e3740001 	cmn	r4, #1
34804400:	e59f60bc 	ldr	r6, [pc, #188]	; 348044c4 <do_load_serial_bin+0x444>
34804404:	1a000004 	bne	3480441c <do_load_serial_bin+0x39c>
			load_addr = 0;
34804408:	e5869000 	str	r9, [r6]
			printf ("## Binary (kermit) download aborted\n");
3480440c:	e59f00b4 	ldr	r0, [pc, #180]	; 348044c8 <do_load_serial_bin+0x448>
34804410:	eb0015ac 	bl	34809ac8 <printf>
			rcode = 1;
34804414:	e3a09001 	mov	r9, #1
34804418:	ea000003 	b	3480442c <do_load_serial_bin+0x3ac>
		} else {
			printf ("## Start Addr      = 0x%08lX\n", addr);
3480441c:	e59f00a8 	ldr	r0, [pc, #168]	; 348044cc <do_load_serial_bin+0x44c>
34804420:	e1a01004 	mov	r1, r4
34804424:	eb0015a7 	bl	34809ac8 <printf>
			load_addr = addr;
34804428:	e5864000 	str	r4, [r6]
		}
	}
	if (load_baudrate != current_baudrate) {
3480442c:	e1550007 	cmp	r5, r7
34804430:	0a00000b 	beq	34804464 <do_load_serial_bin+0x3e4>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
34804434:	e1a01007 	mov	r1, r7
34804438:	e59f0090 	ldr	r0, [pc, #144]	; 348044d0 <do_load_serial_bin+0x450>
3480443c:	eb0015a1 	bl	34809ac8 <printf>
			current_baudrate);
		udelay (50000);
34804440:	e30c0350 	movw	r0, #50000	; 0xc350
34804444:	eb006122 	bl	3481c8d4 <udelay>
		gd->baudrate = current_baudrate;
34804448:	e5887008 	str	r7, [r8, #8]
		serial_setbrg ();
3480444c:	eb002a5e 	bl	3480edcc <serial_setbrg>
		udelay (50000);
34804450:	e30c0350 	movw	r0, #50000	; 0xc350
34804454:	eb00611e 	bl	3481c8d4 <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
34804458:	eb001574 	bl	34809a30 <getc>
3480445c:	e350001b 	cmp	r0, #27
34804460:	1afffffc 	bne	34804458 <do_load_serial_bin+0x3d8>
				break;
		}
	}

	return rcode;
}
34804464:	e1a00009 	mov	r0, r9
34804468:	e28dd028 	add	sp, sp, #40	; 0x28
3480446c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804470:	e1a05007 	mov	r5, r7
34804474:	eaffff2c 	b	3480412c <do_load_serial_bin+0xac>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
				done = 1;
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
34804478:	e59f3024 	ldr	r3, [pc, #36]	; 348044a4 <do_load_serial_bin+0x424>
3480447c:	e1a04005 	mov	r4, r5
34804480:	e9930044 	ldmib	r3, {r2, r6}
34804484:	e0426006 	sub	r6, r2, r6
34804488:	e59d5004 	ldr	r5, [sp, #4]
3480448c:	eaffffc2 	b	3480439c <do_load_serial_bin+0x31c>
34804490:	348228cd 	.word	0x348228cd
34804494:	34823a4c 	.word	0x34823a4c
34804498:	34823a7e 	.word	0x34823a7e
3480449c:	34823a84 	.word	0x34823a84
348044a0:	34823ac3 	.word	0x34823ac3
348044a4:	34829994 	.word	0x34829994
348044a8:	34803868 	.word	0x34803868
348044ac:	34803884 	.word	0x34803884
348044b0:	348299e4 	.word	0x348299e4
348044b4:	348299f8 	.word	0x348299f8
348044b8:	34823951 	.word	0x34823951
348044bc:	34823979 	.word	0x34823979
348044c0:	348231d5 	.word	0x348231d5
348044c4:	34828438 	.word	0x34828438
348044c8:	34823b02 	.word	0x34823b02
348044cc:	34823a2e 	.word	0x34823a2e
348044d0:	34823b27 	.word	0x34823b27

348044d4 <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
348044d4:	e3520002 	cmp	r2, #2
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348044d8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
		return CMD_RET_USAGE;
348044dc:	d3e00000 	mvnle	r0, #0
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348044e0:	e1a07002 	mov	r7, r2
348044e4:	e1a04003 	mov	r4, r3
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
348044e8:	d8bd84f0 	pople	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
348044ec:	e5930004 	ldr	r0, [r3, #4]
348044f0:	e3a01000 	mov	r1, #0
348044f4:	e3a02010 	mov	r2, #16
348044f8:	eb006339 	bl	3481d1e4 <simple_strtoul>
	addr += base_address;
348044fc:	e59f3074 	ldr	r3, [pc, #116]	; 34804578 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
34804500:	e3a01000 	mov	r1, #0

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
34804504:	e5935000 	ldr	r5, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
34804508:	e3a02010 	mov	r2, #16

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
3480450c:	e0805005 	add	r5, r0, r5

	length = simple_strtoul (argv[2], NULL, 16);
34804510:	e5940008 	ldr	r0, [r4, #8]
34804514:	eb006332 	bl	3481d1e4 <simple_strtoul>
34804518:	e1a06000 	mov	r6, r0

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
3480451c:	e1a01005 	mov	r1, r5
34804520:	e1a02006 	mov	r2, r6
34804524:	e3a03801 	mov	r3, #65536	; 0x10000
34804528:	e3a00000 	mov	r0, #0
3480452c:	eb0058e0 	bl	3481a8b4 <crc32_wd>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);
34804530:	e2462001 	sub	r2, r6, #1
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
34804534:	e1a0a000 	mov	sl, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
34804538:	e1a01005 	mov	r1, r5
3480453c:	e59f0038 	ldr	r0, [pc, #56]	; 3480457c <do_mem_crc+0xa8>
34804540:	e0822005 	add	r2, r2, r5
34804544:	e1a0300a 	mov	r3, sl
34804548:	eb00155e 	bl	34809ac8 <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
3480454c:	e3570003 	cmp	r7, #3
34804550:	0a000006 	beq	34804570 <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
34804554:	e594000c 	ldr	r0, [r4, #12]
34804558:	e3a01000 	mov	r1, #0
3480455c:	e3a02010 	mov	r2, #16
34804560:	eb00631f 	bl	3481d1e4 <simple_strtoul>
		*ptr = crc;
34804564:	e580a000 	str	sl, [r0]
	}

	return 0;
34804568:	e3a00000 	mov	r0, #0
3480456c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804570:	e3a00000 	mov	r0, #0
}
34804574:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804578:	348299f8 	.word	0x348299f8
3480457c:	34823c8a 	.word	0x34823c8a

34804580 <do_mem_base>:
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc > 1) {
34804580:	e3520001 	cmp	r2, #1
	}
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804584:	e92d4008 	push	{r3, lr}
	if (argc > 1) {
34804588:	da000005 	ble	348045a4 <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
3480458c:	e5930004 	ldr	r0, [r3, #4]
34804590:	e3a01000 	mov	r1, #0
34804594:	e3a02010 	mov	r2, #16
34804598:	eb006311 	bl	3481d1e4 <simple_strtoul>
3480459c:	e59f3018 	ldr	r3, [pc, #24]	; 348045bc <do_mem_base+0x3c>
348045a0:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
348045a4:	e59f3010 	ldr	r3, [pc, #16]	; 348045bc <do_mem_base+0x3c>
348045a8:	e59f0010 	ldr	r0, [pc, #16]	; 348045c0 <do_mem_base+0x40>
348045ac:	e5931000 	ldr	r1, [r3]
348045b0:	eb001544 	bl	34809ac8 <printf>
	return 0;
}
348045b4:	e3a00000 	mov	r0, #0
348045b8:	e8bd8008 	pop	{r3, pc}
348045bc:	348299f8 	.word	0x348299f8
348045c0:	34823caf 	.word	0x34823caf

348045c4 <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
348045c4:	e3520001 	cmp	r2, #1
 * Perform a memory test. A more complete alternative test can be
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348045c8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348045cc:	e1a05002 	mov	r5, r2
348045d0:	e1a06003 	mov	r6, r3
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
348045d4:	da000056 	ble	34804734 <do_mem_mtest+0x170>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348045d8:	e5930004 	ldr	r0, [r3, #4]
348045dc:	e3a01000 	mov	r1, #0
348045e0:	e3a02010 	mov	r2, #16
348045e4:	eb0062fe 	bl	3481d1e4 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348045e8:	e3550002 	cmp	r5, #2
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348045ec:	e58d0000 	str	r0, [sp]
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348045f0:	0a000051 	beq	3480473c <do_mem_mtest+0x178>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
348045f4:	e5960008 	ldr	r0, [r6, #8]
348045f8:	e3a01000 	mov	r1, #0
348045fc:	e3a02010 	mov	r2, #16
34804600:	eb0062f7 	bl	3481d1e4 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
34804604:	e3550003 	cmp	r5, #3
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
34804608:	e58d0004 	str	r0, [sp, #4]
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
3480460c:	0a00004c 	beq	34804744 <do_mem_mtest+0x180>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804610:	e596000c 	ldr	r0, [r6, #12]
34804614:	e3a01000 	mov	r1, #0
34804618:	e3a02010 	mov	r2, #16
3480461c:	eb0062f0 	bl	3481d1e4 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
34804620:	e3550004 	cmp	r5, #4
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804624:	e1a04000 	mov	r4, r0
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34804628:	03a0b000 	moveq	fp, #0
	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	else
		pattern = 0;

	if (argc > 4)
3480462c:	0a000004 	beq	34804644 <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
34804630:	e5960010 	ldr	r0, [r6, #16]
34804634:	e3a01000 	mov	r1, #0
34804638:	e3a02010 	mov	r2, #16
3480463c:	eb0062e8 	bl	3481d1e4 <simple_strtoul>
34804640:	e1a0b000 	mov	fp, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
34804644:	e3a05001 	mov	r5, #1
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
	int iterations = 1;
34804648:	e1a0a005 	mov	sl, r5
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
3480464c:	e3a09000 	mov	r9, #0
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
		if (ctrlc()) {
34804650:	eb001541 	bl	34809b5c <ctrlc>
34804654:	e3500000 	cmp	r0, #0
34804658:	1a000025 	bne	348046f4 <do_mem_mtest+0x130>
			putc ('\n');
			return 1;
		}

		if (iteration_limit && iterations > iteration_limit) {
3480465c:	e35b0000 	cmp	fp, #0
34804660:	115a000b 	cmpne	sl, fp
34804664:	da000006 	ble	34804684 <do_mem_mtest+0xc0>
			printf("Tested %d iteration(s) with %lu errors.\n",
34804668:	e59f00e0 	ldr	r0, [pc, #224]	; 34804750 <do_mem_mtest+0x18c>
3480466c:	e24a1001 	sub	r1, sl, #1
34804670:	e1a02009 	mov	r2, r9
34804674:	eb001513 	bl	34809ac8 <printf>
				iterations-1, errs);
			return errs != 0;
34804678:	e2590000 	subs	r0, r9, #0
3480467c:	13a00001 	movne	r0, #1
34804680:	ea00002a 	b	34804730 <do_mem_mtest+0x16c>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
34804684:	e59f20c8 	ldr	r2, [pc, #200]	; 34804754 <do_mem_mtest+0x190>
34804688:	e59f00c8 	ldr	r0, [pc, #200]	; 34804758 <do_mem_mtest+0x194>
3480468c:	e1a01004 	mov	r1, r4
34804690:	eb00150c 	bl	34809ac8 <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34804694:	e1a02004 	mov	r2, r4
34804698:	e59d3000 	ldr	r3, [sp]
3480469c:	ea000001 	b	348046a8 <do_mem_mtest+0xe4>
			WATCHDOG_RESET();
			*addr = val;
348046a0:	e4832004 	str	r2, [r3], #4
			val  += incr;
348046a4:	e0822005 	add	r2, r2, r5
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
348046a8:	e59d1004 	ldr	r1, [sp, #4]
348046ac:	e1530001 	cmp	r3, r1
348046b0:	3afffffa 	bcc	348046a0 <do_mem_mtest+0xdc>
			WATCHDOG_RESET();
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
348046b4:	e59f00a0 	ldr	r0, [pc, #160]	; 3480475c <do_mem_mtest+0x198>
348046b8:	eb0014f8 	bl	34809aa0 <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
348046bc:	e1a07004 	mov	r7, r4
348046c0:	e59d6000 	ldr	r6, [sp]
348046c4:	ea000010 	b	3480470c <do_mem_mtest+0x148>
			WATCHDOG_RESET();
			readback = *addr;
348046c8:	e5962000 	ldr	r2, [r6]
			if (readback != val) {
348046cc:	e1520007 	cmp	r2, r7
348046d0:	0a00000b 	beq	34804704 <do_mem_mtest+0x140>
				printf ("\nMem error @ 0x%08X: "
348046d4:	e1a01006 	mov	r1, r6
348046d8:	e1a03007 	mov	r3, r7
348046dc:	e59f007c 	ldr	r0, [pc, #124]	; 34804760 <do_mem_mtest+0x19c>
348046e0:	eb0014f8 	bl	34809ac8 <printf>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
				if (ctrlc()) {
348046e4:	eb00151c 	bl	34809b5c <ctrlc>
348046e8:	e3500000 	cmp	r0, #0
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
348046ec:	02899001 	addeq	r9, r9, #1
348046f0:	0a000003 	beq	34804704 <do_mem_mtest+0x140>
				if (ctrlc()) {
					putc ('\n');
348046f4:	e3a0000a 	mov	r0, #10
348046f8:	eb0014de 	bl	34809a78 <putc>
					return 1;
348046fc:	e3a00001 	mov	r0, #1
34804700:	ea00000a 	b	34804730 <do_mem_mtest+0x16c>
				}
			}
			val += incr;
34804704:	e0877005 	add	r7, r7, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
34804708:	e2866004 	add	r6, r6, #4
3480470c:	e59d3004 	ldr	r3, [sp, #4]
34804710:	e1560003 	cmp	r6, r3
34804714:	3affffeb 	bcc	348046c8 <do_mem_mtest+0x104>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
34804718:	e3540000 	cmp	r4, #0
			pattern = -pattern;	/* complement & increment */
3480471c:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
34804720:	a1e04004 	mvnge	r4, r4
		if (iteration_limit && iterations > iteration_limit) {
			printf("Tested %d iteration(s) with %lu errors.\n",
				iterations-1, errs);
			return errs != 0;
		}
		++iterations;
34804724:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
		}
		else {
			pattern = ~pattern;
		}
		incr = -incr;
34804728:	e2655000 	rsb	r5, r5, #0
	}
3480472c:	eaffffc7 	b	34804650 <do_mem_mtest+0x8c>
#endif
	return 0;	/* not reached */
}
34804730:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
34804734:	e3a01202 	mov	r1, #536870912	; 0x20000000
34804738:	e58d1000 	str	r1, [sp]
3480473c:	e3a03425 	mov	r3, #620756992	; 0x25000000
34804740:	e58d3004 	str	r3, [sp, #4]
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34804744:	e3a04000 	mov	r4, #0
34804748:	e1a0b004 	mov	fp, r4
3480474c:	eaffffbc 	b	34804644 <do_mem_mtest+0x80>
34804750:	34823cc6 	.word	0x34823cc6
34804754:	34823d17 	.word	0x34823d17
34804758:	34823cef 	.word	0x34823cef
3480475c:	34823d18 	.word	0x34823d18
34804760:	34823d23 	.word	0x34823d23

34804764 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34804764:	e3520002 	cmp	r2, #2
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804768:	e92d4070 	push	{r4, r5, r6, lr}
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
		return CMD_RET_USAGE;
3480476c:	d3e00000 	mvnle	r0, #0
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804770:	e1a06003 	mov	r6, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34804774:	d8bd8070 	pople	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804778:	e5930000 	ldr	r0, [r3]
3480477c:	e3a01004 	mov	r1, #4
34804780:	eb0013f2 	bl	34809750 <cmd_get_data_size>
34804784:	e2505000 	subs	r5, r0, #0
34804788:	ba000030 	blt	34804850 <do_mem_loop+0xec>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
3480478c:	e3a01000 	mov	r1, #0
34804790:	e3a02010 	mov	r2, #16
34804794:	e5960004 	ldr	r0, [r6, #4]
34804798:	eb006291 	bl	3481d1e4 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
3480479c:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
348047a0:	e1a04000 	mov	r4, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
348047a4:	e3a02010 	mov	r2, #16
348047a8:	e5960008 	ldr	r0, [r6, #8]
348047ac:	eb00628c 	bl	3481d1e4 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
348047b0:	e3500001 	cmp	r0, #1
348047b4:	1a000009 	bne	348047e0 <do_mem_loop+0x7c>
		if (size == 4) {
348047b8:	e3550004 	cmp	r5, #4
348047bc:	1a000001 	bne	348047c8 <do_mem_loop+0x64>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
348047c0:	e5943000 	ldr	r3, [r4]
348047c4:	eafffffd 	b	348047c0 <do_mem_loop+0x5c>
		}
		if (size == 2) {
348047c8:	e3550002 	cmp	r5, #2
348047cc:	1a000001 	bne	348047d8 <do_mem_loop+0x74>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
348047d0:	e1d430b0 	ldrh	r3, [r4]
348047d4:	eafffffd 	b	348047d0 <do_mem_loop+0x6c>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
348047d8:	e5d43000 	ldrb	r3, [r4]
348047dc:	eafffffd 	b	348047d8 <do_mem_loop+0x74>
	}

	if (size == 4) {
348047e0:	e3550004 	cmp	r5, #4
348047e4:	1a000007 	bne	34804808 <do_mem_loop+0xa4>
		for (;;) {
			longp = (uint *)addr;
348047e8:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
348047ec:	e1a03000 	mov	r3, r0
348047f0:	ea000001 	b	348047fc <do_mem_loop+0x98>
				*longp++;
348047f4:	e4921004 	ldr	r1, [r2], #4
348047f8:	e2433001 	sub	r3, r3, #1

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
348047fc:	e3530000 	cmp	r3, #0
34804800:	0afffff8 	beq	348047e8 <do_mem_loop+0x84>
34804804:	eafffffa 	b	348047f4 <do_mem_loop+0x90>
				*longp++;
		}
	}
	if (size == 2) {
34804808:	e3550002 	cmp	r5, #2
3480480c:	1a000007 	bne	34804830 <do_mem_loop+0xcc>
		for (;;) {
			shortp = (ushort *)addr;
34804810:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
34804814:	e1a03000 	mov	r3, r0
34804818:	ea000001 	b	34804824 <do_mem_loop+0xc0>
				*shortp++;
3480481c:	e0d210b2 	ldrh	r1, [r2], #2
34804820:	e2433001 	sub	r3, r3, #1
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
34804824:	e3530000 	cmp	r3, #0
34804828:	0afffff8 	beq	34804810 <do_mem_loop+0xac>
3480482c:	eafffffa 	b	3480481c <do_mem_loop+0xb8>
				*shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
34804830:	e1a02004 	mov	r2, r4
		i = length;
		while (i-- > 0)
34804834:	e1a03000 	mov	r3, r0
34804838:	ea000001 	b	34804844 <do_mem_loop+0xe0>
			*cp++;
3480483c:	e4d21001 	ldrb	r1, [r2], #1
34804840:	e2433001 	sub	r3, r3, #1
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
34804844:	e3530000 	cmp	r3, #0
34804848:	0afffff8 	beq	34804830 <do_mem_loop+0xcc>
3480484c:	eafffffa 	b	3480483c <do_mem_loop+0xd8>

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34804850:	e3a00001 	mov	r0, #1
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++;
	}
}
34804854:	e8bd8070 	pop	{r4, r5, r6, pc}

34804858 <do_mem_cp>:
int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804858:	e3520004 	cmp	r2, #4
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480485c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
		return CMD_RET_USAGE;
34804860:	13e00000 	mvnne	r0, #0
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804864:	e1a05003 	mov	r5, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804868:	18bd86f8 	popne	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
3480486c:	e5930000 	ldr	r0, [r3]
34804870:	e1a01002 	mov	r1, r2
34804874:	eb0013b5 	bl	34809750 <cmd_get_data_size>
34804878:	e2504000 	subs	r4, r0, #0
3480487c:	ba000026 	blt	3480491c <do_mem_cp+0xc4>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34804880:	e3a01000 	mov	r1, #0
34804884:	e3a02010 	mov	r2, #16
34804888:	e5950004 	ldr	r0, [r5, #4]
3480488c:	eb006254 	bl	3481d1e4 <simple_strtoul>
	addr += base_address;
34804890:	e59f608c 	ldr	r6, [pc, #140]	; 34804924 <do_mem_cp+0xcc>
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34804894:	e1a0a000 	mov	sl, r0
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34804898:	e3a01000 	mov	r1, #0
3480489c:	e3a02010 	mov	r2, #16
348048a0:	e5950008 	ldr	r0, [r5, #8]
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
348048a4:	e5967000 	ldr	r7, [r6]

	dest = simple_strtoul(argv[2], NULL, 16);
348048a8:	eb00624d 	bl	3481d1e4 <simple_strtoul>
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
348048ac:	e3a01000 	mov	r1, #0
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
348048b0:	e1a09000 	mov	r9, r0
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
348048b4:	e3a02010 	mov	r2, #16
348048b8:	e595000c 	ldr	r0, [r5, #12]

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
348048bc:	e5966000 	ldr	r6, [r6]

	count = simple_strtoul(argv[3], NULL, 16);
348048c0:	eb006247 	bl	3481d1e4 <simple_strtoul>

	if (count == 0) {
348048c4:	e3500000 	cmp	r0, #0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
348048c8:	108a7007 	addne	r7, sl, r7

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
348048cc:	10896006 	addne	r6, r9, r6

	count = simple_strtoul(argv[3], NULL, 16);

	if (count == 0) {
348048d0:	1a000003 	bne	348048e4 <do_mem_cp+0x8c>
		puts ("Zero length ???\n");
348048d4:	e59f004c 	ldr	r0, [pc, #76]	; 34804928 <do_mem_cp+0xd0>
348048d8:	eb001470 	bl	34809aa0 <puts>
		return 1;
348048dc:	e3a00001 	mov	r0, #1
348048e0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
348048e4:	e3540004 	cmp	r4, #4
			*((ulong  *)dest) = *((ulong  *)addr);
348048e8:	05973000 	ldreq	r3, [r7]
348048ec:	05863000 	streq	r3, [r6]
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
348048f0:	0a000004 	beq	34804908 <do_mem_cp+0xb0>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
348048f4:	e3540002 	cmp	r4, #2
			*((ushort *)dest) = *((ushort *)addr);
348048f8:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
348048fc:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
34804900:	01c630b0 	strheq	r3, [r6]
		else
			*((u_char *)dest) = *((u_char *)addr);
34804904:	15c63000 	strbne	r3, [r6]
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
34804908:	e2500001 	subs	r0, r0, #1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
3480490c:	e0877004 	add	r7, r7, r4
34804910:	e0866004 	add	r6, r6, r4
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
34804914:	1afffff2 	bne	348048e4 <do_mem_cp+0x8c>
34804918:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
3480491c:	e3a00001 	mov	r0, #1
		/* reset watchdog from time to time */
		if ((count % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}
	return 0;
}
34804920:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34804924:	348299f8 	.word	0x348299f8
34804928:	34823d55 	.word	0x34823d55

3480492c <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480492c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34804930:	e3520004 	cmp	r2, #4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804934:	e24dd018 	sub	sp, sp, #24
34804938:	e1a05003 	mov	r5, r3
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
		return CMD_RET_USAGE;
3480493c:	13e06000 	mvnne	r6, #0
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34804940:	1a00003f 	bne	34804a44 <do_mem_cmp+0x118>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804944:	e5930000 	ldr	r0, [r3]
34804948:	e1a01002 	mov	r1, r2
3480494c:	eb00137f 	bl	34809750 <cmd_get_data_size>
34804950:	e2506000 	subs	r6, r0, #0
		return 1;
34804954:	b3a06001 	movlt	r6, #1
	if (argc != 4)
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804958:	ba000039 	blt	34804a44 <do_mem_cmp+0x118>
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
3480495c:	e3560004 	cmp	r6, #4
34804960:	059f40e8 	ldreq	r4, [pc, #232]	; 34804a50 <do_mem_cmp+0x124>
34804964:	0a000003 	beq	34804978 <do_mem_cmp+0x4c>
34804968:	e59f30e4 	ldr	r3, [pc, #228]	; 34804a54 <do_mem_cmp+0x128>
3480496c:	e3560002 	cmp	r6, #2
34804970:	e59f40e0 	ldr	r4, [pc, #224]	; 34804a58 <do_mem_cmp+0x12c>
34804974:	01a04003 	moveq	r4, r3

	addr1 = simple_strtoul(argv[1], NULL, 16);
34804978:	e5950004 	ldr	r0, [r5, #4]
3480497c:	e3a01000 	mov	r1, #0
34804980:	e3a02010 	mov	r2, #16
34804984:	eb006216 	bl	3481d1e4 <simple_strtoul>
	addr1 += base_address;
34804988:	e59fa0cc 	ldr	sl, [pc, #204]	; 34804a5c <do_mem_cmp+0x130>

	addr2 = simple_strtoul(argv[2], NULL, 16);
3480498c:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804990:	e59a7000 	ldr	r7, [sl]

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804994:	e3a02010 	mov	r2, #16
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804998:	e0807007 	add	r7, r0, r7

	addr2 = simple_strtoul(argv[2], NULL, 16);
3480499c:	e5950008 	ldr	r0, [r5, #8]
348049a0:	eb00620f 	bl	3481d1e4 <simple_strtoul>
	addr2 += base_address;
348049a4:	e59aa000 	ldr	sl, [sl]

	count = simple_strtoul(argv[3], NULL, 16);
348049a8:	e3a01000 	mov	r1, #0

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
348049ac:	e080a00a 	add	sl, r0, sl

	count = simple_strtoul(argv[3], NULL, 16);
348049b0:	e3a02010 	mov	r2, #16
348049b4:	e595000c 	ldr	r0, [r5, #12]
348049b8:	eb006209 	bl	3481d1e4 <simple_strtoul>
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
348049bc:	e3a05000 	mov	r5, #0
348049c0:	ea000018 	b	34804a28 <do_mem_cmp+0xfc>
		ulong word1, word2;
		if (size == 4) {
348049c4:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
348049c8:	05972000 	ldreq	r2, [r7]
			word2 = *(ulong *)addr2;
348049cc:	059a3000 	ldreq	r3, [sl]
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
		ulong word1, word2;
		if (size == 4) {
348049d0:	0a000004 	beq	348049e8 <do_mem_cmp+0xbc>
			word1 = *(ulong *)addr1;
			word2 = *(ulong *)addr2;
		} else if (size == 2) {
348049d4:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
348049d8:	01d720b0 	ldrheq	r2, [r7]
			word2 = *(ushort *)addr2;
348049dc:	01da30b0 	ldrheq	r3, [sl]
		} else {
			word1 = *(u_char *)addr1;
348049e0:	15d72000 	ldrbne	r2, [r7]
			word2 = *(u_char *)addr2;
348049e4:	15da3000 	ldrbne	r3, [sl]
		}
		if (word1 != word2) {
348049e8:	e1520003 	cmp	r2, r3
348049ec:	0a00000a 	beq	34804a1c <do_mem_cmp+0xf0>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
348049f0:	e58d2000 	str	r2, [sp]
348049f4:	e58d3010 	str	r3, [sp, #16]
348049f8:	e59f0060 	ldr	r0, [pc, #96]	; 34804a60 <do_mem_cmp+0x134>
348049fc:	e1a03006 	mov	r3, r6
34804a00:	e1a01004 	mov	r1, r4
34804a04:	e1a02007 	mov	r2, r7
34804a08:	e58d600c 	str	r6, [sp, #12]
34804a0c:	e98d0410 	stmib	sp, {r4, sl}
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
34804a10:	e3a06001 	mov	r6, #1
		} else {
			word1 = *(u_char *)addr1;
			word2 = *(u_char *)addr2;
		}
		if (word1 != word2) {
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804a14:	eb00142b 	bl	34809ac8 <printf>
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
			break;
34804a18:	ea000005 	b	34804a34 <do_mem_cmp+0x108>
		}

		addr1 += size;
34804a1c:	e0877006 	add	r7, r7, r6
34804a20:	e08aa006 	add	sl, sl, r6
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
34804a24:	e2855001 	add	r5, r5, #1
34804a28:	e1550000 	cmp	r5, r0
34804a2c:	3affffe4 	bcc	348049c4 <do_mem_cmp+0x98>

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
34804a30:	e3a06000 	mov	r6, #0
		/* reset watchdog from time to time */
		if ((ngood % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}

	printf("Total of %ld %s(s) were the same\n", ngood, type);
34804a34:	e59f0028 	ldr	r0, [pc, #40]	; 34804a64 <do_mem_cmp+0x138>
34804a38:	e1a01005 	mov	r1, r5
34804a3c:	e1a02004 	mov	r2, r4
34804a40:	eb001420 	bl	34809ac8 <printf>
	return rcode;
}
34804a44:	e1a00006 	mov	r0, r6
34804a48:	e28dd018 	add	sp, sp, #24
34804a4c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804a50:	34823d6f 	.word	0x34823d6f
34804a54:	34823d6b 	.word	0x34823d6b
34804a58:	34823d66 	.word	0x34823d66
34804a5c:	348299f8 	.word	0x348299f8
34804a60:	34823d74 	.word	0x34823d74
34804a64:	34823da6 	.word	0x34823da6

34804a68 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a68:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34804a6c:	e1a06003 	mov	r6, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804a70:	e2423003 	sub	r3, r2, #3
34804a74:	e3530001 	cmp	r3, #1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a78:	e1a04002 	mov	r4, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
		return CMD_RET_USAGE;
34804a7c:	83e00000 	mvnhi	r0, #0
int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804a80:	88bd84f0 	pophi	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
34804a84:	e5960000 	ldr	r0, [r6]
34804a88:	e3a01004 	mov	r1, #4
34804a8c:	eb00132f 	bl	34809750 <cmd_get_data_size>
34804a90:	e2507000 	subs	r7, r0, #0
34804a94:	da00001e 	ble	34804b14 <do_mem_mw+0xac>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804a98:	e3a01000 	mov	r1, #0
34804a9c:	e3a02010 	mov	r2, #16
34804aa0:	e5960004 	ldr	r0, [r6, #4]
34804aa4:	eb0061ce 	bl	3481d1e4 <simple_strtoul>
	addr += base_address;
34804aa8:	e59f306c 	ldr	r3, [pc, #108]	; 34804b1c <do_mem_mw+0xb4>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804aac:	e3a01000 	mov	r1, #0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804ab0:	e5935000 	ldr	r5, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804ab4:	e3a02010 	mov	r2, #16
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804ab8:	e0805005 	add	r5, r0, r5

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804abc:	e5960008 	ldr	r0, [r6, #8]
34804ac0:	eb0061c7 	bl	3481d1e4 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
34804ac4:	e3540004 	cmp	r4, #4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804ac8:	e1a0a000 	mov	sl, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
34804acc:	13a00001 	movne	r0, #1
	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
34804ad0:	1a00000c 	bne	34804b08 <do_mem_mw+0xa0>
		count = simple_strtoul(argv[3], NULL, 16);
34804ad4:	e596000c 	ldr	r0, [r6, #12]
34804ad8:	e3a01000 	mov	r1, #0
34804adc:	e3a02010 	mov	r2, #16
34804ae0:	eb0061bf 	bl	3481d1e4 <simple_strtoul>
34804ae4:	ea000007 	b	34804b08 <do_mem_mw+0xa0>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804ae8:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
34804aec:	0585a000 	streq	sl, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804af0:	0a000002 	beq	34804b00 <do_mem_mw+0x98>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
34804af4:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
34804af8:	01c5a0b0 	strheq	sl, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
34804afc:	15c5a000 	strbne	sl, [r5]
34804b00:	e0855007 	add	r5, r5, r7
34804b04:	e2400001 	sub	r0, r0, #1
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
	}

	while (count-- > 0) {
34804b08:	e3500000 	cmp	r0, #0
34804b0c:	1afffff5 	bne	34804ae8 <do_mem_mw+0x80>
34804b10:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
		return 1;
34804b14:	e3a00001 	mov	r0, #1
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
	}
	return 0;
}
34804b18:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804b1c:	348299f8 	.word	0x348299f8

34804b20 <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804b20:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804b24:	e59fa0b8 	ldr	sl, [pc, #184]	; 34804be4 <do_mem_md+0xc4>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804b28:	e1a07003 	mov	r7, r3
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
34804b2c:	e59f30b4 	ldr	r3, [pc, #180]	; 34804be8 <do_mem_md+0xc8>

	if (argc < 2)
34804b30:	e3520001 	cmp	r2, #1
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804b34:	e1a0b002 	mov	fp, r2
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804b38:	e59a6004 	ldr	r6, [sl, #4]
	size = dp_last_size;
34804b3c:	e59a4008 	ldr	r4, [sl, #8]
	length = dp_last_length;
34804b40:	e5935000 	ldr	r5, [r3]

	if (argc < 2)
		return CMD_RET_USAGE;
34804b44:	d3e00000 	mvnle	r0, #0
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2)
34804b48:	da000024 	ble	34804be0 <do_mem_md+0xc0>
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804b4c:	e2119001 	ands	r9, r1, #1
34804b50:	1a000012 	bne	34804ba0 <do_mem_md+0x80>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804b54:	e5970000 	ldr	r0, [r7]
34804b58:	e3a01004 	mov	r1, #4
34804b5c:	eb0012fb 	bl	34809750 <cmd_get_data_size>
34804b60:	e2504000 	subs	r4, r0, #0
			return 1;
34804b64:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804b68:	ba00001c 	blt	34804be0 <do_mem_md+0xc0>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804b6c:	e5970004 	ldr	r0, [r7, #4]
34804b70:	e1a01009 	mov	r1, r9
34804b74:	e3a02010 	mov	r2, #16
34804b78:	eb006199 	bl	3481d1e4 <simple_strtoul>
		addr += base_address;
34804b7c:	e59a6000 	ldr	r6, [sl]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804b80:	e35b0002 	cmp	fp, #2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
34804b84:	e0806006 	add	r6, r0, r6

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804b88:	0a000004 	beq	34804ba0 <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
34804b8c:	e5970008 	ldr	r0, [r7, #8]
34804b90:	e1a01009 	mov	r1, r9
34804b94:	e3a02010 	mov	r2, #16
34804b98:	eb006191 	bl	3481d1e4 <simple_strtoul>
34804b9c:	e1a05000 	mov	r5, r0
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804ba0:	e1a01004 	mov	r1, r4
34804ba4:	e3a00010 	mov	r0, #16
34804ba8:	eb006c89 	bl	3481fdd4 <__divsi3>
34804bac:	e1a01006 	mov	r1, r6
34804bb0:	e58d0000 	str	r0, [sp]
34804bb4:	e1a00006 	mov	r0, r6
		addr += size*length;
34804bb8:	e0266495 	mla	r6, r5, r4, r6
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804bbc:	e1a02004 	mov	r2, r4
34804bc0:	e1a03005 	mov	r3, r5
34804bc4:	eb005798 	bl	3481aa2c <print_buffer>
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804bc8:	e59f3014 	ldr	r3, [pc, #20]	; 34804be4 <do_mem_md+0xc4>
	dp_last_length = length;
34804bcc:	e59f2014 	ldr	r2, [pc, #20]	; 34804be8 <do_mem_md+0xc8>
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804bd0:	e5836004 	str	r6, [r3, #4]
	dp_last_length = length;
34804bd4:	e5825000 	str	r5, [r2]
	dp_last_size = size;
34804bd8:	e5834008 	str	r4, [r3, #8]
	return (rc);
34804bdc:	e3a00000 	mov	r0, #0
}
34804be0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34804be4:	348299f8 	.word	0x348299f8
34804be8:	3482836c 	.word	0x3482836c

34804bec <mod_mem.clone.0>:
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804bec:	e3520002 	cmp	r2, #2
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
34804bf0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34804bf4:	e1a04000 	mov	r4, r0
34804bf8:	e1a0a003 	mov	sl, r3
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
		return CMD_RET_USAGE;
34804bfc:	13e00000 	mvnne	r0, #0
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804c00:	1a000040 	bne	34804d08 <mod_mem.clone.0+0x11c>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804c04:	e59f7114 	ldr	r7, [pc, #276]	; 34804d20 <mod_mem.clone.0+0x134>
	size = mm_last_size;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804c08:	e2119001 	ands	r9, r1, #1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804c0c:	e597500c 	ldr	r5, [r7, #12]
	size = mm_last_size;
34804c10:	e5976010 	ldr	r6, [r7, #16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804c14:	1a00000b 	bne	34804c48 <mod_mem.clone.0+0x5c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804c18:	e5930000 	ldr	r0, [r3]
34804c1c:	e3a01004 	mov	r1, #4
34804c20:	eb0012ca 	bl	34809750 <cmd_get_data_size>
34804c24:	e2506000 	subs	r6, r0, #0
			return 1;
34804c28:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804c2c:	ba000035 	blt	34804d08 <mod_mem.clone.0+0x11c>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804c30:	e59a0004 	ldr	r0, [sl, #4]
34804c34:	e1a01009 	mov	r1, r9
34804c38:	e3a02010 	mov	r2, #16
34804c3c:	eb006168 	bl	3481d1e4 <simple_strtoul>
		addr += base_address;
34804c40:	e5975000 	ldr	r5, [r7]
34804c44:	e0805005 	add	r5, r0, r5
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804c48:	e59f70d4 	ldr	r7, [pc, #212]	; 34804d24 <mod_mem.clone.0+0x138>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
				addr += nbytes ? -size : size;
34804c4c:	e266a000 	rsb	sl, r6, #0
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804c50:	e28d9004 	add	r9, sp, #4

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
34804c54:	e1a01005 	mov	r1, r5
34804c58:	e59f00c8 	ldr	r0, [pc, #200]	; 34804d28 <mod_mem.clone.0+0x13c>
34804c5c:	eb001399 	bl	34809ac8 <printf>
		if (size == 4)
34804c60:	e3560004 	cmp	r6, #4
			printf(" %08x", *((uint   *)addr));
34804c64:	059f00c0 	ldreq	r0, [pc, #192]	; 34804d2c <mod_mem.clone.0+0x140>
34804c68:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
34804c6c:	0a000004 	beq	34804c84 <mod_mem.clone.0+0x98>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
34804c70:	e3560002 	cmp	r6, #2
			printf(" %04x", *((ushort *)addr));
34804c74:	059f00b4 	ldreq	r0, [pc, #180]	; 34804d30 <mod_mem.clone.0+0x144>
34804c78:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
34804c7c:	159f00b0 	ldrne	r0, [pc, #176]	; 34804d34 <mod_mem.clone.0+0x148>
34804c80:	15d51000 	ldrbne	r1, [r5]
34804c84:	eb00138f 	bl	34809ac8 <printf>

		nbytes = readline (" ? ");
34804c88:	e59f00a8 	ldr	r0, [pc, #168]	; 34804d38 <mod_mem.clone.0+0x14c>
34804c8c:	eb002642 	bl	3480e59c <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
34804c90:	e3500000 	cmp	r0, #0
34804c94:	0a000004 	beq	34804cac <mod_mem.clone.0+0xc0>
34804c98:	e3500001 	cmp	r0, #1
34804c9c:	1a000009 	bne	34804cc8 <mod_mem.clone.0+0xdc>
34804ca0:	e5d73000 	ldrb	r3, [r7]
34804ca4:	e353002d 	cmp	r3, #45	; 0x2d
34804ca8:	1a000006 	bne	34804cc8 <mod_mem.clone.0+0xdc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
34804cac:	e3540000 	cmp	r4, #0
34804cb0:	0affffe7 	beq	34804c54 <mod_mem.clone.0+0x68>
				addr += nbytes ? -size : size;
34804cb4:	e3500000 	cmp	r0, #0
34804cb8:	01a03006 	moveq	r3, r6
34804cbc:	11a0300a 	movne	r3, sl
34804cc0:	e0855003 	add	r5, r5, r3
34804cc4:	eaffffe2 	b	34804c54 <mod_mem.clone.0+0x68>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804cc8:	e59f0054 	ldr	r0, [pc, #84]	; 34804d24 <mod_mem.clone.0+0x138>
34804ccc:	e1a01009 	mov	r1, r9
34804cd0:	e3a02010 	mov	r2, #16
34804cd4:	eb006142 	bl	3481d1e4 <simple_strtoul>
			nbytes = endp - console_buffer;
			if (nbytes) {
34804cd8:	e59d3004 	ldr	r3, [sp, #4]
34804cdc:	e1530007 	cmp	r3, r7
34804ce0:	0a000009 	beq	34804d0c <mod_mem.clone.0+0x120>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804ce4:	e3560004 	cmp	r6, #4
					*((uint   *)addr) = i;
34804ce8:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804cec:	0a000002 	beq	34804cfc <mod_mem.clone.0+0x110>
					*((uint   *)addr) = i;
				else if (size == 2)
34804cf0:	e3560002 	cmp	r6, #2
					*((ushort *)addr) = i;
34804cf4:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
34804cf8:	15c50000 	strbne	r0, [r5]
				if (incrflag)
34804cfc:	e3540000 	cmp	r4, #0
					addr += size;
34804d00:	10855006 	addne	r5, r5, r6
34804d04:	eaffffd2 	b	34804c54 <mod_mem.clone.0+0x68>
	} while (nbytes);

	mm_last_addr = addr;
	mm_last_size = size;
	return 0;
}
34804d08:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804d0c:	e59f300c 	ldr	r3, [pc, #12]	; 34804d20 <mod_mem.clone.0+0x134>
	mm_last_size = size;
	return 0;
34804d10:	e3a00000 	mov	r0, #0
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804d14:	e583500c 	str	r5, [r3, #12]
	mm_last_size = size;
34804d18:	e5836010 	str	r6, [r3, #16]
34804d1c:	eafffff9 	b	34804d08 <mod_mem.clone.0+0x11c>
34804d20:	348299f8 	.word	0x348299f8
34804d24:	3482b3dc 	.word	0x3482b3dc
34804d28:	34823dc8 	.word	0x34823dc8
34804d2c:	34827019 	.word	0x34827019
34804d30:	34823dcf 	.word	0x34823dcf
34804d34:	34823dd5 	.word	0x34823dd5
34804d38:	34823ddb 	.word	0x34823ddb

34804d3c <do_mem_nm>:
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
34804d3c:	e3a00000 	mov	r0, #0
34804d40:	eaffffa9 	b	34804bec <mod_mem.clone.0>

34804d44 <do_mem_mm>:
	return (rc);
}

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
34804d44:	e3a00001 	mov	r0, #1
34804d48:	eaffffa7 	b	34804bec <mod_mem.clone.0>

34804d4c <do_mmcops>:

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
34804d4c:	e3520001 	cmp	r2, #1
	"display MMC info",
	"- dislay info of the current MMC device"
);

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804d50:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34804d54:	e1a07002 	mov	r7, r2
34804d58:	e1a04003 	mov	r4, r3
	enum mmc_state state;

	if (argc < 2)
34804d5c:	da0000eb 	ble	34805110 <do_mmcops+0x3c4>
		return CMD_RET_USAGE;

	if (curr_device < 0) {
34804d60:	e59f53b4 	ldr	r5, [pc, #948]	; 3480511c <do_mmcops+0x3d0>
34804d64:	e5953000 	ldr	r3, [r5]
34804d68:	e3530000 	cmp	r3, #0
34804d6c:	aa000005 	bge	34804d88 <do_mmcops+0x3c>
		if (get_mmc_num() > 0)
34804d70:	eb003779 	bl	34812b5c <get_mmc_num>
34804d74:	e3500000 	cmp	r0, #0
			curr_device = 0;
34804d78:	c3a03000 	movgt	r3, #0
34804d7c:	c5853000 	strgt	r3, [r5]
		else {
			puts("No MMC device available\n");
34804d80:	d59f0398 	ldrle	r0, [pc, #920]	; 34805120 <do_mmcops+0x3d4>

	if (argc < 2)
		return CMD_RET_USAGE;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34804d84:	da000027 	ble	34804e28 <do_mmcops+0xdc>
			puts("No MMC device available\n");
			return 1;
		}
	}

	if (strcmp(argv[1], "rescan") == 0) {
34804d88:	e5940004 	ldr	r0, [r4, #4]
34804d8c:	e59f1390 	ldr	r1, [pc, #912]	; 34805124 <do_mmcops+0x3d8>
34804d90:	eb005d4c 	bl	3481c2c8 <strcmp>
34804d94:	e2505000 	subs	r5, r0, #0
34804d98:	1a000009 	bne	34804dc4 <do_mmcops+0x78>
		struct mmc *mmc = find_mmc_device(curr_device);
34804d9c:	e59f4378 	ldr	r4, [pc, #888]	; 3480511c <do_mmcops+0x3d0>
34804da0:	e5940000 	ldr	r0, [r4]
34804da4:	eb003230 	bl	3481166c <find_mmc_device>

		if (!mmc) {
34804da8:	e2503000 	subs	r3, r0, #0
34804dac:	0a00000f 	beq	34804df0 <do_mmcops+0xa4>
			printf("no mmc device at slot %x\n", curr_device);
			return 1;
		}

		mmc->has_init = 0;
34804db0:	e5835034 	str	r5, [r3, #52]	; 0x34

		if (mmc_init(mmc))
34804db4:	eb00370b 	bl	348129e8 <mmc_init>
int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
		return CMD_RET_USAGE;
34804db8:	e2505000 	subs	r5, r0, #0
34804dbc:	13a05001 	movne	r5, #1
34804dc0:	ea0000d3 	b	34805114 <do_mmcops+0x3c8>

		if (mmc_init(mmc))
			return 1;
		else
			return 0;
	} else if (strncmp(argv[1], "part", 4) == 0) {
34804dc4:	e5940004 	ldr	r0, [r4, #4]
34804dc8:	e59f1358 	ldr	r1, [pc, #856]	; 34805128 <do_mmcops+0x3dc>
34804dcc:	e3a02004 	mov	r2, #4
34804dd0:	eb005d48 	bl	3481c2f8 <strncmp>
34804dd4:	e2505000 	subs	r5, r0, #0
34804dd8:	1a000014 	bne	34804e30 <do_mmcops+0xe4>
		block_dev_desc_t *mmc_dev;
		struct mmc *mmc = find_mmc_device(curr_device);
34804ddc:	e59f4338 	ldr	r4, [pc, #824]	; 3480511c <do_mmcops+0x3d0>
34804de0:	e5940000 	ldr	r0, [r4]
34804de4:	eb003220 	bl	3481166c <find_mmc_device>

		if (!mmc) {
34804de8:	e3500000 	cmp	r0, #0
34804dec:	1a000002 	bne	34804dfc <do_mmcops+0xb0>
			printf("no mmc device at slot %x\n", curr_device);
34804df0:	e59f0334 	ldr	r0, [pc, #820]	; 3480512c <do_mmcops+0x3e0>
34804df4:	e5941000 	ldr	r1, [r4]
34804df8:	ea000092 	b	34805048 <do_mmcops+0x2fc>
			return 1;
		}
		mmc_init(mmc);
34804dfc:	eb0036f9 	bl	348129e8 <mmc_init>
		mmc_dev = mmc_get_dev(curr_device);
34804e00:	e5940000 	ldr	r0, [r4]
34804e04:	eb00372f 	bl	34812ac8 <mmc_get_dev>
		if (mmc_dev != NULL &&
34804e08:	e2503000 	subs	r3, r0, #0
34804e0c:	0a000004 	beq	34804e24 <do_mmcops+0xd8>
34804e10:	e5d3300b 	ldrb	r3, [r3, #11]
34804e14:	e35300ff 	cmp	r3, #255	; 0xff
34804e18:	0a000001 	beq	34804e24 <do_mmcops+0xd8>
				mmc_dev->type != DEV_TYPE_UNKNOWN) {
			print_part(mmc_dev);
34804e1c:	eb002b41 	bl	3480fb28 <print_part>
			return 0;
34804e20:	ea0000bb 	b	34805114 <do_mmcops+0x3c8>
		}

		puts("get mmc type error!\n");
34804e24:	e59f0304 	ldr	r0, [pc, #772]	; 34805130 <do_mmcops+0x3e4>
34804e28:	eb00131c 	bl	34809aa0 <puts>
34804e2c:	ea000086 	b	3480504c <do_mmcops+0x300>
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
34804e30:	e5940004 	ldr	r0, [r4, #4]
34804e34:	e59f12f8 	ldr	r1, [pc, #760]	; 34805134 <do_mmcops+0x3e8>
34804e38:	eb005d22 	bl	3481c2c8 <strcmp>
34804e3c:	e2505000 	subs	r5, r0, #0
34804e40:	1a000002 	bne	34804e50 <do_mmcops+0x104>
		print_mmc_devices('\n');
34804e44:	e280000a 	add	r0, r0, #10
34804e48:	eb00372a 	bl	34812af8 <print_mmc_devices>
		return 0;
34804e4c:	ea0000b0 	b	34805114 <do_mmcops+0x3c8>
	} else if (strcmp(argv[1], "dev") == 0) {
34804e50:	e5940004 	ldr	r0, [r4, #4]
34804e54:	e59f12dc 	ldr	r1, [pc, #732]	; 34805138 <do_mmcops+0x3ec>
34804e58:	eb005d1a 	bl	3481c2c8 <strcmp>
34804e5c:	e2505000 	subs	r5, r0, #0
34804e60:	1a000048 	bne	34804f88 <do_mmcops+0x23c>
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804e64:	e3570002 	cmp	r7, #2
			dev = curr_device;
34804e68:	059f32ac 	ldreq	r3, [pc, #684]	; 3480511c <do_mmcops+0x3d0>
34804e6c:	05934000 	ldreq	r4, [r3]
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804e70:	0a000006 	beq	34804e90 <do_mmcops+0x144>
			dev = curr_device;
		else if (argc == 3)
34804e74:	e3570003 	cmp	r7, #3
34804e78:	1a000006 	bne	34804e98 <do_mmcops+0x14c>
			dev = simple_strtoul(argv[2], NULL, 10);
34804e7c:	e5940008 	ldr	r0, [r4, #8]
34804e80:	e1a01005 	mov	r1, r5
34804e84:	e3a0200a 	mov	r2, #10
34804e88:	eb0060d5 	bl	3481d1e4 <simple_strtoul>
34804e8c:	e1a04000 	mov	r4, r0
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
		print_mmc_devices('\n');
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
34804e90:	e3e07000 	mvn	r7, #0
34804e94:	ea000010 	b	34804edc <do_mmcops+0x190>

		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
34804e98:	e3570004 	cmp	r7, #4
34804e9c:	1a00009b 	bne	34805110 <do_mmcops+0x3c4>
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804ea0:	e1a01005 	mov	r1, r5
34804ea4:	e3a0200a 	mov	r2, #10
34804ea8:	e5940008 	ldr	r0, [r4, #8]
34804eac:	eb0060cc 	bl	3481d1e4 <simple_strtoul>
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804eb0:	e1a01005 	mov	r1, r5
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804eb4:	e1a06000 	mov	r6, r0
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804eb8:	e3a0200a 	mov	r2, #10
34804ebc:	e594000c 	ldr	r0, [r4, #12]
34804ec0:	eb0060c7 	bl	3481d1e4 <simple_strtoul>
			if (part > PART_ACCESS_MASK) {
34804ec4:	e3500007 	cmp	r0, #7
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804ec8:	e1a07000 	mov	r7, r0
			if (part > PART_ACCESS_MASK) {
				printf("#part_num shouldn't be larger"
34804ecc:	c3a01007 	movgt	r1, #7
34804ed0:	c59f0264 	ldrgt	r0, [pc, #612]	; 3480513c <do_mmcops+0x3f0>
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
			if (part > PART_ACCESS_MASK) {
34804ed4:	ca00005b 	bgt	34805048 <do_mmcops+0x2fc>
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804ed8:	e1a04006 	mov	r4, r6
				return 1;
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
34804edc:	e1a00004 	mov	r0, r4
34804ee0:	eb0031e1 	bl	3481166c <find_mmc_device>
		if (!mmc) {
34804ee4:	e2505000 	subs	r5, r0, #0
			printf("no mmc device at slot %x\n", dev);
34804ee8:	059f023c 	ldreq	r0, [pc, #572]	; 3480512c <do_mmcops+0x3e0>
34804eec:	01a01004 	moveq	r1, r4
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
		if (!mmc) {
34804ef0:	0a000054 	beq	34805048 <do_mmcops+0x2fc>
			printf("no mmc device at slot %x\n", dev);
			return 1;
		}

		mmc_init(mmc);
34804ef4:	eb0036bb 	bl	348129e8 <mmc_init>
		if (part != -1) {
34804ef8:	e3770001 	cmn	r7, #1
34804efc:	0a000012 	beq	34804f4c <do_mmcops+0x200>
			int ret;
			if (mmc->part_config == MMCPART_NOAVAILABLE) {
34804f00:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804f04:	e35300ff 	cmp	r3, #255	; 0xff
34804f08:	1a000002 	bne	34804f18 <do_mmcops+0x1cc>
				printf("Card doesn't support part_switch\n");
34804f0c:	e59f022c 	ldr	r0, [pc, #556]	; 34805140 <do_mmcops+0x3f4>
34804f10:	eb0012ec 	bl	34809ac8 <printf>
34804f14:	ea00004c 	b	3480504c <do_mmcops+0x300>
				return 1;
			}

			if (part != mmc->part_num) {
34804f18:	e5d53083 	ldrb	r3, [r5, #131]	; 0x83
34804f1c:	e1570003 	cmp	r7, r3
34804f20:	0a000009 	beq	34804f4c <do_mmcops+0x200>
				ret = mmc_switch_part(dev, part);
34804f24:	e1a01007 	mov	r1, r7
34804f28:	e1a00004 	mov	r0, r4
34804f2c:	eb00340a 	bl	34811f5c <mmc_switch_part>
				if (!ret)
34804f30:	e3500000 	cmp	r0, #0
					mmc->part_num = part;
34804f34:	05c57083 	strbeq	r7, [r5, #131]	; 0x83

				printf("switch to partions #%d, %s\n",
34804f38:	059f2204 	ldreq	r2, [pc, #516]	; 34805144 <do_mmcops+0x3f8>
34804f3c:	159f2204 	ldrne	r2, [pc, #516]	; 34805148 <do_mmcops+0x3fc>
34804f40:	e59f0204 	ldr	r0, [pc, #516]	; 3480514c <do_mmcops+0x400>
34804f44:	e1a01007 	mov	r1, r7
34804f48:	eb0012de 	bl	34809ac8 <printf>
						part, (!ret) ? "OK" : "ERROR");
			}
		}
		curr_device = dev;
34804f4c:	e59f31c8 	ldr	r3, [pc, #456]	; 3480511c <do_mmcops+0x3d0>
34804f50:	e5834000 	str	r4, [r3]
		if (mmc->part_config == MMCPART_NOAVAILABLE)
34804f54:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804f58:	e35300ff 	cmp	r3, #255	; 0xff
34804f5c:	1a000003 	bne	34804f70 <do_mmcops+0x224>
			printf("mmc%d is current device\n", curr_device);
34804f60:	e1a01004 	mov	r1, r4
34804f64:	e59f01e4 	ldr	r0, [pc, #484]	; 34805150 <do_mmcops+0x404>
34804f68:	eb0012d6 	bl	34809ac8 <printf>
34804f6c:	ea000003 	b	34804f80 <do_mmcops+0x234>
		else
			printf("mmc%d(part %d) is current device\n",
34804f70:	e59f01dc 	ldr	r0, [pc, #476]	; 34805154 <do_mmcops+0x408>
34804f74:	e1a01004 	mov	r1, r4
34804f78:	e5d52083 	ldrb	r2, [r5, #131]	; 0x83
34804f7c:	eb0012d1 	bl	34809ac8 <printf>
				curr_device, mmc->part_num);

		return 0;
34804f80:	e3a05000 	mov	r5, #0
34804f84:	ea000062 	b	34805114 <do_mmcops+0x3c8>
	}

	if (strcmp(argv[1], "read") == 0)
34804f88:	e5940004 	ldr	r0, [r4, #4]
34804f8c:	e59f11c4 	ldr	r1, [pc, #452]	; 34805158 <do_mmcops+0x40c>
34804f90:	eb005ccc 	bl	3481c2c8 <strcmp>
34804f94:	e3500000 	cmp	r0, #0
		state = MMC_READ;
34804f98:	03a06001 	moveq	r6, #1
				curr_device, mmc->part_num);

		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
34804f9c:	0a00000b 	beq	34804fd0 <do_mmcops+0x284>
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804fa0:	e5940004 	ldr	r0, [r4, #4]
34804fa4:	e59f11b0 	ldr	r1, [pc, #432]	; 3480515c <do_mmcops+0x410>
34804fa8:	eb005cc6 	bl	3481c2c8 <strcmp>
34804fac:	e3500000 	cmp	r0, #0
		state = MMC_WRITE;
34804fb0:	03a06002 	moveq	r6, #2
		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804fb4:	0a000005 	beq	34804fd0 <do_mmcops+0x284>
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
34804fb8:	e5940004 	ldr	r0, [r4, #4]
34804fbc:	e59f119c 	ldr	r1, [pc, #412]	; 34805160 <do_mmcops+0x414>
34804fc0:	eb005cc0 	bl	3481c2c8 <strcmp>
34804fc4:	e3500000 	cmp	r0, #0
		state = MMC_ERASE;
34804fc8:	03a06003 	moveq	r6, #3

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
34804fcc:	1a00004f 	bne	34805110 <do_mmcops+0x3c4>
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804fd0:	e59f3144 	ldr	r3, [pc, #324]	; 3480511c <do_mmcops+0x3d0>
34804fd4:	e5930000 	ldr	r0, [r3]
34804fd8:	eb0031a3 	bl	3481166c <find_mmc_device>
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
34804fdc:	e3560003 	cmp	r6, #3
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804fe0:	e1a07000 	mov	r7, r0

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
34804fe4:	03a0b000 	moveq	fp, #0
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
		int idx = 2;
34804fe8:	03a05002 	moveq	r5, #2
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
34804fec:	0a000005 	beq	34805008 <do_mmcops+0x2bc>
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804ff0:	e5940008 	ldr	r0, [r4, #8]
34804ff4:	e3a01000 	mov	r1, #0
34804ff8:	e3a02010 	mov	r2, #16
34804ffc:	eb006078 	bl	3481d1e4 <simple_strtoul>
			++idx;
34805000:	e3a05003 	mov	r5, #3
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34805004:	e1a0b000 	mov	fp, r0
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
34805008:	e7940105 	ldr	r0, [r4, r5, lsl #2]
3480500c:	e3a01000 	mov	r1, #0
34805010:	e3a02010 	mov	r2, #16
34805014:	eb006072 	bl	3481d1e4 <simple_strtoul>
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805018:	e2855001 	add	r5, r5, #1
		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
3480501c:	e1a09000 	mov	r9, r0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805020:	e3a01000 	mov	r1, #0
34805024:	e7940105 	ldr	r0, [r4, r5, lsl #2]
34805028:	e3a02010 	mov	r2, #16
3480502c:	eb00606c 	bl	3481d1e4 <simple_strtoul>

		if (!mmc) {
34805030:	e3570000 	cmp	r7, #0
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805034:	e1a05000 	mov	r5, r0
34805038:	e59fa0dc 	ldr	sl, [pc, #220]	; 3480511c <do_mmcops+0x3d0>

		if (!mmc) {
3480503c:	1a000004 	bne	34805054 <do_mmcops+0x308>
			printf("no mmc device at slot %x\n", curr_device);
34805040:	e59f00e4 	ldr	r0, [pc, #228]	; 3480512c <do_mmcops+0x3e0>
34805044:	e59a1000 	ldr	r1, [sl]
34805048:	eb00129e 	bl	34809ac8 <printf>
			return 1;
3480504c:	e3a05001 	mov	r5, #1
34805050:	ea00002f 	b	34805114 <do_mmcops+0x3c8>
		}

		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
34805054:	e58d0000 	str	r0, [sp]
34805058:	e5941004 	ldr	r1, [r4, #4]
3480505c:	e59a2000 	ldr	r2, [sl]
34805060:	e1a03009 	mov	r3, r9
34805064:	e59f00f8 	ldr	r0, [pc, #248]	; 34805164 <do_mmcops+0x418>
34805068:	eb001296 	bl	34809ac8 <printf>
				argv[1], curr_device, blk, cnt);

		mmc_init(mmc);
3480506c:	e1a00007 	mov	r0, r7
34805070:	eb00365c 	bl	348129e8 <mmc_init>

		switch (state) {
34805074:	e3560002 	cmp	r6, #2
34805078:	0a00000c 	beq	348050b0 <do_mmcops+0x364>
3480507c:	e3560003 	cmp	r6, #3
34805080:	0a000011 	beq	348050cc <do_mmcops+0x380>
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34805084:	e1a01009 	mov	r1, r9
34805088:	e597c100 	ldr	ip, [r7, #256]	; 0x100
3480508c:	e59a0000 	ldr	r0, [sl]
34805090:	e1a02005 	mov	r2, r5
34805094:	e1a0300b 	mov	r3, fp
34805098:	e12fff3c 	blx	ip
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
3480509c:	e1a01485 	lsl	r1, r5, #9

		mmc_init(mmc);

		switch (state) {
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
348050a0:	e1a06000 	mov	r6, r0
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
348050a4:	e1a0000b 	mov	r0, fp
348050a8:	ebfff006 	bl	348010c8 <flush_cache>
			break;
348050ac:	ea00000c 	b	348050e4 <do_mmcops+0x398>
		case MMC_WRITE:
			n = mmc->block_dev.block_write(curr_device, blk,
348050b0:	e597c104 	ldr	ip, [r7, #260]	; 0x104
348050b4:	e59a0000 	ldr	r0, [sl]
348050b8:	e1a01009 	mov	r1, r9
348050bc:	e1a02005 	mov	r2, r5
348050c0:	e1a0300b 	mov	r3, fp
348050c4:	e12fff3c 	blx	ip
348050c8:	ea000004 	b	348050e0 <do_mmcops+0x394>
						      cnt, addr);
			break;
		case MMC_ERASE:
			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
348050cc:	e5973108 	ldr	r3, [r7, #264]	; 0x108
348050d0:	e59a0000 	ldr	r0, [sl]
348050d4:	e1a01009 	mov	r1, r9
348050d8:	e1a02005 	mov	r2, r5
348050dc:	e12fff33 	blx	r3
348050e0:	e1a06000 	mov	r6, r0
			break;
		default:
			BUG();
		}

		printf("%d blocks %s: %s\n",
348050e4:	e59fc05c 	ldr	ip, [pc, #92]	; 34805148 <do_mmcops+0x3fc>
348050e8:	e1560005 	cmp	r6, r5
348050ec:	e59f3050 	ldr	r3, [pc, #80]	; 34805144 <do_mmcops+0x3f8>
348050f0:	e59f0070 	ldr	r0, [pc, #112]	; 34805168 <do_mmcops+0x41c>
348050f4:	11a0300c 	movne	r3, ip
348050f8:	e1a01006 	mov	r1, r6
348050fc:	e5942004 	ldr	r2, [r4, #4]
34805100:	eb001270 	bl	34809ac8 <printf>
				n, argv[1], (n == cnt) ? "OK" : "ERROR");
		return (n == cnt) ? 0 : 1;
34805104:	e0565005 	subs	r5, r6, r5
34805108:	13a05001 	movne	r5, #1
3480510c:	ea000000 	b	34805114 <do_mmcops+0x3c8>
	}

	return CMD_RET_USAGE;
34805110:	e3e05000 	mvn	r5, #0
}
34805114:	e1a00005 	mov	r0, r5
34805118:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480511c:	34828370 	.word	0x34828370
34805120:	3482409a 	.word	0x3482409a
34805124:	348240b3 	.word	0x348240b3
34805128:	34824b50 	.word	0x34824b50
3480512c:	348240ba 	.word	0x348240ba
34805130:	348240d4 	.word	0x348240d4
34805134:	348240e9 	.word	0x348240e9
34805138:	348240ee 	.word	0x348240ee
3480513c:	348240f2 	.word	0x348240f2
34805140:	34824119 	.word	0x34824119
34805144:	34824091 	.word	0x34824091
34805148:	34824094 	.word	0x34824094
3480514c:	3482413b 	.word	0x3482413b
34805150:	34824157 	.word	0x34824157
34805154:	34824170 	.word	0x34824170
34805158:	34824192 	.word	0x34824192
3480515c:	34824197 	.word	0x34824197
34805160:	3482419d 	.word	0x3482419d
34805164:	348241a3 	.word	0x348241a3
34805168:	348241d0 	.word	0x348241d0

3480516c <do_mmcinfo>:

	printf("Bus Width: %d-bit\n", mmc->bus_width);
}

int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480516c:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	struct mmc *mmc;

	if (curr_device < 0) {
34805170:	e59f4128 	ldr	r4, [pc, #296]	; 348052a0 <do_mmcinfo+0x134>
34805174:	e5943000 	ldr	r3, [r4]
34805178:	e3530000 	cmp	r3, #0
3480517c:	aa000007 	bge	348051a0 <do_mmcinfo+0x34>
		if (get_mmc_num() > 0)
34805180:	eb003675 	bl	34812b5c <get_mmc_num>
34805184:	e3500000 	cmp	r0, #0
			curr_device = 0;
34805188:	c3a03000 	movgt	r3, #0
3480518c:	c5843000 	strgt	r3, [r4]
int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	struct mmc *mmc;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34805190:	ca000002 	bgt	348051a0 <do_mmcinfo+0x34>
			curr_device = 0;
		else {
			puts("No MMC device available\n");
34805194:	e59f0108 	ldr	r0, [pc, #264]	; 348052a4 <do_mmcinfo+0x138>
34805198:	eb001240 	bl	34809aa0 <puts>
3480519c:	ea00003d 	b	34805298 <do_mmcinfo+0x12c>
			return 1;
		}
	}

	mmc = find_mmc_device(curr_device);
348051a0:	e59f50f8 	ldr	r5, [pc, #248]	; 348052a0 <do_mmcinfo+0x134>
348051a4:	e5950000 	ldr	r0, [r5]
348051a8:	eb00312f 	bl	3481166c <find_mmc_device>

	if (mmc) {
348051ac:	e2504000 	subs	r4, r0, #0
348051b0:	0a000035 	beq	3480528c <do_mmcinfo+0x120>
		mmc_init(mmc);
348051b4:	eb00360b 	bl	348129e8 <mmc_init>
	MMC_WRITE,
	MMC_ERASE,
};
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
348051b8:	e2841008 	add	r1, r4, #8
348051bc:	e59f00e4 	ldr	r0, [pc, #228]	; 348052a8 <do_mmcinfo+0x13c>
348051c0:	eb001240 	bl	34809ac8 <printf>
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
348051c4:	e5d41073 	ldrb	r1, [r4, #115]	; 0x73
348051c8:	e59f00dc 	ldr	r0, [pc, #220]	; 348052ac <do_mmcinfo+0x140>
348051cc:	eb00123d 	bl	34809ac8 <printf>
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
348051d0:	e5941070 	ldr	r1, [r4, #112]	; 0x70
348051d4:	e59f00d4 	ldr	r0, [pc, #212]	; 348052b0 <do_mmcinfo+0x144>
348051d8:	e7ef1451 	ubfx	r1, r1, #8, #16
348051dc:	eb001239 	bl	34809ac8 <printf>
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
348051e0:	e5943074 	ldr	r3, [r4, #116]	; 0x74
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
348051e4:	e5d41070 	ldrb	r1, [r4, #112]	; 0x70
348051e8:	e7e72453 	ubfx	r2, r3, #8, #8
348051ec:	e58d2000 	str	r2, [sp]
348051f0:	e20320ff 	and	r2, r3, #255	; 0xff
348051f4:	e58d2004 	str	r2, [sp, #4]
348051f8:	e59f00b4 	ldr	r0, [pc, #180]	; 348052b4 <do_mmcinfo+0x148>
348051fc:	e1a02c23 	lsr	r2, r3, #24
34805200:	e7e73853 	ubfx	r3, r3, #16, #8
34805204:	eb00122f 	bl	34809ac8 <printf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n", mmc->tran_speed);
34805208:	e5941084 	ldr	r1, [r4, #132]	; 0x84
3480520c:	e59f00a4 	ldr	r0, [pc, #164]	; 348052b8 <do_mmcinfo+0x14c>
34805210:	eb00122c 	bl	34809ac8 <printf>
	printf("Rd Block Len: %d\n", mmc->read_bl_len);
34805214:	e5941088 	ldr	r1, [r4, #136]	; 0x88
34805218:	e59f009c 	ldr	r0, [pc, #156]	; 348052bc <do_mmcinfo+0x150>
3480521c:	eb001229 	bl	34809ac8 <printf>

	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
34805220:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34805224:	e59f2094 	ldr	r2, [pc, #148]	; 348052c0 <do_mmcinfo+0x154>
34805228:	e59f1094 	ldr	r1, [pc, #148]	; 348052c4 <do_mmcinfo+0x158>
3480522c:	e3130802 	tst	r3, #131072	; 0x20000
34805230:	11a01002 	movne	r1, r2
34805234:	e59f008c 	ldr	r0, [pc, #140]	; 348052c8 <do_mmcinfo+0x15c>
34805238:	e7e32253 	ubfx	r2, r3, #4, #4
3480523c:	e203300f 	and	r3, r3, #15
34805240:	eb001220 	bl	34809ac8 <printf>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
34805244:	e5941040 	ldr	r1, [r4, #64]	; 0x40
34805248:	e59f307c 	ldr	r3, [pc, #124]	; 348052cc <do_mmcinfo+0x160>
3480524c:	e59f207c 	ldr	r2, [pc, #124]	; 348052d0 <do_mmcinfo+0x164>
34805250:	e3510000 	cmp	r1, #0
34805254:	01a01002 	moveq	r1, r2
34805258:	11a01003 	movne	r1, r3
3480525c:	e59f0070 	ldr	r0, [pc, #112]	; 348052d4 <do_mmcinfo+0x168>
34805260:	eb001218 	bl	34809ac8 <printf>
	puts("Capacity: ");
34805264:	e59f006c 	ldr	r0, [pc, #108]	; 348052d8 <do_mmcinfo+0x16c>
34805268:	eb00120c 	bl	34809aa0 <puts>
	print_size(mmc->capacity, "\n");
3480526c:	e1c409d8 	ldrd	r0, [r4, #152]	; 0x98
34805270:	e59f2064 	ldr	r2, [pc, #100]	; 348052dc <do_mmcinfo+0x170>
34805274:	eb0055a1 	bl	3481a900 <print_size>

	printf("Bus Width: %d-bit\n", mmc->bus_width);
34805278:	e59f0060 	ldr	r0, [pc, #96]	; 348052e0 <do_mmcinfo+0x174>
3480527c:	e5941044 	ldr	r1, [r4, #68]	; 0x44
34805280:	eb001210 	bl	34809ac8 <printf>

	if (mmc) {
		mmc_init(mmc);

		print_mmcinfo(mmc);
		return 0;
34805284:	e3a00000 	mov	r0, #0
34805288:	ea000003 	b	3480529c <do_mmcinfo+0x130>
	} else {
		printf("no mmc device at slot %x\n", curr_device);
3480528c:	e59f0050 	ldr	r0, [pc, #80]	; 348052e4 <do_mmcinfo+0x178>
34805290:	e5951000 	ldr	r1, [r5]
34805294:	eb00120b 	bl	34809ac8 <printf>
		return 1;
34805298:	e3a00001 	mov	r0, #1
	}
}
3480529c:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
348052a0:	34828370 	.word	0x34828370
348052a4:	3482409a 	.word	0x3482409a
348052a8:	348241ed 	.word	0x348241ed
348052ac:	348241f9 	.word	0x348241f9
348052b0:	3482420e 	.word	0x3482420e
348052b4:	34824217 	.word	0x34824217
348052b8:	3482422a 	.word	0x3482422a
348052bc:	3482423a 	.word	0x3482423a
348052c0:	34826842 	.word	0x34826842
348052c4:	348241e2 	.word	0x348241e2
348052c8:	3482424c 	.word	0x3482424c
348052cc:	348241e6 	.word	0x348241e6
348052d0:	348241ea 	.word	0x348241ea
348052d4:	3482425e 	.word	0x3482425e
348052d8:	34824271 	.word	0x34824271
348052dc:	34826197 	.word	0x34826197
348052e0:	3482427c 	.word	0x3482427c
348052e4:	348240ba 	.word	0x348240ba

348052e8 <mtd_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* mtd_part_info(struct mtd_device *dev, unsigned int part_num)
{
348052e8:	e92d4007 	push	{r0, r1, r2, lr}
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
348052ec:	e3500000 	cmp	r0, #0
348052f0:	0a00001c 	beq	34805368 <mtd_part_info+0x80>

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
348052f4:	e1d030bc 	ldrh	r3, [r0, #12]
348052f8:	e1510003 	cmp	r1, r3
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
348052fc:	31a0c000 	movcc	ip, r0
34805300:	35bc3010 	ldrcc	r3, [ip, #16]!
				dev->id->num, dev->id->mtd_id);
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
34805304:	33a02000 	movcc	r2, #0

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
34805308:	3a000013 	bcc	3480535c <mtd_part_info+0x74>
		printf("invalid partition number %d for device %s%d (%s)\n",
				part_num, MTD_DEV_TYPE(dev->id->type),
3480530c:	e5900008 	ldr	r0, [r0, #8]
34805310:	e5d03008 	ldrb	r3, [r0, #8]
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
34805314:	e3530002 	cmp	r3, #2
34805318:	059f204c 	ldreq	r2, [pc, #76]	; 3480536c <mtd_part_info+0x84>
3480531c:	0a000003 	beq	34805330 <mtd_part_info+0x48>
				part_num, MTD_DEV_TYPE(dev->id->type),
34805320:	e59fc048 	ldr	ip, [pc, #72]	; 34805370 <mtd_part_info+0x88>
34805324:	e3530004 	cmp	r3, #4
34805328:	e59f2044 	ldr	r2, [pc, #68]	; 34805374 <mtd_part_info+0x8c>
3480532c:	11a0200c 	movne	r2, ip
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
34805330:	e5d03009 	ldrb	r3, [r0, #9]
34805334:	e5900010 	ldr	r0, [r0, #16]
34805338:	e58d0000 	str	r0, [sp]
3480533c:	e59f0034 	ldr	r0, [pc, #52]	; 34805378 <mtd_part_info+0x90>
34805340:	eb0011e0 	bl	34809ac8 <printf>
34805344:	ea000006 	b	34805364 <mtd_part_info+0x7c>
	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805348:	e1510002 	cmp	r1, r2
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);
3480534c:	e1a00003 	mov	r0, r3

		if (part_num == num++) {
34805350:	0a000004 	beq	34805368 <mtd_part_info+0x80>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
34805354:	e5933000 	ldr	r3, [r3]
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805358:	e2822001 	add	r2, r2, #1
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
3480535c:	e153000c 	cmp	r3, ip
34805360:	1afffff8 	bne	34805348 <mtd_part_info+0x60>
		if (part_num == num++) {
			return part;
		}
	}

	return NULL;
34805364:	e3a00000 	mov	r0, #0
}
34805368:	e8bd800e 	pop	{r1, r2, r3, pc}
3480536c:	3482479d 	.word	0x3482479d
34805370:	348243cc 	.word	0x348243cc
34805374:	3482479a 	.word	0x3482479a
34805378:	348243d0 	.word	0x348243d0

3480537c <index_partitions>:
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
3480537c:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34805380:	e59f10a0 	ldr	r1, [pc, #160]	; 34805428 <index_partitions+0xac>
34805384:	e5914000 	ldr	r4, [r1]
34805388:	e3540000 	cmp	r4, #0
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
3480538c:	15b13004 	ldrne	r3, [r1, #4]!
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
34805390:	13a02000 	movne	r2, #0
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34805394:	1a000012 	bne	348053e4 <index_partitions+0x68>
34805398:	ea00001b 	b	3480540c <index_partitions+0x90>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
3480539c:	e1530004 	cmp	r3, r4
348053a0:	1a00000b 	bne	348053d4 <index_partitions+0x58>
				mtddevnum += current_mtd_partnum;
348053a4:	e59f307c 	ldr	r3, [pc, #124]	; 34805428 <index_partitions+0xac>
				sprintf(buf, "%d", mtddevnum);
348053a8:	e1a0000d 	mov	r0, sp
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
348053ac:	e5d3300c 	ldrb	r3, [r3, #12]
				sprintf(buf, "%d", mtddevnum);
348053b0:	e59f1074 	ldr	r1, [pc, #116]	; 3480542c <index_partitions+0xb0>
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
348053b4:	e0822003 	add	r2, r2, r3
				sprintf(buf, "%d", mtddevnum);
348053b8:	e6ff2072 	uxth	r2, r2
348053bc:	eb00602e 	bl	3481d47c <sprintf>
				setenv("mtddevnum", buf);
348053c0:	e1a0100d 	mov	r1, sp
348053c4:	e59f0064 	ldr	r0, [pc, #100]	; 34805430 <index_partitions+0xb4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
348053c8:	e1a0400d 	mov	r4, sp
				setenv("mtddevnum", buf);
348053cc:	eb0009c7 	bl	34807af0 <setenv>
				break;
348053d0:	ea000005 	b	348053ec <index_partitions+0x70>
			}
			mtddevnum += dev->num_parts;
348053d4:	e1d300bc 	ldrh	r0, [r3, #12]

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
348053d8:	e5933000 	ldr	r3, [r3]
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
348053dc:	e0822000 	add	r2, r2, r0
348053e0:	e6ff2072 	uxth	r2, r2

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
348053e4:	e1530001 	cmp	r3, r1
348053e8:	1affffeb 	bne	3480539c <index_partitions+0x20>
				break;
			}
			mtddevnum += dev->num_parts;
		}

		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
348053ec:	e59f3034 	ldr	r3, [pc, #52]	; 34805428 <index_partitions+0xac>
348053f0:	e5d3100c 	ldrb	r1, [r3, #12]
348053f4:	e5930000 	ldr	r0, [r3]
348053f8:	ebffffba 	bl	348052e8 <mtd_part_info>
348053fc:	e1a03000 	mov	r3, r0
		setenv("mtddevname", part->name);
34805400:	e5931008 	ldr	r1, [r3, #8]
34805404:	e59f0028 	ldr	r0, [pc, #40]	; 34805434 <index_partitions+0xb8>
34805408:	ea000004 	b	34805420 <index_partitions+0xa4>

		debug("=> mtddevnum %d,\n=> mtddevname %s\n", mtddevnum, part->name);
	} else {
		setenv("mtddevnum", NULL);
3480540c:	e1a01004 	mov	r1, r4
34805410:	e59f0018 	ldr	r0, [pc, #24]	; 34805430 <index_partitions+0xb4>
34805414:	eb0009b5 	bl	34807af0 <setenv>
		setenv("mtddevname", NULL);
34805418:	e59f0014 	ldr	r0, [pc, #20]	; 34805434 <index_partitions+0xb8>
3480541c:	e1a01004 	mov	r1, r4
34805420:	eb0009b2 	bl	34807af0 <setenv>

		debug("=> mtddevnum NULL\n=> mtddevname NULL\n");
	}
}
34805424:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
34805428:	34829a0c 	.word	0x34829a0c
3480542c:	34825a71 	.word	0x34825a71
34805430:	34824402 	.word	0x34824402
34805434:	3482440c 	.word	0x3482440c

34805438 <memsize_format>:
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34805438:	e3c13103 	bic	r3, r1, #-1073741824	; 0xc0000000
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
3480543c:	e1a02001 	mov	r2, r1
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34805440:	e3530000 	cmp	r3, #0
		sprintf(buf, "%ug", size/SIZE_GB);
34805444:	059f1030 	ldreq	r1, [pc, #48]	; 3480547c <memsize_format+0x44>
34805448:	01a02f22 	lsreq	r2, r2, #30
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
3480544c:	0a000009 	beq	34805478 <memsize_format+0x40>
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34805450:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
34805454:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
34805458:	e3530000 	cmp	r3, #0
		sprintf(buf, "%um", size/SIZE_MB);
3480545c:	059f101c 	ldreq	r1, [pc, #28]	; 34805480 <memsize_format+0x48>
34805460:	01a02a22 	lsreq	r2, r2, #20
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34805464:	0a000003 	beq	34805478 <memsize_format+0x40>
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
34805468:	e1b03b02 	lsls	r3, r2, #22
		sprintf(buf, "%uk", size/SIZE_KB);
3480546c:	059f1010 	ldreq	r1, [pc, #16]	; 34805484 <memsize_format+0x4c>
	else
		sprintf(buf, "%u", size);
34805470:	159f1010 	ldrne	r1, [pc, #16]	; 34805488 <memsize_format+0x50>
	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%uk", size/SIZE_KB);
34805474:	01a02522 	lsreq	r2, r2, #10
	else
		sprintf(buf, "%u", size);
34805478:	ea005fff 	b	3481d47c <sprintf>
3480547c:	34824417 	.word	0x34824417
34805480:	3482441b 	.word	0x3482441b
34805484:	3482441f 	.word	0x3482441f
34805488:	34824423 	.word	0x34824423

3480548c <current_save>:

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
3480548c:	e92d4030 	push	{r4, r5, lr}
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805490:	e59f508c 	ldr	r5, [pc, #140]	; 34805524 <current_save+0x98>

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
34805494:	e24dd01c 	sub	sp, sp, #28
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805498:	e5954000 	ldr	r4, [r5]
3480549c:	e3540000 	cmp	r4, #0
348054a0:	0a000018 	beq	34805508 <current_save+0x7c>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_mtd_dev->id->type),
348054a4:	e5943008 	ldr	r3, [r4, #8]
348054a8:	e5d31008 	ldrb	r1, [r3, #8]
348054ac:	e3510002 	cmp	r1, #2
348054b0:	059f2070 	ldreq	r2, [pc, #112]	; 34805528 <current_save+0x9c>
348054b4:	0a000003 	beq	348054c8 <current_save+0x3c>
348054b8:	e59f006c 	ldr	r0, [pc, #108]	; 3480552c <current_save+0xa0>
348054bc:	e3510004 	cmp	r1, #4
348054c0:	e59f2068 	ldr	r2, [pc, #104]	; 34805530 <current_save+0xa4>
348054c4:	11a02000 	movne	r2, r0
348054c8:	e59f5054 	ldr	r5, [pc, #84]	; 34805524 <current_save+0x98>
348054cc:	e28d4008 	add	r4, sp, #8
348054d0:	e5d5100c 	ldrb	r1, [r5, #12]
348054d4:	e5d33009 	ldrb	r3, [r3, #9]
348054d8:	e1a00004 	mov	r0, r4
348054dc:	e58d1000 	str	r1, [sp]
348054e0:	e59f104c 	ldr	r1, [pc, #76]	; 34805534 <current_save+0xa8>
348054e4:	eb005fe4 	bl	3481d47c <sprintf>
					current_mtd_dev->id->num, current_mtd_partnum);

		setenv("partition", buf);
348054e8:	e1a01004 	mov	r1, r4
348054ec:	e59f0044 	ldr	r0, [pc, #68]	; 34805538 <current_save+0xac>
348054f0:	eb00097e 	bl	34807af0 <setenv>
		strncpy(last_partition, buf, 16);
348054f4:	e2850010 	add	r0, r5, #16
348054f8:	e1a01004 	mov	r1, r4
348054fc:	e3a02010 	mov	r2, #16
34805500:	eb005b46 	bl	3481c220 <strncpy>
34805504:	ea000003 	b	34805518 <current_save+0x8c>

		debug("=> partition %s\n", buf);
	} else {
		setenv("partition", NULL);
34805508:	e59f0028 	ldr	r0, [pc, #40]	; 34805538 <current_save+0xac>
3480550c:	e1a01004 	mov	r1, r4
34805510:	eb000976 	bl	34807af0 <setenv>
		last_partition[0] = '\0';
34805514:	e5c54010 	strb	r4, [r5, #16]

		debug("=> partition NULL\n");
	}
	index_partitions();
34805518:	ebffff97 	bl	3480537c <index_partitions>
}
3480551c:	e28dd01c 	add	sp, sp, #28
34805520:	e8bd8030 	pop	{r4, r5, pc}
34805524:	34829a0c 	.word	0x34829a0c
34805528:	3482479d 	.word	0x3482479d
3480552c:	348243cc 	.word	0x348243cc
34805530:	3482479a 	.word	0x3482479a
34805534:	34824426 	.word	0x34824426
34805538:	34824b63 	.word	0x34824b63

3480553c <part_sort_add>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3480553c:	e5903010 	ldr	r3, [r0, #16]
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805540:	e92d4070 	push	{r4, r5, r6, lr}
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
34805544:	e2806010 	add	r6, r0, #16
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805548:	e1a05001 	mov	r5, r1
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
3480554c:	e1530006 	cmp	r3, r6
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805550:	e1a04000 	mov	r4, r0
	struct list_head *entry;
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;
34805554:	e5850024 	str	r0, [r5, #36]	; 0x24

	if (list_empty(&dev->parts)) {
34805558:	1a000007 	bne	3480557c <part_sort_add+0x40>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480555c:	e5831004 	str	r1, [r3, #4]
	new->next = next;
34805560:	e5813000 	str	r3, [r1]
	new->prev = prev;
34805564:	e5813004 	str	r3, [r1, #4]
		debug("part_sort_add: list empty\n");
		list_add(&part->link, &dev->parts);
		dev->num_parts++;
34805568:	e1d030bc 	ldrh	r3, [r0, #12]
	prev->next = new;
3480556c:	e5841010 	str	r1, [r4, #16]
34805570:	e2833001 	add	r3, r3, #1
34805574:	e1c030bc 	strh	r3, [r0, #12]
34805578:	ea000027 	b	3480561c <part_sort_add+0xe0>

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
3480557c:	e59f30dc 	ldr	r3, [pc, #220]	; 34805660 <part_sort_add+0x124>
34805580:	e5932000 	ldr	r2, [r3]
34805584:	e1500002 	cmp	r0, r2
	}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
34805588:	13a00000 	movne	r0, #0
	if (dev == current_mtd_dev)
3480558c:	1a000001 	bne	34805598 <part_sort_add+0x5c>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34805590:	e5d3100c 	ldrb	r1, [r3, #12]
34805594:	ebffff53 	bl	348052e8 <mtd_part_info>

	list_for_each(entry, &dev->parts) {
34805598:	e5943010 	ldr	r3, [r4, #16]
3480559c:	ea000022 	b	3480562c <part_sort_add+0xf0>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
348055a0:	e5952014 	ldr	r2, [r5, #20]
348055a4:	e5931014 	ldr	r1, [r3, #20]
348055a8:	e1520001 	cmp	r2, r1
348055ac:	1a000005 	bne	348055c8 <part_sort_add+0x8c>
348055b0:	e3520000 	cmp	r2, #0
348055b4:	1a000005 	bne	348055d0 <part_sort_add+0x94>
			printf("cannot add second partition at offset 0\n");
348055b8:	e59f00a4 	ldr	r0, [pc, #164]	; 34805664 <part_sort_add+0x128>
348055bc:	eb001141 	bl	34809ac8 <printf>
			return 1;
348055c0:	e3a00001 	mov	r0, #1
348055c4:	e8bd8070 	pop	{r4, r5, r6, pc}
		}

		if (new_pi->offset <= pi->offset) {
348055c8:	8a000016 	bhi	34805628 <part_sort_add+0xec>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
348055cc:	e1a02001 	mov	r2, r1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348055d0:	e5931004 	ldr	r1, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348055d4:	e5853000 	str	r3, [r5]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348055d8:	e5835004 	str	r5, [r3, #4]
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
348055dc:	e1d430bc 	ldrh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348055e0:	e3500000 	cmp	r0, #0
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
348055e4:	e2833001 	add	r3, r3, #1
	new->next = next;
	new->prev = prev;
348055e8:	e5851004 	str	r1, [r5, #4]
	prev->next = new;
348055ec:	e5815000 	str	r5, [r1]
348055f0:	e1c430bc 	strh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348055f4:	0a000008 	beq	3480561c <part_sort_add+0xe0>
348055f8:	e5903014 	ldr	r3, [r0, #20]
348055fc:	e1520003 	cmp	r2, r3
34805600:	8a000005 	bhi	3480561c <part_sort_add+0xe0>
				/* we are modyfing partitions for the current
				 * device, update current */
				current_mtd_partnum++;
34805604:	e59f3054 	ldr	r3, [pc, #84]	; 34805660 <part_sort_add+0x124>
34805608:	e5d3200c 	ldrb	r2, [r3, #12]
3480560c:	e2822001 	add	r2, r2, #1
34805610:	e5c3200c 	strb	r2, [r3, #12]
				current_save();
34805614:	ebffff9c 	bl	3480548c <current_save>
34805618:	ea000000 	b	34805620 <part_sort_add+0xe4>
			} else {
				index_partitions();
3480561c:	ebffff56 	bl	3480537c <index_partitions>
			}
			return 0;
34805620:	e3a00000 	mov	r0, #0
34805624:	e8bd8070 	pop	{r4, r5, r6, pc}
	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);

	list_for_each(entry, &dev->parts) {
34805628:	e5933000 	ldr	r3, [r3]
3480562c:	e1530006 	cmp	r3, r6
34805630:	1affffda 	bne	348055a0 <part_sort_add+0x64>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34805634:	e5853000 	str	r3, [r5]
			return 0;
		}
	}

	list_add_tail(&part->link, &dev->parts);
	dev->num_parts++;
34805638:	e1d430bc 	ldrh	r3, [r4, #12]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480563c:	e5942014 	ldr	r2, [r4, #20]
34805640:	e2833001 	add	r3, r3, #1
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805644:	e5845014 	str	r5, [r4, #20]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34805648:	e5825000 	str	r5, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
3480564c:	e5852004 	str	r2, [r5, #4]
34805650:	e1c430bc 	strh	r3, [r4, #12]
	index_partitions();
34805654:	ebffff48 	bl	3480537c <index_partitions>
	return 0;
34805658:	e3a00000 	mov	r0, #0
}
3480565c:	e8bd8070 	pop	{r4, r5, r6, pc}
34805660:	34829a0c 	.word	0x34829a0c
34805664:	3482442e 	.word	0x3482442e

34805668 <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
34805668:	e92d4070 	push	{r4, r5, r6, lr}
3480566c:	e1a06000 	mov	r6, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805670:	e5900000 	ldr	r0, [r0]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805674:	e3a05000 	mov	r5, #0
34805678:	e5904000 	ldr	r4, [r0]
3480567c:	ea000007 	b	348056a0 <part_delall+0x38>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805680:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805684:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805688:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
3480568c:	e5805004 	str	r5, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805690:	e5805000 	str	r5, [r0]
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
34805694:	eb001249 	bl	34809fc0 <free>
{
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805698:	e1a00004 	mov	r0, r4
3480569c:	e5944000 	ldr	r4, [r4]
348056a0:	e1500006 	cmp	r0, r6
348056a4:	1afffff5 	bne	34805680 <part_delall+0x18>
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
	}
}
348056a8:	e8bd8070 	pop	{r4, r5, r6, pc}

348056ac <device_del>:
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 */
static int device_del(struct mtd_device *dev)
{
348056ac:	e92d4038 	push	{r3, r4, r5, lr}
348056b0:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
348056b4:	e2800010 	add	r0, r0, #16
348056b8:	ebffffea 	bl	34805668 <part_delall>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348056bc:	e894000c 	ldm	r4, {r2, r3}
	entry->next = LIST_POISON1;
348056c0:	e3a05000 	mov	r5, #0
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348056c4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348056c8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348056cc:	e5845004 	str	r5, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348056d0:	e5845000 	str	r5, [r4]
	list_del(&dev->link);
	free(dev);
348056d4:	e1a00004 	mov	r0, r4
348056d8:	eb001238 	bl	34809fc0 <free>

	if (dev == current_mtd_dev) {
348056dc:	e59f3034 	ldr	r3, [pc, #52]	; 34805718 <device_del+0x6c>
348056e0:	e5932000 	ldr	r2, [r3]
348056e4:	e1540002 	cmp	r4, r2
348056e8:	1a000007 	bne	3480570c <device_del+0x60>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348056ec:	e1a02003 	mov	r2, r3
348056f0:	e5b21004 	ldr	r1, [r2, #4]!
		/* we just deleted current device */
		if (list_empty(&devices)) {
348056f4:	e1510002 	cmp	r1, r2
			current_mtd_dev = NULL;
348056f8:	05835000 	streq	r5, [r3]
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
348056fc:	15831000 	strne	r1, [r3]
			current_mtd_partnum = 0;
34805700:	15c3500c 	strbne	r5, [r3, #12]
		}
		current_save();
34805704:	ebffff60 	bl	3480548c <current_save>
		return 0;
34805708:	ea000000 	b	34805710 <device_del+0x64>
	}

	index_partitions();
3480570c:	ebffff1a 	bl	3480537c <index_partitions>
	return 0;
}
34805710:	e3a00000 	mov	r0, #0
34805714:	e8bd8038 	pop	{r3, r4, r5, pc}
34805718:	34829a0c 	.word	0x34829a0c

3480571c <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
3480571c:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805720:	e3a02000 	mov	r2, #0
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
34805724:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805728:	eb005ead 	bl	3481d1e4 <simple_strtoul>

	switch (**retptr) {
3480572c:	e5942000 	ldr	r2, [r4]
34805730:	e5d23000 	ldrb	r3, [r2]
34805734:	e353004d 	cmp	r3, #77	; 0x4d
34805738:	0a00000c 	beq	34805770 <memsize_parse+0x54>
3480573c:	8a000004 	bhi	34805754 <memsize_parse+0x38>
34805740:	e3530047 	cmp	r3, #71	; 0x47
34805744:	0a000008 	beq	3480576c <memsize_parse+0x50>
34805748:	e353004b 	cmp	r3, #75	; 0x4b
3480574c:	18bd8010 	popne	{r4, pc}
34805750:	ea000007 	b	34805774 <memsize_parse+0x58>
34805754:	e353006b 	cmp	r3, #107	; 0x6b
34805758:	0a000005 	beq	34805774 <memsize_parse+0x58>
3480575c:	e353006d 	cmp	r3, #109	; 0x6d
34805760:	0a000002 	beq	34805770 <memsize_parse+0x54>
34805764:	e3530067 	cmp	r3, #103	; 0x67
34805768:	18bd8010 	popne	{r4, pc}
		case 'G':
		case 'g':
			ret <<= 10;
3480576c:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
34805770:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
34805774:	e2822001 	add	r2, r2, #1
		case 'M':
		case 'm':
			ret <<= 10;
		case 'K':
		case 'k':
			ret <<= 10;
34805778:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
3480577c:	e5842000 	str	r2, [r4]
		default:
			break;
	}

	return ret;
}
34805780:	e8bd8010 	pop	{r4, pc}

34805784 <get_mtd_info>:
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
34805784:	e92d4030 	push	{r4, r5, lr}
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805788:	e3500002 	cmp	r0, #2
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
3480578c:	e1a05002 	mov	r5, r2
34805790:	e24dd014 	sub	sp, sp, #20
34805794:	e1a03001 	mov	r3, r1
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805798:	059f2050 	ldreq	r2, [pc, #80]	; 348057f0 <get_mtd_info+0x6c>
3480579c:	0a000003 	beq	348057b0 <get_mtd_info+0x2c>
348057a0:	e59f104c 	ldr	r1, [pc, #76]	; 348057f4 <get_mtd_info+0x70>
348057a4:	e3500004 	cmp	r0, #4
348057a8:	e59f2048 	ldr	r2, [pc, #72]	; 348057f8 <get_mtd_info+0x74>
348057ac:	11a02001 	movne	r2, r1
348057b0:	e59f1044 	ldr	r1, [pc, #68]	; 348057fc <get_mtd_info+0x78>
348057b4:	e1a0000d 	mov	r0, sp
348057b8:	eb005f2f 	bl	3481d47c <sprintf>
	*mtd = get_mtd_device_nm(mtd_dev);
348057bc:	e1a0000d 	mov	r0, sp
348057c0:	eb003799 	bl	3481362c <get_mtd_device_nm>
	if (IS_ERR(*mtd)) {
348057c4:	e3700a01 	cmn	r0, #4096	; 0x1000
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
348057c8:	e5850000 	str	r0, [r5]
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
348057cc:	e1a0400d 	mov	r4, sp
	if (IS_ERR(*mtd)) {
		printf("Device %s not found!\n", mtd_dev);
		return 1;
	}

	return 0;
348057d0:	93a00000 	movls	r0, #0
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
	if (IS_ERR(*mtd)) {
348057d4:	9a000003 	bls	348057e8 <get_mtd_info+0x64>
		printf("Device %s not found!\n", mtd_dev);
348057d8:	e59f0020 	ldr	r0, [pc, #32]	; 34805800 <get_mtd_info+0x7c>
348057dc:	e1a0100d 	mov	r1, sp
348057e0:	eb0010b8 	bl	34809ac8 <printf>
		return 1;
348057e4:	e3a00001 	mov	r0, #1
	}

	return 0;
}
348057e8:	e28dd014 	add	sp, sp, #20
348057ec:	e8bd8030 	pop	{r4, r5, pc}
348057f0:	3482479d 	.word	0x3482479d
348057f4:	348243cc 	.word	0x348243cc
348057f8:	3482479a 	.word	0x3482479a
348057fc:	34824457 	.word	0x34824457
34805800:	3482445c 	.word	0x3482445c

34805804 <part_validate_eraseblock>:
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34805804:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct mtd_info *mtd = NULL;
34805808:	e3a03000 	mov	r3, #0
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
3480580c:	e1a05000 	mov	r5, r0
	struct mtd_info *mtd = NULL;
34805810:	e28d2008 	add	r2, sp, #8
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34805814:	e1a04001 	mov	r4, r1
	struct mtd_info *mtd = NULL;
34805818:	e5223004 	str	r3, [r2, #-4]!
	int i, j;
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
3480581c:	e5d00008 	ldrb	r0, [r0, #8]
34805820:	e5d51009 	ldrb	r1, [r5, #9]
34805824:	ebffffd6 	bl	34805784 <get_mtd_info>
34805828:	e3500000 	cmp	r0, #0
3480582c:	1a00001f 	bne	348058b0 <part_validate_eraseblock+0xac>
		return 1;

	part->sector_size = mtd->erasesize;
34805830:	e59d7004 	ldr	r7, [sp, #4]

	if (!mtd->numeraseregions) {
34805834:	e597c02c 	ldr	ip, [r7, #44]	; 0x2c
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34805838:	e5976010 	ldr	r6, [r7, #16]

	if (!mtd->numeraseregions) {
3480583c:	e35c0000 	cmp	ip, #0
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34805840:	e5846020 	str	r6, [r4, #32]

	if (!mtd->numeraseregions) {
34805844:	11a06000 	movne	r6, r0
34805848:	1a00002b 	bne	348058fc <part_validate_eraseblock+0xf8>
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
3480584c:	e5940014 	ldr	r0, [r4, #20]
34805850:	e1a01006 	mov	r1, r6
34805854:	eb006956 	bl	3481fdb4 <__aeabi_uidivmod>
34805858:	e3510000 	cmp	r1, #0
3480585c:	0a000009 	beq	34805888 <part_validate_eraseblock+0x84>
			printf("%s%d: partition (%s) start offset"
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805860:	e5d53008 	ldrb	r3, [r5, #8]
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34805864:	e3530002 	cmp	r3, #2
34805868:	059f113c 	ldreq	r1, [pc, #316]	; 348059ac <part_validate_eraseblock+0x1a8>
3480586c:	0a000003 	beq	34805880 <part_validate_eraseblock+0x7c>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805870:	e59f2138 	ldr	r2, [pc, #312]	; 348059b0 <part_validate_eraseblock+0x1ac>
34805874:	e3530004 	cmp	r3, #4
34805878:	e59f1134 	ldr	r1, [pc, #308]	; 348059b4 <part_validate_eraseblock+0x1b0>
3480587c:	01a01002 	moveq	r1, r2
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34805880:	e59f0130 	ldr	r0, [pc, #304]	; 348059b8 <part_validate_eraseblock+0x1b4>
34805884:	ea000006 	b	348058a4 <part_validate_eraseblock+0xa0>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
34805888:	e5940010 	ldr	r0, [r4, #16]
3480588c:	e1a01006 	mov	r1, r6
34805890:	eb006947 	bl	3481fdb4 <__aeabi_uidivmod>
34805894:	e2510000 	subs	r0, r1, #0
34805898:	1a000038 	bne	34805980 <part_validate_eraseblock+0x17c>
3480589c:	ea000041 	b	348059a8 <part_validate_eraseblock+0x1a4>
			printf("%s%d: partition (%s) size alignment incorrect\n",
348058a0:	e59f0114 	ldr	r0, [pc, #276]	; 348059bc <part_validate_eraseblock+0x1b8>
348058a4:	e5d52009 	ldrb	r2, [r5, #9]
348058a8:	e5943008 	ldr	r3, [r4, #8]
348058ac:	eb001085 	bl	34809ac8 <printf>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
348058b0:	e3a00001 	mov	r0, #1
348058b4:	ea00003b 	b	348059a8 <part_validate_eraseblock+0x1a4>
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
348058b8:	e5971030 	ldr	r1, [r7, #48]	; 0x30
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058bc:	e3a0a000 	mov	sl, #0
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
348058c0:	e0819000 	add	r9, r1, r0
348058c4:	e7913000 	ldr	r3, [r1, r0]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058c8:	e599b00c 	ldr	fp, [r9, #12]
348058cc:	ea000006 	b	348058ec <part_validate_eraseblock+0xe8>
				if (part->offset == start)
348058d0:	e5942014 	ldr	r2, [r4, #20]
348058d4:	e1520003 	cmp	r2, r3
348058d8:	03a00000 	moveq	r0, #0
348058dc:	0a000021 	beq	34805968 <part_validate_eraseblock+0x164>
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
348058e0:	e5992008 	ldr	r2, [r9, #8]
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058e4:	e28aa001 	add	sl, sl, #1
				if (part->offset == start)
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
348058e8:	e0833002 	add	r3, r3, r2
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058ec:	e15a000b 	cmp	sl, fp
348058f0:	3afffff6 	bcc	348058d0 <part_validate_eraseblock+0xcc>
		 * Multiple eraseregions (non-uniform NOR),
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
348058f4:	e2866001 	add	r6, r6, #1
348058f8:	e2800018 	add	r0, r0, #24
348058fc:	e156000c 	cmp	r6, ip
34805900:	baffffec 	blt	348058b8 <part_validate_eraseblock+0xb4>
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805904:	e5d53008 	ldrb	r3, [r5, #8]
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34805908:	e3530002 	cmp	r3, #2
3480590c:	059f1098 	ldreq	r1, [pc, #152]	; 348059ac <part_validate_eraseblock+0x1a8>
34805910:	0a000003 	beq	34805924 <part_validate_eraseblock+0x120>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805914:	e59f2094 	ldr	r2, [pc, #148]	; 348059b0 <part_validate_eraseblock+0x1ac>
34805918:	e3530004 	cmp	r3, #4
3480591c:	e59f1090 	ldr	r1, [pc, #144]	; 348059b4 <part_validate_eraseblock+0x1b0>
34805920:	01a01002 	moveq	r1, r2
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34805924:	e59f0094 	ldr	r0, [pc, #148]	; 348059c0 <part_validate_eraseblock+0x1bc>
34805928:	eaffffdd 	b	348058a4 <part_validate_eraseblock+0xa0>

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
3480592c:	e5913000 	ldr	r3, [r1]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805930:	e591700c 	ldr	r7, [r1, #12]
34805934:	e3a06000 	mov	r6, #0
34805938:	ea000006 	b	34805958 <part_validate_eraseblock+0x154>
				if ((part->offset + part->size) == start)
3480593c:	e594a010 	ldr	sl, [r4, #16]
34805940:	e082a00a 	add	sl, r2, sl
34805944:	e15a0003 	cmp	sl, r3
34805948:	0a000015 	beq	348059a4 <part_validate_eraseblock+0x1a0>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
3480594c:	e591a008 	ldr	sl, [r1, #8]
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805950:	e2866001 	add	r6, r6, #1
				if ((part->offset + part->size) == start)
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34805954:	e083300a 	add	r3, r3, sl
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805958:	e1560007 	cmp	r6, r7
3480595c:	3afffff6 	bcc	3480593c <part_validate_eraseblock+0x138>
		return 1;

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
34805960:	e2800001 	add	r0, r0, #1
34805964:	e2811018 	add	r1, r1, #24
34805968:	e150000c 	cmp	r0, ip
3480596c:	baffffee 	blt	3480592c <part_validate_eraseblock+0x128>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
34805970:	e5941010 	ldr	r1, [r4, #16]
34805974:	e0822001 	add	r2, r2, r1
34805978:	e1520003 	cmp	r2, r3
3480597c:	0a000008 	beq	348059a4 <part_validate_eraseblock+0x1a0>
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805980:	e5d53008 	ldrb	r3, [r5, #8]
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34805984:	e3530002 	cmp	r3, #2
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
			printf("%s%d: partition (%s) size alignment incorrect\n",
34805988:	059f101c 	ldreq	r1, [pc, #28]	; 348059ac <part_validate_eraseblock+0x1a8>
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
3480598c:	0affffc3 	beq	348058a0 <part_validate_eraseblock+0x9c>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805990:	e59f2018 	ldr	r2, [pc, #24]	; 348059b0 <part_validate_eraseblock+0x1ac>
34805994:	e3530004 	cmp	r3, #4
34805998:	e59f1014 	ldr	r1, [pc, #20]	; 348059b4 <part_validate_eraseblock+0x1b0>
3480599c:	01a01002 	moveq	r1, r2
348059a0:	eaffffbe 	b	348058a0 <part_validate_eraseblock+0x9c>
		return 1;

	end_ok:
		return 0;
348059a4:	e3a00000 	mov	r0, #0
	}

	return 0;
}
348059a8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348059ac:	3482479d 	.word	0x3482479d
348059b0:	3482479a 	.word	0x3482479a
348059b4:	348243cc 	.word	0x348243cc
348059b8:	34824472 	.word	0x34824472
348059bc:	348244a8 	.word	0x348244a8
348059c0:	348244d7 	.word	0x348244d7

348059c4 <device_delall.clone.2>:
 * Delete all mtd devices from a supplied devices list, free memory allocated for
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
348059c4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
348059c8:	e59f6054 	ldr	r6, [pc, #84]	; 34805a24 <device_delall.clone.2+0x60>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348059cc:	e3a07000 	mov	r7, #0
348059d0:	e5b64004 	ldr	r4, [r6, #4]!
348059d4:	e5945000 	ldr	r5, [r4]
348059d8:	ea00000a 	b	34805a08 <device_delall.clone.2+0x44>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348059dc:	e894000c 	ldm	r4, {r2, r3}
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
348059e0:	e2840010 	add	r0, r4, #16
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348059e4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348059e8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348059ec:	e5847004 	str	r7, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348059f0:	e5847000 	str	r7, [r4]
348059f4:	ebffff1b 	bl	34805668 <part_delall>
		free(dev_tmp);
348059f8:	e1a00004 	mov	r0, r4
348059fc:	eb00116f 	bl	34809fc0 <free>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805a00:	e1a04005 	mov	r4, r5
34805a04:	e5955000 	ldr	r5, [r5]
34805a08:	e1540006 	cmp	r4, r6
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
34805a0c:	e59f3010 	ldr	r3, [pc, #16]	; 34805a24 <device_delall.clone.2+0x60>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805a10:	1afffff1 	bne	348059dc <device_delall.clone.2+0x18>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805a14:	e5834004 	str	r4, [r3, #4]
	list->prev = list;
34805a18:	e5834008 	str	r4, [r3, #8]
		free(dev_tmp);
	}
	INIT_LIST_HEAD(&devices);

	return 0;
}
34805a1c:	e3a00000 	mov	r0, #0
34805a20:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34805a24:	34829a0c 	.word	0x34829a0c

34805a28 <mtd_devices_init>:
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
	last_parts[0] = '\0';
34805a28:	e59f3018 	ldr	r3, [pc, #24]	; 34805a48 <mtd_devices_init+0x20>
34805a2c:	e3a02000 	mov	r2, #0
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
34805a30:	e92d4010 	push	{r4, lr}
	last_parts[0] = '\0';
34805a34:	e5c32020 	strb	r2, [r3, #32]
	current_mtd_dev = NULL;
34805a38:	e5832000 	str	r2, [r3]
	current_save();
34805a3c:	ebfffe92 	bl	3480548c <current_save>

	return device_delall(&devices);
}
34805a40:	e8bd4010 	pop	{r4, lr}
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
34805a44:	eaffffde 	b	348059c4 <device_delall.clone.2>
34805a48:	34829a0c 	.word	0x34829a0c

34805a4c <generate_mtdparts_save.clone.1>:
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
34805a4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34805a50:	e59f52a8 	ldr	r5, [pc, #680]	; 34805d00 <generate_mtdparts_save.clone.1+0x2b4>
34805a54:	e24dd030 	sub	sp, sp, #48	; 0x30
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805a58:	e5952004 	ldr	r2, [r5, #4]
34805a5c:	e2853004 	add	r3, r5, #4
34805a60:	e1520003 	cmp	r2, r3
		buf[0] = '\0';
34805a64:	03a04000 	moveq	r4, #0
34805a68:	05c54020 	strbeq	r4, [r5, #32]
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805a6c:	0a000095 	beq	34805cc8 <generate_mtdparts_save.clone.1+0x27c>
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
34805a70:	e2850020 	add	r0, r5, #32
34805a74:	e59f1288 	ldr	r1, [pc, #648]	; 34805d04 <generate_mtdparts_save.clone.1+0x2b8>
34805a78:	eb005e7f 	bl	3481d47c <sprintf>
	struct mtd_device *dev;
	struct part_info *part, *prev_part;
	char *p = buf;
	char tmpbuf[32];
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;
34805a7c:	e30041ff 	movw	r4, #511	; 0x1ff
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805a80:	e5957004 	ldr	r7, [r5, #4]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805a84:	e28d9010 	add	r9, sp, #16
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
34805a88:	e2855029 	add	r5, r5, #41	; 0x29
34805a8c:	ea000083 	b	34805ca0 <generate_mtdparts_save.clone.1+0x254>

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805a90:	e5973008 	ldr	r3, [r7, #8]
34805a94:	e5930010 	ldr	r0, [r3, #16]
34805a98:	eb005a3e 	bl	3481c398 <strlen>
34805a9c:	e280a001 	add	sl, r0, #1
		if (len > maxlen)
34805aa0:	e15a0004 	cmp	sl, r4

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805aa4:	e1a06000 	mov	r6, r0
		if (len > maxlen)
34805aa8:	8a000082 	bhi	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
34805aac:	e5973008 	ldr	r3, [r7, #8]
34805ab0:	e1a00005 	mov	r0, r5
34805ab4:	e5931010 	ldr	r1, [r3, #16]
34805ab8:	e1a02006 	mov	r2, r6
34805abc:	eb005af9 	bl	3481c6a8 <memcpy>
		p += len - 1;
		*(p++) = ':';
34805ac0:	e3a0203a 	mov	r2, #58	; 0x3a
34805ac4:	e7c52006 	strb	r2, [r5, r6]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805ac8:	e1a02007 	mov	r2, r7
		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
34805acc:	e0853006 	add	r3, r5, r6
		*(p++) = ':';
		maxlen -= len;
34805ad0:	e06a4004 	rsb	r4, sl, r4

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805ad4:	e5b2a010 	ldr	sl, [r2, #16]!
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
34805ad8:	e2835001 	add	r5, r3, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
34805adc:	e3a03000 	mov	r3, #0
		list_for_each(pentry, &dev->parts) {
34805ae0:	e88d0088 	stm	sp, {r3, r7}
34805ae4:	e58d2004 	str	r2, [sp, #4]
		p += len - 1;
		*(p++) = ':';
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
34805ae8:	e1a0b003 	mov	fp, r3
34805aec:	ea00005e 	b	34805c6c <generate_mtdparts_save.clone.1+0x220>
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805af0:	e59a2014 	ldr	r2, [sl, #20]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805af4:	e1a00009 	mov	r0, r9
34805af8:	e59a1010 	ldr	r1, [sl, #16]
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805afc:	e58d2008 	str	r2, [sp, #8]

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
34805b00:	e58da00c 	str	sl, [sp, #12]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805b04:	ebfffe4b 	bl	34805438 <memsize_format>
			len = strlen(tmpbuf);
34805b08:	e1a00009 	mov	r0, r9
34805b0c:	eb005a21 	bl	3481c398 <strlen>
			if (len > maxlen)
34805b10:	e1500004 	cmp	r0, r4
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
34805b14:	e1a06000 	mov	r6, r0
			if (len > maxlen)
34805b18:	8a000066 	bhi	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			memcpy(p, tmpbuf, len);
34805b1c:	e1a00005 	mov	r0, r5
34805b20:	e1a02006 	mov	r2, r6
34805b24:	e1a01009 	mov	r1, r9
34805b28:	eb005ade 	bl	3481c6a8 <memcpy>
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805b2c:	e59d2008 	ldr	r2, [sp, #8]
34805b30:	e27b3001 	rsbs	r3, fp, #1
34805b34:	33a03000 	movcc	r3, #0
34805b38:	e3520000 	cmp	r2, #0
34805b3c:	03a03000 	moveq	r3, #0
34805b40:	e3530000 	cmp	r3, #0
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
34805b44:	e0855006 	add	r5, r5, r6
			maxlen -= len;
34805b48:	e0664004 	rsb	r4, r6, r4


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805b4c:	1a000007 	bne	34805b70 <generate_mtdparts_save.clone.1+0x124>
34805b50:	e35b0000 	cmp	fp, #0
34805b54:	0a000016 	beq	34805bb4 <generate_mtdparts_save.clone.1+0x168>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {
34805b58:	e59b3014 	ldr	r3, [fp, #20]
34805b5c:	e59b2010 	ldr	r2, [fp, #16]
34805b60:	e0822003 	add	r2, r2, r3
34805b64:	e59a3014 	ldr	r3, [sl, #20]
34805b68:	e1520003 	cmp	r2, r3
34805b6c:	0a000010 	beq	34805bb4 <generate_mtdparts_save.clone.1+0x168>

				memsize_format(tmpbuf, offset);
34805b70:	e1a00009 	mov	r0, r9
34805b74:	e59d1008 	ldr	r1, [sp, #8]
34805b78:	ebfffe2e 	bl	34805438 <memsize_format>
				len = strlen(tmpbuf) + 1;
34805b7c:	e1a00009 	mov	r0, r9
34805b80:	eb005a04 	bl	3481c398 <strlen>
34805b84:	e280b001 	add	fp, r0, #1
				if (len > maxlen)
34805b88:	e15b0004 	cmp	fp, r4
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {

				memsize_format(tmpbuf, offset);
				len = strlen(tmpbuf) + 1;
34805b8c:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805b90:	8a000048 	bhi	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = '@';
34805b94:	e3a03040 	mov	r3, #64	; 0x40
34805b98:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, tmpbuf, len - 1);
34805b9c:	e1a00005 	mov	r0, r5
34805ba0:	e1a01009 	mov	r1, r9
34805ba4:	e1a02006 	mov	r2, r6
34805ba8:	eb005abe 	bl	3481c6a8 <memcpy>
				p += len - 1;
34805bac:	e0855006 	add	r5, r5, r6
				maxlen -= len;
34805bb0:	e06b4004 	rsb	r4, fp, r4
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
34805bb4:	e5da300c 	ldrb	r3, [sl, #12]
34805bb8:	e3530000 	cmp	r3, #0
34805bbc:	1a000010 	bne	34805c04 <generate_mtdparts_save.clone.1+0x1b8>
				len = strlen(part->name) + 2;
34805bc0:	e59a0008 	ldr	r0, [sl, #8]
34805bc4:	eb0059f3 	bl	3481c398 <strlen>
34805bc8:	e280b002 	add	fp, r0, #2
				if (len > maxlen)
34805bcc:	e15b0004 	cmp	fp, r4
				maxlen -= len;
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
				len = strlen(part->name) + 2;
34805bd0:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805bd4:	8a000037 	bhi	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;

				*(p++) = '(';
34805bd8:	e3a02028 	mov	r2, #40	; 0x28
34805bdc:	e4c52001 	strb	r2, [r5], #1
				memcpy(p, part->name, len - 2);
34805be0:	e1a00005 	mov	r0, r5
34805be4:	e1a02006 	mov	r2, r6
34805be8:	e59a1008 	ldr	r1, [sl, #8]
34805bec:	eb005aad 	bl	3481c6a8 <memcpy>
				p += len - 2;
34805bf0:	e0853006 	add	r3, r5, r6
				*(p++) = ')';
34805bf4:	e3a02029 	mov	r2, #41	; 0x29
34805bf8:	e7c52006 	strb	r2, [r5, r6]
				maxlen -= len;
34805bfc:	e06b4004 	rsb	r4, fp, r4
					goto cleanup;

				*(p++) = '(';
				memcpy(p, part->name, len - 2);
				p += len - 2;
				*(p++) = ')';
34805c00:	e2835001 	add	r5, r3, #1
				maxlen -= len;
			}

			/* ro mask flag */
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
34805c04:	e59a301c 	ldr	r3, [sl, #28]
34805c08:	e3530000 	cmp	r3, #0
34805c0c:	0a000008 	beq	34805c34 <generate_mtdparts_save.clone.1+0x1e8>
				len = 2;
				if (len > maxlen)
34805c10:	e3540001 	cmp	r4, #1
34805c14:	9a000027 	bls	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = 'r';
34805c18:	e1a03005 	mov	r3, r5
34805c1c:	e3a02072 	mov	r2, #114	; 0x72
34805c20:	e4c32001 	strb	r2, [r3], #1
				*(p++) = 'o';
34805c24:	e3a0206f 	mov	r2, #111	; 0x6f
34805c28:	e5c52001 	strb	r2, [r5, #1]
				maxlen -= 2;
34805c2c:	e2444002 	sub	r4, r4, #2
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
				len = 2;
				if (len > maxlen)
					goto cleanup;
				*(p++) = 'r';
				*(p++) = 'o';
34805c30:	e2835001 	add	r5, r3, #1
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
34805c34:	e59d3000 	ldr	r3, [sp]
34805c38:	e2833001 	add	r3, r3, #1
34805c3c:	e58d3000 	str	r3, [sp]
				maxlen -= 2;
			}

			/* print ',' separator if there are other partitions
			 * following */
			if (dev->num_parts > part_cnt) {
34805c40:	e59d2000 	ldr	r2, [sp]
34805c44:	e1d730bc 	ldrh	r3, [r7, #12]
34805c48:	e1530002 	cmp	r3, r2
34805c4c:	9a000004 	bls	34805c64 <generate_mtdparts_save.clone.1+0x218>
				if (1 > maxlen)
34805c50:	e3540000 	cmp	r4, #0
34805c54:	0a000017 	beq	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = ',';
34805c58:	e3a0302c 	mov	r3, #44	; 0x2c
34805c5c:	e4c53001 	strb	r3, [r5], #1
				maxlen--;
34805c60:	e2444001 	sub	r4, r4, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805c64:	e59aa000 	ldr	sl, [sl]
34805c68:	e59db00c 	ldr	fp, [sp, #12]
34805c6c:	e59d2004 	ldr	r2, [sp, #4]
34805c70:	e15a0002 	cmp	sl, r2
34805c74:	1affff9d 	bne	34805af0 <generate_mtdparts_save.clone.1+0xa4>
				maxlen--;
			}
			prev_part = part;
		}
		/* print ';' separator if there are other devices following */
		if (dentry->next != &devices) {
34805c78:	e5972000 	ldr	r2, [r7]
34805c7c:	e59f3084 	ldr	r3, [pc, #132]	; 34805d08 <generate_mtdparts_save.clone.1+0x2bc>
34805c80:	e1520003 	cmp	r2, r3
34805c84:	0a000004 	beq	34805c9c <generate_mtdparts_save.clone.1+0x250>
			if (1 > maxlen)
34805c88:	e3540000 	cmp	r4, #0
34805c8c:	0a000009 	beq	34805cb8 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			*(p++) = ';';
34805c90:	e3a0303b 	mov	r3, #59	; 0x3b
34805c94:	e4c53001 	strb	r3, [r5], #1
			maxlen--;
34805c98:	e2444001 	sub	r4, r4, #1
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805c9c:	e5977000 	ldr	r7, [r7]
34805ca0:	e59f3060 	ldr	r3, [pc, #96]	; 34805d08 <generate_mtdparts_save.clone.1+0x2bc>
34805ca4:	e1570003 	cmp	r7, r3
34805ca8:	1affff78 	bne	34805a90 <generate_mtdparts_save.clone.1+0x44>
		}
	}

	/* we still have at least one char left, as we decremented maxlen at
	 * the begining */
	*p = '\0';
34805cac:	e3a04000 	mov	r4, #0
34805cb0:	e5c54000 	strb	r4, [r5]
34805cb4:	ea000003 	b	34805cc8 <generate_mtdparts_save.clone.1+0x27c>

	return 0;

cleanup:
	last_parts[0] = '\0';
34805cb8:	e59f3040 	ldr	r3, [pc, #64]	; 34805d00 <generate_mtdparts_save.clone.1+0x2b4>
34805cbc:	e3a02000 	mov	r2, #0
34805cc0:	e5c32020 	strb	r2, [r3, #32]
	return 1;
34805cc4:	e3a04001 	mov	r4, #1
{
	int ret;

	ret = generate_mtdparts(buf, buflen);

	if ((buf[0] != '\0') && (ret == 0))
34805cc8:	e59f3030 	ldr	r3, [pc, #48]	; 34805d00 <generate_mtdparts_save.clone.1+0x2b4>
34805ccc:	e2242001 	eor	r2, r4, #1
34805cd0:	e5d31020 	ldrb	r1, [r3, #32]
34805cd4:	e3510000 	cmp	r1, #0
34805cd8:	03a01000 	moveq	r1, #0
34805cdc:	12021001 	andne	r1, r2, #1
34805ce0:	e3510000 	cmp	r1, #0
		setenv("mtdparts", buf);
34805ce4:	159f0020 	ldrne	r0, [pc, #32]	; 34805d0c <generate_mtdparts_save.clone.1+0x2c0>
34805ce8:	12831020 	addne	r1, r3, #32
	else
		setenv("mtdparts", NULL);
34805cec:	059f0018 	ldreq	r0, [pc, #24]	; 34805d0c <generate_mtdparts_save.clone.1+0x2c0>
34805cf0:	eb00077e 	bl	34807af0 <setenv>

	return ret;
}
34805cf4:	e1a00004 	mov	r0, r4
34805cf8:	e28dd030 	add	sp, sp, #48	; 0x30
34805cfc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805d00:	34829a0c 	.word	0x34829a0c
34805d04:	3482450e 	.word	0x3482450e
34805d08:	34829a10 	.word	0x34829a10
34805d0c:	34824518 	.word	0x34824518

34805d10 <mtd_device_validate>:
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805d10:	e92d4013 	push	{r0, r1, r4, lr}
	struct mtd_info *mtd = NULL;
34805d14:	e3a03000 	mov	r3, #0
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805d18:	e1a04002 	mov	r4, r2
	struct mtd_info *mtd = NULL;
34805d1c:	e28d2008 	add	r2, sp, #8
34805d20:	e5223004 	str	r3, [r2, #-4]!

	if (get_mtd_info(type, num, &mtd))
34805d24:	ebfffe96 	bl	34805784 <get_mtd_info>
34805d28:	e3500000 	cmp	r0, #0
		return 1;

	*size = mtd->size;
34805d2c:	059d3004 	ldreq	r3, [sp, #4]
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
	struct mtd_info *mtd = NULL;

	if (get_mtd_info(type, num, &mtd))
		return 1;
34805d30:	13a00001 	movne	r0, #1

	*size = mtd->size;
34805d34:	05933008 	ldreq	r3, [r3, #8]
34805d38:	05843000 	streq	r3, [r4]

	return 0;
}
34805d3c:	e8bd801c 	pop	{r2, r3, r4, pc}

34805d40 <device_find>:
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805d40:	e59fc040 	ldr	ip, [pc, #64]	; 34805d88 <device_find+0x48>
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
struct mtd_device *device_find(u8 type, u8 num)
{
34805d44:	e92d4030 	push	{r4, r5, lr}
34805d48:	e1a03000 	mov	r3, r0
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805d4c:	e5bc2004 	ldr	r2, [ip, #4]!
34805d50:	ea000008 	b	34805d78 <device_find+0x38>
		dev_tmp = list_entry(entry, struct mtd_device, link);

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805d54:	e5924008 	ldr	r4, [r2, #8]
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
		dev_tmp = list_entry(entry, struct mtd_device, link);
34805d58:	e1a00002 	mov	r0, r2

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805d5c:	e5d45008 	ldrb	r5, [r4, #8]
34805d60:	e1550003 	cmp	r5, r3
34805d64:	1a000002 	bne	34805d74 <device_find+0x34>
34805d68:	e5d44009 	ldrb	r4, [r4, #9]
34805d6c:	e1540001 	cmp	r4, r1
34805d70:	08bd8030 	popeq	{r4, r5, pc}
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805d74:	e5922000 	ldr	r2, [r2]
34805d78:	e152000c 	cmp	r2, ip
34805d7c:	1afffff4 	bne	34805d54 <device_find+0x14>

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
			return dev_tmp;
	}

	return NULL;
34805d80:	e3a00000 	mov	r0, #0
}
34805d84:	e8bd8030 	pop	{r4, r5, pc}
34805d88:	34829a0c 	.word	0x34829a0c

34805d8c <device_parse>:
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805d8c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34805d90:	e24dd028 	sub	sp, sp, #40	; 0x28
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p;
	const char *pend;
	LIST_HEAD(tmp_list);
34805d94:	e28d301c 	add	r3, sp, #28
34805d98:	e58d301c 	str	r3, [sp, #28]
34805d9c:	e58d3020 	str	r3, [sp, #32]
	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;

	if (ret)
34805da0:	e2517000 	subs	r7, r1, #0
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805da4:	e3a03000 	mov	r3, #0
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805da8:	e58d2010 	str	r2, [sp, #16]
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805dac:	e3a0103a 	mov	r1, #58	; 0x3a
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805db0:	e5823000 	str	r3, [r2]

	if (ret)
		*ret = NULL;
34805db4:	15873000 	strne	r3, [r7]
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805db8:	e1a04000 	mov	r4, r0
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805dbc:	eb00595f 	bl	3481c340 <strchr>
34805dc0:	e2509000 	subs	r9, r0, #0
		printf("no <mtd-id> identifier\n");
34805dc4:	059f04cc 	ldreq	r0, [pc, #1228]	; 34806298 <device_parse+0x50c>
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805dc8:	0a000109 	beq	348061f4 <device_parse+0x468>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805dcc:	e59fa4c8 	ldr	sl, [pc, #1224]	; 3480629c <device_parse+0x510>
	}
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
34805dd0:	e0646009 	rsb	r6, r4, r9
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805dd4:	e5ba5220 	ldr	r5, [sl, #544]!	; 0x220
34805dd8:	ea00000a 	b	34805e08 <device_parse+0x7c>
		id = list_entry(entry, struct mtdids, link);

		debug("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
34805ddc:	e5950010 	ldr	r0, [r5, #16]
34805de0:	eb00596c 	bl	3481c398 <strlen>
34805de4:	e1560000 	cmp	r6, r0
34805de8:	1a000005 	bne	34805e04 <device_parse+0x78>
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
34805dec:	e5950010 	ldr	r0, [r5, #16]
34805df0:	e1a01004 	mov	r1, r4
34805df4:	e1a02006 	mov	r2, r6
34805df8:	eb00593e 	bl	3481c2f8 <strncmp>
34805dfc:	e3500000 	cmp	r0, #0
34805e00:	0a000003 	beq	34805e14 <device_parse+0x88>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805e04:	e5955000 	ldr	r5, [r5]
34805e08:	e155000a 	cmp	r5, sl
34805e0c:	1afffff2 	bne	34805ddc <device_parse+0x50>
34805e10:	ea000006 	b	34805e30 <device_parse+0xa4>

	/* parse partitions */
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805e14:	e5d50008 	ldrb	r0, [r5, #8]
34805e18:	e5d51009 	ldrb	r1, [r5, #9]
34805e1c:	ebffffc7 	bl	34805d40 <device_find>
34805e20:	e3500000 	cmp	r0, #0


	/* parse partitions */
	num_parts = 0;

	offset = 0;
34805e24:	058d0008 	streq	r0, [sp, #8]
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805e28:	1a000005 	bne	34805e44 <device_parse+0xb8>
34805e2c:	ea000009 	b	34805e58 <device_parse+0xcc>
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
34805e30:	e1a01006 	mov	r1, r6
34805e34:	e1a02004 	mov	r2, r4
34805e38:	e59f0460 	ldr	r0, [pc, #1120]	; 348062a0 <device_parse+0x514>
34805e3c:	eb000f21 	bl	34809ac8 <printf>
34805e40:	ea000111 	b	3480628c <device_parse+0x500>
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
34805e44:	e5903014 	ldr	r3, [r0, #20]
		offset = part->offset + part->size;
34805e48:	e5932010 	ldr	r2, [r3, #16]
34805e4c:	e5933014 	ldr	r3, [r3, #20]
34805e50:	e0823003 	add	r3, r2, r3
34805e54:	e58d3008 	str	r3, [sp, #8]
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
	p++;
34805e58:	e3a02000 	mov	r2, #0
34805e5c:	e2896001 	add	r6, r9, #1
34805e60:	e3a00001 	mov	r0, #1
34805e64:	e58d2004 	str	r2, [sp, #4]
34805e68:	e58d7014 	str	r7, [sp, #20]
34805e6c:	ea0000a9 	b	34806118 <device_parse+0x38c>
	const char *name;
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
34805e70:	e58d6024 	str	r6, [sp, #36]	; 0x24
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805e74:	e5d63000 	ldrb	r3, [r6]
34805e78:	e353002d 	cmp	r3, #45	; 0x2d
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
34805e7c:	02866001 	addeq	r6, r6, #1
34805e80:	058d6024 	streq	r6, [sp, #36]	; 0x24

	/* fetch the partition size */
	if (*p == '-') {
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
34805e84:	03e09000 	mvneq	r9, #0
	p = partdef;
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805e88:	0a000008 	beq	34805eb0 <device_parse+0x124>
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805e8c:	e1a00006 	mov	r0, r6
34805e90:	e28d1024 	add	r1, sp, #36	; 0x24
34805e94:	ebfffe20 	bl	3480571c <memsize_parse>
		if (size < MIN_PART_SIZE) {
34805e98:	e3003fff 	movw	r3, #4095	; 0xfff
34805e9c:	e1500003 	cmp	r0, r3
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805ea0:	e1a09000 	mov	r9, r0
		if (size < MIN_PART_SIZE) {
			printf("partition size too small (%lx)\n", size);
34805ea4:	959f03f8 	ldrls	r0, [pc, #1016]	; 348062a4 <device_parse+0x518>
34805ea8:	91a01009 	movls	r1, r9
34805eac:	9a000039 	bls	34805f98 <device_parse+0x20c>
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
34805eb0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805eb4:	e5d03000 	ldrb	r3, [r0]
34805eb8:	e3530040 	cmp	r3, #64	; 0x40
			return 1;
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
34805ebc:	13e0b000 	mvnne	fp, #0
	if (*p == '@') {
34805ec0:	1a000004 	bne	34805ed8 <device_parse+0x14c>
		p++;
34805ec4:	e2800001 	add	r0, r0, #1
		offset = memsize_parse(p, &p);
34805ec8:	e28d1024 	add	r1, sp, #36	; 0x24
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
		p++;
34805ecc:	e58d0024 	str	r0, [sp, #36]	; 0x24
		offset = memsize_parse(p, &p);
34805ed0:	ebfffe11 	bl	3480571c <memsize_parse>
34805ed4:	e1a0b000 	mov	fp, r0
	}

	/* now look for the name */
	if (*p == '(') {
34805ed8:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34805edc:	e5d73000 	ldrb	r3, [r7]
34805ee0:	e3530028 	cmp	r3, #40	; 0x28
			return 1;
		}
		p++;
	} else {
		/* 0x00000000@0x00000000 */
		name_len = 22;
34805ee4:	13a0a016 	movne	sl, #22
		name = NULL;
34805ee8:	13a07000 	movne	r7, #0
		p++;
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
34805eec:	1a00000f 	bne	34805f30 <device_parse+0x1a4>
		name = ++p;
34805ef0:	e2877001 	add	r7, r7, #1
		if ((p = strchr(name, ')')) == NULL) {
34805ef4:	e1a00007 	mov	r0, r7
34805ef8:	e3a01029 	mov	r1, #41	; 0x29
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
		name = ++p;
34805efc:	e58d7024 	str	r7, [sp, #36]	; 0x24
		if ((p = strchr(name, ')')) == NULL) {
34805f00:	eb00590e 	bl	3481c340 <strchr>
34805f04:	e3500000 	cmp	r0, #0
34805f08:	e58d0024 	str	r0, [sp, #36]	; 0x24
			printf("no closing ) found in partition name\n");
34805f0c:	059f0394 	ldreq	r0, [pc, #916]	; 348062a8 <device_parse+0x51c>
34805f10:	0a00002a 	beq	34805fc0 <device_parse+0x234>
			return 1;
		}
		name_len = p - name + 1;
34805f14:	e267a001 	rsb	sl, r7, #1
34805f18:	e080a00a 	add	sl, r0, sl
		if ((name_len - 1) == 0) {
34805f1c:	e35a0001 	cmp	sl, #1
			printf("empty partition name\n");
34805f20:	059f0384 	ldreq	r0, [pc, #900]	; 348062ac <device_parse+0x520>
34805f24:	0a000025 	beq	34805fc0 <device_parse+0x234>
			return 1;
		}
		p++;
34805f28:	e2800001 	add	r0, r0, #1
34805f2c:	e58d0024 	str	r0, [sp, #36]	; 0x24
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
34805f30:	e3a02002 	mov	r2, #2
34805f34:	e59f1374 	ldr	r1, [pc, #884]	; 348062b0 <device_parse+0x524>
34805f38:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805f3c:	eb0058ed 	bl	3481c2f8 <strncmp>
34805f40:	e3500000 	cmp	r0, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
34805f44:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
34805f48:	03a02001 	moveq	r2, #1
		p += 2;
34805f4c:	02833002 	addeq	r3, r3, #2
34805f50:	058d3024 	streq	r3, [sp, #36]	; 0x24
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34805f54:	13a03000 	movne	r3, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34805f58:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
34805f5c:	058d200c 	streq	r2, [sp, #12]
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34805f60:	158d300c 	strne	r3, [sp, #12]
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34805f64:	e5d61000 	ldrb	r1, [r6]
34805f68:	e351002c 	cmp	r1, #44	; 0x2c
34805f6c:	1a000005 	bne	34805f88 <device_parse+0x1fc>
		if (size == SIZE_REMAINING) {
34805f70:	e3790001 	cmn	r9, #1
			*ret = NULL;
			printf("no partitions allowed after a fill-up partition\n");
34805f74:	059f0338 	ldreq	r0, [pc, #824]	; 348062b4 <device_parse+0x528>
34805f78:	0a000010 	beq	34805fc0 <device_parse+0x234>
			return 1;
		}
		*ret = ++p;
34805f7c:	e2866001 	add	r6, r6, #1
34805f80:	e58d6024 	str	r6, [sp, #36]	; 0x24
34805f84:	ea000005 	b	34805fa0 <device_parse+0x214>
	} else if ((*p == ';') || (*p == '\0')) {
34805f88:	e351003b 	cmp	r1, #59	; 0x3b
34805f8c:	13510000 	cmpne	r1, #0
34805f90:	0a000002 	beq	34805fa0 <device_parse+0x214>
		*ret = p;
	} else {
		printf("unexpected character '%c' at the end of partition\n", *p);
34805f94:	e59f031c 	ldr	r0, [pc, #796]	; 348062b8 <device_parse+0x52c>
34805f98:	eb000eca 	bl	34809ac8 <printf>
34805f9c:	ea000067 	b	34806140 <device_parse+0x3b4>
		*ret = NULL;
		return 1;
	}

	/*  allocate memory */
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
34805fa0:	e28a2028 	add	r2, sl, #40	; 0x28
34805fa4:	e1a00002 	mov	r0, r2
34805fa8:	e58d2000 	str	r2, [sp]
34805fac:	eb00108c 	bl	3480a1e4 <malloc>
	if (!part) {
34805fb0:	e2504000 	subs	r4, r0, #0
34805fb4:	e59d2000 	ldr	r2, [sp]
34805fb8:	1a000002 	bne	34805fc8 <device_parse+0x23c>
		printf("out of memory\n");
34805fbc:	e59f02f8 	ldr	r0, [pc, #760]	; 348062bc <device_parse+0x530>
34805fc0:	eb000ec0 	bl	34809ac8 <printf>
34805fc4:	ea00005d 	b	34806140 <device_parse+0x3b4>
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
34805fc8:	e3a01000 	mov	r1, #0
34805fcc:	eb005991 	bl	3481c618 <memset>
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
34805fd0:	e59d200c 	ldr	r2, [sp, #12]
	part->name = (char *)(part + 1);
34805fd4:	e2840028 	add	r0, r4, #40	; 0x28

	if (name) {
34805fd8:	e3570000 	cmp	r7, #0
	if (!part) {
		printf("out of memory\n");
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
34805fdc:	e5849010 	str	r9, [r4, #16]
	part->offset = offset;
34805fe0:	e584b014 	str	fp, [r4, #20]
	part->mask_flags = mask_flags;
34805fe4:	e584201c 	str	r2, [r4, #28]
	part->name = (char *)(part + 1);
34805fe8:	e5840008 	str	r0, [r4, #8]

	if (name) {
34805fec:	0a000005 	beq	34806008 <device_parse+0x27c>
		/* copy user provided name */
		strncpy(part->name, name, name_len - 1);
34805ff0:	e1a01007 	mov	r1, r7
34805ff4:	e24a2001 	sub	r2, sl, #1
34805ff8:	eb005888 	bl	3481c220 <strncpy>
		part->auto_name = 0;
34805ffc:	e3a03000 	mov	r3, #0
34806000:	e5c4300c 	strb	r3, [r4, #12]
34806004:	ea000005 	b	34806020 <device_parse+0x294>
	} else {
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
34806008:	e1a02009 	mov	r2, r9
3480600c:	e59f12ac 	ldr	r1, [pc, #684]	; 348062c0 <device_parse+0x534>
34806010:	e1a0300b 	mov	r3, fp
34806014:	eb005d18 	bl	3481d47c <sprintf>
		part->auto_name = 1;
34806018:	e3a02001 	mov	r2, #1
3480601c:	e5c4200c 	strb	r2, [r4, #12]
	}

	part->name[name_len - 1] = '\0';
34806020:	e5943008 	ldr	r3, [r4, #8]
34806024:	e083a00a 	add	sl, r3, sl
34806028:	e3a03000 	mov	r3, #0
3480602c:	e54a3001 	strb	r3, [sl, #-1]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34806030:	e5947014 	ldr	r7, [r4, #20]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806034:	e5943010 	ldr	r3, [r4, #16]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34806038:	e3770001 	cmn	r7, #1
			part->offset = offset;
3480603c:	059d2008 	ldreq	r2, [sp, #8]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34806040:	e5844000 	str	r4, [r4]
34806044:	05842014 	streq	r2, [r4, #20]
34806048:	01a07002 	moveq	r7, r2
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
3480604c:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
34806050:	0595200c 	ldreq	r2, [r5, #12]
34806054:	05943014 	ldreq	r3, [r4, #20]
	list->prev = list;
34806058:	e5844004 	str	r4, [r4, #4]
3480605c:	00633002 	rsbeq	r3, r3, r2
34806060:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
34806064:	e5942014 	ldr	r2, [r4, #20]
34806068:	e595300c 	ldr	r3, [r5, #12]
3480606c:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34806070:	859f024c 	ldrhi	r0, [pc, #588]	; 348062c4 <device_parse+0x538>
34806074:	85951010 	ldrhi	r1, [r5, #16]
34806078:	8a00000e 	bhi	348060b8 <device_parse+0x32c>
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
3480607c:	e5941010 	ldr	r1, [r4, #16]
34806080:	e0821001 	add	r1, r2, r1
34806084:	e1510002 	cmp	r1, r2
34806088:	8a00000c 	bhi	348060c0 <device_parse+0x334>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
3480608c:	e5d53008 	ldrb	r3, [r5, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806090:	e3530002 	cmp	r3, #2
34806094:	059f122c 	ldreq	r1, [pc, #556]	; 348062c8 <device_parse+0x53c>
34806098:	0a000003 	beq	348060ac <device_parse+0x320>
				MTD_DEV_TYPE(id->type), id->num, part->name);
3480609c:	e59f2228 	ldr	r2, [pc, #552]	; 348062cc <device_parse+0x540>
348060a0:	e3530004 	cmp	r3, #4
348060a4:	e59f1224 	ldr	r1, [pc, #548]	; 348062d0 <device_parse+0x544>
348060a8:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
348060ac:	e59f0220 	ldr	r0, [pc, #544]	; 348062d4 <device_parse+0x548>
348060b0:	e5d52009 	ldrb	r2, [r5, #9]
348060b4:	e5943008 	ldr	r3, [r4, #8]
348060b8:	eb000e82 	bl	34809ac8 <printf>
348060bc:	ea00001f 	b	34806140 <device_parse+0x3b4>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
348060c0:	e1510003 	cmp	r1, r3
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
348060c4:	859f020c 	ldrhi	r0, [pc, #524]	; 348062d8 <device_parse+0x54c>
348060c8:	85951010 	ldrhi	r1, [r5, #16]
348060cc:	8affffb1 	bhi	34805f98 <device_parse+0x20c>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
348060d0:	e1a00005 	mov	r0, r5
348060d4:	e1a01004 	mov	r1, r4
348060d8:	ebfffdc9 	bl	34805804 <part_validate_eraseblock>
			part->offset = offset;
		else
			offset = part->offset;

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
348060dc:	e3500000 	cmp	r0, #0
348060e0:	1a000016 	bne	34806140 <device_parse+0x3b4>
			break;

		offset += part->size;
348060e4:	e5943010 	ldr	r3, [r4, #16]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348060e8:	e28d201c 	add	r2, sp, #28
348060ec:	e0873003 	add	r3, r7, r3
348060f0:	e5842000 	str	r2, [r4]
348060f4:	e58d3008 	str	r3, [sp, #8]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
348060f8:	e59d2004 	ldr	r2, [sp, #4]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348060fc:	e59d3020 	ldr	r3, [sp, #32]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806100:	e58d4020 	str	r4, [sp, #32]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34806104:	e5834000 	str	r4, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34806108:	e5843004 	str	r3, [r4, #4]
3480610c:	e2823001 	add	r3, r2, #1
34806110:	e6ff3073 	uxth	r3, r3
34806114:	e58d3004 	str	r3, [sp, #4]
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
		offset = part->offset + part->size;
	}

	while (p && (*p != '\0') && (*p != ';')) {
34806118:	e3560000 	cmp	r6, #0
3480611c:	0a000004 	beq	34806134 <device_parse+0x3a8>
34806120:	e5d63000 	ldrb	r3, [r6]
34806124:	e3530000 	cmp	r3, #0
34806128:	0a000001 	beq	34806134 <device_parse+0x3a8>
3480612c:	e353003b 	cmp	r3, #59	; 0x3b
34806130:	1affff4e 	bne	34805e70 <device_parse+0xe4>
		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
	}
	if (err == 1) {
34806134:	e3500001 	cmp	r0, #1
34806138:	e59d7014 	ldr	r7, [sp, #20]
3480613c:	1a000002 	bne	3480614c <device_parse+0x3c0>
		part_delall(&tmp_list);
34806140:	e28d001c 	add	r0, sp, #28
34806144:	ebfffd47 	bl	34805668 <part_delall>
34806148:	ea00004f 	b	3480628c <device_parse+0x500>
		return 1;
	}

	if (num_parts == 0) {
3480614c:	e59d3004 	ldr	r3, [sp, #4]
34806150:	e3530000 	cmp	r3, #0
34806154:	1a00000c 	bne	3480618c <device_parse+0x400>
		printf("no partitions for device %s%d (%s)\n",
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806158:	e5d53008 	ldrb	r3, [r5, #8]
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
3480615c:	e3530002 	cmp	r3, #2
34806160:	059f1160 	ldreq	r1, [pc, #352]	; 348062c8 <device_parse+0x53c>
34806164:	0a000003 	beq	34806178 <device_parse+0x3ec>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806168:	e59f215c 	ldr	r2, [pc, #348]	; 348062cc <device_parse+0x540>
3480616c:	e3530004 	cmp	r3, #4
34806170:	e59f1158 	ldr	r1, [pc, #344]	; 348062d0 <device_parse+0x544>
34806174:	01a01002 	moveq	r1, r2
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
34806178:	e5d52009 	ldrb	r2, [r5, #9]
3480617c:	e5953010 	ldr	r3, [r5, #16]
34806180:	e59f0154 	ldr	r0, [pc, #340]	; 348062dc <device_parse+0x550>
34806184:	eb000e4f 	bl	34809ac8 <printf>
34806188:	ea00003f 	b	3480628c <device_parse+0x500>
	}

	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
3480618c:	e3560000 	cmp	r6, #0
34806190:	0a000012 	beq	348061e0 <device_parse+0x454>
		if (*p == ';') {
34806194:	e5d61000 	ldrb	r1, [r6]
34806198:	e351003b 	cmp	r1, #59	; 0x3b
3480619c:	1a000003 	bne	348061b0 <device_parse+0x424>
			if (ret)
348061a0:	e3570000 	cmp	r7, #0
				*ret = ++p;
348061a4:	12866001 	addne	r6, r6, #1
	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
			if (ret)
348061a8:	1a000004 	bne	348061c0 <device_parse+0x434>
348061ac:	ea00000b 	b	348061e0 <device_parse+0x454>
				*ret = ++p;
		} else if (*p == '\0') {
348061b0:	e3510000 	cmp	r1, #0
348061b4:	1a000003 	bne	348061c8 <device_parse+0x43c>
			if (ret)
348061b8:	e3570000 	cmp	r7, #0
348061bc:	0a000007 	beq	348061e0 <device_parse+0x454>
				*ret = p;
348061c0:	e5876000 	str	r6, [r7]
348061c4:	ea000005 	b	348061e0 <device_parse+0x454>
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
348061c8:	e59f0110 	ldr	r0, [pc, #272]	; 348062e0 <device_parse+0x554>
348061cc:	eb000e3d 	bl	34809ac8 <printf>
			if (ret)
348061d0:	e3570000 	cmp	r7, #0
				*ret = NULL;
348061d4:	13a03000 	movne	r3, #0
348061d8:	15873000 	strne	r3, [r7]
348061dc:	ea00002a 	b	3480628c <device_parse+0x500>
			return 1;
		}
	}

	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
348061e0:	e3a00018 	mov	r0, #24
348061e4:	eb000ffe 	bl	3480a1e4 <malloc>
348061e8:	e2504000 	subs	r4, r0, #0
348061ec:	1a000002 	bne	348061fc <device_parse+0x470>
		printf("out of memory\n");
348061f0:	e59f00c4 	ldr	r0, [pc, #196]	; 348062bc <device_parse+0x530>
348061f4:	eb000e33 	bl	34809ac8 <printf>
348061f8:	ea000023 	b	3480628c <device_parse+0x500>
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
348061fc:	e3a01000 	mov	r1, #0
34806200:	e3a02018 	mov	r2, #24
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806204:	e28d6028 	add	r6, sp, #40	; 0x28
	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
34806208:	eb005902 	bl	3481c618 <memset>
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
3480620c:	e2843010 	add	r3, r4, #16
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806210:	e536100c 	ldr	r1, [r6, #-12]!
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34806214:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34806218:	e5843010 	str	r3, [r4, #16]
3480621c:	e5844000 	str	r4, [r4]
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
34806220:	e5845008 	str	r5, [r4, #8]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34806224:	e1c420bc 	strh	r2, [r4, #12]
	list->prev = list;
34806228:	e5843014 	str	r3, [r4, #20]
3480622c:	e5844004 	str	r4, [r4, #4]
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806230:	e5915000 	ldr	r5, [r1]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806234:	e3a07000 	mov	r7, #0
34806238:	ea00000d 	b	34806274 <device_parse+0x4e8>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
3480623c:	e891000c 	ldm	r1, {r2, r3}
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
34806240:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34806244:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34806248:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
3480624c:	e5817004 	str	r7, [r1, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806250:	e5817000 	str	r7, [r1]
34806254:	ebfffcb8 	bl	3480553c <part_sort_add>
34806258:	e3500000 	cmp	r0, #0
3480625c:	0a000002 	beq	3480626c <device_parse+0x4e0>
			device_del(dev);
34806260:	e1a00004 	mov	r0, r4
34806264:	ebfffd10 	bl	348056ac <device_del>
34806268:	ea000007 	b	3480628c <device_parse+0x500>
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
3480626c:	e1a01005 	mov	r1, r5
34806270:	e5955000 	ldr	r5, [r5]
34806274:	e1510006 	cmp	r1, r6
34806278:	1affffef 	bne	3480623c <device_parse+0x4b0>
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
3480627c:	e59d3010 	ldr	r3, [sp, #16]

	debug("===\n\n");
	return 0;
34806280:	e3a00000 	mov	r0, #0
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
34806284:	e5834000 	str	r4, [r3]

	debug("===\n\n");
	return 0;
34806288:	ea000000 	b	34806290 <device_parse+0x504>
				*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
			if (ret)
				*ret = NULL;
			return 1;
3480628c:	e3a00001 	mov	r0, #1

	*retdev = dev;

	debug("===\n\n");
	return 0;
}
34806290:	e28dd028 	add	sp, sp, #40	; 0x28
34806294:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34806298:	34824830 	.word	0x34824830
3480629c:	34829a0c 	.word	0x34829a0c
348062a0:	34824521 	.word	0x34824521
348062a4:	3482453c 	.word	0x3482453c
348062a8:	3482455c 	.word	0x3482455c
348062ac:	34824582 	.word	0x34824582
348062b0:	34824598 	.word	0x34824598
348062b4:	3482459b 	.word	0x3482459b
348062b8:	348245cc 	.word	0x348245cc
348062bc:	348245ff 	.word	0x348245ff
348062c0:	3482460e 	.word	0x3482460e
348062c4:	3482461e 	.word	0x3482461e
348062c8:	3482479d 	.word	0x3482479d
348062cc:	3482479a 	.word	0x3482479a
348062d0:	348243cc 	.word	0x348243cc
348062d4:	34824646 	.word	0x34824646
348062d8:	34824669 	.word	0x34824669
348062dc:	3482468e 	.word	0x3482468e
348062e0:	348246b2 	.word	0x348246b2

348062e4 <mtd_id_parse>:
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062e4:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348062e8:	e1a07003 	mov	r7, r3
	const char *p = id;

	*dev_type = 0;
348062ec:	e3a03000 	mov	r3, #0
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
	const char *p = id;
348062f0:	e58d0004 	str	r0, [sp, #4]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062f4:	e1a05001 	mov	r5, r1
	const char *p = id;

	*dev_type = 0;
348062f8:	e5c23000 	strb	r3, [r2]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062fc:	e1a04002 	mov	r4, r2
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
34806300:	e59f10d4 	ldr	r1, [pc, #212]	; 348063dc <mtd_id_parse+0xf8>
34806304:	e3a02004 	mov	r2, #4
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
34806308:	e1a06000 	mov	r6, r0
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
3480630c:	eb0057f9 	bl	3481c2f8 <strncmp>
34806310:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NAND;
34806314:	03a03002 	moveq	r3, #2
34806318:	05c43000 	strbeq	r3, [r4]
		p += 4;
3480631c:	059d3004 	ldreq	r3, [sp, #4]
34806320:	02833004 	addeq	r3, r3, #4
34806324:	0a000013 	beq	34806378 <mtd_id_parse+0x94>
	} else if (strncmp(p, "nor", 3) == 0) {
34806328:	e59d0004 	ldr	r0, [sp, #4]
3480632c:	e59f10ac 	ldr	r1, [pc, #172]	; 348063e0 <mtd_id_parse+0xfc>
34806330:	e3a02003 	mov	r2, #3
34806334:	eb0057ef 	bl	3481c2f8 <strncmp>
34806338:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NOR;
3480633c:	03a03001 	moveq	r3, #1
34806340:	05c43000 	strbeq	r3, [r4]
		p += 3;
34806344:	059d3004 	ldreq	r3, [sp, #4]
34806348:	02833003 	addeq	r3, r3, #3
3480634c:	0a000009 	beq	34806378 <mtd_id_parse+0x94>
	} else if (strncmp(p, "onenand", 7) == 0) {
34806350:	e59d0004 	ldr	r0, [sp, #4]
34806354:	e59f1088 	ldr	r1, [pc, #136]	; 348063e4 <mtd_id_parse+0x100>
34806358:	e3a02007 	mov	r2, #7
3480635c:	eb0057e5 	bl	3481c2f8 <strncmp>
34806360:	e3500000 	cmp	r0, #0
34806364:	1a00000b 	bne	34806398 <mtd_id_parse+0xb4>
		*dev_type = MTD_DEV_TYPE_ONENAND;
34806368:	e3a03004 	mov	r3, #4
3480636c:	e5c43000 	strb	r3, [r4]
		p += 7;
34806370:	e59d3004 	ldr	r3, [sp, #4]
34806374:	e2833007 	add	r3, r3, #7
34806378:	e58d3004 	str	r3, [sp, #4]
	} else {
		printf("incorrect device type in %s\n", id);
		return 1;
	}

	if (!isdigit(*p)) {
3480637c:	e59d0004 	ldr	r0, [sp, #4]
34806380:	e59f2060 	ldr	r2, [pc, #96]	; 348063e8 <mtd_id_parse+0x104>
34806384:	e5d03000 	ldrb	r3, [r0]
34806388:	e7d23003 	ldrb	r3, [r2, r3]
3480638c:	e3130004 	tst	r3, #4
34806390:	1a000007 	bne	348063b4 <mtd_id_parse+0xd0>
34806394:	ea000001 	b	348063a0 <mtd_id_parse+0xbc>
		p += 3;
	} else if (strncmp(p, "onenand", 7) == 0) {
		*dev_type = MTD_DEV_TYPE_ONENAND;
		p += 7;
	} else {
		printf("incorrect device type in %s\n", id);
34806398:	e59f004c 	ldr	r0, [pc, #76]	; 348063ec <mtd_id_parse+0x108>
3480639c:	ea000000 	b	348063a4 <mtd_id_parse+0xc0>
		return 1;
	}

	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
348063a0:	e59f0048 	ldr	r0, [pc, #72]	; 348063f0 <mtd_id_parse+0x10c>
348063a4:	e1a01006 	mov	r1, r6
348063a8:	eb000dc6 	bl	34809ac8 <printf>
		return 1;
348063ac:	e3a00001 	mov	r0, #1
348063b0:	ea000008 	b	348063d8 <mtd_id_parse+0xf4>
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
348063b4:	e28d1004 	add	r1, sp, #4
348063b8:	e3a02000 	mov	r2, #0
348063bc:	eb005b88 	bl	3481d1e4 <simple_strtoul>
	if (ret_id)
348063c0:	e3550000 	cmp	r5, #0
		*ret_id = p;
348063c4:	159d3004 	ldrne	r3, [sp, #4]
	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
		return 1;
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
348063c8:	e5c70000 	strb	r0, [r7]
	if (ret_id)
		*ret_id = p;
348063cc:	15853000 	strne	r3, [r5]
	return 0;
348063d0:	13a00000 	movne	r0, #0
348063d4:	01a00005 	moveq	r0, r5
}
348063d8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
348063dc:	3482479d 	.word	0x3482479d
348063e0:	348243cc 	.word	0x348243cc
348063e4:	3482479a 	.word	0x3482479a
348063e8:	34821cf4 	.word	0x34821cf4
348063ec:	348246e2 	.word	0x348246e2
348063f0:	348246ff 	.word	0x348246ff

348063f4 <find_dev_and_part>:
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348063f4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348063f8:	e59fb18c 	ldr	fp, [pc, #396]	; 3480658c <find_dev_and_part+0x198>
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348063fc:	e1a0a003 	mov	sl, r3
34806400:	e1a07000 	mov	r7, r0
34806404:	e1a05001 	mov	r5, r1
34806408:	e1a04002 	mov	r4, r2
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
3480640c:	e5bb6004 	ldr	r6, [fp, #4]!
		*part_num = 0;
34806410:	e3a03000 	mov	r3, #0
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34806414:	ea000014 	b	3480646c <find_dev_and_part+0x78>
		*part_num = 0;
34806418:	e5c43000 	strb	r3, [r4]
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
3480641c:	e5969010 	ldr	r9, [r6, #16]

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
34806420:	e5856000 	str	r6, [r5]
		list_for_each(pentry, &(*dev)->parts) {
34806424:	ea00000b 	b	34806458 <find_dev_and_part+0x64>
			*part = list_entry(pentry, struct part_info, link);
			if (strcmp((*part)->name, id) == 0)
34806428:	e5990008 	ldr	r0, [r9, #8]

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
			*part = list_entry(pentry, struct part_info, link);
3480642c:	e58a9000 	str	r9, [sl]
			if (strcmp((*part)->name, id) == 0)
34806430:	e1a01007 	mov	r1, r7
34806434:	e58d3004 	str	r3, [sp, #4]
34806438:	eb0057a2 	bl	3481c2c8 <strcmp>
3480643c:	e3500000 	cmp	r0, #0
34806440:	e59d3004 	ldr	r3, [sp, #4]
34806444:	0a00004e 	beq	34806584 <find_dev_and_part+0x190>
				return 0;
			(*part_num)++;
34806448:	e5d42000 	ldrb	r2, [r4]
3480644c:	e2822001 	add	r2, r2, #1
34806450:	e5c42000 	strb	r2, [r4]
	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
34806454:	e5999000 	ldr	r9, [r9]
34806458:	e5952000 	ldr	r2, [r5]
3480645c:	e2822010 	add	r2, r2, #16
34806460:	e1590002 	cmp	r9, r2
34806464:	1affffef 	bne	34806428 <find_dev_and_part+0x34>
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34806468:	e5966000 	ldr	r6, [r6]
3480646c:	e156000b 	cmp	r6, fp
34806470:	1affffe8 	bne	34806418 <find_dev_and_part+0x24>
				return 0;
			(*part_num)++;
		}
	}

	p = id;
34806474:	e28d6010 	add	r6, sp, #16
34806478:	e5267008 	str	r7, [r6, #-8]!
	*dev = NULL;
3480647c:	e3a03000 	mov	r3, #0
34806480:	e5853000 	str	r3, [r5]
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34806484:	e28d200f 	add	r2, sp, #15
		}
	}

	p = id;
	*dev = NULL;
	*part = NULL;
34806488:	e58a3000 	str	r3, [sl]
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
3480648c:	e1a00007 	mov	r0, r7
	}

	p = id;
	*dev = NULL;
	*part = NULL;
	*part_num = 0;
34806490:	e5c43000 	strb	r3, [r4]

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34806494:	e1a01006 	mov	r1, r6
34806498:	e28d300e 	add	r3, sp, #14
3480649c:	ebffff90 	bl	348062e4 <mtd_id_parse>
348064a0:	e2502000 	subs	r2, r0, #0
348064a4:	1a000035 	bne	34806580 <find_dev_and_part+0x18c>
		return 1;

	if ((*p++ != ',') || (*p == '\0')) {
348064a8:	e59d3008 	ldr	r3, [sp, #8]
348064ac:	e1a00003 	mov	r0, r3
348064b0:	e4d01001 	ldrb	r1, [r0], #1
348064b4:	e351002c 	cmp	r1, #44	; 0x2c
348064b8:	e58d0008 	str	r0, [sp, #8]
348064bc:	1a000002 	bne	348064cc <find_dev_and_part+0xd8>
348064c0:	e5d33001 	ldrb	r3, [r3, #1]
348064c4:	e3530000 	cmp	r3, #0
348064c8:	1a000002 	bne	348064d8 <find_dev_and_part+0xe4>
		printf("no partition number specified\n");
348064cc:	e59f00bc 	ldr	r0, [pc, #188]	; 34806590 <find_dev_and_part+0x19c>
348064d0:	eb000d7c 	bl	34809ac8 <printf>
348064d4:	ea000029 	b	34806580 <find_dev_and_part+0x18c>
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
348064d8:	e1a01006 	mov	r1, r6
348064dc:	eb005b40 	bl	3481d1e4 <simple_strtoul>
	if (*p != '\0') {
348064e0:	e59d3008 	ldr	r3, [sp, #8]

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
348064e4:	e1a0b000 	mov	fp, r0
	if (*p != '\0') {
348064e8:	e5d36000 	ldrb	r6, [r3]
348064ec:	e3560000 	cmp	r6, #0
348064f0:	0a000003 	beq	34806504 <find_dev_and_part+0x110>
		printf("unexpected trailing character '%c'\n", *p);
348064f4:	e1a01006 	mov	r1, r6
348064f8:	e59f0094 	ldr	r0, [pc, #148]	; 34806594 <find_dev_and_part+0x1a0>
348064fc:	eb000d71 	bl	34809ac8 <printf>
34806500:	ea00001e 	b	34806580 <find_dev_and_part+0x18c>
		return 1;
	}

	if ((*dev = device_find(type, dnum)) == NULL) {
34806504:	e5dd700f 	ldrb	r7, [sp, #15]
34806508:	e5dd900e 	ldrb	r9, [sp, #14]
3480650c:	e1a00007 	mov	r0, r7
34806510:	e1a01009 	mov	r1, r9
34806514:	ebfffe09 	bl	34805d40 <device_find>
34806518:	e3500000 	cmp	r0, #0
3480651c:	e5850000 	str	r0, [r5]
34806520:	1a00000a 	bne	34806550 <find_dev_and_part+0x15c>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
34806524:	e3570002 	cmp	r7, #2
34806528:	059f1068 	ldreq	r1, [pc, #104]	; 34806598 <find_dev_and_part+0x1a4>
3480652c:	0a000003 	beq	34806540 <find_dev_and_part+0x14c>
34806530:	e59f3064 	ldr	r3, [pc, #100]	; 3480659c <find_dev_and_part+0x1a8>
34806534:	e3570004 	cmp	r7, #4
34806538:	e59f1060 	ldr	r1, [pc, #96]	; 348065a0 <find_dev_and_part+0x1ac>
3480653c:	01a01003 	moveq	r1, r3
34806540:	e1a02009 	mov	r2, r9
34806544:	e59f0058 	ldr	r0, [pc, #88]	; 348065a4 <find_dev_and_part+0x1b0>
34806548:	eb000d5e 	bl	34809ac8 <printf>
3480654c:	ea00000b 	b	34806580 <find_dev_and_part+0x18c>

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34806550:	e6ef707b 	uxtb	r7, fp
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34806554:	e1a01007 	mov	r1, r7
34806558:	ebfffb62 	bl	348052e8 <mtd_part_info>
3480655c:	e3500000 	cmp	r0, #0
34806560:	e58a0000 	str	r0, [sl]
34806564:	e1a09000 	mov	r9, r0
		printf("no such partition\n");
		*dev = NULL;
		return 1;
	}

	*part_num = pnum;
34806568:	15c47000 	strbne	r7, [r4]

	return 0;
3480656c:	11a00006 	movne	r0, r6
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34806570:	1a000003 	bne	34806584 <find_dev_and_part+0x190>
		printf("no such partition\n");
34806574:	e59f002c 	ldr	r0, [pc, #44]	; 348065a8 <find_dev_and_part+0x1b4>
34806578:	eb000d52 	bl	34809ac8 <printf>
		*dev = NULL;
3480657c:	e5859000 	str	r9, [r5]
	*dev = NULL;
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
		return 1;
34806580:	e3a00001 	mov	r0, #1
	}

	*part_num = pnum;

	return 0;
}
34806584:	e28dd010 	add	sp, sp, #16
34806588:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480658c:	34829a0c 	.word	0x34829a0c
34806590:	3482471e 	.word	0x3482471e
34806594:	3482473d 	.word	0x3482473d
34806598:	3482479d 	.word	0x3482479d
3480659c:	3482479a 	.word	0x3482479a
348065a0:	348243cc 	.word	0x348243cc
348065a4:	34824761 	.word	0x34824761
348065a8:	34824776 	.word	0x34824776

348065ac <mtdparts_init>:
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
348065ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
348065b0:	e59f4594 	ldr	r4, [pc, #1428]	; 34806b4c <mtdparts_init+0x5a0>
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
348065b4:	e24dd028 	sub	sp, sp, #40	; 0x28
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
348065b8:	e5945228 	ldr	r5, [r4, #552]	; 0x228
348065bc:	e3550000 	cmp	r5, #0
348065c0:	1a000013 	bne	34806614 <mtdparts_init+0x68>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348065c4:	e2843e22 	add	r3, r4, #544	; 0x220
348065c8:	e5843220 	str	r3, [r4, #544]	; 0x220
	list->prev = list;
348065cc:	e5843224 	str	r3, [r4, #548]	; 0x224
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348065d0:	e2843004 	add	r3, r4, #4
348065d4:	e5843004 	str	r3, [r4, #4]
	list->prev = list;
348065d8:	e5843008 	str	r3, [r4, #8]
		INIT_LIST_HEAD(&mtdids);
		INIT_LIST_HEAD(&devices);
		memset(last_ids, 0, MTDIDS_MAXLEN);
348065dc:	e1a01005 	mov	r1, r5
348065e0:	e3a02080 	mov	r2, #128	; 0x80
348065e4:	e2840f8b 	add	r0, r4, #556	; 0x22c
348065e8:	eb00580a 	bl	3481c618 <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
348065ec:	e1a01005 	mov	r1, r5
348065f0:	e3a02c02 	mov	r2, #512	; 0x200
348065f4:	e2840020 	add	r0, r4, #32
348065f8:	eb005806 	bl	3481c618 <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
348065fc:	e2840010 	add	r0, r4, #16
34806600:	e1a01005 	mov	r1, r5
34806604:	e3a02010 	mov	r2, #16
34806608:	eb005802 	bl	3481c618 <memset>
		initialized = 1;
3480660c:	e3a03001 	mov	r3, #1
34806610:	e5843228 	str	r3, [r4, #552]	; 0x228
	}

	/* get variables */
	ids = getenv("mtdids");
34806614:	e59f0534 	ldr	r0, [pc, #1332]	; 34806b50 <mtdparts_init+0x5a4>
34806618:	eb00063c 	bl	34807f10 <getenv>
3480661c:	e1a05000 	mov	r5, r0
	parts = getenv("mtdparts");
34806620:	e59f052c 	ldr	r0, [pc, #1324]	; 34806b54 <mtdparts_init+0x5a8>
34806624:	eb000639 	bl	34807f10 <getenv>
34806628:	e1a04000 	mov	r4, r0
	current_partition = getenv("partition");
3480662c:	e59f0524 	ldr	r0, [pc, #1316]	; 34806b58 <mtdparts_init+0x5ac>
34806630:	eb000636 	bl	34807f10 <getenv>

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
34806634:	e3a03000 	mov	r3, #0
	if (current_partition)
34806638:	e2501000 	subs	r1, r0, #0
	parts = getenv("mtdparts");
	current_partition = getenv("partition");

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
3480663c:	e5cd3004 	strb	r3, [sp, #4]
	if (current_partition)
34806640:	0a000002 	beq	34806650 <mtdparts_init+0xa4>
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
34806644:	e28d0004 	add	r0, sp, #4
34806648:	e3a02010 	mov	r2, #16
3480664c:	eb0056f3 	bl	3481c220 <strncpy>

	debug("last_partition : %s\n", last_partition);
	debug("env_partition  : %s\n", current_partition);

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
34806650:	e3550000 	cmp	r5, #0
34806654:	1a000003 	bne	34806668 <mtdparts_init+0xbc>
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
			setenv("mtdids", (char *)ids);
34806658:	e59f04f0 	ldr	r0, [pc, #1264]	; 34806b50 <mtdparts_init+0x5a4>
3480665c:	e59f14f8 	ldr	r1, [pc, #1272]	; 34806b5c <mtdparts_init+0x5b0>
34806660:	eb000522 	bl	34807af0 <setenv>

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
34806664:	e59f54f0 	ldr	r5, [pc, #1264]	; 34806b5c <mtdparts_init+0x5b0>
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34806668:	e1a00005 	mov	r0, r5
3480666c:	eb005749 	bl	3481c398 <strlen>
34806670:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
34806674:	859f04e4 	ldrhi	r0, [pc, #1252]	; 34806b60 <mtdparts_init+0x5b4>
34806678:	83a01080 	movhi	r1, #128	; 0x80
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
3480667c:	8a00000a 	bhi	348066ac <mtdparts_init+0x100>
		return 1;
	}

	/* do no try to use defaults when mtdparts variable is not defined,
	 * just check the length */
	if (!parts)
34806680:	e3540000 	cmp	r4, #0
34806684:	1a000002 	bne	34806694 <mtdparts_init+0xe8>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
34806688:	e59f04d4 	ldr	r0, [pc, #1236]	; 34806b64 <mtdparts_init+0x5b8>
3480668c:	eb000d0d 	bl	34809ac8 <printf>
34806690:	ea000008 	b	348066b8 <mtdparts_init+0x10c>

	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
34806694:	e1a00004 	mov	r0, r4
34806698:	eb00573e 	bl	3481c398 <strlen>
3480669c:	e3500c02 	cmp	r0, #512	; 0x200
348066a0:	3a000004 	bcc	348066b8 <mtdparts_init+0x10c>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
348066a4:	e59f04bc 	ldr	r0, [pc, #1212]	; 34806b68 <mtdparts_init+0x5bc>
348066a8:	e3a01c02 	mov	r1, #512	; 0x200
348066ac:	eb000d05 	bl	34809ac8 <printf>
		return 1;
348066b0:	e3a00001 	mov	r0, #1
348066b4:	ea00010c 	b	34806aec <mtdparts_init+0x540>
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
348066b8:	e59f048c 	ldr	r0, [pc, #1164]	; 34806b4c <mtdparts_init+0x5a0>
348066bc:	e5d0322c 	ldrb	r3, [r0, #556]	; 0x22c
348066c0:	e3530000 	cmp	r3, #0
348066c4:	0a000005 	beq	348066e0 <mtdparts_init+0x134>
348066c8:	e1a01005 	mov	r1, r5
348066cc:	e2800f8b 	add	r0, r0, #556	; 0x22c
348066d0:	eb0056fc 	bl	3481c2c8 <strcmp>
348066d4:	e3500000 	cmp	r0, #0
		ids_changed = 0;
348066d8:	01a05000 	moveq	r5, r0
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
348066dc:	0a000088 	beq	34806904 <mtdparts_init+0x358>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348066e0:	e59f7464 	ldr	r7, [pc, #1124]	; 34806b4c <mtdparts_init+0x5a0>
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdids(const char *const ids)
{
	const char *p = ids;
348066e4:	e58d5018 	str	r5, [sp, #24]
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348066e8:	e5b70220 	ldr	r0, [r7, #544]!	; 0x220
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348066ec:	e3a0a000 	mov	sl, #0
348066f0:	e5906000 	ldr	r6, [r0]
348066f4:	ea000007 	b	34806718 <mtdparts_init+0x16c>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348066f8:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348066fc:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34806700:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34806704:	e580a004 	str	sl, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806708:	e580a000 	str	sl, [r0]
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
3480670c:	eb000e2b 	bl	34809fc0 <free>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34806710:	e1a00006 	mov	r0, r6
34806714:	e5966000 	ldr	r6, [r6]
34806718:	e1500007 	cmp	r0, r7
3480671c:	e59f9428 	ldr	r9, [pc, #1064]	; 34806b4c <mtdparts_init+0x5a0>
34806720:	1afffff4 	bne	348066f8 <mtdparts_init+0x14c>
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
34806724:	e3a03000 	mov	r3, #0
34806728:	e5c9322c 	strb	r3, [r9, #556]	; 0x22c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480672c:	e5890220 	str	r0, [r9, #544]	; 0x220
	list->prev = list;
34806730:	e5890224 	str	r0, [r9, #548]	; 0x224
	struct mtdids *id;
	struct list_head *entry, *n;
	struct mtdids *id_tmp;
	u8 type, num;
	u32 size;
	int ret = 1;
34806734:	e2833001 	add	r3, r3, #1
34806738:	e1a0a005 	mov	sl, r5
3480673c:	ea000057 	b	348068a0 <mtdparts_init+0x2f4>

	while(p && (*p != '\0')) {

		ret = 1;
		/* parse 'nor'|'nand'|'onenand'<dev-num> */
		if (mtd_id_parse(p, &p, &type, &num) != 0)
34806740:	e28d1018 	add	r1, sp, #24
34806744:	e28d2027 	add	r2, sp, #39	; 0x27
34806748:	e28d3020 	add	r3, sp, #32
3480674c:	ebfffee4 	bl	348062e4 <mtd_id_parse>
34806750:	e3500000 	cmp	r0, #0
34806754:	1a000059 	bne	348068c0 <mtdparts_init+0x314>
			break;

		if (*p != '=') {
34806758:	e59d3018 	ldr	r3, [sp, #24]
3480675c:	e5d32000 	ldrb	r2, [r3]
34806760:	e352003d 	cmp	r2, #61	; 0x3d
			printf("mtdids: incorrect <dev-num>\n");
34806764:	159f0400 	ldrne	r0, [pc, #1024]	; 34806b6c <mtdparts_init+0x5c0>
34806768:	1a000032 	bne	34806838 <mtdparts_init+0x28c>
			break;
		}
		p++;
3480676c:	e2833001 	add	r3, r3, #1

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806770:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
34806774:	e5dd1020 	ldrb	r1, [sp, #32]
34806778:	e28d201c 	add	r2, sp, #28

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
3480677c:	e58d3018 	str	r3, [sp, #24]

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806780:	ebfffd62 	bl	34805d10 <mtd_device_validate>
34806784:	e3500000 	cmp	r0, #0
34806788:	1a00005b 	bne	348068fc <mtdparts_init+0x350>
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
3480678c:	e59d7018 	ldr	r7, [sp, #24]
		if ((p = strchr(mtd_id, ',')) != NULL) {
34806790:	e3a0102c 	mov	r1, #44	; 0x2c
34806794:	e1a00007 	mov	r0, r7
34806798:	eb0056e8 	bl	3481c340 <strchr>
3480679c:	e3500000 	cmp	r0, #0
348067a0:	e58d0018 	str	r0, [sp, #24]
			mtd_id_len = p - mtd_id + 1;
348067a4:	12676001 	rsbne	r6, r7, #1
348067a8:	10806006 	addne	r6, r0, r6
			p++;
348067ac:	12800001 	addne	r0, r0, #1
348067b0:	158d0018 	strne	r0, [sp, #24]
348067b4:	1a000002 	bne	348067c4 <mtdparts_init+0x218>
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
348067b8:	e1a00007 	mov	r0, r7
348067bc:	eb0056f5 	bl	3481c398 <strlen>
348067c0:	e2806001 	add	r6, r0, #1
		}
		if (mtd_id_len == 0) {
348067c4:	e3560000 	cmp	r6, #0
			printf("mtdids: no <mtd-id> identifier\n");
348067c8:	059f03a0 	ldreq	r0, [pc, #928]	; 34806b70 <mtdparts_init+0x5c4>
348067cc:	0a000019 	beq	34806838 <mtdparts_init+0x28c>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
348067d0:	e5993220 	ldr	r3, [r9, #544]	; 0x220
			id_tmp = list_entry(entry, struct mtdids, link);
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
348067d4:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
348067d8:	e5dd1020 	ldrb	r1, [sp, #32]
348067dc:	ea000006 	b	348067fc <mtdparts_init+0x250>
348067e0:	e5d32008 	ldrb	r2, [r3, #8]
348067e4:	e1520000 	cmp	r2, r0
348067e8:	1a000002 	bne	348067f8 <mtdparts_init+0x24c>
348067ec:	e5d32009 	ldrb	r2, [r3, #9]
348067f0:	e1520001 	cmp	r2, r1
348067f4:	0a000004 	beq	3480680c <mtdparts_init+0x260>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
348067f8:	e5933000 	ldr	r3, [r3]
348067fc:	e59f2370 	ldr	r2, [pc, #880]	; 34806b74 <mtdparts_init+0x5c8>
34806800:	e1530002 	cmp	r3, r2
34806804:	1afffff5 	bne	348067e0 <mtdparts_init+0x234>
34806808:	ea0000b9 	b	34806af4 <mtdparts_init+0x548>
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
3480680c:	e3500002 	cmp	r0, #2
34806810:	059f1360 	ldreq	r1, [pc, #864]	; 34806b78 <mtdparts_init+0x5cc>
34806814:	0a000003 	beq	34806828 <mtdparts_init+0x27c>
					MTD_DEV_TYPE(type), num);
34806818:	e59f335c 	ldr	r3, [pc, #860]	; 34806b7c <mtdparts_init+0x5d0>
3480681c:	e3500004 	cmp	r0, #4
34806820:	e59f1358 	ldr	r1, [pc, #856]	; 34806b80 <mtdparts_init+0x5d4>
34806824:	01a01003 	moveq	r1, r3
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
34806828:	e59f0354 	ldr	r0, [pc, #852]	; 34806b84 <mtdparts_init+0x5d8>
3480682c:	eb000ca5 	bl	34809ac8 <printf>
34806830:	ea000022 	b	348068c0 <mtdparts_init+0x314>
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
34806834:	e59f034c 	ldr	r0, [pc, #844]	; 34806b88 <mtdparts_init+0x5dc>
34806838:	eb000ca2 	bl	34809ac8 <printf>
3480683c:	ea00001f 	b	348068c0 <mtdparts_init+0x314>
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
34806840:	e3a01000 	mov	r1, #0
34806844:	e1a0200b 	mov	r2, fp
34806848:	eb005772 	bl	3481c618 <memset>
		id->num = num;
3480684c:	e5dd3020 	ldrb	r3, [sp, #32]
		id->type = type;
		id->size = size;
		id->mtd_id = (char *)(id + 1);
34806850:	e2850014 	add	r0, r5, #20
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
34806854:	e5c53009 	strb	r3, [r5, #9]
		id->type = type;
34806858:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
		id->size = size;
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
3480685c:	e2462001 	sub	r2, r6, #1
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
34806860:	e5c53008 	strb	r3, [r5, #8]
		id->size = size;
34806864:	e59d301c 	ldr	r3, [sp, #28]
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806868:	e1a01007 	mov	r1, r7
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
		id->size = size;
3480686c:	e585300c 	str	r3, [r5, #12]
		id->mtd_id = (char *)(id + 1);
34806870:	e5850010 	str	r0, [r5, #16]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806874:	eb005669 	bl	3481c220 <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
34806878:	e5953010 	ldr	r3, [r5, #16]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480687c:	e59f12c8 	ldr	r1, [pc, #712]	; 34806b4c <mtdparts_init+0x5a0>
34806880:	e0836006 	add	r6, r3, r6
34806884:	e3a03000 	mov	r3, #0
34806888:	e5463001 	strb	r3, [r6, #-1]
3480688c:	e5912224 	ldr	r2, [r1, #548]	; 0x224
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806890:	e5815224 	str	r5, [r1, #548]	; 0x224
	new->next = next;
34806894:	e59f12d8 	ldr	r1, [pc, #728]	; 34806b74 <mtdparts_init+0x5c8>
	new->prev = prev;
34806898:	e8850006 	stm	r5, {r1, r2}
	prev->next = new;
3480689c:	e5825000 	str	r5, [r2]
		free(id_tmp);
	}
	last_ids[0] = '\0';
	INIT_LIST_HEAD(&mtdids);

	while(p && (*p != '\0')) {
348068a0:	e59d0018 	ldr	r0, [sp, #24]
348068a4:	e3500000 	cmp	r0, #0
348068a8:	0a000002 	beq	348068b8 <mtdparts_init+0x30c>
348068ac:	e5d02000 	ldrb	r2, [r0]
348068b0:	e3520000 	cmp	r2, #0
348068b4:	1affffa1 	bne	34806740 <mtdparts_init+0x194>
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
348068b8:	e3530001 	cmp	r3, #1
348068bc:	1a000092 	bne	34806b0c <mtdparts_init+0x560>
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
348068c0:	e59f5284 	ldr	r5, [pc, #644]	; 34806b4c <mtdparts_init+0x5a0>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348068c4:	e3a06000 	mov	r6, #0
348068c8:	e5b50220 	ldr	r0, [r5, #544]!	; 0x220
348068cc:	e5904000 	ldr	r4, [r0]
348068d0:	ea000007 	b	348068f4 <mtdparts_init+0x348>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348068d4:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348068d8:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348068dc:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348068e0:	e5806004 	str	r6, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348068e4:	e5806000 	str	r6, [r0]
			id_tmp = list_entry(entry, struct mtdids, link);
			list_del(entry);
			free(id_tmp);
348068e8:	eb000db4 	bl	34809fc0 <free>
		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
348068ec:	e1a00004 	mov	r0, r4
348068f0:	e5944000 	ldr	r4, [r4]
348068f4:	e1500005 	cmp	r0, r5
348068f8:	1afffff5 	bne	348068d4 <mtdparts_init+0x328>
		ids_changed = 0;
	} else {
		ids_changed = 1;

		if (parse_mtdids(ids) != 0) {
			mtd_devices_init();
348068fc:	ebfffc49 	bl	34805a28 <mtd_devices_init>
34806900:	eaffff6a 	b	348066b0 <mtdparts_init+0x104>
		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
	}

	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
34806904:	e3540000 	cmp	r4, #0
34806908:	e59f023c 	ldr	r0, [pc, #572]	; 34806b4c <mtdparts_init+0x5a0>
3480690c:	0a000056 	beq	34806a6c <mtdparts_init+0x4c0>
34806910:	e5d03020 	ldrb	r3, [r0, #32]
34806914:	e3530000 	cmp	r3, #0
34806918:	0a000006 	beq	34806938 <mtdparts_init+0x38c>
3480691c:	e2800020 	add	r0, r0, #32
34806920:	e1a01004 	mov	r1, r4
34806924:	eb005667 	bl	3481c2c8 <strcmp>
34806928:	e3500000 	cmp	r0, #0
3480692c:	1a000001 	bne	34806938 <mtdparts_init+0x38c>
34806930:	e3550000 	cmp	r5, #0
34806934:	0a000080 	beq	34806b3c <mtdparts_init+0x590>
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
34806938:	e58d4018 	str	r4, [sp, #24]
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
3480693c:	ebfffc39 	bl	34805a28 <mtd_devices_init>
34806940:	e3500000 	cmp	r0, #0
		printf("could not initialise device list\n");
34806944:	159f0240 	ldrne	r0, [pc, #576]	; 34806b8c <mtdparts_init+0x5e0>
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34806948:	1a00003b 	bne	34806a3c <mtdparts_init+0x490>
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
3480694c:	e59f0200 	ldr	r0, [pc, #512]	; 34806b54 <mtdparts_init+0x5a8>
34806950:	eb00056e 	bl	34807f10 <getenv>

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806954:	e59f1234 	ldr	r1, [pc, #564]	; 34806b90 <mtdparts_init+0x5e4>
34806958:	e3a02009 	mov	r2, #9
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
3480695c:	e58d0018 	str	r0, [sp, #24]

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806960:	eb005664 	bl	3481c2f8 <strncmp>
34806964:	e3500000 	cmp	r0, #0
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
34806968:	159f0224 	ldrne	r0, [pc, #548]	; 34806b94 <mtdparts_init+0x5e8>
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");

	if (strncmp(p, "mtdparts=", 9) != 0) {
3480696c:	1a000032 	bne	34806a3c <mtdparts_init+0x490>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
34806970:	e59d3018 	ldr	r3, [sp, #24]
34806974:	e28d6028 	add	r6, sp, #40	; 0x28
34806978:	e2833009 	add	r3, r3, #9
3480697c:	e5263010 	str	r3, [r6, #-16]!

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806980:	e28d7014 	add	r7, sp, #20
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
	struct mtd_device *dev;
	int err = 1;
34806984:	e3a03001 	mov	r3, #1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806988:	e59f51bc 	ldr	r5, [pc, #444]	; 34806b4c <mtdparts_init+0x5a0>
3480698c:	ea00001f 	b	34806a10 <mtdparts_init+0x464>
	}
	p += 9;

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806990:	e1a01006 	mov	r1, r6
34806994:	e1a02007 	mov	r2, r7
34806998:	ebfffcfb 	bl	34805d8c <device_parse>
3480699c:	e3500000 	cmp	r0, #0
348069a0:	1a000022 	bne	34806a30 <mtdparts_init+0x484>
348069a4:	e59da014 	ldr	sl, [sp, #20]
348069a8:	e35a0000 	cmp	sl, #0
348069ac:	0a00001f 	beq	34806a30 <mtdparts_init+0x484>

		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
348069b0:	e59a3008 	ldr	r3, [sl, #8]
348069b4:	e5d39008 	ldrb	r9, [r3, #8]
348069b8:	e5d3b009 	ldrb	fp, [r3, #9]
348069bc:	e1a00009 	mov	r0, r9
348069c0:	e1a0100b 	mov	r1, fp
348069c4:	ebfffcdd 	bl	34805d40 <device_find>
348069c8:	e2503000 	subs	r3, r0, #0
348069cc:	0a00000a 	beq	348069fc <mtdparts_init+0x450>
			printf("device %s%d redefined, please correct mtdparts variable\n",
348069d0:	e3590002 	cmp	r9, #2
348069d4:	059f119c 	ldreq	r1, [pc, #412]	; 34806b78 <mtdparts_init+0x5cc>
348069d8:	0a000003 	beq	348069ec <mtdparts_init+0x440>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
348069dc:	e59f3198 	ldr	r3, [pc, #408]	; 34806b7c <mtdparts_init+0x5d0>
348069e0:	e3590004 	cmp	r9, #4
348069e4:	e59f1194 	ldr	r1, [pc, #404]	; 34806b80 <mtdparts_init+0x5d4>
348069e8:	01a01003 	moveq	r1, r3
		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
			printf("device %s%d redefined, please correct mtdparts variable\n",
348069ec:	e1a0200b 	mov	r2, fp
348069f0:	e59f01a0 	ldr	r0, [pc, #416]	; 34806b98 <mtdparts_init+0x5ec>
348069f4:	eb000c33 	bl	34809ac8 <printf>
348069f8:	ea00000c 	b	34806a30 <mtdparts_init+0x484>
348069fc:	e5952008 	ldr	r2, [r5, #8]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34806a00:	e59f1194 	ldr	r1, [pc, #404]	; 34806b9c <mtdparts_init+0x5f0>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806a04:	e585a008 	str	sl, [r5, #8]
	new->next = next;
34806a08:	e88a0006 	stm	sl, {r1, r2}
	new->prev = prev;
	prev->next = new;
34806a0c:	e582a000 	str	sl, [r2]
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;

	while (p && (*p != '\0')) {
34806a10:	e59d0018 	ldr	r0, [sp, #24]
34806a14:	e3500000 	cmp	r0, #0
34806a18:	0a000002 	beq	34806a28 <mtdparts_init+0x47c>
34806a1c:	e5d02000 	ldrb	r2, [r0]
34806a20:	e3520000 	cmp	r2, #0
34806a24:	1affffd9 	bne	34806990 <mtdparts_init+0x3e4>
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
	}
	if (err == 1) {
34806a28:	e3530001 	cmp	r3, #1
34806a2c:	1a00003c 	bne	34806b24 <mtdparts_init+0x578>
		device_delall(&devices);
34806a30:	ebfffbe3 	bl	348059c4 <device_delall.clone.2>
34806a34:	eaffff1d 	b	348066b0 <mtdparts_init+0x104>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
			printf("mtdparts_init: no valid partitions\n");
34806a38:	e59f0160 	ldr	r0, [pc, #352]	; 34806ba0 <mtdparts_init+0x5f4>
34806a3c:	eb000c21 	bl	34809ac8 <printf>
34806a40:	eaffff1a 	b	348066b0 <mtdparts_init+0x104>
			return 1;
		}

		/* ok it's good, save new parts */
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
34806a44:	e2850020 	add	r0, r5, #32
34806a48:	e1a01004 	mov	r1, r4
34806a4c:	e3a02c02 	mov	r2, #512	; 0x200
34806a50:	eb0055f2 	bl	3481c220 <strncpy>

		/* reset first partition from first dev from the list as current */
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34806a54:	e5953004 	ldr	r3, [r5, #4]
34806a58:	e5853000 	str	r3, [r5]
		current_mtd_partnum = 0;
34806a5c:	e3a03000 	mov	r3, #0
34806a60:	e5c5300c 	strb	r3, [r5, #12]
		current_save();
34806a64:	ebfffa88 	bl	3480548c <current_save>
34806a68:	ea000033 	b	34806b3c <mtdparts_init+0x590>
				MTD_DEV_TYPE(current_mtd_dev->id->type),
				current_mtd_dev->id->num, current_mtd_partnum);
	}

	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
34806a6c:	e5d03020 	ldrb	r3, [r0, #32]
34806a70:	e3530000 	cmp	r3, #0
34806a74:	0a000019 	beq	34806ae0 <mtdparts_init+0x534>
		return mtd_devices_init();
34806a78:	ebfffbea 	bl	34805a28 <mtd_devices_init>
34806a7c:	ea00001a 	b	34806aec <mtdparts_init+0x540>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806a80:	e59f50c4 	ldr	r5, [pc, #196]	; 34806b4c <mtdparts_init+0x5a0>
34806a84:	e28d4004 	add	r4, sp, #4
34806a88:	e1a00004 	mov	r0, r4
34806a8c:	e2851010 	add	r1, r5, #16
34806a90:	eb00560c 	bl	3481c2c8 <strcmp>
34806a94:	e3500000 	cmp	r0, #0
34806a98:	0a00000b 	beq	34806acc <mtdparts_init+0x520>
		struct mtd_device *cdev;
		u8 pnum;

		debug("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
34806a9c:	e1a00004 	mov	r0, r4
34806aa0:	e28d1014 	add	r1, sp, #20
34806aa4:	e28d2027 	add	r2, sp, #39	; 0x27
34806aa8:	e28d3020 	add	r3, sp, #32
34806aac:	ebfffe50 	bl	348063f4 <find_dev_and_part>
34806ab0:	e2504000 	subs	r4, r0, #0
34806ab4:	1a00000b 	bne	34806ae8 <mtdparts_init+0x53c>
			current_mtd_dev = cdev;
34806ab8:	e59d3014 	ldr	r3, [sp, #20]
34806abc:	e5853000 	str	r3, [r5]
			current_mtd_partnum = pnum;
34806ac0:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
34806ac4:	e5c5300c 	strb	r3, [r5, #12]
34806ac8:	ea000003 	b	34806adc <mtdparts_init+0x530>
			current_save();
		}
	} else if (getenv("partition") == NULL) {
34806acc:	e59f0084 	ldr	r0, [pc, #132]	; 34806b58 <mtdparts_init+0x5ac>
34806ad0:	eb00050e 	bl	34807f10 <getenv>
34806ad4:	e2504000 	subs	r4, r0, #0
34806ad8:	1a000002 	bne	34806ae8 <mtdparts_init+0x53c>
		debug("no partition variable set, setting...\n");
		current_save();
34806adc:	ebfffa6a 	bl	3480548c <current_save>
	if (!parts && (last_parts[0] != '\0'))
		return mtd_devices_init();

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;
34806ae0:	e1a00004 	mov	r0, r4
34806ae4:	ea000000 	b	34806aec <mtdparts_init+0x540>
	} else if (getenv("partition") == NULL) {
		debug("no partition variable set, setting...\n");
		current_save();
	}

	return 0;
34806ae8:	e3a00000 	mov	r0, #0
}
34806aec:	e28dd028 	add	sp, sp, #40	; 0x28
34806af0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
					MTD_DEV_TYPE(type), num);
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
34806af4:	e286b014 	add	fp, r6, #20
34806af8:	e1a0000b 	mov	r0, fp
34806afc:	eb000db8 	bl	3480a1e4 <malloc>
34806b00:	e2505000 	subs	r5, r0, #0
34806b04:	1affff4d 	bne	34806840 <mtdparts_init+0x294>
34806b08:	eaffff49 	b	34806834 <mtdparts_init+0x288>
			mtd_devices_init();
			return 1;
		}

		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
34806b0c:	e59f0090 	ldr	r0, [pc, #144]	; 34806ba4 <mtdparts_init+0x5f8>
34806b10:	e1a0100a 	mov	r1, sl
34806b14:	e3a02080 	mov	r2, #128	; 0x80
34806b18:	eb0055c0 	bl	3481c220 <strncpy>

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
34806b1c:	e3a05001 	mov	r5, #1
34806b20:	eaffff77 	b	34806904 <mtdparts_init+0x358>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34806b24:	e59f5020 	ldr	r5, [pc, #32]	; 34806b4c <mtdparts_init+0x5a0>
	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
34806b28:	e5952004 	ldr	r2, [r5, #4]
34806b2c:	e2853004 	add	r3, r5, #4
34806b30:	e1520003 	cmp	r2, r3
34806b34:	1affffc2 	bne	34806a44 <mtdparts_init+0x498>
34806b38:	eaffffbe 	b	34806a38 <mtdparts_init+0x48c>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806b3c:	e5dd3004 	ldrb	r3, [sp, #4]
34806b40:	e3530000 	cmp	r3, #0
34806b44:	1affffcd 	bne	34806a80 <mtdparts_init+0x4d4>
34806b48:	eaffffdf 	b	34806acc <mtdparts_init+0x520>
34806b4c:	34829a0c 	.word	0x34829a0c
34806b50:	348247a2 	.word	0x348247a2
34806b54:	34824518 	.word	0x34824518
34806b58:	34824b63 	.word	0x34824b63
34806b5c:	34824789 	.word	0x34824789
34806b60:	348247a9 	.word	0x348247a9
34806b64:	348247c1 	.word	0x348247c1
34806b68:	348247f1 	.word	0x348247f1
34806b6c:	3482480b 	.word	0x3482480b
34806b70:	34824828 	.word	0x34824828
34806b74:	34829c2c 	.word	0x34829c2c
34806b78:	3482479d 	.word	0x3482479d
34806b7c:	3482479a 	.word	0x3482479a
34806b80:	348243cc 	.word	0x348243cc
34806b84:	34824848 	.word	0x34824848
34806b88:	348245ff 	.word	0x348245ff
34806b8c:	34824882 	.word	0x34824882
34806b90:	3482450e 	.word	0x3482450e
34806b94:	348248a4 	.word	0x348248a4
34806b98:	348248d6 	.word	0x348248d6
34806b9c:	34829a10 	.word	0x34829a10
34806ba0:	3482490f 	.word	0x3482490f
34806ba4:	34829c38 	.word	0x34829c38

34806ba8 <do_mtdparts>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806ba8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc == 2) {
34806bac:	e3520002 	cmp	r2, #2
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806bb0:	e24dd060 	sub	sp, sp, #96	; 0x60
34806bb4:	e1a05002 	mov	r5, r2
34806bb8:	e1a04003 	mov	r4, r3
	if (argc == 2) {
34806bbc:	1a00001b 	bne	34806c30 <do_mtdparts+0x88>
		if (strcmp(argv[1], "default") == 0) {
34806bc0:	e5930004 	ldr	r0, [r3, #4]
34806bc4:	e59f157c 	ldr	r1, [pc, #1404]	; 34807148 <do_mtdparts+0x5a0>
34806bc8:	eb0055be 	bl	3481c2c8 <strcmp>
34806bcc:	e2506000 	subs	r6, r0, #0
34806bd0:	1a00000b 	bne	34806c04 <do_mtdparts+0x5c>
			setenv("mtdids", (char *)mtdids_default);
34806bd4:	e59f1570 	ldr	r1, [pc, #1392]	; 3480714c <do_mtdparts+0x5a4>
34806bd8:	e59f0570 	ldr	r0, [pc, #1392]	; 34807150 <do_mtdparts+0x5a8>
34806bdc:	eb0003c3 	bl	34807af0 <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
34806be0:	e59f156c 	ldr	r1, [pc, #1388]	; 34807154 <do_mtdparts+0x5ac>
34806be4:	e59f056c 	ldr	r0, [pc, #1388]	; 34807158 <do_mtdparts+0x5b0>
34806be8:	eb0003c0 	bl	34807af0 <setenv>
			setenv("partition", NULL);
34806bec:	e1a01006 	mov	r1, r6
34806bf0:	e59f0564 	ldr	r0, [pc, #1380]	; 3480715c <do_mtdparts+0x5b4>
34806bf4:	eb0003bd 	bl	34807af0 <setenv>

			mtdparts_init();
34806bf8:	ebfffe6b 	bl	348065ac <mtdparts_init>
			return 0;
34806bfc:	e1a00006 	mov	r0, r6
34806c00:	ea00014e 	b	34807140 <do_mtdparts+0x598>
		} else if (strcmp(argv[1], "delall") == 0) {
34806c04:	e5940004 	ldr	r0, [r4, #4]
34806c08:	e59f1550 	ldr	r1, [pc, #1360]	; 34807160 <do_mtdparts+0x5b8>
34806c0c:	eb0055ad 	bl	3481c2c8 <strcmp>
34806c10:	e2506000 	subs	r6, r0, #0
34806c14:	1a000005 	bne	34806c30 <do_mtdparts+0x88>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
34806c18:	ebfffe63 	bl	348065ac <mtdparts_init>

			setenv("mtdparts", NULL);
34806c1c:	e1a01006 	mov	r1, r6
34806c20:	e59f0530 	ldr	r0, [pc, #1328]	; 34807158 <do_mtdparts+0x5b0>
34806c24:	eb0003b1 	bl	34807af0 <setenv>

			/* mtd_devices_init() calls current_save() */
			return mtd_devices_init();
34806c28:	ebfffb7e 	bl	34805a28 <mtd_devices_init>
34806c2c:	ea000143 	b	34807140 <do_mtdparts+0x598>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
34806c30:	ebfffe5d 	bl	348065ac <mtdparts_init>
34806c34:	e3500000 	cmp	r0, #0
34806c38:	1a00013d 	bne	34807134 <do_mtdparts+0x58c>
		return 1;

	if (argc == 1) {
34806c3c:	e3550001 	cmp	r5, #1
34806c40:	1a00005b 	bne	34806db4 <do_mtdparts+0x20c>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806c44:	e59fa518 	ldr	sl, [pc, #1304]	; 34807164 <do_mtdparts+0x5bc>
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c48:	e59f9518 	ldr	r9, [pc, #1304]	; 34807168 <do_mtdparts+0x5c0>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806c4c:	e5ba4004 	ldr	r4, [sl, #4]!
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c50:	e59fb514 	ldr	fp, [pc, #1300]	; 3480716c <do_mtdparts+0x5c4>
34806c54:	ea000021 	b	34806ce0 <do_mtdparts+0x138>
34806c58:	e5943008 	ldr	r3, [r4, #8]
34806c5c:	e5d31008 	ldrb	r1, [r3, #8]
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806c60:	e3510002 	cmp	r1, #2
34806c64:	059f1504 	ldreq	r1, [pc, #1284]	; 34807170 <do_mtdparts+0x5c8>
34806c68:	0a000002 	beq	34806c78 <do_mtdparts+0xd0>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c6c:	e3510004 	cmp	r1, #4
34806c70:	11a01009 	movne	r1, r9
34806c74:	01a0100b 	moveq	r1, fp
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806c78:	e1d400bc 	ldrh	r0, [r4, #12]
34806c7c:	e5d32009 	ldrb	r2, [r3, #9]
34806c80:	e58d0000 	str	r0, [sp]
34806c84:	e5933010 	ldr	r3, [r3, #16]
34806c88:	e59f04e4 	ldr	r0, [pc, #1252]	; 34807174 <do_mtdparts+0x5cc>
34806c8c:	eb000b8d 	bl	34809ac8 <printf>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806c90:	e1a06004 	mov	r6, r4
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");
34806c94:	e59f04dc 	ldr	r0, [pc, #1244]	; 34807178 <do_mtdparts+0x5d0>
34806c98:	eb000b8a 	bl	34809ac8 <printf>
	int part_num;

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);
		/* list partitions for given device */
		part_num = 0;
34806c9c:	e3a07000 	mov	r7, #0
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806ca0:	e5b65010 	ldr	r5, [r6, #16]!
34806ca4:	ea00000a 	b	34806cd4 <do_mtdparts+0x12c>
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806ca8:	e5953014 	ldr	r3, [r5, #20]
34806cac:	e1a01007 	mov	r1, r7
34806cb0:	e58d3000 	str	r3, [sp]
34806cb4:	e595301c 	ldr	r3, [r5, #28]
34806cb8:	e59f04bc 	ldr	r0, [pc, #1212]	; 3480717c <do_mtdparts+0x5d4>
34806cbc:	e58d3004 	str	r3, [sp, #4]
34806cc0:	e5952008 	ldr	r2, [r5, #8]
34806cc4:	e5953010 	ldr	r3, [r5, #16]
34806cc8:	eb000b7e 	bl	34809ac8 <printf>
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806ccc:	e5955000 	ldr	r5, [r5]
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					part->offset, part->mask_flags);
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
34806cd0:	e2877001 	add	r7, r7, #1
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806cd4:	e1550006 	cmp	r5, r6
34806cd8:	1afffff2 	bne	34806ca8 <do_mtdparts+0x100>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806cdc:	e5944000 	ldr	r4, [r4]
34806ce0:	e154000a 	cmp	r4, sl
34806ce4:	1affffdb 	bne	34806c58 <do_mtdparts+0xb0>
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
		}
	}

	if (list_empty(&devices))
34806ce8:	e59f3474 	ldr	r3, [pc, #1140]	; 34807164 <do_mtdparts+0x5bc>
34806cec:	e5933004 	ldr	r3, [r3, #4]
34806cf0:	e1530004 	cmp	r3, r4
34806cf4:	1a000001 	bne	34806d00 <do_mtdparts+0x158>
		printf("no partitions defined\n");
34806cf8:	e59f0480 	ldr	r0, [pc, #1152]	; 34807180 <do_mtdparts+0x5d8>
34806cfc:	eb000b71 	bl	34809ac8 <printf>

	debug("\n---list_partitions---\n");
	print_partition_table();

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
34806d00:	e59f445c 	ldr	r4, [pc, #1116]	; 34807164 <do_mtdparts+0x5bc>
34806d04:	e5940000 	ldr	r0, [r4]
34806d08:	e3500000 	cmp	r0, #0
34806d0c:	0a00001b 	beq	34806d80 <do_mtdparts+0x1d8>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806d10:	e5d4100c 	ldrb	r1, [r4, #12]
34806d14:	ebfff973 	bl	348052e8 <mtd_part_info>
		if (part) {
34806d18:	e3500000 	cmp	r0, #0
34806d1c:	0a000015 	beq	34806d78 <do_mtdparts+0x1d0>
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806d20:	e5943000 	ldr	r3, [r4]
34806d24:	e5933008 	ldr	r3, [r3, #8]
34806d28:	e5d32008 	ldrb	r2, [r3, #8]

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806d2c:	e3520002 	cmp	r2, #2
34806d30:	059f1438 	ldreq	r1, [pc, #1080]	; 34807170 <do_mtdparts+0x5c8>
34806d34:	0a000003 	beq	34806d48 <do_mtdparts+0x1a0>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806d38:	e59fc428 	ldr	ip, [pc, #1064]	; 34807168 <do_mtdparts+0x5c0>
34806d3c:	e3520004 	cmp	r2, #4
34806d40:	e59f1424 	ldr	r1, [pc, #1060]	; 3480716c <do_mtdparts+0x5c4>
34806d44:	11a0100c 	movne	r1, ip

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806d48:	e5d32009 	ldrb	r2, [r3, #9]
34806d4c:	e590c008 	ldr	ip, [r0, #8]
34806d50:	e59f340c 	ldr	r3, [pc, #1036]	; 34807164 <do_mtdparts+0x5bc>
34806d54:	e5d3300c 	ldrb	r3, [r3, #12]
34806d58:	e58dc000 	str	ip, [sp]
34806d5c:	e590c010 	ldr	ip, [r0, #16]
34806d60:	e58dc004 	str	ip, [sp, #4]
34806d64:	e5900014 	ldr	r0, [r0, #20]
34806d68:	e58d0008 	str	r0, [sp, #8]
34806d6c:	e59f0410 	ldr	r0, [pc, #1040]	; 34807184 <do_mtdparts+0x5dc>
34806d70:	eb000b54 	bl	34809ac8 <printf>
34806d74:	ea000001 	b	34806d80 <do_mtdparts+0x1d8>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
					current_mtd_dev->id->num, current_mtd_partnum,
					part->name, part->size, part->offset);
		} else {
			printf("could not get current partition info\n\n");
34806d78:	e59f0408 	ldr	r0, [pc, #1032]	; 34807188 <do_mtdparts+0x5e0>
34806d7c:	eb000b51 	bl	34809ac8 <printf>
		}
	}

	printf("\ndefaults:\n");
34806d80:	e59f0404 	ldr	r0, [pc, #1028]	; 3480718c <do_mtdparts+0x5e4>
34806d84:	eb000b4f 	bl	34809ac8 <printf>
	printf("mtdids  : %s\n",
34806d88:	e59f13bc 	ldr	r1, [pc, #956]	; 3480714c <do_mtdparts+0x5a4>
34806d8c:	e59f03fc 	ldr	r0, [pc, #1020]	; 34807190 <do_mtdparts+0x5e8>
34806d90:	eb000b4c 	bl	34809ac8 <printf>
	/*
	 * Using printf() here results in printbuffer overflow
	 * if default mtdparts string is greater than console
	 * printbuffer. Use puts() to prevent system crashes.
	 */
	puts("mtdparts: ");
34806d94:	e59f03f8 	ldr	r0, [pc, #1016]	; 34807194 <do_mtdparts+0x5ec>
34806d98:	eb000b40 	bl	34809aa0 <puts>
	puts(mtdparts_default ? mtdparts_default : "none");
34806d9c:	e59f03b0 	ldr	r0, [pc, #944]	; 34807154 <do_mtdparts+0x5ac>
34806da0:	eb000b3e 	bl	34809aa0 <puts>
	puts("\n");
34806da4:	e59f03ec 	ldr	r0, [pc, #1004]	; 34807198 <do_mtdparts+0x5f0>
34806da8:	eb000b3c 	bl	34809aa0 <puts>
	if (mtdparts_init() != 0)
		return 1;

	if (argc == 1) {
		list_partitions();
		return 0;
34806dac:	e3a00000 	mov	r0, #0
34806db0:	ea0000e2 	b	34807140 <do_mtdparts+0x598>
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strncmp(argv[1], "add", 3) == 0)) {
34806db4:	e2453005 	sub	r3, r5, #5
34806db8:	e3530001 	cmp	r3, #1
34806dbc:	8a000090 	bhi	34807004 <do_mtdparts+0x45c>
34806dc0:	e59f13d4 	ldr	r1, [pc, #980]	; 3480719c <do_mtdparts+0x5f4>
34806dc4:	e5940004 	ldr	r0, [r4, #4]
34806dc8:	e3a02003 	mov	r2, #3
34806dcc:	eb005549 	bl	3481c2f8 <strncmp>
34806dd0:	e2501000 	subs	r1, r0, #0
34806dd4:	1a0000d8 	bne	3480713c <do_mtdparts+0x594>
		struct mtd_device *dev;
		struct mtd_device *dev_tmp;
		struct mtdids *id;
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
34806dd8:	e5940008 	ldr	r0, [r4, #8]
34806ddc:	e28d2054 	add	r2, sp, #84	; 0x54
34806de0:	e28d305f 	add	r3, sp, #95	; 0x5f
34806de4:	ebfffd3e 	bl	348062e4 <mtd_id_parse>
34806de8:	e3500000 	cmp	r0, #0
34806dec:	1a0000d0 	bne	34807134 <do_mtdparts+0x58c>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806df0:	e59f336c 	ldr	r3, [pc, #876]	; 34807164 <do_mtdparts+0x5bc>
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
34806df4:	e5dd1054 	ldrb	r1, [sp, #84]	; 0x54
34806df8:	e5dd205f 	ldrb	r2, [sp, #95]	; 0x5f
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806dfc:	e5b35220 	ldr	r5, [r3, #544]!	; 0x220
34806e00:	ea000006 	b	34806e20 <do_mtdparts+0x278>
		id = list_entry(entry, struct mtdids, link);

		if ((id->type == type) && (id->num == num))
34806e04:	e5d50008 	ldrb	r0, [r5, #8]
34806e08:	e1500001 	cmp	r0, r1
34806e0c:	1a000002 	bne	34806e1c <do_mtdparts+0x274>
34806e10:	e5d50009 	ldrb	r0, [r5, #9]
34806e14:	e1500002 	cmp	r0, r2
34806e18:	0a000003 	beq	34806e2c <do_mtdparts+0x284>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806e1c:	e5955000 	ldr	r5, [r5]
34806e20:	e1550003 	cmp	r5, r3
34806e24:	1afffff6 	bne	34806e04 <do_mtdparts+0x25c>
34806e28:	ea00000f 	b	34806e6c <do_mtdparts+0x2c4>
		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
34806e2c:	e5950010 	ldr	r0, [r5, #16]
34806e30:	eb005558 	bl	3481c398 <strlen>
34806e34:	e1a07000 	mov	r7, r0
		len += strlen(argv[3]);		/* size@offset */
34806e38:	e594000c 	ldr	r0, [r4, #12]
34806e3c:	eb005555 	bl	3481c398 <strlen>
34806e40:	e1a06000 	mov	r6, r0
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806e44:	e5940010 	ldr	r0, [r4, #16]
34806e48:	eb005552 	bl	3481c398 <strlen>
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
34806e4c:	e0876006 	add	r6, r7, r6
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806e50:	e2866003 	add	r6, r6, #3
34806e54:	e6e06076 	uxtab	r6, r0, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806e58:	e5940014 	ldr	r0, [r4, #20]
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806e5c:	e6ef6076 	uxtb	r6, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806e60:	e3500000 	cmp	r0, #0
34806e64:	1a000003 	bne	34806e78 <do_mtdparts+0x2d0>
34806e68:	ea000006 	b	34806e88 <do_mtdparts+0x2e0>

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
34806e6c:	e59f032c 	ldr	r0, [pc, #812]	; 348071a0 <do_mtdparts+0x5f8>
34806e70:	e5941008 	ldr	r1, [r4, #8]
34806e74:	ea0000ad 	b	34807130 <do_mtdparts+0x588>
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
34806e78:	eb005546 	bl	3481c398 <strlen>
34806e7c:	e3500002 	cmp	r0, #2
			len += 2;		/* 'ro' */
34806e80:	02866002 	addeq	r6, r6, #2
34806e84:	06ef6076 	uxtbeq	r6, r6

		if (len >= PART_ADD_DESC_MAXLEN) {
34806e88:	e356003f 	cmp	r6, #63	; 0x3f
			printf("too long partition description\n");
34806e8c:	859f0310 	ldrhi	r0, [pc, #784]	; 348071a4 <do_mtdparts+0x5fc>
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
			len += 2;		/* 'ro' */

		if (len >= PART_ADD_DESC_MAXLEN) {
34806e90:	8a0000a2 	bhi	34807120 <do_mtdparts+0x578>
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
34806e94:	e5941014 	ldr	r1, [r4, #20]

		if (len >= PART_ADD_DESC_MAXLEN) {
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806e98:	e59fc308 	ldr	ip, [pc, #776]	; 348071a8 <do_mtdparts+0x600>
34806e9c:	e5940010 	ldr	r0, [r4, #16]
34806ea0:	e3510000 	cmp	r1, #0
34806ea4:	e594300c 	ldr	r3, [r4, #12]
34806ea8:	01a0100c 	moveq	r1, ip
34806eac:	e28d4014 	add	r4, sp, #20
34806eb0:	e5952010 	ldr	r2, [r5, #16]
34806eb4:	e88d0003 	stm	sp, {r0, r1}
34806eb8:	e1a00004 	mov	r0, r4
34806ebc:	e59f12e8 	ldr	r1, [pc, #744]	; 348071ac <do_mtdparts+0x604>
34806ec0:	eb00596d 	bl	3481d47c <sprintf>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
34806ec4:	e1a00004 	mov	r0, r4
34806ec8:	e3a01000 	mov	r1, #0
34806ecc:	e28d2058 	add	r2, sp, #88	; 0x58
34806ed0:	ebfffbad 	bl	34805d8c <device_parse>
34806ed4:	e3500000 	cmp	r0, #0
34806ed8:	1a000095 	bne	34807134 <do_mtdparts+0x58c>
34806edc:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34806ee0:	e3550000 	cmp	r5, #0
34806ee4:	0a000092 	beq	34807134 <do_mtdparts+0x58c>
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806ee8:	e5953008 	ldr	r3, [r5, #8]
			return 1;

		debug("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		p = list_entry(dev->parts.next, struct part_info, link);
34806eec:	e5954010 	ldr	r4, [r5, #16]
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806ef0:	e5d30008 	ldrb	r0, [r3, #8]
34806ef4:	e5d31009 	ldrb	r1, [r3, #9]
34806ef8:	ebfffb90 	bl	34805d40 <device_find>
		if (dev_tmp == NULL) {
34806efc:	e2506000 	subs	r6, r0, #0
34806f00:	1a00000e 	bne	34806f40 <do_mtdparts+0x398>
34806f04:	e59f3258 	ldr	r3, [pc, #600]	; 34807164 <do_mtdparts+0x5bc>
 */
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
34806f08:	e5931004 	ldr	r1, [r3, #4]
34806f0c:	e2832004 	add	r2, r3, #4
34806f10:	e1510002 	cmp	r1, r2
		current_mtd_dev = dev;
		current_mtd_partnum = 0;
34806f14:	05c3600c 	strbeq	r6, [r3, #12]
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_mtd_dev = dev;
34806f18:	05835000 	streq	r5, [r3]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806f1c:	e59f3240 	ldr	r3, [pc, #576]	; 34807164 <do_mtdparts+0x5bc>
		current_mtd_partnum = 0;
		current_save_needed = 1;
34806f20:	03a06001 	moveq	r6, #1
34806f24:	e5932008 	ldr	r2, [r3, #8]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806f28:	e5835008 	str	r5, [r3, #8]
	new->next = next;
34806f2c:	e2833004 	add	r3, r3, #4
34806f30:	e5853000 	str	r3, [r5]
	new->prev = prev;
34806f34:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
34806f38:	e5825000 	str	r5, [r2]
34806f3c:	ea00006e 	b	348070fc <do_mtdparts+0x554>
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806f40:	e5943010 	ldr	r3, [r4, #16]
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
34806f44:	e596c008 	ldr	ip, [r6, #8]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806f48:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
34806f4c:	059c200c 	ldreq	r2, [ip, #12]
34806f50:	05943014 	ldreq	r3, [r4, #20]
34806f54:	00633002 	rsbeq	r3, r3, r2
34806f58:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
34806f5c:	e5942014 	ldr	r2, [r4, #20]
34806f60:	e59c300c 	ldr	r3, [ip, #12]
34806f64:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34806f68:	859f0240 	ldrhi	r0, [pc, #576]	; 348071b0 <do_mtdparts+0x608>
34806f6c:	859c1010 	ldrhi	r1, [ip, #16]
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
34806f70:	8a00000e 	bhi	34806fb0 <do_mtdparts+0x408>
		printf("%s: offset %08x beyond flash size %08x\n",
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
34806f74:	e5941010 	ldr	r1, [r4, #16]
34806f78:	e0821001 	add	r1, r2, r1
34806f7c:	e1510002 	cmp	r1, r2
34806f80:	8a00000c 	bhi	34806fb8 <do_mtdparts+0x410>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806f84:	e5dc3008 	ldrb	r3, [ip, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806f88:	e3530002 	cmp	r3, #2
34806f8c:	059f11dc 	ldreq	r1, [pc, #476]	; 34807170 <do_mtdparts+0x5c8>
34806f90:	0a000003 	beq	34806fa4 <do_mtdparts+0x3fc>
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806f94:	e59f21d0 	ldr	r2, [pc, #464]	; 3480716c <do_mtdparts+0x5c4>
34806f98:	e3530004 	cmp	r3, #4
34806f9c:	e59f11c4 	ldr	r1, [pc, #452]	; 34807168 <do_mtdparts+0x5c0>
34806fa0:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806fa4:	e59f0208 	ldr	r0, [pc, #520]	; 348071b4 <do_mtdparts+0x60c>
34806fa8:	e5dc2009 	ldrb	r2, [ip, #9]
34806fac:	e5943008 	ldr	r3, [r4, #8]
34806fb0:	eb000ac4 	bl	34809ac8 <printf>
34806fb4:	ea00000f 	b	34806ff8 <do_mtdparts+0x450>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
34806fb8:	e1510003 	cmp	r1, r3
34806fbc:	9a000003 	bls	34806fd0 <do_mtdparts+0x428>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
34806fc0:	e59c1010 	ldr	r1, [ip, #16]
34806fc4:	e59f01ec 	ldr	r0, [pc, #492]	; 348071b8 <do_mtdparts+0x610>
34806fc8:	eb000abe 	bl	34809ac8 <printf>
34806fcc:	ea000009 	b	34806ff8 <do_mtdparts+0x450>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
34806fd0:	e1a0000c 	mov	r0, ip
34806fd4:	e1a01004 	mov	r1, r4
34806fd8:	ebfffa09 	bl	34805804 <part_validate_eraseblock>
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
34806fdc:	e3500000 	cmp	r0, #0
34806fe0:	1a000004 	bne	34806ff8 <do_mtdparts+0x450>
		return 1;

	/* partition is ok, add it to the list */
	if (part_sort_add(dev, part) != 0)
34806fe4:	e1a00006 	mov	r0, r6
34806fe8:	e1a01004 	mov	r1, r4
34806fec:	ebfff952 	bl	3480553c <part_sort_add>
34806ff0:	e3500000 	cmp	r0, #0
34806ff4:	0a000045 	beq	34807110 <do_mtdparts+0x568>
		dev_tmp = device_find(dev->id->type, dev->id->num);
		if (dev_tmp == NULL) {
			device_add(dev);
		} else if (part_add(dev_tmp, p) != 0) {
			/* merge new partition with existing ones*/
			device_del(dev);
34806ff8:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
34806ffc:	ebfff9aa 	bl	348056ac <device_del>
34807000:	ea00004b 	b	34807134 <do_mtdparts+0x58c>

		return 0;
	}

	/* mtdparts del part-id */
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
34807004:	e3550003 	cmp	r5, #3
34807008:	1a00004b 	bne	3480713c <do_mtdparts+0x594>
3480700c:	e5940004 	ldr	r0, [r4, #4]
34807010:	e59f11a4 	ldr	r1, [pc, #420]	; 348071bc <do_mtdparts+0x614>
34807014:	eb0054ab 	bl	3481c2c8 <strcmp>
34807018:	e3500000 	cmp	r0, #0
3480701c:	1a000046 	bne	3480713c <do_mtdparts+0x594>
		debug("del: part-id = %s\n", argv[2]);

		return delete_partition(argv[2]);
34807020:	e5944008 	ldr	r4, [r4, #8]
{
	u8 pnum;
	struct mtd_device *dev;
	struct part_info *part;

	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
34807024:	e28d1058 	add	r1, sp, #88	; 0x58
34807028:	e1a00004 	mov	r0, r4
3480702c:	e28d205f 	add	r2, sp, #95	; 0x5f
34807030:	e28d3054 	add	r3, sp, #84	; 0x54
34807034:	ebfffcee 	bl	348063f4 <find_dev_and_part>
34807038:	e2506000 	subs	r6, r0, #0
3480703c:	1a000039 	bne	34807128 <do_mtdparts+0x580>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34807040:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34807044:	e59d4054 	ldr	r4, [sp, #84]	; 0x54
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
34807048:	e1d570bc 	ldrh	r7, [r5, #12]
3480704c:	e3570001 	cmp	r7, #1
34807050:	1a000005 	bne	3480706c <do_mtdparts+0x4c4>
		return device_del(dev);
34807054:	e1a00005 	mov	r0, r5
34807058:	ebfff993 	bl	348056ac <device_del>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
3480705c:	e3500000 	cmp	r0, #0
			return 1;
34807060:	11a00007 	movne	r0, r7

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34807064:	1a000035 	bne	34807140 <do_mtdparts+0x598>
34807068:	ea000028 	b	34807110 <do_mtdparts+0x568>
	if (dev->num_parts == 1)
		return device_del(dev);

	/* otherwise just delete this partition */

	if (dev == current_mtd_dev) {
3480706c:	e59f30f0 	ldr	r3, [pc, #240]	; 34807164 <do_mtdparts+0x5bc>
34807070:	e5932000 	ldr	r2, [r3]
34807074:	e1550002 	cmp	r5, r2
34807078:	1a000014 	bne	348070d0 <do_mtdparts+0x528>
		/* we are modyfing partitions for the current device,
		 * update current */
		struct part_info *curr_pi;
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
3480707c:	e1a00005 	mov	r0, r5
34807080:	e5d3100c 	ldrb	r1, [r3, #12]
34807084:	ebfff897 	bl	348052e8 <mtd_part_info>

		if (curr_pi) {
34807088:	e2506000 	subs	r6, r0, #0
3480708c:	0a00000f 	beq	348070d0 <do_mtdparts+0x528>
			if (curr_pi == part) {
34807090:	e1560004 	cmp	r6, r4
34807094:	1a000004 	bne	348070ac <do_mtdparts+0x504>
				printf("current partition deleted, resetting current to 0\n");
34807098:	e59f0120 	ldr	r0, [pc, #288]	; 348071c0 <do_mtdparts+0x618>
3480709c:	eb000a89 	bl	34809ac8 <printf>
				current_mtd_partnum = 0;
348070a0:	e3a02000 	mov	r2, #0
348070a4:	e59f30b8 	ldr	r3, [pc, #184]	; 34807164 <do_mtdparts+0x5bc>
348070a8:	ea000006 	b	348070c8 <do_mtdparts+0x520>
			} else if (part->offset <= curr_pi->offset) {
348070ac:	e5942014 	ldr	r2, [r4, #20]
348070b0:	e5963014 	ldr	r3, [r6, #20]
348070b4:	e1520003 	cmp	r2, r3
348070b8:	8a000003 	bhi	348070cc <do_mtdparts+0x524>
				current_mtd_partnum--;
348070bc:	e59f30a0 	ldr	r3, [pc, #160]	; 34807164 <do_mtdparts+0x5bc>
348070c0:	e5d3200c 	ldrb	r2, [r3, #12]
348070c4:	e2422001 	sub	r2, r2, #1
348070c8:	e5c3200c 	strb	r2, [r3, #12]
			}
			current_save_needed = 1;
348070cc:	e3a06001 	mov	r6, #1
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348070d0:	e894000c 	ldm	r4, {r2, r3}
		}
	}

	list_del(&part->link);
	free(part);
348070d4:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348070d8:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348070dc:	e5832000 	str	r2, [r3]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348070e0:	e3a03000 	mov	r3, #0
348070e4:	e5843000 	str	r3, [r4]
	entry->prev = LIST_POISON2;
348070e8:	e5843004 	str	r3, [r4, #4]
348070ec:	eb000bb3 	bl	34809fc0 <free>
	dev->num_parts--;
348070f0:	e1d530bc 	ldrh	r3, [r5, #12]
348070f4:	e2433001 	sub	r3, r3, #1
348070f8:	e1c530bc 	strh	r3, [r5, #12]

	if (current_save_needed > 0)
348070fc:	e3560000 	cmp	r6, #0
34807100:	0a000001 	beq	3480710c <do_mtdparts+0x564>
		current_save();
34807104:	ebfff8e0 	bl	3480548c <current_save>
34807108:	ea000000 	b	34807110 <do_mtdparts+0x568>
	else
		index_partitions();
3480710c:	ebfff89a 	bl	3480537c <index_partitions>
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
			return 1;

		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
34807110:	ebfffa4d 	bl	34805a4c <generate_mtdparts_save.clone.1>
34807114:	e3500000 	cmp	r0, #0
34807118:	0a000008 	beq	34807140 <do_mtdparts+0x598>
			printf("generated mtdparts too long, reseting to null\n");
3480711c:	e59f00a0 	ldr	r0, [pc, #160]	; 348071c4 <do_mtdparts+0x61c>
34807120:	eb000a68 	bl	34809ac8 <printf>
34807124:	ea000002 	b	34807134 <do_mtdparts+0x58c>
			return 1;
		}
		return 0;
	}

	printf("partition %s not found\n", id);
34807128:	e59f0098 	ldr	r0, [pc, #152]	; 348071c8 <do_mtdparts+0x620>
3480712c:	e1a01004 	mov	r1, r4
34807130:	eb000a64 	bl	34809ac8 <printf>
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
			return 1;
34807134:	e3a00001 	mov	r0, #1
34807138:	ea000000 	b	34807140 <do_mtdparts+0x598>
#if defined(CONFIG_CMD_MTDPARTS_SPREAD)
	if ((argc == 2) && (strcmp(argv[1], "spread") == 0))
		return spread_partitions();
#endif /* CONFIG_CMD_MTDPARTS_SPREAD */

	return CMD_RET_USAGE;
3480713c:	e3e00000 	mvn	r0, #0
}
34807140:	e28dd060 	add	sp, sp, #96	; 0x60
34807144:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807148:	34824933 	.word	0x34824933
3480714c:	34824789 	.word	0x34824789
34807150:	348247a2 	.word	0x348247a2
34807154:	348201c4 	.word	0x348201c4
34807158:	34824518 	.word	0x34824518
3480715c:	34824b63 	.word	0x34824b63
34807160:	3482493b 	.word	0x3482493b
34807164:	34829a0c 	.word	0x34829a0c
34807168:	348243cc 	.word	0x348243cc
3480716c:	3482479a 	.word	0x3482479a
34807170:	3482479d 	.word	0x3482479d
34807174:	34824942 	.word	0x34824942
34807178:	34824963 	.word	0x34824963
3480717c:	34824987 	.word	0x34824987
34807180:	348249a3 	.word	0x348249a3
34807184:	348249ba 	.word	0x348249ba
34807188:	348249ed 	.word	0x348249ed
3480718c:	34824a14 	.word	0x34824a14
34807190:	34824a20 	.word	0x34824a20
34807194:	34824a2e 	.word	0x34824a2e
34807198:	34826197 	.word	0x34826197
3480719c:	34824a39 	.word	0x34824a39
348071a0:	34824a3d 	.word	0x34824a3d
348071a4:	34824a6b 	.word	0x34824a6b
348071a8:	34823d17 	.word	0x34823d17
348071ac:	34824a8b 	.word	0x34824a8b
348071b0:	3482461e 	.word	0x3482461e
348071b4:	34824646 	.word	0x34824646
348071b8:	34824669 	.word	0x34824669
348071bc:	34824ac6 	.word	0x34824ac6
348071c0:	34824aca 	.word	0x34824aca
348071c4:	34824a97 	.word	0x34824a97
348071c8:	34824afd 	.word	0x34824afd

348071cc <do_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348071cc:	e92d4030 	push	{r4, r5, lr}
348071d0:	e24dd014 	sub	sp, sp, #20
348071d4:	e1a04002 	mov	r4, r2
348071d8:	e1a05003 	mov	r5, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
348071dc:	ebfffcf2 	bl	348065ac <mtdparts_init>
348071e0:	e3500000 	cmp	r0, #0
348071e4:	1a000021 	bne	34807270 <do_chpart+0xa4>
		return 1;

	if (argc < 2) {
348071e8:	e3540001 	cmp	r4, #1
348071ec:	ca000002 	bgt	348071fc <do_chpart+0x30>
		printf("no partition id specified\n");
348071f0:	e59f0084 	ldr	r0, [pc, #132]	; 3480727c <do_chpart+0xb0>
348071f4:	eb000a33 	bl	34809ac8 <printf>
348071f8:	ea00001c 	b	34807270 <do_chpart+0xa4>
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
348071fc:	e5950004 	ldr	r0, [r5, #4]
34807200:	e28d1008 	add	r1, sp, #8
34807204:	e28d200f 	add	r2, sp, #15
34807208:	e28d3004 	add	r3, sp, #4
3480720c:	ebfffc78 	bl	348063f4 <find_dev_and_part>
34807210:	e3500000 	cmp	r0, #0
34807214:	1a000015 	bne	34807270 <do_chpart+0xa4>
		return 1;

	current_mtd_dev = dev;
34807218:	e59f3060 	ldr	r3, [pc, #96]	; 34807280 <do_chpart+0xb4>
3480721c:	e59d2008 	ldr	r2, [sp, #8]
34807220:	e5832000 	str	r2, [r3]
	current_mtd_partnum = pnum;
34807224:	e5dd200f 	ldrb	r2, [sp, #15]
34807228:	e5c3200c 	strb	r2, [r3, #12]
	current_save();
3480722c:	ebfff896 	bl	3480548c <current_save>

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34807230:	e59d3008 	ldr	r3, [sp, #8]
34807234:	e5933008 	ldr	r3, [r3, #8]
34807238:	e5d32008 	ldrb	r2, [r3, #8]

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
3480723c:	e3520002 	cmp	r2, #2
34807240:	059f103c 	ldreq	r1, [pc, #60]	; 34807284 <do_chpart+0xb8>
34807244:	0a000003 	beq	34807258 <do_chpart+0x8c>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34807248:	e59f0038 	ldr	r0, [pc, #56]	; 34807288 <do_chpart+0xbc>
3480724c:	e3520004 	cmp	r2, #4
34807250:	e59f1034 	ldr	r1, [pc, #52]	; 3480728c <do_chpart+0xc0>
34807254:	11a01000 	movne	r1, r0

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
34807258:	e5d32009 	ldrb	r2, [r3, #9]
3480725c:	e59f002c 	ldr	r0, [pc, #44]	; 34807290 <do_chpart+0xc4>
34807260:	e5dd300f 	ldrb	r3, [sp, #15]
34807264:	eb000a17 	bl	34809ac8 <printf>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
34807268:	e3a00000 	mov	r0, #0
3480726c:	ea000000 	b	34807274 <do_chpart+0xa8>
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
		return 1;
34807270:	e3a00001 	mov	r0, #1

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
}
34807274:	e28dd014 	add	sp, sp, #20
34807278:	e8bd8030 	pop	{r4, r5, pc}
3480727c:	34824b15 	.word	0x34824b15
34807280:	34829a0c 	.word	0x34829a0c
34807284:	3482479d 	.word	0x3482479d
34807288:	348243cc 	.word	0x348243cc
3480728c:	3482479a 	.word	0x3482479a
34807290:	34824b30 	.word	0x34824b30

34807294 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
34807294:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
}
#endif

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807298:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480729c:	e1a05000 	mov	r5, r0
348072a0:	e1a06001 	mov	r6, r1
348072a4:	e1a04002 	mov	r4, r2
	cmd_tbl_t *cp;

	if (argc < 2)
		return CMD_RET_USAGE;
348072a8:	d3e00000 	mvnle	r0, #0

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
348072ac:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}

	/* drop initial "env" arg */
	argc--;
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348072b0:	e5930004 	ldr	r0, [r3, #4]
348072b4:	e59f1034 	ldr	r1, [pc, #52]	; 348072f0 <do_env+0x5c>
348072b8:	e3a02008 	mov	r2, #8
	if (argc < 2)
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
	argv++;
348072bc:	e2837004 	add	r7, r3, #4

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348072c0:	eb000878 	bl	348094a8 <find_cmd_tbl>

	if (cp)
348072c4:	e3500000 	cmp	r0, #0
348072c8:	0a000006 	beq	348072e8 <do_env+0x54>
		return cp->cmd(cmdtp, flag, argc, argv);
348072cc:	e590c00c 	ldr	ip, [r0, #12]
348072d0:	e1a01006 	mov	r1, r6
348072d4:	e1a00005 	mov	r0, r5
348072d8:	e2442001 	sub	r2, r4, #1
348072dc:	e1a03007 	mov	r3, r7
348072e0:	e12fff3c 	blx	ip
348072e4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	return CMD_RET_USAGE;
348072e8:	e3e00000 	mvn	r0, #0
}
348072ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348072f0:	34828374 	.word	0x34828374

348072f4 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348072f4:	e92d4008 	push	{r3, lr}
	printf("Not implemented yet\n");
348072f8:	e59f0008 	ldr	r0, [pc, #8]	; 34807308 <do_env_delete+0x14>
348072fc:	eb0009f1 	bl	34809ac8 <printf>
	return 0;
}
34807300:	e3a00000 	mov	r0, #0
34807304:	e8bd8008 	pop	{r3, pc}
34807308:	3482509c 	.word	0x3482509c

3480730c <do_env_import>:
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
3480730c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
34807310:	e3a0a000 	mov	sl, #0
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807314:	e1a04002 	mov	r4, r2
34807318:	e24dd01c 	sub	sp, sp, #28
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
	size_t	size;

	cmd = *argv;
3480731c:	e4931004 	ldr	r1, [r3], #4
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807320:	e1a0200a 	mov	r2, sl
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
34807324:	e1a0900a 	mov	r9, sl
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
34807328:	e3a0700a 	mov	r7, #10
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
3480732c:	ea00001d 	b	348073a8 <do_env_import+0x9c>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807330:	e3500063 	cmp	r0, #99	; 0x63
34807334:	0a00000c 	beq	3480736c <do_env_import+0x60>
34807338:	8a000002 	bhi	34807348 <do_env_import+0x3c>
3480733c:	e3500062 	cmp	r0, #98	; 0x62
34807340:	1a000077 	bne	34807524 <do_env_import+0x218>
34807344:	ea000004 	b	3480735c <do_env_import+0x50>
34807348:	e3500064 	cmp	r0, #100	; 0x64
3480734c:	0a000011 	beq	34807398 <do_env_import+0x8c>
34807350:	e3500074 	cmp	r0, #116	; 0x74
34807354:	1a000072 	bne	34807524 <do_env_import+0x218>
34807358:	ea000009 	b	34807384 <do_env_import+0x78>
			case 'b':		/* raw binary format */
				if (fmt++)
3480735c:	e3520000 	cmp	r2, #0
34807360:	1a00006b 	bne	34807514 <do_env_import+0x208>
34807364:	e2822001 	add	r2, r2, #1
34807368:	ea000003 	b	3480737c <do_env_import+0x70>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
3480736c:	e3520000 	cmp	r2, #0
34807370:	1a000067 	bne	34807514 <do_env_import+0x208>
34807374:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\0';
				chk = 1;
34807378:	e1a09002 	mov	r9, r2
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
3480737c:	e3a07000 	mov	r7, #0
34807380:	ea000005 	b	3480739c <do_env_import+0x90>
				chk = 1;
				break;
			case 't':		/* text format */
				if (fmt++)
34807384:	e3520000 	cmp	r2, #0
34807388:	1a000061 	bne	34807514 <do_env_import+0x208>
3480738c:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\n';
34807390:	e3a0700a 	mov	r7, #10
34807394:	ea000000 	b	3480739c <do_env_import+0x90>
				break;
			case 'd':
				del = 1;
34807398:	e3a0a001 	mov	sl, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
3480739c:	e5fc0001 	ldrb	r0, [ip, #1]!
348073a0:	e3500000 	cmp	r0, #0
348073a4:	1affffe1 	bne	34807330 <do_env_import+0x24>
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
348073a8:	e2444001 	sub	r4, r4, #1
348073ac:	e3540000 	cmp	r4, #0
348073b0:	da00005b 	ble	34807524 <do_env_import+0x218>
348073b4:	e1a05003 	mov	r5, r3
348073b8:	e493c004 	ldr	ip, [r3], #4
348073bc:	e5dc0000 	ldrb	r0, [ip]
348073c0:	e350002d 	cmp	r0, #45	; 0x2d
348073c4:	0afffff4 	beq	3480739c <do_env_import+0x90>
348073c8:	ea000058 	b	34807530 <do_env_import+0x224>

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");
348073cc:	e59f0168 	ldr	r0, [pc, #360]	; 3480753c <do_env_import+0x230>
348073d0:	eb0009bc 	bl	34809ac8 <printf>

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348073d4:	e3a02010 	mov	r2, #16
348073d8:	e5950000 	ldr	r0, [r5]
348073dc:	e3a01000 	mov	r1, #0
348073e0:	eb00577f 	bl	3481d1e4 <simple_strtoul>

	if (argc == 2) {
348073e4:	e3540002 	cmp	r4, #2
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348073e8:	e1a06000 	mov	r6, r0

	if (argc == 2) {
348073ec:	11a02000 	movne	r2, r0
348073f0:	13a03000 	movne	r3, #0
348073f4:	1a000006 	bne	34807414 <do_env_import+0x108>
		size = simple_strtoul(argv[1], NULL, 16);
348073f8:	e5950004 	ldr	r0, [r5, #4]
348073fc:	e3a01000 	mov	r1, #0
34807400:	e3a02010 	mov	r2, #16
34807404:	eb005776 	bl	3481d1e4 <simple_strtoul>
34807408:	e1a05000 	mov	r5, r0
3480740c:	ea000013 	b	34807460 <do_env_import+0x154>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807410:	e1a03005 	mov	r3, r5
			if ((*s == sep) && (*(s+1) == '\0'))
34807414:	e4d21001 	ldrb	r1, [r2], #1
34807418:	e2835001 	add	r5, r3, #1
3480741c:	e1510007 	cmp	r1, r7
34807420:	1a000002 	bne	34807430 <do_env_import+0x124>
34807424:	e7d61005 	ldrb	r1, [r6, r5]
34807428:	e3510000 	cmp	r1, #0
3480742c:	0a000005 	beq	34807448 <do_env_import+0x13c>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807430:	e3550601 	cmp	r5, #1048576	; 0x100000
34807434:	1afffff5 	bne	34807410 <do_env_import+0x104>
				break;
			++s;
			++size;
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
34807438:	e1a01005 	mov	r1, r5
3480743c:	e59f00fc 	ldr	r0, [pc, #252]	; 34807540 <do_env_import+0x234>
34807440:	eb0009a0 	bl	34809ac8 <printf>
34807444:	ea000000 	b	3480744c <do_env_import+0x140>
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
			if ((*s == sep) && (*(s+1) == '\0'))
34807448:	e1a05003 	mov	r5, r3
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
				" - truncated\n", MAX_ENV_SIZE);
		}
		size += 2;
3480744c:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
34807450:	e59f00ec 	ldr	r0, [pc, #236]	; 34807544 <do_env_import+0x238>
34807454:	e1a01005 	mov	r1, r5
34807458:	e1a02005 	mov	r2, r5
3480745c:	eb000999 	bl	34809ac8 <printf>
	}

	if (chk) {
34807460:	e3590000 	cmp	r9, #0
34807464:	0a00000f 	beq	348074a8 <do_env_import+0x19c>
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
34807468:	e1a01006 	mov	r1, r6
3480746c:	e3a02004 	mov	r2, #4

	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
34807470:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
34807474:	e28d0014 	add	r0, sp, #20

		if (crc32(0, ep->data, size) != crc) {
34807478:	e2866004 	add	r6, r6, #4
	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
3480747c:	eb005489 	bl	3481c6a8 <memcpy>

		if (crc32(0, ep->data, size) != crc) {
34807480:	e3a00000 	mov	r0, #0
34807484:	e1a01006 	mov	r1, r6
34807488:	e1a02005 	mov	r2, r5
3480748c:	eb004d03 	bl	3481a8a0 <crc32>
34807490:	e59d3014 	ldr	r3, [sp, #20]
34807494:	e1500003 	cmp	r0, r3
34807498:	0a000002 	beq	348074a8 <do_env_import+0x19c>
			puts("## Error: bad CRC, import failed\n");
3480749c:	e59f00a4 	ldr	r0, [pc, #164]	; 34807548 <do_env_import+0x23c>
348074a0:	eb00097e 	bl	34809aa0 <puts>
348074a4:	ea00001c 	b	3480751c <do_env_import+0x210>
			return 1;
		}
		addr = (char *)ep->data;
	}

	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
348074a8:	e3a04000 	mov	r4, #0
348074ac:	e22aa001 	eor	sl, sl, #1
348074b0:	e59f0094 	ldr	r0, [pc, #148]	; 3480754c <do_env_import+0x240>
348074b4:	e1a01006 	mov	r1, r6
348074b8:	e1a02005 	mov	r2, r5
348074bc:	e1a03007 	mov	r3, r7
348074c0:	e58da000 	str	sl, [sp]
348074c4:	e58d4004 	str	r4, [sp, #4]
348074c8:	e58d4008 	str	r4, [sp, #8]
348074cc:	e58d400c 	str	r4, [sp, #12]
348074d0:	eb0050b5 	bl	3481b7ac <himport_r>
348074d4:	e1500004 	cmp	r0, r4
348074d8:	1a000008 	bne	34807500 <do_env_import+0x1f4>
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
348074dc:	e59f306c 	ldr	r3, [pc, #108]	; 34807550 <do_env_import+0x244>
348074e0:	e59f206c 	ldr	r2, [pc, #108]	; 34807554 <do_env_import+0x248>
348074e4:	e58d3000 	str	r3, [sp]
348074e8:	e59f3068 	ldr	r3, [pc, #104]	; 34807558 <do_env_import+0x24c>
348074ec:	e59f0068 	ldr	r0, [pc, #104]	; 3480755c <do_env_import+0x250>
348074f0:	e5931000 	ldr	r1, [r3]
348074f4:	e30033bd 	movw	r3, #957	; 0x3bd
348074f8:	eb000972 	bl	34809ac8 <printf>
348074fc:	ea000006 	b	3480751c <do_env_import+0x210>
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
34807500:	e5982004 	ldr	r2, [r8, #4]

	return 0;
34807504:	e1a00004 	mov	r0, r4
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
34807508:	e3822080 	orr	r2, r2, #128	; 0x80
3480750c:	e5882004 	str	r2, [r8, #4]

	return 0;
34807510:	ea000004 	b	34807528 <do_env_import+0x21c>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
34807514:	e59f0044 	ldr	r0, [pc, #68]	; 34807560 <do_env_import+0x254>
34807518:	eb00096a 	bl	34809ac8 <printf>
		cmd);
	return 1;
3480751c:	e3a00001 	mov	r0, #1
34807520:	ea000000 	b	34807528 <do_env_import+0x21c>
			}
		}
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34807524:	e3e00000 	mvn	r0, #0

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
		cmd);
	return 1;
}
34807528:	e28dd01c 	add	sp, sp, #28
3480752c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
34807530:	e3520000 	cmp	r2, #0
34807534:	1affffa6 	bne	348073d4 <do_env_import+0xc8>
34807538:	eaffffa3 	b	348073cc <do_env_import+0xc0>
3480753c:	348250b1 	.word	0x348250b1
34807540:	348250d8 	.word	0x348250d8
34807544:	3482510d 	.word	0x3482510d
34807548:	34825135 	.word	0x34825135
3480754c:	34828928 	.word	0x34828928
34807550:	34820240 	.word	0x34820240
34807554:	34825194 	.word	0x34825194
34807558:	3482bba0 	.word	0x3482bba0
3480755c:	34825157 	.word	0x34825157
34807560:	348251a1 	.word	0x348251a1

34807564 <do_env_default>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
			  int argc, char * const argv[])
{
34807564:	e92d4070 	push	{r4, r5, r6, lr}
	int all = 0, flag = 0;
34807568:	e3a0c000 	mov	ip, #0

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
3480756c:	ea000009 	b	34807598 <do_env_default+0x34>
		char *arg = *argv;

		while (*++arg) {
			switch (*arg) {
34807570:	e3530061 	cmp	r3, #97	; 0x61
34807574:	0a000002 	beq	34807584 <do_env_default+0x20>
34807578:	e3530066 	cmp	r3, #102	; 0x66
3480757c:	1a000021 	bne	34807608 <do_env_default+0xa4>
34807580:	ea000000 	b	34807588 <do_env_default+0x24>
			case 'a':		/* default all */
				all = 1;
34807584:	e3a0c001 	mov	ip, #1

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;

		while (*++arg) {
34807588:	e5f13001 	ldrb	r3, [r1, #1]!
3480758c:	e3530000 	cmp	r3, #0
34807590:	1afffff6 	bne	34807570 <do_env_default+0xc>
34807594:	e1a03004 	mov	r3, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34807598:	e2422001 	sub	r2, r2, #1
3480759c:	e3520000 	cmp	r2, #0
		char *arg = *argv;

		while (*++arg) {
348075a0:	e1a01003 	mov	r1, r3
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348075a4:	da000006 	ble	348075c4 <do_env_default+0x60>

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
348075a8:	e2834004 	add	r4, r3, #4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348075ac:	e5933004 	ldr	r3, [r3, #4]

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
348075b0:	e1a01004 	mov	r1, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348075b4:	e5d35000 	ldrb	r5, [r3]
348075b8:	e355002d 	cmp	r5, #45	; 0x2d
348075bc:	01a01003 	moveq	r1, r3
348075c0:	0afffff0 	beq	34807588 <do_env_default+0x24>
				return cmd_usage(cmdtp);
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	if (all && (argc == 0)) {
348075c4:	e3520000 	cmp	r2, #0
348075c8:	13a03000 	movne	r3, #0
348075cc:	020c3001 	andeq	r3, ip, #1
348075d0:	e3530000 	cmp	r3, #0
348075d4:	0a000002 	beq	348075e4 <do_env_default+0x80>
		/* Reset the whole environment */
		set_default_env("## Resetting to default environment\n");
348075d8:	e59f0038 	ldr	r0, [pc, #56]	; 34807618 <do_env_default+0xb4>
348075dc:	eb000e50 	bl	3480af24 <set_default_env>
		return 0;
348075e0:	ea00000a 	b	34807610 <do_env_default+0xac>
	}
	if (!all && (argc > 0)) {
348075e4:	e22cc001 	eor	ip, ip, #1
348075e8:	e3520000 	cmp	r2, #0
348075ec:	d3a0c000 	movle	ip, #0
348075f0:	c20cc001 	andgt	ip, ip, #1
348075f4:	e35c0000 	cmp	ip, #0
348075f8:	0a000002 	beq	34807608 <do_env_default+0xa4>
		/* Reset individual variables */
		set_default_vars(argc, argv);
348075fc:	e1a00002 	mov	r0, r2
34807600:	eb000e76 	bl	3480afe0 <set_default_vars>
		return 0;
34807604:	ea000001 	b	34807610 <do_env_default+0xac>
	}

	return cmd_usage(cmdtp);
}
34807608:	e8bd4070 	pop	{r4, r5, r6, lr}
		/* Reset individual variables */
		set_default_vars(argc, argv);
		return 0;
	}

	return cmd_usage(cmdtp);
3480760c:	ea0007d6 	b	3480956c <cmd_usage>
}
34807610:	e3a00000 	mov	r0, #0
34807614:	e8bd8070 	pop	{r4, r5, r6, pc}
34807618:	348251d0 	.word	0x348251d0

3480761c <env_print>:
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
3480761c:	e92d4010 	push	{r4, lr}
	char *res = NULL;
34807620:	e3a02000 	mov	r2, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34807624:	e24dd018 	sub	sp, sp, #24
	char *res = NULL;
	size_t len;

	if (name) {		/* print a single name */
34807628:	e2503000 	subs	r3, r0, #0
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
	char *res = NULL;
3480762c:	e58d2014 	str	r2, [sp, #20]
	size_t len;

	if (name) {		/* print a single name */
34807630:	0a000010 	beq	34807678 <env_print+0x5c>
		ENTRY e, *ep;

		e.key = name;
34807634:	e58d3008 	str	r3, [sp, #8]
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34807638:	e59f3074 	ldr	r3, [pc, #116]	; 348076b4 <env_print+0x98>

	if (name) {		/* print a single name */
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
3480763c:	e58d200c 	str	r2, [sp, #12]
		hsearch_r(e, FIND, &ep, &env_htab);
34807640:	e58d3000 	str	r3, [sp]
34807644:	e28d3008 	add	r3, sp, #8
34807648:	e8930003 	ldm	r3, {r0, r1}
3480764c:	e28d3010 	add	r3, sp, #16
34807650:	eb004ec4 	bl	3481b168 <hsearch_r>
		if (ep == NULL)
34807654:	e59d3010 	ldr	r3, [sp, #16]
34807658:	e3530000 	cmp	r3, #0
			return 0;
3480765c:	01a04003 	moveq	r4, r3
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
		if (ep == NULL)
34807660:	0a000010 	beq	348076a8 <env_print+0x8c>
			return 0;
		len = printf("%s=%s\n", ep->key, ep->data);
34807664:	e59f004c 	ldr	r0, [pc, #76]	; 348076b8 <env_print+0x9c>
34807668:	e8930006 	ldm	r3, {r1, r2}
3480766c:	eb000915 	bl	34809ac8 <printf>
34807670:	e1a04000 	mov	r4, r0
		return len;
34807674:	ea00000b 	b	348076a8 <env_print+0x8c>
	}

	/* print whole list */
	len = hexport_r(&env_htab, '\n', &res, 0, 0, NULL);
34807678:	e59f0034 	ldr	r0, [pc, #52]	; 348076b4 <env_print+0x98>
3480767c:	e3a0100a 	mov	r1, #10
34807680:	e28d2014 	add	r2, sp, #20
34807684:	e58d3000 	str	r3, [sp]
34807688:	e58d3004 	str	r3, [sp, #4]
3480768c:	eb004f9b 	bl	3481b500 <hexport_r>

	if (len > 0) {
34807690:	e2504000 	subs	r4, r0, #0
34807694:	0a000003 	beq	348076a8 <env_print+0x8c>
		puts(res);
34807698:	e59d0014 	ldr	r0, [sp, #20]
3480769c:	eb0008ff 	bl	34809aa0 <puts>
		free(res);
348076a0:	e59d0014 	ldr	r0, [sp, #20]
348076a4:	eb000a45 	bl	34809fc0 <free>
		return len;
	}

	/* should never happen */
	return 0;
}
348076a8:	e1a00004 	mov	r0, r4
348076ac:	e28dd018 	add	sp, sp, #24
348076b0:	e8bd8010 	pop	{r4, pc}
348076b4:	34828928 	.word	0x34828928
348076b8:	348251f5 	.word	0x348251f5

348076bc <do_env_print>:
int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {
348076bc:	e3520001 	cmp	r2, #1
	/* should never happen */
	return 0;
}

int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348076c0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348076c4:	e1a04002 	mov	r4, r2
	int i;
	int rcode = 0;

	if (argc == 1) {
348076c8:	11a07003 	movne	r7, r3
348076cc:	13a05000 	movne	r5, #0
348076d0:	13a06001 	movne	r6, #1
348076d4:	1a000012 	bne	34807724 <do_env_print+0x68>
		/* print all env vars */
		rcode = env_print(NULL);
348076d8:	e3a00000 	mov	r0, #0
348076dc:	ebffffce 	bl	3480761c <env_print>
		if (!rcode)
348076e0:	e2501000 	subs	r1, r0, #0
			return 1;
348076e4:	01a05004 	moveq	r5, r4
	int rcode = 0;

	if (argc == 1) {
		/* print all env vars */
		rcode = env_print(NULL);
		if (!rcode)
348076e8:	0a00000f 	beq	3480772c <do_env_print+0x70>
			return 1;
		printf("\nEnvironment size: %d/%ld bytes\n",
348076ec:	e59f0040 	ldr	r0, [pc, #64]	; 34807734 <do_env_print+0x78>
348076f0:	e59f2040 	ldr	r2, [pc, #64]	; 34807738 <do_env_print+0x7c>
348076f4:	eb0008f3 	bl	34809ac8 <printf>
			rcode, (ulong)ENV_SIZE);
		return 0;
348076f8:	e3a05000 	mov	r5, #0
348076fc:	ea00000a 	b	3480772c <do_env_print+0x70>
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
		int rc = env_print(argv[i]);
34807700:	e5b70004 	ldr	r0, [r7, #4]!
34807704:	ebffffc4 	bl	3480761c <env_print>
		if (!rc) {
34807708:	e3500000 	cmp	r0, #0
3480770c:	1a000003 	bne	34807720 <do_env_print+0x64>
			printf("## Error: \"%s\" not defined\n", argv[i]);
34807710:	e59f0024 	ldr	r0, [pc, #36]	; 3480773c <do_env_print+0x80>
34807714:	e5971000 	ldr	r1, [r7]
34807718:	eb0008ea 	bl	34809ac8 <printf>
			++rcode;
3480771c:	e2855001 	add	r5, r5, #1
			rcode, (ulong)ENV_SIZE);
		return 0;
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
34807720:	e2866001 	add	r6, r6, #1
34807724:	e1560004 	cmp	r6, r4
34807728:	bafffff4 	blt	34807700 <do_env_print+0x44>
			++rcode;
		}
	}

	return rcode;
}
3480772c:	e1a00005 	mov	r0, r5
34807730:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34807734:	348251fc 	.word	0x348251fc
34807738:	0003fffc 	.word	0x0003fffc
3480773c:	3482521d 	.word	0x3482521d

34807740 <get_env_id>:
static int env_id = 1;

int get_env_id(void)
{
	return env_id;
}
34807740:	e59f3004 	ldr	r3, [pc, #4]	; 3480774c <get_env_id+0xc>
34807744:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34807748:	e12fff1e 	bx	lr
3480774c:	34828374 	.word	0x34828374

34807750 <env_check_apply>:
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807750:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807754:	e3520000 	cmp	r2, #0
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807758:	e1a05001 	mov	r5, r1

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
3480775c:	e59f118c 	ldr	r1, [pc, #396]	; 348078f0 <env_check_apply+0x1a0>
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807760:	e1a04000 	mov	r4, r0
34807764:	e1a07003 	mov	r7, r3
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807768:	e59f6184 	ldr	r6, [pc, #388]	; 348078f4 <env_check_apply+0x1a4>
3480776c:	11a06002 	movne	r6, r2

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34807770:	eb0052d4 	bl	3481c2c8 <strcmp>
34807774:	e3500000 	cmp	r0, #0
34807778:	0a00000b 	beq	348077ac <env_check_apply+0x5c>
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
3480777c:	e1a00004 	mov	r0, r4
34807780:	e59f1170 	ldr	r1, [pc, #368]	; 348078f8 <env_check_apply+0x1a8>
34807784:	eb0052cf 	bl	3481c2c8 <strcmp>
34807788:	e3500000 	cmp	r0, #0
		console = stdout;
3480778c:	03a00001 	moveq	r0, #1
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34807790:	0a000005 	beq	348077ac <env_check_apply+0x5c>
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34807794:	e1a00004 	mov	r0, r4
34807798:	e59f115c 	ldr	r1, [pc, #348]	; 348078fc <env_check_apply+0x1ac>
3480779c:	eb0052c9 	bl	3481c2c8 <strcmp>
348077a0:	e3500000 	cmp	r0, #0
		console = stderr;
348077a4:	02800002 	addeq	r0, r0, #2
	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
348077a8:	1a00000f 	bne	348077ec <env_check_apply+0x9c>
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
348077ac:	e5d63000 	ldrb	r3, [r6]
348077b0:	e3530000 	cmp	r3, #0
348077b4:	1a000004 	bne	348077cc <env_check_apply+0x7c>
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
348077b8:	e3170002 	tst	r7, #2
				printf("Can't delete \"%s\"\n", name);
348077bc:	059f013c 	ldreq	r0, [pc, #316]	; 34807900 <env_check_apply+0x1b0>
348077c0:	01a01004 	moveq	r1, r4
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
348077c4:	1a000047 	bne	348078e8 <env_check_apply+0x198>
348077c8:	ea000025 	b	34807864 <env_check_apply+0x114>
#ifdef CONFIG_CONSOLE_MUX
		if (iomux_doenv(console, newval))
			return 1;
#else
		/* Try assigning specified device */
		if (console_assign(console, newval) < 0)
348077cc:	e1a01006 	mov	r1, r6
348077d0:	eb000910 	bl	34809c18 <console_assign>
348077d4:	e3500000 	cmp	r0, #0
348077d8:	ba000042 	blt	348078e8 <env_check_apply+0x198>
			return 1;

#ifdef CONFIG_SERIAL_MULTI
		if (serial_assign(newval) < 0)
348077dc:	e1a00006 	mov	r0, r6
348077e0:	eb001d42 	bl	3480ecf0 <serial_assign>
348077e4:	e3500000 	cmp	r0, #0
348077e8:	ba00003e 	blt	348078e8 <env_check_apply+0x198>
	/*
	 * When we change baudrate, or we are doing an env default -a
	 * (which will erase all variables prior to calling this),
	 * we want the baudrate to actually change - for real.
	 */
	if (oldval != NULL ||			/* variable exists */
348077ec:	e3550000 	cmp	r5, #0
348077f0:	1a000001 	bne	348077fc <env_check_apply+0xac>
348077f4:	e3170001 	tst	r7, #1
348077f8:	1a000027 	bne	3480789c <env_check_apply+0x14c>
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
348077fc:	e59f1100 	ldr	r1, [pc, #256]	; 34807904 <env_check_apply+0x1b4>
34807800:	e1a00004 	mov	r0, r4
34807804:	eb0052af 	bl	3481c2c8 <strcmp>
34807808:	e2501000 	subs	r1, r0, #0
3480780c:	1a000022 	bne	3480789c <env_check_apply+0x14c>
			int baudrate = simple_strtoul(newval, NULL, 10);
34807810:	e1a00006 	mov	r0, r6
34807814:	e3a0200a 	mov	r2, #10
34807818:	eb005671 	bl	3481d1e4 <simple_strtoul>
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
3480781c:	e3500d96 	cmp	r0, #9600	; 0x2580
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
			int baudrate = simple_strtoul(newval, NULL, 10);
34807820:	e1a05000 	mov	r5, r0
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34807824:	0a000008 	beq	3480784c <env_check_apply+0xfc>
34807828:	e3500c4b 	cmp	r0, #19200	; 0x4b00
3480782c:	0a000006 	beq	3480784c <env_check_apply+0xfc>
34807830:	e3500c96 	cmp	r0, #38400	; 0x9600
34807834:	0a000004 	beq	3480784c <env_check_apply+0xfc>
34807838:	e3500ce1 	cmp	r0, #57600	; 0xe100
3480783c:	0a000002 	beq	3480784c <env_check_apply+0xfc>
34807840:	e59f30c0 	ldr	r3, [pc, #192]	; 34807908 <env_check_apply+0x1b8>
34807844:	e1500003 	cmp	r0, r3
34807848:	1a000024 	bne	348078e0 <env_check_apply+0x190>
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
3480784c:	e5983008 	ldr	r3, [r8, #8]
34807850:	e1530005 	cmp	r3, r5
34807854:	1a000004 	bne	3480786c <env_check_apply+0x11c>
34807858:	ea00001c 	b	348078d0 <env_check_apply+0x180>
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
3480785c:	e59f00a8 	ldr	r0, [pc, #168]	; 3480790c <env_check_apply+0x1bc>
34807860:	e1a01005 	mov	r1, r5
34807864:	eb000897 	bl	34809ac8 <printf>
34807868:	ea00001e 	b	348078e8 <env_check_apply+0x198>
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
			}
			printf("## Switch baudrate to %d bps and"
3480786c:	e1a01005 	mov	r1, r5
34807870:	e59f0098 	ldr	r0, [pc, #152]	; 34807910 <env_check_apply+0x1c0>
34807874:	eb000893 	bl	34809ac8 <printf>
				"press ENTER ...\n", baudrate);
			udelay(50000);
34807878:	e30c0350 	movw	r0, #50000	; 0xc350
3480787c:	eb005414 	bl	3481c8d4 <udelay>
			gd->baudrate = baudrate;
34807880:	e5885008 	str	r5, [r8, #8]
#if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg();
34807884:	eb001d50 	bl	3480edcc <serial_setbrg>
			udelay(50000);
34807888:	e30c0350 	movw	r0, #50000	; 0xc350
3480788c:	eb005410 	bl	3481c8d4 <udelay>
			while (getc() != '\r')
34807890:	eb000866 	bl	34809a30 <getc>
34807894:	e350000d 	cmp	r0, #13
34807898:	1afffffc 	bne	34807890 <env_check_apply+0x140>

	/*
	 * Some variables should be updated when the corresponding
	 * entry in the environment is changed
	 */
	if (strcmp(name, "loadaddr") == 0) {
3480789c:	e1a00004 	mov	r0, r4
348078a0:	e59f106c 	ldr	r1, [pc, #108]	; 34807914 <env_check_apply+0x1c4>
348078a4:	eb005287 	bl	3481c2c8 <strcmp>
348078a8:	e2504000 	subs	r4, r0, #0
348078ac:	1a000009 	bne	348078d8 <env_check_apply+0x188>
		load_addr = simple_strtoul(newval, NULL, 16);
348078b0:	e1a00006 	mov	r0, r6
348078b4:	e1a01004 	mov	r1, r4
348078b8:	e3a02010 	mov	r2, #16
348078bc:	eb005648 	bl	3481d1e4 <simple_strtoul>
348078c0:	e59f3050 	ldr	r3, [pc, #80]	; 34807918 <env_check_apply+0x1c8>
348078c4:	e58300c4 	str	r0, [r3, #196]	; 0xc4
		return 0;
348078c8:	e1a00004 	mov	r0, r4
348078cc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
348078d0:	e3a00000 	mov	r0, #0
348078d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else if (strcmp(name, "bootfile") == 0) {
		copy_filename(BootFile, newval, sizeof(BootFile));
		return 0;
	}
#endif
	return 0;
348078d8:	e3a00000 	mov	r0, #0
}
348078dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
348078e0:	e3170002 	tst	r7, #2
348078e4:	0affffdc 	beq	3480785c <env_check_apply+0x10c>
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
348078e8:	e3a00001 	mov	r0, #1
348078ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348078f0:	34825239 	.word	0x34825239
348078f4:	34823d17 	.word	0x34823d17
348078f8:	3482523f 	.word	0x3482523f
348078fc:	34825246 	.word	0x34825246
34807900:	3482524d 	.word	0x3482524d
34807904:	348228bc 	.word	0x348228bc
34807908:	0001c200 	.word	0x0001c200
3480790c:	34825260 	.word	0x34825260
34807910:	34825282 	.word	0x34825282
34807914:	348228cd 	.word	0x348228cd
34807918:	34828374 	.word	0x34828374

3480791c <_do_env_set>:
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
3480791c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807920:	e5924004 	ldr	r4, [r2, #4]
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807924:	e24dd01c 	sub	sp, sp, #28
34807928:	e1a06001 	mov	r6, r1
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
3480792c:	e1a00004 	mov	r0, r4
34807930:	e3a0103d 	mov	r1, #61	; 0x3d
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807934:	e1a05002 	mov	r5, r2
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807938:	e282a004 	add	sl, r2, #4
	value = argv[2];
3480793c:	e5927008 	ldr	r7, [r2, #8]

	if (strchr(name, '=')) {
34807940:	eb00527e 	bl	3481c340 <strchr>
34807944:	e2502000 	subs	r2, r0, #0
		printf("## Error: illegal character '='"
34807948:	159f0168 	ldrne	r0, [pc, #360]	; 34807ab8 <_do_env_set+0x19c>
3480794c:	11a01004 	movne	r1, r4
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34807950:	1a000032 	bne	34807a20 <_do_env_set+0x104>
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807954:	e59f3160 	ldr	r3, [pc, #352]	; 34807abc <_do_env_set+0x1a0>
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
34807958:	e58d2010 	str	r2, [sp, #16]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
3480795c:	e59310c0 	ldr	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
34807960:	e58d400c 	str	r4, [sp, #12]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807964:	e2811001 	add	r1, r1, #1
34807968:	e58310c0 	str	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
	hsearch_r(e, FIND, &ep, &env_htab);
3480796c:	e59f314c 	ldr	r3, [pc, #332]	; 34807ac0 <_do_env_set+0x1a4>
34807970:	e58d3000 	str	r3, [sp]
34807974:	e28d300c 	add	r3, sp, #12
34807978:	e8930003 	ldm	r3, {r0, r1}
3480797c:	e28d3014 	add	r3, sp, #20
34807980:	eb004df8 	bl	3481b168 <hsearch_r>

	/*
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
34807984:	e59d1014 	ldr	r1, [sp, #20]
34807988:	e1a02007 	mov	r2, r7
3480798c:	e3510000 	cmp	r1, #0
34807990:	15911004 	ldrne	r1, [r1, #4]
34807994:	e1a00004 	mov	r0, r4
34807998:	e3a03001 	mov	r3, #1
3480799c:	ebffff6b 	bl	34807750 <env_check_apply>
348079a0:	e2507000 	subs	r7, r0, #0
348079a4:	1a000040 	bne	34807aac <_do_env_set+0x190>
		debug("check function did not approve, refusing\n");
		return 1;
	}

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
348079a8:	e3560002 	cmp	r6, #2
348079ac:	da000004 	ble	348079c4 <_do_env_set+0xa8>
348079b0:	e5953008 	ldr	r3, [r5, #8]
348079b4:	e3530000 	cmp	r3, #0
348079b8:	11a0900a 	movne	r9, sl
348079bc:	13a05002 	movne	r5, #2
348079c0:	1a000006 	bne	348079e0 <_do_env_set+0xc4>
		int rc = hdelete_r(name, &env_htab, 0);
348079c4:	e1a00004 	mov	r0, r4
348079c8:	e59f10f0 	ldr	r1, [pc, #240]	; 34807ac0 <_do_env_set+0x1a4>
348079cc:	e3a02000 	mov	r2, #0
348079d0:	eb004e9d 	bl	3481b44c <hdelete_r>
		return !rc;
348079d4:	e2700001 	rsbs	r0, r0, #1
348079d8:	33a00000 	movcc	r0, #0
348079dc:	ea000033 	b	34807ab0 <_do_env_set+0x194>

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;
348079e0:	e5b90004 	ldr	r0, [r9, #4]!
348079e4:	eb00526b 	bl	3481c398 <strlen>
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
348079e8:	e2855001 	add	r5, r5, #1
		len += strlen(argv[i]) + 1;
348079ec:	e2800001 	add	r0, r0, #1
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
348079f0:	e1550006 	cmp	r5, r6
		len += strlen(argv[i]) + 1;
348079f4:	e0807007 	add	r7, r0, r7
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
348079f8:	bafffff8 	blt	348079e0 <_do_env_set+0xc4>
		len += strlen(argv[i]) + 1;

	value = malloc(len);
348079fc:	e1a00007 	mov	r0, r7
34807a00:	eb0009f7 	bl	3480a1e4 <malloc>
	if (value == NULL) {
34807a04:	e2505000 	subs	r5, r0, #0
34807a08:	11a0c005 	movne	ip, r5
34807a0c:	13a01002 	movne	r1, #2
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807a10:	13a07020 	movne	r7, #32
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
34807a14:	1a000003 	bne	34807a28 <_do_env_set+0x10c>
		printf("## Can't malloc %d bytes\n", len);
34807a18:	e59f00a4 	ldr	r0, [pc, #164]	; 34807ac4 <_do_env_set+0x1a8>
34807a1c:	e1a01007 	mov	r1, r7
34807a20:	eb000828 	bl	34809ac8 <printf>
34807a24:	ea000020 	b	34807aac <_do_env_set+0x190>
		return 1;
34807a28:	e5bae004 	ldr	lr, [sl, #4]!
34807a2c:	e1a0300c 	mov	r3, ip
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
34807a30:	e4de2001 	ldrb	r2, [lr], #1
34807a34:	e1a00003 	mov	r0, r3
34807a38:	e3520000 	cmp	r2, #0
34807a3c:	e4c32001 	strb	r2, [r3], #1
34807a40:	e1a0c003 	mov	ip, r3
34807a44:	1afffff9 	bne	34807a30 <_do_env_set+0x114>
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807a48:	e2811001 	add	r1, r1, #1
34807a4c:	e1510006 	cmp	r1, r6
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807a50:	e5c07000 	strb	r7, [r0]
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807a54:	1afffff3 	bne	34807a28 <_do_env_set+0x10c>

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
34807a58:	e1530005 	cmp	r3, r5
		*--s = '\0';

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807a5c:	e59f305c 	ldr	r3, [pc, #92]	; 34807ac0 <_do_env_set+0x1a4>
		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';
34807a60:	15c02000 	strbne	r2, [r0]

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807a64:	e58d3000 	str	r3, [sp]
	}
	if (s != value)
		*--s = '\0';

	e.key	= name;
	e.data	= value;
34807a68:	e58d5010 	str	r5, [sp, #16]
	hsearch_r(e, ENTER, &ep, &env_htab);
34807a6c:	e28d300c 	add	r3, sp, #12
34807a70:	e8930003 	ldm	r3, {r0, r1}
34807a74:	e3a02001 	mov	r2, #1
34807a78:	e28d3014 	add	r3, sp, #20
34807a7c:	eb004db9 	bl	3481b168 <hsearch_r>
	free(value);
34807a80:	e1a00005 	mov	r0, r5
34807a84:	eb00094d 	bl	34809fc0 <free>
	if (!ep) {
34807a88:	e59d3014 	ldr	r3, [sp, #20]
34807a8c:	e3530000 	cmp	r3, #0
		printf("## Error inserting \"%s\" variable, errno=%d\n",
			name, errno);
		return 1;
	}

	return 0;
34807a90:	13a00000 	movne	r0, #0

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
	free(value);
	if (!ep) {
34807a94:	1a000005 	bne	34807ab0 <_do_env_set+0x194>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
34807a98:	e59f3028 	ldr	r3, [pc, #40]	; 34807ac8 <_do_env_set+0x1ac>
34807a9c:	e59f0028 	ldr	r0, [pc, #40]	; 34807acc <_do_env_set+0x1b0>
34807aa0:	e1a01004 	mov	r1, r4
34807aa4:	e5932000 	ldr	r2, [r3]
34807aa8:	eb000806 	bl	34809ac8 <printf>
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
		debug("check function did not approve, refusing\n");
		return 1;
34807aac:	e3a00001 	mov	r0, #1
			name, errno);
		return 1;
	}

	return 0;
}
34807ab0:	e28dd01c 	add	sp, sp, #28
34807ab4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807ab8:	348252b3 	.word	0x348252b3
34807abc:	34828374 	.word	0x34828374
34807ac0:	34828928 	.word	0x34828928
34807ac4:	348252e9 	.word	0x348252e9
34807ac8:	3482bba0 	.word	0x3482bba0
34807acc:	34825303 	.word	0x34825303

34807ad0 <do_env_set>:
}

#ifndef CONFIG_SPL_BUILD
int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
34807ad0:	e3520001 	cmp	r2, #1
34807ad4:	da000003 	ble	34807ae8 <do_env_set+0x18>
		return CMD_RET_USAGE;

	return _do_env_set(flag, argc, argv);
34807ad8:	e1a00001 	mov	r0, r1
34807adc:	e1a01002 	mov	r1, r2
34807ae0:	e1a02003 	mov	r2, r3
34807ae4:	eaffff8c 	b	3480791c <_do_env_set>
}
34807ae8:	e3e00000 	mvn	r0, #0
34807aec:	e12fff1e 	bx	lr

34807af0 <setenv>:

	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
34807af0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807af4:	e59f3040 	ldr	r3, [pc, #64]	; 34807b3c <setenv+0x4c>
34807af8:	e58d0004 	str	r0, [sp, #4]
34807afc:	e3a00000 	mov	r0, #0

	if (varvalue == NULL || varvalue[0] == '\0')
34807b00:	e1510000 	cmp	r1, r0
	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807b04:	e58d3000 	str	r3, [sp]
34807b08:	e58d1008 	str	r1, [sp, #8]
34807b0c:	e58d000c 	str	r0, [sp, #12]

	if (varvalue == NULL || varvalue[0] == '\0')
34807b10:	0a000003 	beq	34807b24 <setenv+0x34>
34807b14:	e5d13000 	ldrb	r3, [r1]
34807b18:	e1530000 	cmp	r3, r0
		return _do_env_set(0, 2, (char * const *)argv);
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807b1c:	13a01003 	movne	r1, #3

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };

	if (varvalue == NULL || varvalue[0] == '\0')
34807b20:	1a000001 	bne	34807b2c <setenv+0x3c>
		return _do_env_set(0, 2, (char * const *)argv);
34807b24:	e3a00000 	mov	r0, #0
34807b28:	e3a01002 	mov	r1, #2
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807b2c:	e1a0200d 	mov	r2, sp
34807b30:	ebffff79 	bl	3480791c <_do_env_set>
}
34807b34:	e28dd014 	add	sp, sp, #20
34807b38:	e8bd8000 	pop	{pc}
34807b3c:	3482532f 	.word	0x3482532f

34807b40 <do_env_export>:
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807b40:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807b44:	e3a0a000 	mov	sl, #0
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807b48:	e24dd038 	sub	sp, sp, #56	; 0x38
34807b4c:	e1a0c000 	mov	ip, r0
34807b50:	e1a04002 	mov	r4, r2
34807b54:	e1a05003 	mov	r5, r3
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;
34807b58:	e593b000 	ldr	fp, [r3]
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
34807b5c:	e1a0900a 	mov	r9, sl
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
34807b60:	e3a0600a 	mov	r6, #10
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
34807b64:	e1a0700a 	mov	r7, sl
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807b68:	ea000027 	b	34807c0c <do_env_export+0xcc>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807b6c:	e3520063 	cmp	r2, #99	; 0x63
34807b70:	0a00000b 	beq	34807ba4 <do_env_export+0x64>
34807b74:	8a000002 	bhi	34807b84 <do_env_export+0x44>
34807b78:	e3520062 	cmp	r2, #98	; 0x62
34807b7c:	1a000072 	bne	34807d4c <do_env_export+0x20c>
34807b80:	ea000004 	b	34807b98 <do_env_export+0x58>
34807b84:	e3520073 	cmp	r2, #115	; 0x73
34807b88:	0a00000a 	beq	34807bb8 <do_env_export+0x78>
34807b8c:	e3520074 	cmp	r2, #116	; 0x74
34807b90:	1a00006d 	bne	34807d4c <do_env_export+0x20c>
34807b94:	ea000014 	b	34807bec <do_env_export+0xac>
			case 'b':		/* raw binary format */
				if (fmt++)
34807b98:	e3530000 	cmp	r3, #0
34807b9c:	0a000003 	beq	34807bb0 <do_env_export+0x70>
34807ba0:	ea000064 	b	34807d38 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
34807ba4:	e3530000 	cmp	r3, #0
34807ba8:	1a000062 	bne	34807d38 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				chk = 1;
34807bac:	e3a09001 	mov	r9, #1
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
34807bb0:	e1a06003 	mov	r6, r3
34807bb4:	ea00000f 	b	34807bf8 <do_env_export+0xb8>
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
34807bb8:	e2544001 	subs	r4, r4, #1
34807bbc:	1a000002 	bne	34807bcc <do_env_export+0x8c>
					return cmd_usage(cmdtp);
34807bc0:	e1a0000c 	mov	r0, ip
34807bc4:	eb000668 	bl	3480956c <cmd_usage>
34807bc8:	ea000060 	b	34807d50 <do_env_export+0x210>
				size = simple_strtoul(*++argv, NULL, 16);
34807bcc:	e5b50004 	ldr	r0, [r5, #4]!
34807bd0:	e3a01000 	mov	r1, #0
34807bd4:	e3a02010 	mov	r2, #16
34807bd8:	e58dc00c 	str	ip, [sp, #12]
34807bdc:	eb005580 	bl	3481d1e4 <simple_strtoul>
				goto NXTARG;
34807be0:	e59dc00c 	ldr	ip, [sp, #12]
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
34807be4:	e1a07000 	mov	r7, r0
				goto NXTARG;
34807be8:	ea000007 	b	34807c0c <do_env_export+0xcc>
			case 't':		/* text format */
				if (fmt++)
34807bec:	e3530000 	cmp	r3, #0
34807bf0:	1a000050 	bne	34807d38 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\n';
34807bf4:	e3a0600a 	mov	r6, #10
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807bf8:	e3a03001 	mov	r3, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807bfc:	e5f02001 	ldrb	r2, [r0, #1]!
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807c00:	e1a0a003 	mov	sl, r3

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807c04:	e3520000 	cmp	r2, #0
34807c08:	1affffd7 	bne	34807b6c <do_env_export+0x2c>
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807c0c:	e2444001 	sub	r4, r4, #1
34807c10:	e3540000 	cmp	r4, #0
34807c14:	da00004c 	ble	34807d4c <do_env_export+0x20c>
34807c18:	e5b50004 	ldr	r0, [r5, #4]!
34807c1c:	e5d03000 	ldrb	r3, [r0]
34807c20:	e353002d 	cmp	r3, #45	; 0x2d
34807c24:	1a00004b 	bne	34807d58 <do_env_export+0x218>
34807c28:	e1a0300a 	mov	r3, sl
34807c2c:	eafffff2 	b	34807bfc <do_env_export+0xbc>
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);
34807c30:	e3a01000 	mov	r1, #0
34807c34:	e1a02007 	mov	r2, r7
34807c38:	eb005276 	bl	3481c618 <memset>

	argc--;
	argv++;

	if (sep) {		/* export as text file */
34807c3c:	e3560000 	cmp	r6, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);

	argc--;
34807c40:	e2444001 	sub	r4, r4, #1
	argv++;
34807c44:	e2855004 	add	r5, r5, #4

	if (sep) {		/* export as text file */
34807c48:	0a000013 	beq	34807c9c <do_env_export+0x15c>
		len = hexport_r(&env_htab, sep, &addr, size, argc, argv);
34807c4c:	e28d2034 	add	r2, sp, #52	; 0x34
34807c50:	e59f011c 	ldr	r0, [pc, #284]	; 34807d74 <do_env_export+0x234>
34807c54:	e1a01006 	mov	r1, r6
34807c58:	e1a03007 	mov	r3, r7
34807c5c:	e88d0030 	stm	sp, {r4, r5}
34807c60:	eb004e26 	bl	3481b500 <hexport_r>
		if (len < 0) {
34807c64:	e2502000 	subs	r2, r0, #0
34807c68:	aa000007 	bge	34807c8c <do_env_export+0x14c>
			error("Cannot export environment: errno = %d\n", errno);
34807c6c:	e59f3104 	ldr	r3, [pc, #260]	; 34807d78 <do_env_export+0x238>
34807c70:	e59f0104 	ldr	r0, [pc, #260]	; 34807d7c <do_env_export+0x23c>
34807c74:	e58d3000 	str	r3, [sp]
34807c78:	e59f3100 	ldr	r3, [pc, #256]	; 34807d80 <do_env_export+0x240>
34807c7c:	e59f2100 	ldr	r2, [pc, #256]	; 34807d84 <do_env_export+0x244>
34807c80:	e5931000 	ldr	r1, [r3]
34807c84:	e3003333 	movw	r3, #819	; 0x333
34807c88:	ea000017 	b	34807cec <do_env_export+0x1ac>
			return 1;
		}
		sprintf(buf, "%zX", (size_t)len);
34807c8c:	e28d4010 	add	r4, sp, #16
34807c90:	e1a00004 	mov	r0, r4
34807c94:	e59f10ec 	ldr	r1, [pc, #236]	; 34807d88 <do_env_export+0x248>
34807c98:	ea000020 	b	34807d20 <do_env_export+0x1e0>
		setenv("filesize", buf);

		return 0;
	}

	envp = (env_t *)addr;
34807c9c:	e59d6034 	ldr	r6, [sp, #52]	; 0x34

	if (chk)		/* export as checksum protected block */
34807ca0:	e3590000 	cmp	r9, #0
		res = (char *)envp->data;
34807ca4:	12863004 	addne	r3, r6, #4
34807ca8:	158d3030 	strne	r3, [sp, #48]	; 0x30
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807cac:	e59f00c0 	ldr	r0, [pc, #192]	; 34807d74 <do_env_export+0x234>
34807cb0:	e3a01000 	mov	r1, #0
34807cb4:	e28d2030 	add	r2, sp, #48	; 0x30
34807cb8:	e59f30cc 	ldr	r3, [pc, #204]	; 34807d8c <do_env_export+0x24c>
	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
	else			/* export as raw binary data */
		res = addr;
34807cbc:	058d6030 	streq	r6, [sp, #48]	; 0x30

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807cc0:	e88d0030 	stm	sp, {r4, r5}
34807cc4:	eb004e0d 	bl	3481b500 <hexport_r>
	if (len < 0) {
34807cc8:	e2505000 	subs	r5, r0, #0
34807ccc:	aa000008 	bge	34807cf4 <do_env_export+0x1b4>
		error("Cannot export environment: errno = %d\n", errno);
34807cd0:	e59f30a0 	ldr	r3, [pc, #160]	; 34807d78 <do_env_export+0x238>
34807cd4:	e59f00a0 	ldr	r0, [pc, #160]	; 34807d7c <do_env_export+0x23c>
34807cd8:	e58d3000 	str	r3, [sp]
34807cdc:	e59f309c 	ldr	r3, [pc, #156]	; 34807d80 <do_env_export+0x240>
34807ce0:	e59f209c 	ldr	r2, [pc, #156]	; 34807d84 <do_env_export+0x244>
34807ce4:	e5931000 	ldr	r1, [r3]
34807ce8:	e3003345 	movw	r3, #837	; 0x345
34807cec:	eb000775 	bl	34809ac8 <printf>
34807cf0:	ea000013 	b	34807d44 <do_env_export+0x204>
		return 1;
	}

	if (chk) {
34807cf4:	e3590000 	cmp	r9, #0
34807cf8:	0a000004 	beq	34807d10 <do_env_export+0x1d0>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
34807cfc:	e3a00000 	mov	r0, #0
34807d00:	e2861004 	add	r1, r6, #4
34807d04:	e59f2080 	ldr	r2, [pc, #128]	; 34807d8c <do_env_export+0x24c>
34807d08:	eb004ae4 	bl	3481a8a0 <crc32>
34807d0c:	e5860000 	str	r0, [r6]
#ifdef CONFIG_ENV_ADDR_REDUND
		envp->flags = ACTIVE_FLAG;
#endif
	}
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
34807d10:	e28d4010 	add	r4, sp, #16
34807d14:	e59f106c 	ldr	r1, [pc, #108]	; 34807d88 <do_env_export+0x248>
34807d18:	e1a00004 	mov	r0, r4
34807d1c:	e2852004 	add	r2, r5, #4
34807d20:	eb0055d5 	bl	3481d47c <sprintf>
	setenv("filesize", buf);
34807d24:	e59f0064 	ldr	r0, [pc, #100]	; 34807d90 <do_env_export+0x250>
34807d28:	e1a01004 	mov	r1, r4
34807d2c:	ebffff6f 	bl	34807af0 <setenv>

	return 0;
34807d30:	e3a00000 	mov	r0, #0
34807d34:	ea000005 	b	34807d50 <do_env_export+0x210>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
34807d38:	e59f0054 	ldr	r0, [pc, #84]	; 34807d94 <do_env_export+0x254>
34807d3c:	e1a0100b 	mov	r1, fp
34807d40:	eb000760 	bl	34809ac8 <printf>
	return 1;
34807d44:	e3a00001 	mov	r0, #1
34807d48:	ea000000 	b	34807d50 <do_env_export+0x210>
		}
NXTARG:		;
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34807d4c:	e3e00000 	mvn	r0, #0
	return 0;

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
	return 1;
}
34807d50:	e28dd038 	add	sp, sp, #56	; 0x38
34807d54:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807d58:	e3a01000 	mov	r1, #0
34807d5c:	e3a02010 	mov	r2, #16
34807d60:	eb00551f 	bl	3481d1e4 <simple_strtoul>

	if (size)
34807d64:	e3570000 	cmp	r7, #0
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807d68:	e58d0034 	str	r0, [sp, #52]	; 0x34

	if (size)
34807d6c:	0affffb2 	beq	34807c3c <do_env_export+0xfc>
34807d70:	eaffffae 	b	34807c30 <do_env_export+0xf0>
34807d74:	34828928 	.word	0x34828928
34807d78:	34820250 	.word	0x34820250
34807d7c:	34825336 	.word	0x34825336
34807d80:	3482bba0 	.word	0x3482bba0
34807d84:	34825194 	.word	0x34825194
34807d88:	34825373 	.word	0x34825373
34807d8c:	0003fffc 	.word	0x0003fffc
34807d90:	348231d5 	.word	0x348231d5
34807d94:	348251a1 	.word	0x348251a1

34807d98 <setenv_ulong>:
 * @param varname	Environmet variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_ulong(const char *varname, ulong value)
{
34807d98:	e92d4010 	push	{r4, lr}
34807d9c:	e1a04000 	mov	r4, r0
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);
34807da0:	e1a00001 	mov	r0, r1
34807da4:	eb0055d3 	bl	3481d4f8 <simple_itoa>
34807da8:	e1a01000 	mov	r1, r0

	return setenv(varname, str);
34807dac:	e1a00004 	mov	r0, r4
}
34807db0:	e8bd4010 	pop	{r4, lr}
int setenv_ulong(const char *varname, ulong value)
{
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);

	return setenv(varname, str);
34807db4:	eaffff4d 	b	34807af0 <setenv>

34807db8 <setenv_addr>:
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807db8:	e92d4030 	push	{r4, r5, lr}
34807dbc:	e24dd01c 	sub	sp, sp, #28
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
34807dc0:	e28d4004 	add	r4, sp, #4
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807dc4:	e1a05000 	mov	r5, r0
34807dc8:	e1a02001 	mov	r2, r1
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
34807dcc:	e1a00004 	mov	r0, r4
34807dd0:	e59f1014 	ldr	r1, [pc, #20]	; 34807dec <setenv_addr+0x34>
34807dd4:	eb0055a8 	bl	3481d47c <sprintf>
	return setenv(varname, str);
34807dd8:	e1a00005 	mov	r0, r5
34807ddc:	e1a01004 	mov	r1, r4
34807de0:	ebffff42 	bl	34807af0 <setenv>
}
34807de4:	e28dd01c 	add	sp, sp, #28
34807de8:	e8bd8030 	pop	{r4, r5, pc}
34807dec:	348230c8 	.word	0x348230c8

34807df0 <envmatch>:
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
34807df0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34807df4:	e1a05001 	mov	r5, r1
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
		return i2;

	return -1;
34807df8:	e1a06000 	mov	r6, r0
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807dfc:	ea000003 	b	34807e10 <envmatch+0x20>
		if (*s1++ == '=')
34807e00:	e5563001 	ldrb	r3, [r6, #-1]
34807e04:	e353003d 	cmp	r3, #61	; 0x3d
34807e08:	0a00000f 	beq	34807e4c <envmatch+0x5c>
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807e0c:	e1a05004 	mov	r5, r4
34807e10:	e1a00005 	mov	r0, r5
		if (*s1++ == '=')
34807e14:	e1a07006 	mov	r7, r6
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807e18:	e4d6a001 	ldrb	sl, [r6], #1
34807e1c:	eb000c33 	bl	3480aef0 <env_get_char>
34807e20:	e15a0000 	cmp	sl, r0
34807e24:	e2854001 	add	r4, r5, #1
34807e28:	0afffff4 	beq	34807e00 <envmatch+0x10>
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807e2c:	e5d73000 	ldrb	r3, [r7]
34807e30:	e3530000 	cmp	r3, #0
		return i2;

	return -1;
34807e34:	13e04000 	mvnne	r4, #0
{
	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807e38:	1a000003 	bne	34807e4c <envmatch+0x5c>
34807e3c:	e1a00005 	mov	r0, r5
34807e40:	eb000c2a 	bl	3480aef0 <env_get_char>
		return i2;

	return -1;
34807e44:	e350003d 	cmp	r0, #61	; 0x3d
34807e48:	13e04000 	mvnne	r4, #0
}
34807e4c:	e1a00004 	mov	r0, r4
34807e50:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34807e54 <getenv_f>:

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
34807e54:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34807e58:	e1a05000 	mov	r5, r0
34807e5c:	e1a06001 	mov	r6, r1
34807e60:	e1a0a002 	mov	sl, r2
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807e64:	e3a0b000 	mov	fp, #0
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34807e68:	e59f9098 	ldr	r9, [pc, #152]	; 34807f08 <getenv_f+0xb4>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807e6c:	ea00001d 	b	34807ee8 <getenv_f+0x94>
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34807e70:	e1570009 	cmp	r7, r9
34807e74:	ca000020 	bgt	34807efc <getenv_f+0xa8>
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
34807e78:	e2877001 	add	r7, r7, #1
34807e7c:	e1a00007 	mov	r0, r7
34807e80:	eb000c1a 	bl	3480aef0 <env_get_char>
34807e84:	e2504000 	subs	r4, r0, #0
34807e88:	1afffff8 	bne	34807e70 <getenv_f+0x1c>
			if (nxt >= CONFIG_ENV_SIZE)
				return -1;
		}

		val = envmatch((uchar *)name, i);
34807e8c:	e1a0100b 	mov	r1, fp
34807e90:	e1a00005 	mov	r0, r5
34807e94:	ebffffd5 	bl	34807df0 <envmatch>
		if (val < 0)
34807e98:	e250b000 	subs	fp, r0, #0
34807e9c:	aa000006 	bge	34807ebc <getenv_f+0x68>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807ea0:	e287b001 	add	fp, r7, #1
34807ea4:	ea00000f 	b	34807ee8 <getenv_f+0x94>
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
34807ea8:	eb000c10 	bl	3480aef0 <env_get_char>
			if (*buf == '\0')
34807eac:	e3500000 	cmp	r0, #0
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
34807eb0:	e4c60001 	strb	r0, [r6], #1
			if (*buf == '\0')
34807eb4:	0a000011 	beq	34807f00 <getenv_f+0xac>
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807eb8:	e2844001 	add	r4, r4, #1
34807ebc:	e154000a 	cmp	r4, sl
}

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
34807ec0:	e084000b 	add	r0, r4, fp
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807ec4:	3afffff7 	bcc	34807ea8 <getenv_f+0x54>
			*buf = env_get_char(val++);
			if (*buf == '\0')
				return n;
		}

		if (n)
34807ec8:	e3540000 	cmp	r4, #0
			*--buf = '\0';
34807ecc:	13a03000 	movne	r3, #0
34807ed0:	15463001 	strbne	r3, [r6, #-1]

		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807ed4:	e1a0100a 	mov	r1, sl
34807ed8:	e1a02005 	mov	r2, r5
34807edc:	e59f0028 	ldr	r0, [pc, #40]	; 34807f0c <getenv_f+0xb8>
34807ee0:	eb0006f8 	bl	34809ac8 <printf>
			len, name);

		return n;
34807ee4:	ea000005 	b	34807f00 <getenv_f+0xac>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807ee8:	e1a0000b 	mov	r0, fp
34807eec:	eb000bff 	bl	3480aef0 <env_get_char>
34807ef0:	e3500000 	cmp	r0, #0
34807ef4:	11a0700b 	movne	r7, fp
34807ef8:	1affffdf 	bne	34807e7c <getenv_f+0x28>
			len, name);

		return n;
	}

	return -1;
34807efc:	e3e04000 	mvn	r4, #0
}
34807f00:	e1a00004 	mov	r0, r4
34807f04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807f08:	0003ffff 	.word	0x0003ffff
34807f0c:	34825377 	.word	0x34825377

34807f10 <getenv>:
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
34807f10:	e92d4010 	push	{r4, lr}
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34807f14:	e5984004 	ldr	r4, [r8, #4]
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
34807f18:	e24dd018 	sub	sp, sp, #24
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34807f1c:	e2144080 	ands	r4, r4, #128	; 0x80
34807f20:	0a00000c 	beq	34807f58 <getenv+0x48>

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34807f24:	e59f304c 	ldr	r3, [pc, #76]	; 34807f78 <getenv+0x68>
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
34807f28:	e3a02000 	mov	r2, #0
		hsearch_r(e, FIND, &ep, &env_htab);
34807f2c:	e58d3000 	str	r3, [sp]
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
34807f30:	e58d000c 	str	r0, [sp, #12]
		e.data	= NULL;
34807f34:	e58d2010 	str	r2, [sp, #16]
		hsearch_r(e, FIND, &ep, &env_htab);
34807f38:	e28d300c 	add	r3, sp, #12
34807f3c:	e8930003 	ldm	r3, {r0, r1}
34807f40:	e28d3014 	add	r3, sp, #20
34807f44:	eb004c87 	bl	3481b168 <hsearch_r>

		return ep ? ep->data : NULL;
34807f48:	e59d0014 	ldr	r0, [sp, #20]
34807f4c:	e3500000 	cmp	r0, #0
34807f50:	15900004 	ldrne	r0, [r0, #4]
34807f54:	ea000005 	b	34807f70 <getenv+0x60>
	}

	/* restricted capabilities before import */
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
34807f58:	e2881058 	add	r1, r8, #88	; 0x58
34807f5c:	e3a02020 	mov	r2, #32
34807f60:	ebffffbb 	bl	34807e54 <getenv_f>
34807f64:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
34807f68:	c2880058 	addgt	r0, r8, #88	; 0x58

	return NULL;
34807f6c:	d1a00004 	movle	r0, r4
}
34807f70:	e28dd018 	add	sp, sp, #24
34807f74:	e8bd8010 	pop	{r4, pc}
34807f78:	34828928 	.word	0x34828928

34807f7c <getenv_ulong>:
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 */
ulong getenv_ulong(const char *name, int base, ulong default_val)
{
34807f7c:	e92d4070 	push	{r4, r5, r6, lr}
34807f80:	e1a04001 	mov	r4, r1
34807f84:	e1a05002 	mov	r5, r2
	/*
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);
34807f88:	ebffffe0 	bl	34807f10 <getenv>

	return str ? simple_strtoul(str, NULL, base) : default_val;
34807f8c:	e3500000 	cmp	r0, #0
34807f90:	0a000003 	beq	34807fa4 <getenv_ulong+0x28>
34807f94:	e3a01000 	mov	r1, #0
34807f98:	e1a02004 	mov	r2, r4
}
34807f9c:	e8bd4070 	pop	{r4, r5, r6, lr}
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);

	return str ? simple_strtoul(str, NULL, base) : default_val;
34807fa0:	ea00548f 	b	3481d1e4 <simple_strtoul>
}
34807fa4:	e1a00005 	mov	r0, r5
34807fa8:	e8bd8070 	pop	{r4, r5, r6, pc}

34807fac <do_env_edit>:
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807fac:	e92d4030 	push	{r4, r5, lr}
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
34807fb0:	e3520001 	cmp	r2, #1
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807fb4:	e24ddf41 	sub	sp, sp, #260	; 0x104
34807fb8:	e1a05003 	mov	r5, r3
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
		return CMD_RET_USAGE;
34807fbc:	d3e00000 	mvnle	r0, #0
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
34807fc0:	da00000f 	ble	34808004 <do_env_edit+0x58>
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
34807fc4:	e5930004 	ldr	r0, [r3, #4]
34807fc8:	ebffffd0 	bl	34807f10 <getenv>
	if (init_val)
34807fcc:	e2502000 	subs	r2, r0, #0
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';
34807fd0:	05cd2000 	strbeq	r2, [sp]
	if (argc < 2)
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
	if (init_val)
34807fd4:	0a000002 	beq	34807fe4 <do_env_edit+0x38>
		sprintf(buffer, "%s", init_val);
34807fd8:	e1a0000d 	mov	r0, sp
34807fdc:	e59f1028 	ldr	r1, [pc, #40]	; 3480800c <do_env_edit+0x60>
34807fe0:	eb005525 	bl	3481d47c <sprintf>
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34807fe4:	e1a0100d 	mov	r1, sp
34807fe8:	e59f0020 	ldr	r0, [pc, #32]	; 34808010 <do_env_edit+0x64>
34807fec:	e3a02000 	mov	r2, #0
34807ff0:	eb00172c 	bl	3480dca8 <readline_into_buffer>

	return setenv(argv[1], buffer);
34807ff4:	e5950004 	ldr	r0, [r5, #4]
34807ff8:	e1a0100d 	mov	r1, sp
	if (init_val)
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34807ffc:	e1a0400d 	mov	r4, sp

	return setenv(argv[1], buffer);
34808000:	ebfffeba 	bl	34807af0 <setenv>
}
34808004:	e28ddf41 	add	sp, sp, #260	; 0x104
34808008:	e8bd8030 	pop	{r4, r5, pc}
3480800c:	34824a94 	.word	0x34824a94
34808010:	348253a7 	.word	0x348253a7

34808014 <do_onenand>:

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
34808014:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_onenand_sub, ARRAY_SIZE(cmd_onenand_sub));
}
#endif

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808018:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480801c:	e1a05000 	mov	r5, r0
34808020:	e1a06001 	mov	r6, r1
34808024:	e1a04002 	mov	r4, r2
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;
34808028:	d3e00000 	mvnle	r0, #0

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
3480802c:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
34808030:	e59f1044 	ldr	r1, [pc, #68]	; 3480807c <do_onenand+0x68>
34808034:	e59f2044 	ldr	r2, [pc, #68]	; 34808080 <do_onenand+0x6c>

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34808038:	e5930004 	ldr	r0, [r3, #4]
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
3480803c:	e5821000 	str	r1, [r2]

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34808040:	e59f103c 	ldr	r1, [pc, #60]	; 34808084 <do_onenand+0x70>
34808044:	e3a02009 	mov	r2, #9

	mtd = &onenand_mtd;

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;
34808048:	e2837004 	add	r7, r3, #4

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
3480804c:	eb000515 	bl	348094a8 <find_cmd_tbl>

	if (c)
34808050:	e3500000 	cmp	r0, #0
34808054:	0a000006 	beq	34808074 <do_onenand+0x60>
		return c->cmd(cmdtp, flag, argc, argv);
34808058:	e590c00c 	ldr	ip, [r0, #12]
3480805c:	e1a01006 	mov	r1, r6
34808060:	e1a00005 	mov	r0, r5
34808064:	e2442001 	sub	r2, r4, #1
34808068:	e1a03007 	mov	r3, r7
3480806c:	e12fff3c 	blx	ip
34808070:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else
		return CMD_RET_USAGE;
34808074:	e3e00000 	mvn	r0, #0
}
34808078:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480807c:	3482ba20 	.word	0x3482ba20
34808080:	34829cc0 	.word	0x34829cc0
34808084:	3482843c 	.word	0x3482843c

34808088 <str2long>:

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34808088:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
3480808c:	e1a05001 	mov	r5, r1
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
34808090:	e3a02010 	mov	r2, #16
34808094:	e28d1004 	add	r1, sp, #4

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34808098:	e1a04000 	mov	r4, r0
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
3480809c:	eb005450 	bl	3481d1e4 <simple_strtoul>
348080a0:	e5850000 	str	r0, [r5]
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
348080a4:	e5d40000 	ldrb	r0, [r4]
348080a8:	e3500000 	cmp	r0, #0
348080ac:	0a000003 	beq	348080c0 <str2long+0x38>
348080b0:	e59d3004 	ldr	r3, [sp, #4]
static struct mtd_info *mtd;

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
348080b4:	e5d30000 	ldrb	r0, [r3]
348080b8:	e2700001 	rsbs	r0, r0, #1
348080bc:	33a00000 	movcc	r0, #0
{
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}
348080c0:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}

348080c4 <do_onenand_markbad>:

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348080c4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	ulong addr;

	argc -= 2;
348080c8:	e2425002 	sub	r5, r2, #2
	argv += 2;

	if (argc <= 0)
348080cc:	e3550000 	cmp	r5, #0
		return CMD_RET_USAGE;
348080d0:	d3e04000 	mvnle	r4, #0
	ulong addr;

	argc -= 2;
	argv += 2;

	if (argc <= 0)
348080d4:	da00001a 	ble	34808144 <do_onenand_markbad+0x80>
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);

		if (mtd->block_markbad(mtd, addr)) {
348080d8:	e59fa06c 	ldr	sl, [pc, #108]	; 3480814c <do_onenand_markbad+0x88>
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
348080dc:	e2836004 	add	r6, r3, #4
348080e0:	e3a04000 	mov	r4, #0

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);
348080e4:	e3a01000 	mov	r1, #0
348080e8:	e3a02010 	mov	r2, #16
348080ec:	e5b60004 	ldr	r0, [r6, #4]!
348080f0:	eb00543b 	bl	3481d1e4 <simple_strtoul>
348080f4:	e1a07000 	mov	r7, r0

		if (mtd->block_markbad(mtd, addr)) {
348080f8:	e59a0000 	ldr	r0, [sl]
348080fc:	e1a02007 	mov	r2, r7
34808100:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34808104:	e3a03000 	mov	r3, #0
34808108:	e12fff31 	blx	r1
3480810c:	e3500000 	cmp	r0, #0
34808110:	0a000005 	beq	3480812c <do_onenand_markbad+0x68>
			printf("block 0x%08lx NOT marked "
34808114:	e1a02004 	mov	r2, r4
34808118:	e59f0030 	ldr	r0, [pc, #48]	; 34808150 <do_onenand_markbad+0x8c>
3480811c:	e1a01007 	mov	r1, r7
34808120:	eb000668 	bl	34809ac8 <printf>
				"as bad! ERROR %d\n",
				addr, ret);
			ret = 1;
34808124:	e3a04001 	mov	r4, #1
34808128:	ea000002 	b	34808138 <do_onenand_markbad+0x74>
		} else {
			printf("block 0x%08lx successfully "
3480812c:	e59f0020 	ldr	r0, [pc, #32]	; 34808154 <do_onenand_markbad+0x90>
34808130:	e1a01007 	mov	r1, r7
34808134:	eb000663 	bl	34809ac8 <printf>
				"marked as bad\n",
				addr);
		}
		--argc;
34808138:	e2455001 	sub	r5, r5, #1
	argv += 2;

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
3480813c:	e3550000 	cmp	r5, #0
34808140:	caffffe7 	bgt	348080e4 <do_onenand_markbad+0x20>
		}
		--argc;
		++argv;
	}
	return ret;
}
34808144:	e1a00004 	mov	r0, r4
34808148:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480814c:	34829cc0 	.word	0x34829cc0
34808150:	34825795 	.word	0x34825795
34808154:	348257c0 	.word	0x348257c0

34808158 <do_onenand_bad>:
	printf("%s\n", mtd->name);
	return 0;
}

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808158:	e92d4038 	push	{r3, r4, r5, lr}
	ulong ofs;

	mtd = &onenand_mtd;
3480815c:	e59f3070 	ldr	r3, [pc, #112]	; 348081d4 <do_onenand_bad+0x7c>
34808160:	e59f5070 	ldr	r5, [pc, #112]	; 348081d8 <do_onenand_bad+0x80>
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34808164:	e59f0070 	ldr	r0, [pc, #112]	; 348081dc <do_onenand_bad+0x84>
34808168:	e3a01000 	mov	r1, #0

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	ulong ofs;

	mtd = &onenand_mtd;
3480816c:	e5853000 	str	r3, [r5]
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34808170:	e3a04000 	mov	r4, #0
{
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34808174:	eb000653 	bl	34809ac8 <printf>
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34808178:	ea00000b 	b	348081ac <do_onenand_bad+0x54>
		if (mtd->block_isbad(mtd, ofs))
3480817c:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808180:	e1a02004 	mov	r2, r4
34808184:	e3a03000 	mov	r3, #0
34808188:	e12fff31 	blx	r1
3480818c:	e3500000 	cmp	r0, #0
34808190:	0a000002 	beq	348081a0 <do_onenand_bad+0x48>
			printf("  %08x\n", (u32)ofs);
34808194:	e59f0044 	ldr	r0, [pc, #68]	; 348081e0 <do_onenand_bad+0x88>
34808198:	e1a01004 	mov	r1, r4
3480819c:	eb000649 	bl	34809ac8 <printf>
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
348081a0:	e5953000 	ldr	r3, [r5]
348081a4:	e5933010 	ldr	r3, [r3, #16]
348081a8:	e0844003 	add	r4, r4, r3
348081ac:	e5950000 	ldr	r0, [r5]
348081b0:	e590300c 	ldr	r3, [r0, #12]
348081b4:	e3530000 	cmp	r3, #0
348081b8:	8affffef 	bhi	3480817c <do_onenand_bad+0x24>
348081bc:	1a000002 	bne	348081cc <do_onenand_bad+0x74>
348081c0:	e5903008 	ldr	r3, [r0, #8]
348081c4:	e1530004 	cmp	r3, r4
348081c8:	8affffeb 	bhi	3480817c <do_onenand_bad+0x24>
		if (mtd->block_isbad(mtd, ofs))
			printf("  %08x\n", (u32)ofs);
	}

	return 0;
}
348081cc:	e3a00000 	mov	r0, #0
348081d0:	e8bd8038 	pop	{r3, r4, r5, pc}
348081d4:	3482ba20 	.word	0x3482ba20
348081d8:	34829cc0 	.word	0x34829cc0
348081dc:	348257ea 	.word	0x348257ea
348081e0:	348263d2 	.word	0x348263d2

348081e4 <do_onenand_info>:

	return 0;
}

static int do_onenand_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348081e4:	e92d4008 	push	{r3, lr}
	printf("%s\n", mtd->name);
348081e8:	e59f3014 	ldr	r3, [pc, #20]	; 34808204 <do_onenand_info+0x20>
348081ec:	e59f0014 	ldr	r0, [pc, #20]	; 34808208 <do_onenand_info+0x24>
348081f0:	e5933000 	ldr	r3, [r3]
348081f4:	e5931020 	ldr	r1, [r3, #32]
348081f8:	eb000632 	bl	34809ac8 <printf>
	return 0;
}
348081fc:	e3a00000 	mov	r0, #0
34808200:	e8bd8008 	pop	{r3, pc}
34808204:	34829cc0 	.word	0x34829cc0
34808208:	34825e78 	.word	0x34825e78

3480820c <arg_off_size>:
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
3480820c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	if (argc >= 1) {
34808210:	e2507000 	subs	r7, r0, #0
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
34808214:	e1a04001 	mov	r4, r1
34808218:	e1a05002 	mov	r5, r2
3480821c:	e1a06003 	mov	r6, r3
	if (argc >= 1) {
34808220:	da000007 	ble	34808244 <arg_off_size+0x38>
		if (!(str2long(argv[0], off))) {
34808224:	e5910000 	ldr	r0, [r1]
34808228:	e1a01002 	mov	r1, r2
3480822c:	ebffff95 	bl	34808088 <str2long>
34808230:	e3500000 	cmp	r0, #0
			printf("'%s' is not a number\n", argv[0]);
34808234:	059f00d0 	ldreq	r0, [pc, #208]	; 3480830c <arg_off_size+0x100>
34808238:	05941000 	ldreq	r1, [r4]
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
	if (argc >= 1) {
		if (!(str2long(argv[0], off))) {
3480823c:	1a000003 	bne	34808250 <arg_off_size+0x44>
34808240:	ea00000b 	b	34808274 <arg_off_size+0x68>
			printf("'%s' is not a number\n", argv[0]);
			return -1;
		}
	} else {
		*off = 0;
34808244:	e3a03000 	mov	r3, #0
34808248:	e5823000 	str	r3, [r2]
3480824c:	ea00000a 	b	3480827c <arg_off_size+0x70>
	}

	if (argc >= 2) {
34808250:	e3570001 	cmp	r7, #1
34808254:	0a000008 	beq	3480827c <arg_off_size+0x70>
		if (!(str2long(argv[1], (ulong *)size))) {
34808258:	e5940004 	ldr	r0, [r4, #4]
3480825c:	e1a01006 	mov	r1, r6
34808260:	ebffff88 	bl	34808088 <str2long>
34808264:	e3500000 	cmp	r0, #0
34808268:	1a000009 	bne	34808294 <arg_off_size+0x88>
			printf("'%s' is not a number\n", argv[1]);
3480826c:	e59f0098 	ldr	r0, [pc, #152]	; 3480830c <arg_off_size+0x100>
34808270:	e5941004 	ldr	r1, [r4, #4]
34808274:	eb000613 	bl	34809ac8 <printf>
34808278:	ea000014 	b	348082d0 <arg_off_size+0xc4>
			return -1;
		}
	} else {
		*size = mtd->size - *off;
3480827c:	e59f308c 	ldr	r3, [pc, #140]	; 34808310 <arg_off_size+0x104>
34808280:	e5933000 	ldr	r3, [r3]
34808284:	e5932008 	ldr	r2, [r3, #8]
34808288:	e5953000 	ldr	r3, [r5]
3480828c:	e0633002 	rsb	r3, r3, r2
34808290:	e5863000 	str	r3, [r6]
	}

	if ((*off + *size) > mtd->size) {
34808294:	e59f3074 	ldr	r3, [pc, #116]	; 34808310 <arg_off_size+0x104>
34808298:	e5951000 	ldr	r1, [r5]
3480829c:	e5933000 	ldr	r3, [r3]
348082a0:	e5962000 	ldr	r2, [r6]
348082a4:	e593400c 	ldr	r4, [r3, #12]
348082a8:	e593c008 	ldr	ip, [r3, #8]
348082ac:	e3a03000 	mov	r3, #0
348082b0:	e1530004 	cmp	r3, r4
348082b4:	e0820001 	add	r0, r2, r1
348082b8:	1a000006 	bne	348082d8 <arg_off_size+0xcc>
348082bc:	e150000c 	cmp	r0, ip
348082c0:	9a000004 	bls	348082d8 <arg_off_size+0xcc>
		printf("total chip size (0x%llx) exceeded!\n", mtd->size);
348082c4:	e59f0048 	ldr	r0, [pc, #72]	; 34808314 <arg_off_size+0x108>
348082c8:	e1a0200c 	mov	r2, ip
348082cc:	eb0005fd 	bl	34809ac8 <printf>
		return -1;
348082d0:	e3e00000 	mvn	r0, #0
348082d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
348082d8:	e152000c 	cmp	r2, ip
348082dc:	1a000006 	bne	348082fc <arg_off_size+0xf0>
348082e0:	e3a03000 	mov	r3, #0
348082e4:	e1530004 	cmp	r3, r4
348082e8:	1a000003 	bne	348082fc <arg_off_size+0xf0>
		puts("whole chip\n");
348082ec:	e59f0024 	ldr	r0, [pc, #36]	; 34808318 <arg_off_size+0x10c>
348082f0:	eb0005ea 	bl	34809aa0 <puts>
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);

	return 0;
348082f4:	e1a00004 	mov	r0, r4
348082f8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
		puts("whole chip\n");
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);
348082fc:	e59f0018 	ldr	r0, [pc, #24]	; 3480831c <arg_off_size+0x110>
34808300:	eb0005f0 	bl	34809ac8 <printf>

	return 0;
34808304:	e3a00000 	mov	r0, #0
}
34808308:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480830c:	34825802 	.word	0x34825802
34808310:	34829cc0 	.word	0x34829cc0
34808314:	34825818 	.word	0x34825818
34808318:	3482583c 	.word	0x3482583c
3480831c:	34825848 	.word	0x34825848

34808320 <do_onenand_read>:

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808320:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
34808324:	e3520002 	cmp	r2, #2

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808328:	e24dd048 	sub	sp, sp, #72	; 0x48
3480832c:	e1a04002 	mov	r4, r2
34808330:	e1a06003 	mov	r6, r3
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
34808334:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
34808338:	da000065 	ble	348084d4 <do_onenand_read+0x1b4>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
3480833c:	e5930000 	ldr	r0, [r3]
34808340:	e3a0102e 	mov	r1, #46	; 0x2e
34808344:	eb004ffd 	bl	3481c340 <strchr>
	if ((s != NULL) && (!strcmp(s, ".oob")))
34808348:	e2503000 	subs	r3, r0, #0
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
3480834c:	058d300c 	streq	r3, [sp, #12]

	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
34808350:	0a000004 	beq	34808368 <do_onenand_read+0x48>
34808354:	e59f1180 	ldr	r1, [pc, #384]	; 348084dc <do_onenand_read+0x1bc>
34808358:	eb004fda 	bl	3481c2c8 <strcmp>
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
3480835c:	e2700001 	rsbs	r0, r0, #1
34808360:	33a00000 	movcc	r0, #0
34808364:	e58d000c 	str	r0, [sp, #12]

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808368:	e3a01000 	mov	r1, #0
3480836c:	e3a02010 	mov	r2, #16
34808370:	e5960004 	ldr	r0, [r6, #4]
34808374:	eb00539a 	bl	3481d1e4 <simple_strtoul>
34808378:	e1a07000 	mov	r7, r0

	printf("\nOneNAND read: ");
3480837c:	e59f015c 	ldr	r0, [pc, #348]	; 348084e0 <do_onenand_read+0x1c0>
34808380:	eb0005d0 	bl	34809ac8 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808384:	e2861008 	add	r1, r6, #8
34808388:	e2440002 	sub	r0, r4, #2
3480838c:	e28d2044 	add	r2, sp, #68	; 0x44
34808390:	e28d3040 	add	r3, sp, #64	; 0x40
34808394:	ebffff9c 	bl	3480820c <arg_off_size>
34808398:	e2501000 	subs	r1, r0, #0
		return 1;
3480839c:	13a00001 	movne	r0, #1
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
348083a0:	1a00004b 	bne	348084d4 <do_onenand_read+0x1b4>
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348083a4:	e59f3138 	ldr	r3, [pc, #312]	; 348084e4 <do_onenand_read+0x1c4>
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
348083a8:	e3a0a001 	mov	sl, #1
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348083ac:	e5933000 	ldr	r3, [r3]
	int blocks = (int) len >> this->erase_shift;
348083b0:	e59db040 	ldr	fp, [sp, #64]	; 0x40
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348083b4:	e5933094 	ldr	r3, [r3, #148]	; 0x94
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348083b8:	e3a02020 	mov	r2, #32
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348083bc:	e58d301c 	str	r3, [sp, #28]
	int blocks = (int) len >> this->erase_shift;
348083c0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348083c4:	e28d0020 	add	r0, sp, #32
static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
348083c8:	e1a0a31a 	lsl	sl, sl, r3

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
348083cc:	e59d4044 	ldr	r4, [sp, #68]	; 0x44

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
348083d0:	e1a0b35b 	asr	fp, fp, r3
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348083d4:	eb00508f 	bl	3481c618 <memset>
		.retlen		= 0,
	};
	int ret;

	if (oob)
348083d8:	e59d200c 	ldr	r2, [sp, #12]

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
348083dc:	e3a05000 	mov	r5, #0
	struct mtd_oob_ops ops = {
		.retlen		= 0,
	};
	int ret;

	if (oob)
348083e0:	e3520000 	cmp	r2, #0
348083e4:	e1a0200a 	mov	r2, sl
348083e8:	e1a03fc2 	asr	r3, r2, #31
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;
348083ec:	058da024 	streq	sl, [sp, #36]	; 0x24
		.retlen		= 0,
	};
	int ret;

	if (oob)
		ops.ooblen = blocksize;
348083f0:	158da02c 	strne	sl, [sp, #44]	; 0x2c
	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;
348083f4:	e3a09000 	mov	r9, #0
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
348083f8:	e59f60e4 	ldr	r6, [pc, #228]	; 348084e4 <do_onenand_read+0x1c4>
348083fc:	e1cd21f0 	strd	r2, [sp, #16]
34808400:	ea00002c 	b	348084b8 <do_onenand_read+0x198>
34808404:	e5960000 	ldr	r0, [r6]
34808408:	e1a02004 	mov	r2, r4
3480840c:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808410:	e1a03005 	mov	r3, r5
34808414:	e12fff31 	blx	r1
		if (ret) {
34808418:	e3500000 	cmp	r0, #0
3480841c:	0a000008 	beq	34808444 <do_onenand_read+0x124>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808420:	e59d301c 	ldr	r3, [sp, #28]
34808424:	e1a00004 	mov	r0, r4
34808428:	e5932030 	ldr	r2, [r3, #48]	; 0x30
3480842c:	e1a01005 	mov	r1, r5
34808430:	eb005efe 	bl	34820030 <__ashrdi3>
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808434:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808438:	e1a01000 	mov	r1, r0
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
3480843c:	e59f00a4 	ldr	r0, [pc, #164]	; 348084e8 <do_onenand_read+0x1c8>
34808440:	ea000010 	b	34808488 <do_onenand_read+0x168>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
34808444:	e59d300c 	ldr	r3, [sp, #12]
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34808448:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
3480844c:	e3530000 	cmp	r3, #0
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34808450:	e28d3020 	add	r3, sp, #32
34808454:	e58d3000 	str	r3, [sp]
		if (oob)
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
34808458:	e3a02000 	mov	r2, #0
			ofs += blocksize;
			continue;
		}

		if (oob)
			ops.oobbuf = buf;
3480845c:	158d703c 	strne	r7, [sp, #60]	; 0x3c
		else
			ops.datbuf = buf;
34808460:	058d7038 	streq	r7, [sp, #56]	; 0x38

		ops.retlen = 0;
34808464:	e58d2028 	str	r2, [sp, #40]	; 0x28
		ret = mtd->read_oob(mtd, ofs, &ops);
34808468:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
3480846c:	e1a02004 	mov	r2, r4
34808470:	e1a03005 	mov	r3, r5
34808474:	e12fff31 	blx	r1
		if (ret) {
34808478:	e2502000 	subs	r2, r0, #0
3480847c:	0a000006 	beq	3480849c <do_onenand_read+0x17c>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
34808480:	e59f0064 	ldr	r0, [pc, #100]	; 348084ec <do_onenand_read+0x1cc>
34808484:	e1a01004 	mov	r1, r4
34808488:	eb00058e 	bl	34809ac8 <printf>
			ofs += blocksize;
3480848c:	e1cd21d0 	ldrd	r2, [sp, #16]
34808490:	e0944002 	adds	r4, r4, r2
34808494:	e0a55003 	adc	r5, r5, r3
34808498:	ea000006 	b	348084b8 <do_onenand_read+0x198>
			continue;
		}
		ofs += blocksize;
3480849c:	e1cd21d0 	ldrd	r2, [sp, #16]
348084a0:	e0944002 	adds	r4, r4, r2
348084a4:	e0a55003 	adc	r5, r5, r3
		buf += blocksize;
		blocks--;
		*retlen += ops.retlen;
348084a8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			ofs += blocksize;
			continue;
		}
		ofs += blocksize;
		buf += blocksize;
348084ac:	e087700a 	add	r7, r7, sl
		blocks--;
348084b0:	e24bb001 	sub	fp, fp, #1
		*retlen += ops.retlen;
348084b4:	e0899003 	add	r9, r9, r3
	if (oob)
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
348084b8:	e35b0000 	cmp	fp, #0
348084bc:	1affffd0 	bne	34808404 <do_onenand_read+0xe4>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);

	printf(" %d bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
348084c0:	e59f0028 	ldr	r0, [pc, #40]	; 348084f0 <do_onenand_read+0x1d0>
348084c4:	e1a01009 	mov	r1, r9
348084c8:	e59f2024 	ldr	r2, [pc, #36]	; 348084f4 <do_onenand_read+0x1d4>
348084cc:	eb00057d 	bl	34809ac8 <printf>

	return ret == 0 ? 0 : 1;
348084d0:	e1a0000b 	mov	r0, fp
}
348084d4:	e28dd048 	add	sp, sp, #72	; 0x48
348084d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348084dc:	34825861 	.word	0x34825861
348084e0:	34825866 	.word	0x34825866
348084e4:	34829cc0 	.word	0x34829cc0
348084e8:	34825876 	.word	0x34825876
348084ec:	3482588d 	.word	0x3482588d
348084f0:	348258a3 	.word	0x348258a3
348084f4:	34824091 	.word	0x34824091

348084f8 <onenand_dump>:

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
348084f8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348084fc:	e1a06000 	mov	r6, r0
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34808500:	e5963014 	ldr	r3, [r6, #20]
34808504:	e5900018 	ldr	r0, [r0, #24]

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34808508:	e24dd058 	sub	sp, sp, #88	; 0x58
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
3480850c:	e0800003 	add	r0, r0, r3

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34808510:	e1a09001 	mov	r9, r1
34808514:	e1a0b002 	mov	fp, r2
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34808518:	eb000731 	bl	3480a1e4 <malloc>
3480851c:	e1a05000 	mov	r5, r0
	oobbuf = malloc(mtd->oobsize);
34808520:	e5960018 	ldr	r0, [r6, #24]
34808524:	eb00072e 	bl	3480a1e4 <malloc>
	if (!datbuf || !oobbuf) {
34808528:	e3550000 	cmp	r5, #0
3480852c:	13500000 	cmpne	r0, #0
34808530:	e1a07000 	mov	r7, r0
34808534:	13a04000 	movne	r4, #0
34808538:	03a04001 	moveq	r4, #1
3480853c:	1a000002 	bne	3480854c <onenand_dump+0x54>
		puts("No memory for page buffer\n");
34808540:	e59f01b4 	ldr	r0, [pc, #436]	; 348086fc <onenand_dump+0x204>
34808544:	eb000555 	bl	34809aa0 <puts>
34808548:	ea00001d 	b	348085c4 <onenand_dump+0xcc>
		return 1;
	}
	off &= ~(mtd->writesize - 1);
3480854c:	e596a014 	ldr	sl, [r6, #20]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
34808550:	e1a01004 	mov	r1, r4
	oobbuf = malloc(mtd->oobsize);
	if (!datbuf || !oobbuf) {
		puts("No memory for page buffer\n");
		return 1;
	}
	off &= ~(mtd->writesize - 1);
34808554:	e26aa000 	rsb	sl, sl, #0
34808558:	e009a00a 	and	sl, r9, sl
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
3480855c:	e28d9038 	add	r9, sp, #56	; 0x38
34808560:	e3a02020 	mov	r2, #32
34808564:	e1a00009 	mov	r0, r9
34808568:	eb00502a 	bl	3481c618 <memset>
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
3480856c:	e5963014 	ldr	r3, [r6, #20]
		return 1;
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
34808570:	e58d5050 	str	r5, [sp, #80]	; 0x50
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
34808574:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	ops.ooblen = mtd->oobsize;
34808578:	e5963018 	ldr	r3, [r6, #24]
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
3480857c:	e58d9000 	str	r9, [sp]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
34808580:	e58d3044 	str	r3, [sp, #68]	; 0x44
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
34808584:	e596104c 	ldr	r1, [r6, #76]	; 0x4c
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
34808588:	e58d7054 	str	r7, [sp, #84]	; 0x54
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
	ops.retlen = 0;
3480858c:	e58d4040 	str	r4, [sp, #64]	; 0x40
	i = mtd->read_oob(mtd, addr, &ops);
34808590:	e1a00006 	mov	r0, r6
34808594:	e1a0200a 	mov	r2, sl
34808598:	e1a03004 	mov	r3, r4
3480859c:	e12fff31 	blx	r1
	if (i < 0) {
348085a0:	e2501000 	subs	r1, r0, #0
348085a4:	aa000008 	bge	348085cc <onenand_dump+0xd4>
		printf("Error (%d) reading page %08lx\n", i, off);
348085a8:	e1a0200a 	mov	r2, sl
348085ac:	e59f014c 	ldr	r0, [pc, #332]	; 34808700 <onenand_dump+0x208>
348085b0:	eb000544 	bl	34809ac8 <printf>
		free(datbuf);
348085b4:	e1a00005 	mov	r0, r5
348085b8:	eb000680 	bl	34809fc0 <free>
		free(oobbuf);
348085bc:	e1a00007 	mov	r0, r7
348085c0:	eb00067e 	bl	34809fc0 <free>
		return 1;
348085c4:	e3a00001 	mov	r0, #1
348085c8:	ea000049 	b	348086f4 <onenand_dump+0x1fc>
	}
	printf("Page %08lx dump:\n", off);
348085cc:	e1a0100a 	mov	r1, sl
348085d0:	e59f012c 	ldr	r0, [pc, #300]	; 34808704 <onenand_dump+0x20c>
348085d4:	eb00053b 	bl	34809ac8 <printf>
	i = mtd->writesize >> 4;
348085d8:	e596a014 	ldr	sl, [r6, #20]
	p = datbuf;

	while (i--) {
348085dc:	e1a04005 	mov	r4, r5
		free(datbuf);
		free(oobbuf);
		return 1;
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
348085e0:	e1a0a22a 	lsr	sl, sl, #4
	p = datbuf;

	while (i--) {
348085e4:	ea000022 	b	34808674 <onenand_dump+0x17c>
		if (!only_oob)
348085e8:	e35b0000 	cmp	fp, #0
348085ec:	1a00001e 	bne	3480866c <onenand_dump+0x174>
			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
348085f0:	e5d40003 	ldrb	r0, [r4, #3]
348085f4:	e5d41000 	ldrb	r1, [r4]
348085f8:	e5d42001 	ldrb	r2, [r4, #1]
348085fc:	e5d43002 	ldrb	r3, [r4, #2]
34808600:	e58d0000 	str	r0, [sp]
34808604:	e5d40004 	ldrb	r0, [r4, #4]
34808608:	e58d0004 	str	r0, [sp, #4]
3480860c:	e5d40005 	ldrb	r0, [r4, #5]
34808610:	e58d0008 	str	r0, [sp, #8]
34808614:	e5d40006 	ldrb	r0, [r4, #6]
34808618:	e58d000c 	str	r0, [sp, #12]
3480861c:	e5d40007 	ldrb	r0, [r4, #7]
34808620:	e58d0010 	str	r0, [sp, #16]
34808624:	e5d40008 	ldrb	r0, [r4, #8]
34808628:	e58d0014 	str	r0, [sp, #20]
3480862c:	e5d40009 	ldrb	r0, [r4, #9]
34808630:	e58d0018 	str	r0, [sp, #24]
34808634:	e5d4000a 	ldrb	r0, [r4, #10]
34808638:	e58d001c 	str	r0, [sp, #28]
3480863c:	e5d4000b 	ldrb	r0, [r4, #11]
34808640:	e58d0020 	str	r0, [sp, #32]
34808644:	e5d4000c 	ldrb	r0, [r4, #12]
34808648:	e58d0024 	str	r0, [sp, #36]	; 0x24
3480864c:	e5d4000d 	ldrb	r0, [r4, #13]
34808650:	e58d0028 	str	r0, [sp, #40]	; 0x28
34808654:	e5d4000e 	ldrb	r0, [r4, #14]
34808658:	e58d002c 	str	r0, [sp, #44]	; 0x2c
3480865c:	e5d4000f 	ldrb	r0, [r4, #15]
34808660:	e58d0030 	str	r0, [sp, #48]	; 0x30
34808664:	e59f009c 	ldr	r0, [pc, #156]	; 34808708 <onenand_dump+0x210>
34808668:	eb000516 	bl	34809ac8 <printf>
			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
3480866c:	e2844010 	add	r4, r4, #16
34808670:	e24aa001 	sub	sl, sl, #1
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
	p = datbuf;

	while (i--) {
34808674:	e35a0000 	cmp	sl, #0
34808678:	1affffda 	bne	348085e8 <onenand_dump+0xf0>
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
	}
	puts("OOB:\n");
3480867c:	e59f0088 	ldr	r0, [pc, #136]	; 3480870c <onenand_dump+0x214>
34808680:	eb000506 	bl	34809aa0 <puts>
	i = mtd->oobsize >> 3;
34808684:	e5966018 	ldr	r6, [r6, #24]
34808688:	e1a04007 	mov	r4, r7
3480868c:	e1a061a6 	lsr	r6, r6, #3
	p = oobbuf;

	while (i--) {
34808690:	ea00000f 	b	348086d4 <onenand_dump+0x1dc>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
34808694:	e5540005 	ldrb	r0, [r4, #-5]
34808698:	e5541008 	ldrb	r1, [r4, #-8]
3480869c:	e5542007 	ldrb	r2, [r4, #-7]
348086a0:	e5543006 	ldrb	r3, [r4, #-6]
348086a4:	e58d0000 	str	r0, [sp]
348086a8:	e5540004 	ldrb	r0, [r4, #-4]
348086ac:	e2466001 	sub	r6, r6, #1
348086b0:	e58d0004 	str	r0, [sp, #4]
348086b4:	e5540003 	ldrb	r0, [r4, #-3]
348086b8:	e58d0008 	str	r0, [sp, #8]
348086bc:	e5540002 	ldrb	r0, [r4, #-2]
348086c0:	e58d000c 	str	r0, [sp, #12]
348086c4:	e5540001 	ldrb	r0, [r4, #-1]
348086c8:	e58d0010 	str	r0, [sp, #16]
348086cc:	e59f003c 	ldr	r0, [pc, #60]	; 34808710 <onenand_dump+0x218>
348086d0:	eb0004fc 	bl	34809ac8 <printf>
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
348086d4:	e3560000 	cmp	r6, #0
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
348086d8:	e2844008 	add	r4, r4, #8
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
348086dc:	1affffec 	bne	34808694 <onenand_dump+0x19c>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
		p += 8;
	}
	free(datbuf);
348086e0:	e1a00005 	mov	r0, r5
348086e4:	eb000635 	bl	34809fc0 <free>
	free(oobbuf);
348086e8:	e1a00007 	mov	r0, r7
348086ec:	eb000633 	bl	34809fc0 <free>

	return 0;
348086f0:	e1a00006 	mov	r0, r6
}
348086f4:	e28dd058 	add	sp, sp, #88	; 0x58
348086f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348086fc:	348258b7 	.word	0x348258b7
34808700:	348258d2 	.word	0x348258d2
34808704:	348258f1 	.word	0x348258f1
34808708:	34825903 	.word	0x34825903
3480870c:	34825956 	.word	0x34825956
34808710:	3482595c 	.word	0x3482595c

34808714 <do_onenand_dump>:
{
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34808714:	e3520001 	cmp	r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_dump(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808718:	e92d4038 	push	{r3, r4, r5, lr}
3480871c:	e1a05003 	mov	r5, r3
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34808720:	da00001b 	ble	34808794 <do_onenand_dump+0x80>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34808724:	e5930000 	ldr	r0, [r3]
34808728:	e3a0102e 	mov	r1, #46	; 0x2e
3480872c:	eb004f03 	bl	3481c340 <strchr>
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808730:	e3a01000 	mov	r1, #0
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34808734:	e1a04000 	mov	r4, r0
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808738:	e3a02010 	mov	r2, #16
3480873c:	e5950004 	ldr	r0, [r5, #4]
34808740:	eb0052a7 	bl	3481d1e4 <simple_strtoul>

	if (s != NULL && strcmp(s, ".oob") == 0)
34808744:	e3540000 	cmp	r4, #0

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808748:	e1a05000 	mov	r5, r0

	if (s != NULL && strcmp(s, ".oob") == 0)
3480874c:	0a000008 	beq	34808774 <do_onenand_dump+0x60>
34808750:	e1a00004 	mov	r0, r4
34808754:	e59f1040 	ldr	r1, [pc, #64]	; 3480879c <do_onenand_dump+0x88>
34808758:	eb004eda 	bl	3481c2c8 <strcmp>
3480875c:	e3500000 	cmp	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
34808760:	059f3038 	ldreq	r3, [pc, #56]	; 348087a0 <do_onenand_dump+0x8c>
34808764:	01a01005 	moveq	r1, r5
34808768:	05930000 	ldreq	r0, [r3]
3480876c:	03a02001 	moveq	r2, #1
34808770:	0a000003 	beq	34808784 <do_onenand_dump+0x70>
	else
		ret = onenand_dump(mtd, ofs, 0);
34808774:	e59f3024 	ldr	r3, [pc, #36]	; 348087a0 <do_onenand_dump+0x8c>
34808778:	e1a01005 	mov	r1, r5
3480877c:	e5930000 	ldr	r0, [r3]
34808780:	e3a02000 	mov	r2, #0
34808784:	ebffff5b 	bl	348084f8 <onenand_dump>

	return ret == 0 ? 1 : 0;
34808788:	e2700001 	rsbs	r0, r0, #1
3480878c:	33a00000 	movcc	r0, #0
34808790:	e8bd8038 	pop	{r3, r4, r5, pc}
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;
34808794:	e3e00000 	mvn	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
	else
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}
34808798:	e8bd8038 	pop	{r3, r4, r5, pc}
3480879c:	34825861 	.word	0x34825861
348087a0:	34829cc0 	.word	0x34829cc0

348087a4 <do_onenand_test>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348087a4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
348087a8:	e59f0258 	ldr	r0, [pc, #600]	; 34808a08 <do_onenand_test+0x264>

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348087ac:	e24dd078 	sub	sp, sp, #120	; 0x78
348087b0:	e1a04002 	mov	r4, r2
348087b4:	e1a06003 	mov	r6, r3
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
348087b8:	eb0004c2 	bl	34809ac8 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348087bc:	e2861004 	add	r1, r6, #4
348087c0:	e2440001 	sub	r0, r4, #1
348087c4:	e28d2074 	add	r2, sp, #116	; 0x74
348087c8:	e28d3070 	add	r3, sp, #112	; 0x70
348087cc:	ebfffe8e 	bl	3480820c <arg_off_size>
348087d0:	e2501000 	subs	r1, r0, #0
		return 1;
348087d4:	13a00001 	movne	r0, #1
	 */

	printf("\nOneNAND test: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348087d8:	1a000088 	bne	34808a00 <do_onenand_test+0x25c>
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348087dc:	e59f6228 	ldr	r6, [pc, #552]	; 34808a0c <do_onenand_test+0x268>
	struct erase_info instr = {
348087e0:	e3a02048 	mov	r2, #72	; 0x48
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348087e4:	e5963000 	ldr	r3, [r6]
	struct erase_info instr = {
348087e8:	e28d0020 	add	r0, sp, #32
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348087ec:	e5937094 	ldr	r7, [r3, #148]	; 0x94

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);
348087f0:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
348087f4:	e59db070 	ldr	fp, [sp, #112]	; 0x70
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
348087f8:	eb004f86 	bl	3481c618 <memset>
		.priv		= 0,
	};

	int blocks;
	loff_t ofs;
	int blocksize = 1 << this->erase_shift;
348087fc:	e5973030 	ldr	r3, [r7, #48]	; 0x30
34808800:	e3a0a001 	mov	sl, #1
34808804:	e1a0a31a 	lsl	sl, sl, r3
	size_t retlen;
	u_char *buf;
	u_char *verify_buf;
	int ret;

	buf = malloc(blocksize);
34808808:	e1a0000a 	mov	r0, sl
3480880c:	eb000674 	bl	3480a1e4 <malloc>
	if (!buf) {
34808810:	e3500000 	cmp	r0, #0
34808814:	e58d0010 	str	r0, [sp, #16]
34808818:	0a000004 	beq	34808830 <do_onenand_test+0x8c>
		printf("Not enough malloc space available!\n");
		return -1;
	}

	verify_buf = malloc(blocksize);
3480881c:	e1a0000a 	mov	r0, sl
34808820:	eb00066f 	bl	3480a1e4 <malloc>
	if (!verify_buf) {
34808824:	e3500000 	cmp	r0, #0
34808828:	e58d0014 	str	r0, [sp, #20]
3480882c:	1a000004 	bne	34808844 <do_onenand_test+0xa0>
		printf("Not enough malloc space available!\n");
34808830:	e59f01d8 	ldr	r0, [pc, #472]	; 34808a10 <do_onenand_test+0x26c>
34808834:	eb0004a3 	bl	34809ac8 <printf>
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34808838:	e3e04000 	mvn	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
3480883c:	e59f11d0 	ldr	r1, [pc, #464]	; 34808a14 <do_onenand_test+0x270>
34808840:	ea00006b 	b	348089f4 <do_onenand_test+0x250>
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34808844:	e5972030 	ldr	r2, [r7, #48]	; 0x30

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34808848:	e5963000 	ldr	r3, [r6]
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;
3480884c:	e08bb004 	add	fp, fp, r4
34808850:	e1a0b23b 	lsr	fp, fp, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34808854:	e1c300d8 	ldrd	r0, [r3, #8]
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34808858:	e1a09234 	lsr	r9, r4, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
3480885c:	eb005dec 	bl	34820014 <__lshrdi3>
34808860:	e1a0200b 	mov	r2, fp
34808864:	e1a03fc2 	asr	r3, r2, #31
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34808868:	e3590002 	cmp	r9, #2
3480886c:	b3a09002 	movlt	r9, #2

	if (end_block > (mtd->size >> this->erase_shift))
34808870:	e1530001 	cmp	r3, r1
34808874:	8a000002 	bhi	34808884 <do_onenand_test+0xe0>
34808878:	1a000002 	bne	34808888 <do_onenand_test+0xe4>
3480887c:	e1520000 	cmp	r2, r0
34808880:	9a000000 	bls	34808888 <do_onenand_test+0xe4>
		end_block = mtd->size >> this->erase_shift;
34808884:	e1a0b000 	mov	fp, r0
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808888:	e1a0200a 	mov	r2, sl
3480888c:	e1a03fc2 	asr	r3, r2, #31

	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
34808890:	e3a05000 	mov	r5, #0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
34808894:	e59f6170 	ldr	r6, [pc, #368]	; 34808a0c <do_onenand_test+0x268>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808898:	e1cd21f8 	strd	r2, [sp, #24]
3480889c:	ea00004a 	b	348089cc <do_onenand_test+0x228>
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);
348088a0:	e5972030 	ldr	r2, [r7, #48]	; 0x30
348088a4:	e1a00004 	mov	r0, r4
348088a8:	e1a01005 	mov	r1, r5
348088ac:	eb005ddf 	bl	34820030 <__ashrdi3>
348088b0:	e1a02004 	mov	r2, r4
348088b4:	e1a01000 	mov	r1, r0
348088b8:	e59f0158 	ldr	r0, [pc, #344]	; 34808a18 <do_onenand_test+0x274>
348088bc:	eb000481 	bl	34809ac8 <printf>

		ret = mtd->block_isbad(mtd, ofs);
348088c0:	e5960000 	ldr	r0, [r6]
348088c4:	e1a02004 	mov	r2, r4
348088c8:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348088cc:	e1a03005 	mov	r3, r5
348088d0:	e12fff31 	blx	r1
		if (ret) {
348088d4:	e3500000 	cmp	r0, #0
348088d8:	0a000007 	beq	348088fc <do_onenand_test+0x158>
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348088dc:	e5972030 	ldr	r2, [r7, #48]	; 0x30
348088e0:	e1a00004 	mov	r0, r4
348088e4:	e1a01005 	mov	r1, r5
348088e8:	eb005dd0 	bl	34820030 <__ashrdi3>
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
348088ec:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348088f0:	e1a01000 	mov	r1, r0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
348088f4:	e59f0120 	ldr	r0, [pc, #288]	; 34808a1c <do_onenand_test+0x278>
348088f8:	ea00000a 	b	34808928 <do_onenand_test+0x184>
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
		ret = mtd->erase(mtd, &instr);
348088fc:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808900:	e1cd21d8 	ldrd	r2, [sp, #24]
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
34808904:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
		instr.len = blocksize;
34808908:	e1cd23f0 	strd	r2, [sp, #48]	; 0x30
		ret = mtd->erase(mtd, &instr);
3480890c:	e28d1020 	add	r1, sp, #32
34808910:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34808914:	e12fff33 	blx	r3
		if (ret) {
34808918:	e2502000 	subs	r2, r0, #0
3480891c:	0a000003 	beq	34808930 <do_onenand_test+0x18c>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
34808920:	e59f00f8 	ldr	r0, [pc, #248]	; 34808a20 <do_onenand_test+0x27c>
34808924:	e1a01004 	mov	r1, r4
34808928:	eb000466 	bl	34809ac8 <printf>
3480892c:	ea000022 	b	348089bc <do_onenand_test+0x218>
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
34808930:	e59d2010 	ldr	r2, [sp, #16]
34808934:	e5960000 	ldr	r0, [r6]
34808938:	e28d306c 	add	r3, sp, #108	; 0x6c
3480893c:	e58d3004 	str	r3, [sp, #4]
34808940:	e58d2008 	str	r2, [sp, #8]
34808944:	e58da000 	str	sl, [sp]
34808948:	e1a02004 	mov	r2, r4
3480894c:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808950:	e1a03005 	mov	r3, r5
34808954:	e12fff31 	blx	r1
		if (ret) {
34808958:	e2502000 	subs	r2, r0, #0
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
3480895c:	159f00c0 	ldrne	r0, [pc, #192]	; 34808a24 <do_onenand_test+0x280>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
		if (ret) {
34808960:	1affffef 	bne	34808924 <do_onenand_test+0x180>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
34808964:	e59d2014 	ldr	r2, [sp, #20]
34808968:	e5960000 	ldr	r0, [r6]
3480896c:	e28d306c 	add	r3, sp, #108	; 0x6c
34808970:	e58d3004 	str	r3, [sp, #4]
34808974:	e58d2008 	str	r2, [sp, #8]
34808978:	e58da000 	str	sl, [sp]
3480897c:	e1a02004 	mov	r2, r4
34808980:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34808984:	e1a03005 	mov	r3, r5
34808988:	e12fff31 	blx	r1
		if (ret) {
3480898c:	e2502000 	subs	r2, r0, #0
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
34808990:	159f0090 	ldrne	r0, [pc, #144]	; 34808a28 <do_onenand_test+0x284>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
		if (ret) {
34808994:	1affffe2 	bne	34808924 <do_onenand_test+0x180>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		if (memcmp(buf, verify_buf, blocksize))
34808998:	e59d0010 	ldr	r0, [sp, #16]
3480899c:	e59d1014 	ldr	r1, [sp, #20]
348089a0:	e1a0200a 	mov	r2, sl
348089a4:	eb004f72 	bl	3481c774 <memcmp>
348089a8:	e3500000 	cmp	r0, #0
348089ac:	0a000002 	beq	348089bc <do_onenand_test+0x218>
			printk("\nRead/Write test failed at 0x%x\n", (u32)ofs);
348089b0:	e59f0074 	ldr	r0, [pc, #116]	; 34808a2c <do_onenand_test+0x288>
348089b4:	e1a01004 	mov	r1, r4
348089b8:	eb000442 	bl	34809ac8 <printf>

next:
		ofs += blocksize;
348089bc:	e1cd21d8 	ldrd	r2, [sp, #24]
348089c0:	e0944002 	adds	r4, r4, r2
348089c4:	e0a55003 	adc	r5, r5, r3
		blocks++;
348089c8:	e2899001 	add	r9, r9, #1
	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
348089cc:	e159000b 	cmp	r9, fp
348089d0:	baffffb2 	blt	348088a0 <do_onenand_test+0xfc>

next:
		ofs += blocksize;
		blocks++;
	}
	printf("...Done\n");
348089d4:	e59f0054 	ldr	r0, [pc, #84]	; 34808a30 <do_onenand_test+0x28c>
348089d8:	eb00043a 	bl	34809ac8 <printf>

	free(buf);
348089dc:	e59d0010 	ldr	r0, [sp, #16]
348089e0:	eb000576 	bl	34809fc0 <free>
	free(verify_buf);
348089e4:	e59d0014 	ldr	r0, [sp, #20]
348089e8:	eb000574 	bl	34809fc0 <free>
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
348089ec:	e59f1040 	ldr	r1, [pc, #64]	; 34808a34 <do_onenand_test+0x290>
	printf("...Done\n");

	free(buf);
	free(verify_buf);

	return 0;
348089f0:	e3a04000 	mov	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
348089f4:	e59f003c 	ldr	r0, [pc, #60]	; 34808a38 <do_onenand_test+0x294>
348089f8:	eb000432 	bl	34809ac8 <printf>

	return ret == 0 ? 0 : 1;
348089fc:	e2640000 	rsb	r0, r4, #0
}
34808a00:	e28dd078 	add	sp, sp, #120	; 0x78
34808a04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808a08:	34825986 	.word	0x34825986
34808a0c:	34829cc0 	.word	0x34829cc0
34808a10:	34825996 	.word	0x34825996
34808a14:	34824094 	.word	0x34824094
34808a18:	348259ba 	.word	0x348259ba
34808a1c:	348259d4 	.word	0x348259d4
34808a20:	348259f5 	.word	0x348259f5
34808a24:	34825a0c 	.word	0x34825a0c
34808a28:	3482588d 	.word	0x3482588d
34808a2c:	34825a23 	.word	0x34825a23
34808a30:	34825a44 	.word	0x34825a44
34808a34:	34824091 	.word	0x34824091
34808a38:	34825e78 	.word	0x34825e78

34808a3c <do_onenand_write>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808a3c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
34808a40:	e3520002 	cmp	r2, #2

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808a44:	e24dd078 	sub	sp, sp, #120	; 0x78
34808a48:	e1a04002 	mov	r4, r2
34808a4c:	e1a07003 	mov	r7, r3
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
34808a50:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
34808a54:	da0000b5 	ble	34808d30 <do_onenand_write+0x2f4>
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808a58:	e5930000 	ldr	r0, [r3]
34808a5c:	e59f12d4 	ldr	r1, [pc, #724]	; 34808d38 <do_onenand_write+0x2fc>
34808a60:	e3a02005 	mov	r2, #5
34808a64:	e2800006 	add	r0, r0, #6
34808a68:	eb004e22 	bl	3481c2f8 <strncmp>
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808a6c:	e3a01000 	mov	r1, #0
34808a70:	e3a02010 	mov	r2, #16
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808a74:	e58d001c 	str	r0, [sp, #28]
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808a78:	e5970004 	ldr	r0, [r7, #4]
34808a7c:	eb0051d8 	bl	3481d1e4 <simple_strtoul>
34808a80:	e1a06000 	mov	r6, r0

	printf("\nOneNAND write: ");
34808a84:	e59f02b0 	ldr	r0, [pc, #688]	; 34808d3c <do_onenand_write+0x300>
34808a88:	eb00040e 	bl	34809ac8 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808a8c:	e2440002 	sub	r0, r4, #2
34808a90:	e2871008 	add	r1, r7, #8
34808a94:	e28d2074 	add	r2, sp, #116	; 0x74
34808a98:	e28d3070 	add	r3, sp, #112	; 0x70
34808a9c:	ebfffdda 	bl	3480820c <arg_off_size>
34808aa0:	e3500000 	cmp	r0, #0
		return 1;
34808aa4:	13a00001 	movne	r0, #1
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808aa8:	1a0000a0 	bne	34808d30 <do_onenand_write+0x2f4>
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808aac:	e59fc28c 	ldr	ip, [pc, #652]	; 34808d40 <do_onenand_write+0x304>

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808ab0:	e59d1070 	ldr	r1, [sp, #112]	; 0x70
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808ab4:	e59c3000 	ldr	r3, [ip]

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808ab8:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808abc:	e5933094 	ldr	r3, [r3, #148]	; 0x94

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808ac0:	e3a05000 	mov	r5, #0
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808ac4:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int blocks = len >> this->erase_shift;
34808ac8:	e5933030 	ldr	r3, [r3, #48]	; 0x30

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808acc:	e58d6014 	str	r6, [sp, #20]

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
34808ad0:	e1a02331 	lsr	r2, r1, r3
34808ad4:	e58d2018 	str	r2, [sp, #24]
	int blocksize = (1 << this->erase_shift);
34808ad8:	e3a02001 	mov	r2, #1
34808adc:	e1a02312 	lsl	r2, r2, r3
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
34808ae0:	e59c3008 	ldr	r3, [ip, #8]
static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34808ae4:	e58d2024 	str	r2, [sp, #36]	; 0x24
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
34808ae8:	e1530004 	cmp	r3, r4
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs;
	size_t _retlen = 0;
34808aec:	e58d006c 	str	r0, [sp, #108]	; 0x6c
	int ret;

	if (to == next_ofs) {
34808af0:	1a000010 	bne	34808b38 <do_onenand_write+0xfc>
34808af4:	e59c300c 	ldr	r3, [ip, #12]
34808af8:	e3530000 	cmp	r3, #0
34808afc:	1a00000d 	bne	34808b38 <do_onenand_write+0xfc>
		next_ofs = to + len;
34808b00:	e0942001 	adds	r2, r4, r1
34808b04:	e2a53000 	adc	r3, r5, #0
34808b08:	e1cc20f8 	strd	r2, [ip, #8]
		to += skip_ofs;
34808b0c:	e1cc21d0 	ldrd	r2, [ip, #16]
34808b10:	e0944002 	adds	r4, r4, r2
34808b14:	e0a55003 	adc	r5, r5, r3
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808b18:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808b1c:	e3a03000 	mov	r3, #0
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808b20:	e1a00001 	mov	r0, r1
34808b24:	e1a01fc0 	asr	r1, r0, #31
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808b28:	e58d3020 	str	r3, [sp, #32]
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
34808b2c:	e59f620c 	ldr	r6, [pc, #524]	; 34808d40 <do_onenand_write+0x304>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808b30:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
34808b34:	ea000075 	b	34808d10 <do_onenand_write+0x2d4>

	if (to == next_ofs) {
		next_ofs = to + len;
		to += skip_ofs;
	} else {
		next_ofs = to + len;
34808b38:	e0942001 	adds	r2, r4, r1
34808b3c:	e59f01fc 	ldr	r0, [pc, #508]	; 34808d40 <do_onenand_write+0x304>
34808b40:	e2a53000 	adc	r3, r5, #0
34808b44:	e1c020f8 	strd	r2, [r0, #8]
		skip_ofs = 0;
34808b48:	e3a02000 	mov	r2, #0
34808b4c:	e3a03000 	mov	r3, #0
34808b50:	e1c021f0 	strd	r2, [r0, #16]
34808b54:	eaffffef 	b	34808b18 <do_onenand_write+0xdc>
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
34808b58:	e5960000 	ldr	r0, [r6]
34808b5c:	e1a02004 	mov	r2, r4
34808b60:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808b64:	e1a03005 	mov	r3, r5
34808b68:	e12fff31 	blx	r1
		if (ret) {
34808b6c:	e3500000 	cmp	r0, #0
34808b70:	e58d0010 	str	r0, [sp, #16]
34808b74:	0a000008 	beq	34808b9c <do_onenand_write+0x160>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808b78:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
34808b7c:	e1a00004 	mov	r0, r4
34808b80:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34808b84:	e1a01005 	mov	r1, r5
34808b88:	eb005d28 	bl	34820030 <__ashrdi3>
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808b8c:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808b90:	e1a01000 	mov	r1, r0
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808b94:	e59f01a8 	ldr	r0, [pc, #424]	; 34808d44 <do_onenand_write+0x308>
34808b98:	ea000047 	b	34808cbc <do_onenand_write+0x280>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			skip_ofs += blocksize;
			goto next;
		}

		if (!withoob)
34808b9c:	e59d101c 	ldr	r1, [sp, #28]
34808ba0:	e3510000 	cmp	r1, #0
34808ba4:	0a00000b 	beq	34808bd8 <do_onenand_write+0x19c>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
34808ba8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34808bac:	e59d1014 	ldr	r1, [sp, #20]
34808bb0:	e5960000 	ldr	r0, [r6]
34808bb4:	e28d306c 	add	r3, sp, #108	; 0x6c
34808bb8:	e88d000c 	stm	sp, {r2, r3}
34808bbc:	e58d1008 	str	r1, [sp, #8]
34808bc0:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808bc4:	e1a02004 	mov	r2, r4
34808bc8:	e1a03005 	mov	r3, r5
34808bcc:	e12fff31 	blx	r1
34808bd0:	e58d0010 	str	r0, [sp, #16]
34808bd4:	ea000032 	b	34808ca4 <do_onenand_write+0x268>

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
		.len = mtd->writesize,
34808bd8:	e5963000 	ldr	r3, [r6]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808bdc:	e3a02020 	mov	r2, #32
34808be0:	e28d004c 	add	r0, sp, #76	; 0x4c
34808be4:	e59d101c 	ldr	r1, [sp, #28]
		.len = mtd->writesize,
34808be8:	e5937014 	ldr	r7, [r3, #20]
		.ooblen = mtd->oobsize,
34808bec:	e593a018 	ldr	sl, [r3, #24]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808bf0:	eb004e88 	bl	3481c618 <memset>
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808bf4:	e59dc01c 	ldr	ip, [sp, #28]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808bf8:	e3a02001 	mov	r2, #1
34808bfc:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
34808c00:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
34808c04:	e58d204c 	str	r2, [sp, #76]	; 0x4c
34808c08:	e58d7050 	str	r7, [sp, #80]	; 0x50
34808c0c:	e58da058 	str	sl, [sp, #88]	; 0x58
34808c10:	e59d9014 	ldr	r9, [sp, #20]
34808c14:	e1a0400c 	mov	r4, ip
34808c18:	ea000013 	b	34808c6c <do_onenand_write+0x230>
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808c1c:	e28d304c 	add	r3, sp, #76	; 0x4c
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
34808c20:	e58d9064 	str	r9, [sp, #100]	; 0x64
		buf += mtd->writesize;
34808c24:	e0899007 	add	r9, r9, r7
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
34808c28:	e59b7018 	ldr	r7, [fp, #24]
		ret = mtd->write_oob(mtd, to, &ops);
34808c2c:	e58d3000 	str	r3, [sp]
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
34808c30:	e58d9068 	str	r9, [sp, #104]	; 0x68
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808c34:	e59b1050 	ldr	r1, [fp, #80]	; 0x50
34808c38:	e1a0000b 	mov	r0, fp
34808c3c:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
34808c40:	e12fff31 	blx	r1
		if (ret)
34808c44:	e3500000 	cmp	r0, #0
34808c48:	1a000011 	bne	34808c94 <do_onenand_write+0x258>
			break;
		to += mtd->writesize;
34808c4c:	e5963000 	ldr	r3, [r6]
34808c50:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
34808c54:	e5933014 	ldr	r3, [r3, #20]
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
34808c58:	e0899007 	add	r9, r9, r7
		ret = mtd->write_oob(mtd, to, &ops);
		if (ret)
			break;
		to += mtd->writesize;
34808c5c:	e0900003 	adds	r0, r0, r3
34808c60:	e2a11000 	adc	r1, r1, #0
34808c64:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808c68:	e2844001 	add	r4, r4, #1
34808c6c:	e596b000 	ldr	fp, [r6]
34808c70:	e59ba010 	ldr	sl, [fp, #16]
34808c74:	e59b7014 	ldr	r7, [fp, #20]
34808c78:	e1a0000a 	mov	r0, sl
34808c7c:	e1a01007 	mov	r1, r7
34808c80:	eb005bd0 	bl	3481fbc8 <__udivsi3>
34808c84:	e1540000 	cmp	r4, r0
34808c88:	3affffe3 	bcc	34808c1c <do_onenand_write+0x1e0>
34808c8c:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
34808c90:	ea000002 	b	34808ca0 <do_onenand_write+0x264>
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808c94:	e58d0010 	str	r0, [sp, #16]
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808c98:	e3a0a000 	mov	sl, #0
34808c9c:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
34808ca0:	e58da06c 	str	sl, [sp, #108]	; 0x6c

		if (!withoob)
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
34808ca4:	e59d1010 	ldr	r1, [sp, #16]
34808ca8:	e3510000 	cmp	r1, #0
34808cac:	0a000009 	beq	34808cd8 <do_onenand_write+0x29c>
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
34808cb0:	e59f0090 	ldr	r0, [pc, #144]	; 34808d48 <do_onenand_write+0x30c>
34808cb4:	e59d2010 	ldr	r2, [sp, #16]
34808cb8:	e1a01004 	mov	r1, r4
34808cbc:	eb000381 	bl	34809ac8 <printf>
			skip_ofs += blocksize;
34808cc0:	e1c621d0 	ldrd	r2, [r6, #16]
34808cc4:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
34808cc8:	e0922000 	adds	r2, r2, r0
34808ccc:	e0a33001 	adc	r3, r3, r1
34808cd0:	e1c621f0 	strd	r2, [r6, #16]
34808cd4:	ea00000a 	b	34808d04 <do_onenand_write+0x2c8>
			goto next;
		}

		buf += blocksize;
		blocks--;
34808cd8:	e59d3018 	ldr	r3, [sp, #24]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808cdc:	e59d1014 	ldr	r1, [sp, #20]
		blocks--;
34808ce0:	e2433001 	sub	r3, r3, #1
		*retlen += _retlen;
34808ce4:	e59d0020 	ldr	r0, [sp, #32]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808ce8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		blocks--;
34808cec:	e58d3018 	str	r3, [sp, #24]
		*retlen += _retlen;
34808cf0:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808cf4:	e0811002 	add	r1, r1, r2
		blocks--;
		*retlen += _retlen;
34808cf8:	e0800003 	add	r0, r0, r3
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808cfc:	e58d1014 	str	r1, [sp, #20]
		blocks--;
		*retlen += _retlen;
34808d00:	e58d0020 	str	r0, [sp, #32]
next:
		ofs += blocksize;
34808d04:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
34808d08:	e0944002 	adds	r4, r4, r2
34808d0c:	e0a55003 	adc	r5, r5, r3
		next_ofs = to + len;
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
34808d10:	e59d3018 	ldr	r3, [sp, #24]
34808d14:	e3530000 	cmp	r3, #0
34808d18:	1affff8e 	bne	34808b58 <do_onenand_write+0x11c>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);

	printf(" %d bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
34808d1c:	e59f0028 	ldr	r0, [pc, #40]	; 34808d4c <do_onenand_write+0x310>
34808d20:	e59d1020 	ldr	r1, [sp, #32]
34808d24:	e59f2024 	ldr	r2, [pc, #36]	; 34808d50 <do_onenand_write+0x314>
34808d28:	eb000366 	bl	34809ac8 <printf>

	return ret == 0 ? 0 : 1;
34808d2c:	e59d0018 	ldr	r0, [sp, #24]
}
34808d30:	e28dd078 	add	sp, sp, #120	; 0x78
34808d34:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808d38:	34825cd2 	.word	0x34825cd2
34808d3c:	34825a4d 	.word	0x34825a4d
34808d40:	34829cc0 	.word	0x34829cc0
34808d44:	34825876 	.word	0x34825876
34808d48:	34825a5e 	.word	0x34825a5e
34808d4c:	34825a74 	.word	0x34825a74
34808d50:	34824091 	.word	0x34824091

34808d54 <do_onenand_erase>:

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808d54:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
	if (argc)
34808d58:	e2526001 	subs	r6, r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808d5c:	e24dd068 	sub	sp, sp, #104	; 0x68
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
34808d60:	e2834004 	add	r4, r3, #4
	if (argc)
34808d64:	0a000005 	beq	34808d80 <do_onenand_erase+0x2c>
	{
		if (!strcmp("force", argv[0]))
34808d68:	e59f0134 	ldr	r0, [pc, #308]	; 34808ea4 <do_onenand_erase+0x150>
34808d6c:	e5931004 	ldr	r1, [r3, #4]
34808d70:	eb004d54 	bl	3481c2c8 <strcmp>
34808d74:	e3500000 	cmp	r0, #0
		{
			force = 1;
			argc--;
34808d78:	02466001 	subeq	r6, r6, #1
			argv++;
34808d7c:	02844004 	addeq	r4, r4, #4
		}
	}
	printf("\nOneNAND erase: ");
34808d80:	e59f0120 	ldr	r0, [pc, #288]	; 34808ea8 <do_onenand_erase+0x154>
34808d84:	eb00034f 	bl	34809ac8 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808d88:	e1a00006 	mov	r0, r6
34808d8c:	e1a01004 	mov	r1, r4
34808d90:	e28d2064 	add	r2, sp, #100	; 0x64
34808d94:	e28d3060 	add	r3, sp, #96	; 0x60
34808d98:	ebfffd1b 	bl	3480820c <arg_off_size>
34808d9c:	e2509000 	subs	r9, r0, #0
		return 1;
34808da0:	13a00001 	movne	r0, #1
		}
	}
	printf("\nOneNAND erase: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808da4:	1a00003c 	bne	34808e9c <do_onenand_erase+0x148>
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808da8:	e59f60fc 	ldr	r6, [pc, #252]	; 34808eac <do_onenand_erase+0x158>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808dac:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808db0:	e5962000 	ldr	r2, [r6]
	struct erase_info instr = {
34808db4:	e28db018 	add	fp, sp, #24
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808db8:	e5927094 	ldr	r7, [r2, #148]	; 0x94
	struct erase_info instr = {
34808dbc:	e1a01009 	mov	r1, r9
34808dc0:	e3a02048 	mov	r2, #72	; 0x48
34808dc4:	e1a0000b 	mov	r0, fp

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808dc8:	e59da064 	ldr	sl, [sp, #100]	; 0x64
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
34808dcc:	e58d3004 	str	r3, [sp, #4]
34808dd0:	eb004e10 	bl	3481c618 <memset>
		.callback	= NULL,
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;
34808dd4:	e5971030 	ldr	r1, [r7, #48]	; 0x30
34808dd8:	e3a02001 	mov	r2, #1
34808ddc:	e1a0c112 	lsl	ip, r2, r1

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808de0:	e59d3004 	ldr	r3, [sp, #4]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808de4:	e1a0000c 	mov	r0, ip
34808de8:	e1a01fc0 	asr	r1, r0, #31
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808dec:	e083300a 	add	r3, r3, sl
34808df0:	e1a0400a 	mov	r4, sl
34808df4:	e3a05000 	mov	r5, #0
34808df8:	e58d3014 	str	r3, [sp, #20]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808dfc:	e1cd00f8 	strd	r0, [sp, #8]
		instr.priv = force;
34808e00:	e1a0a002 	mov	sl, r2
34808e04:	ea00001a 	b	34808e74 <do_onenand_erase+0x120>
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
		ret = mtd->block_isbad(mtd, ofs);
34808e08:	e5960000 	ldr	r0, [r6]
34808e0c:	e1a02004 	mov	r2, r4
34808e10:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808e14:	e1a03005 	mov	r3, r5
34808e18:	e12fff31 	blx	r1
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808e1c:	e1cd20d8 	ldrd	r2, [sp, #8]
		instr.priv = force;
		instr.mtd = mtd;
34808e20:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808e24:	e1cd22f8 	strd	r2, [sp, #40]	; 0x28
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
34808e28:	e1cd42f0 	strd	r4, [sp, #32]
		instr.len = blocksize;
		instr.priv = force;
34808e2c:	e58da04c 	str	sl, [sp, #76]	; 0x4c
		instr.mtd = mtd;
34808e30:	e58d0018 	str	r0, [sp, #24]
		ret = mtd->erase(mtd, &instr);
34808e34:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34808e38:	e1a0100b 	mov	r1, fp
34808e3c:	e12fff33 	blx	r3
		if (ret) {
34808e40:	e3500000 	cmp	r0, #0
34808e44:	0a000007 	beq	34808e68 <do_onenand_erase+0x114>
			printf("erase failed block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808e48:	e5972030 	ldr	r2, [r7, #48]	; 0x30
34808e4c:	e1a00004 	mov	r0, r4
34808e50:	e1a01005 	mov	r1, r5
34808e54:	eb005c75 	bl	34820030 <__ashrdi3>
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
34808e58:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808e5c:	e1a01000 	mov	r1, r0
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
34808e60:	e59f0048 	ldr	r0, [pc, #72]	; 34808eb0 <do_onenand_erase+0x15c>
34808e64:	eb000317 	bl	34809ac8 <printf>
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808e68:	e1cd00d8 	ldrd	r0, [sp, #8]
34808e6c:	e0944000 	adds	r4, r4, r0
34808e70:	e0a55001 	adc	r5, r5, r1
34808e74:	e1590005 	cmp	r9, r5
34808e78:	caffffe2 	bgt	34808e08 <do_onenand_erase+0xb4>
34808e7c:	1a000002 	bne	34808e8c <do_onenand_erase+0x138>
34808e80:	e59d1014 	ldr	r1, [sp, #20]
34808e84:	e1510004 	cmp	r1, r4
34808e88:	8affffde 	bhi	34808e08 <do_onenand_erase+0xb4>
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);

	printf("%s\n", ret ? "ERROR" : "OK");
34808e8c:	e59f0020 	ldr	r0, [pc, #32]	; 34808eb4 <do_onenand_erase+0x160>
34808e90:	e59f1020 	ldr	r1, [pc, #32]	; 34808eb8 <do_onenand_erase+0x164>
34808e94:	eb00030b 	bl	34809ac8 <printf>

	return ret == 0 ? 0 : 1;
34808e98:	e3a00000 	mov	r0, #0
}
34808e9c:	e28dd068 	add	sp, sp, #104	; 0x68
34808ea0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808ea4:	34825a8b 	.word	0x34825a8b
34808ea8:	34825a91 	.word	0x34825a91
34808eac:	34829cc0 	.word	0x34829cc0
34808eb0:	34825aa2 	.word	0x34825aa2
34808eb4:	34825e78 	.word	0x34825e78
34808eb8:	34824091 	.word	0x34824091

34808ebc <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
34808ebc:	e3a00000 	mov	r0, #0
34808ec0:	e12fff1e 	bx	lr

34808ec4 <__fswab32>:
34808ec4:	e6bf0f30 	rev	r0, r0
34808ec8:	e12fff1e 	bx	lr

34808ecc <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
34808ecc:	e92d4070 	push	{r4, r5, r6, lr}
34808ed0:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
34808ed4:	e59f00b0 	ldr	r0, [pc, #176]	; 34808f8c <source+0xc0>
34808ed8:	eb00112c 	bl	3480d390 <getenv_yesno>
34808edc:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
34808ee0:	e1a00004 	mov	r0, r4
34808ee4:	eb00121d 	bl	3480d760 <genimg_get_format>
34808ee8:	e3500001 	cmp	r0, #1
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808eec:	159f009c 	ldrne	r0, [pc, #156]	; 34808f90 <source+0xc4>
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");

	switch (genimg_get_format ((void *)addr)) {
34808ef0:	1a00001f 	bne	34808f74 <source+0xa8>
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34808ef4:	e5940000 	ldr	r0, [r4]
34808ef8:	ebfffff1 	bl	34808ec4 <__fswab32>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808efc:	e59f3090 	ldr	r3, [pc, #144]	; 34808f94 <source+0xc8>
34808f00:	e1500003 	cmp	r0, r3
			puts ("Bad magic number\n");
34808f04:	159f008c 	ldrne	r0, [pc, #140]	; 34808f98 <source+0xcc>

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808f08:	1a000019 	bne	34808f74 <source+0xa8>
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
34808f0c:	e1a00004 	mov	r0, r4
34808f10:	eb0010d1 	bl	3480d25c <image_check_hcrc>
34808f14:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
34808f18:	059f007c 	ldreq	r0, [pc, #124]	; 34808f9c <source+0xd0>
		if (!image_check_magic (hdr)) {
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
34808f1c:	0a000014 	beq	34808f74 <source+0xa8>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
34808f20:	e3550000 	cmp	r5, #0
34808f24:	0a000004 	beq	34808f3c <source+0x70>
			if (!image_check_dcrc (hdr)) {
34808f28:	e1a00004 	mov	r0, r4
34808f2c:	eb0010de 	bl	3480d2ac <image_check_dcrc>
34808f30:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
34808f34:	059f0064 	ldreq	r0, [pc, #100]	; 34808fa0 <source+0xd4>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
			if (!image_check_dcrc (hdr)) {
34808f38:	0a00000d 	beq	34808f74 <source+0xa8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
34808f3c:	e5d4301e 	ldrb	r3, [r4, #30]
34808f40:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
34808f44:	159f0058 	ldrne	r0, [pc, #88]	; 34808fa4 <source+0xd8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
34808f48:	1a000009 	bne	34808f74 <source+0xa8>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
34808f4c:	e5940040 	ldr	r0, [r4, #64]	; 0x40
34808f50:	ebffffdb 	bl	34808ec4 <__fswab32>
34808f54:	e2501000 	subs	r1, r0, #0
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34808f58:	e2845040 	add	r5, r4, #64	; 0x40
			puts ("Empty Script\n");
34808f5c:	059f0044 	ldreq	r0, [pc, #68]	; 34808fa8 <source+0xdc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
34808f60:	0a000003 	beq	34808f74 <source+0xa8>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
34808f64:	e4952004 	ldr	r2, [r5], #4
34808f68:	e3520000 	cmp	r2, #0
34808f6c:	1afffffc 	bne	34808f64 <source+0x98>
34808f70:	ea000002 	b	34808f80 <source+0xb4>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808f74:	eb0002c9 	bl	34809aa0 <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
34808f78:	e3a00001 	mov	r0, #1
34808f7c:	e8bd8070 	pop	{r4, r5, r6, pc}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34808f80:	e1a00005 	mov	r0, r5
}
34808f84:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34808f88:	ea0015ad 	b	3480e644 <run_command_list>
34808f8c:	34822f76 	.word	0x34822f76
34808f90:	34825d56 	.word	0x34825d56
34808f94:	27051956 	.word	0x27051956
34808f98:	34825d08 	.word	0x34825d08
34808f9c:	34825d1a 	.word	0x34825d1a
34808fa0:	34825d2a 	.word	0x34825d2a
34808fa4:	34825d38 	.word	0x34825d38
34808fa8:	34825d48 	.word	0x34825d48

34808fac <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808fac:	e3520001 	cmp	r2, #1

/**************************************************/
#if defined(CONFIG_CMD_SOURCE)
int
do_source (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34808fb0:	e92d4010 	push	{r4, lr}
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
		addr = CONFIG_SYS_LOAD_ADDR;
34808fb4:	d3a04309 	movle	r4, #603979776	; 0x24000000
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808fb8:	da000004 	ble	34808fd0 <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
34808fbc:	e5930004 	ldr	r0, [r3, #4]
34808fc0:	e3a01000 	mov	r1, #0
34808fc4:	e3a02010 	mov	r2, #16
34808fc8:	eb005085 	bl	3481d1e4 <simple_strtoul>
34808fcc:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
34808fd0:	e1a01004 	mov	r1, r4
34808fd4:	e59f0010 	ldr	r0, [pc, #16]	; 34808fec <do_source+0x40>
34808fd8:	eb0002ba 	bl	34809ac8 <printf>
	rcode = source (addr, fit_uname);
34808fdc:	e1a00004 	mov	r0, r4
34808fe0:	e3a01000 	mov	r1, #0
	return rcode;
}
34808fe4:	e8bd4010 	pop	{r4, lr}
		addr = simple_strtoul(argv[1], NULL, 16);
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
	rcode = source (addr, fit_uname);
34808fe8:	eaffffb7 	b	34808ecc <source>
34808fec:	34825d7f 	.word	0x34825d7f

34808ff0 <do_false>:
);

int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
34808ff0:	e3a00001 	mov	r0, #1
34808ff4:	e12fff1e 	bx	lr

34808ff8 <do_true>:
);

int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
34808ff8:	e3a00000 	mov	r0, #0
34808ffc:	e12fff1e 	bx	lr

34809000 <do_test>:
{
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
34809000:	e3520002 	cmp	r2, #2

#include <common.h>
#include <command.h>

int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34809004:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
34809008:	da0000fd 	ble	34809404 <do_test+0x404>
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
3480900c:	e5930004 	ldr	r0, [r3, #4]
34809010:	e59f141c 	ldr	r1, [pc, #1052]	; 34809434 <do_test+0x434>
			debug(" '%s'", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
34809014:	e2426001 	sub	r6, r2, #1
34809018:	e2834004 	add	r4, r3, #4
	if (left > 0 && strcmp(ap[0], "!") == 0) {
3480901c:	eb004ca9 	bl	3481c2c8 <strcmp>
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
34809020:	e3e05000 	mvn	r5, #0
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34809024:	e3500000 	cmp	r0, #0
		neg = 1;
		ap++;
34809028:	02844004 	addeq	r4, r4, #4
		left--;
3480902c:	02466001 	subeq	r6, r6, #1
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
34809030:	03a0b001 	moveq	fp, #1
		ap++;
		left--;
	} else
		neg = 0;
34809034:	13a0b000 	movne	fp, #0

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
34809038:	e1a07005 	mov	r7, r5
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
3480903c:	e1a0a005 	mov	sl, r5
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
34809040:	e5940000 	ldr	r0, [r4]
34809044:	e59f13ec 	ldr	r1, [pc, #1004]	; 34809438 <do_test+0x438>
34809048:	eb004c9e 	bl	3481c2c8 <strcmp>
3480904c:	e3500000 	cmp	r0, #0
34809050:	0a0000ed 	beq	3480940c <do_test+0x40c>
34809054:	e5940000 	ldr	r0, [r4]
34809058:	e59f13dc 	ldr	r1, [pc, #988]	; 3480943c <do_test+0x43c>
3480905c:	eb004c99 	bl	3481c2c8 <strcmp>
34809060:	e3500000 	cmp	r0, #0
34809064:	0a0000e8 	beq	3480940c <do_test+0x40c>
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34809068:	e5940000 	ldr	r0, [r4]
3480906c:	e59f13cc 	ldr	r1, [pc, #972]	; 34809440 <do_test+0x440>
34809070:	eb004c94 	bl	3481c2c8 <strcmp>
34809074:	e3500000 	cmp	r0, #0
			adv = 2;
34809078:	03a09002 	moveq	r9, #2
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
3480907c:	0a000005 	beq	34809098 <do_test+0x98>
34809080:	e5940000 	ldr	r0, [r4]
34809084:	e59f13b8 	ldr	r1, [pc, #952]	; 34809444 <do_test+0x444>
34809088:	eb004c8e 	bl	3481c2c8 <strcmp>
			adv = 2;
		else
			adv = 3;
3480908c:	e3500000 	cmp	r0, #0
34809090:	03a09002 	moveq	r9, #2
34809094:	13a09003 	movne	r9, #3

		if (left < adv) {
34809098:	e1560009 	cmp	r6, r9
3480909c:	aa000006 	bge	348090bc <do_test+0xbc>
348090a0:	ea0000cf 	b	348093e4 <do_test+0x3e4>

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
348090a4:	e5940000 	ldr	r0, [r4]
348090a8:	e59f138c 	ldr	r1, [pc, #908]	; 3480943c <do_test+0x43c>
348090ac:	eb004c85 	bl	3481c2c8 <strcmp>
348090b0:	e3500000 	cmp	r0, #0
348090b4:	0a0000da 	beq	34809424 <do_test+0x424>
348090b8:	ea0000c9 	b	348093e4 <do_test+0x3e4>
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
348090bc:	e3590002 	cmp	r9, #2
348090c0:	1a00001e 	bne	34809140 <do_test+0x140>
			if (strcmp(ap[0], "-z") == 0)
348090c4:	e5940000 	ldr	r0, [r4]
348090c8:	e59f1370 	ldr	r1, [pc, #880]	; 34809440 <do_test+0x440>
348090cc:	eb004c7d 	bl	3481c2c8 <strcmp>
348090d0:	e3500000 	cmp	r0, #0
348090d4:	1a000004 	bne	348090ec <do_test+0xec>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
348090d8:	e5940004 	ldr	r0, [r4, #4]
348090dc:	eb004cad 	bl	3481c398 <strlen>
348090e0:	e270a001 	rsbs	sl, r0, #1
348090e4:	33a0a000 	movcc	sl, #0
348090e8:	ea000008 	b	34809110 <do_test+0x110>
			else if (strcmp(ap[0], "-n") == 0)
348090ec:	e5940000 	ldr	r0, [r4]
348090f0:	e59f134c 	ldr	r1, [pc, #844]	; 34809444 <do_test+0x444>
348090f4:	eb004c73 	bl	3481c2c8 <strcmp>
348090f8:	e3500000 	cmp	r0, #0
348090fc:	1a0000b8 	bne	348093e4 <do_test+0x3e4>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
34809100:	e5940004 	ldr	r0, [r4, #4]
34809104:	eb004ca3 	bl	3481c398 <strlen>
34809108:	e250a000 	subs	sl, r0, #0
3480910c:	13a0a001 	movne	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
34809110:	e3550000 	cmp	r5, #0
34809114:	1a000003 	bne	34809128 <do_test+0x128>
				expr = last_expr || expr;
34809118:	e19aa007 	orrs	sl, sl, r7
3480911c:	03a0a000 	moveq	sl, #0
34809120:	13a0a001 	movne	sl, #1
34809124:	ea0000a8 	b	348093cc <do_test+0x3cc>
			else if (last_cmp == 1)
34809128:	e3550001 	cmp	r5, #1
3480912c:	1a0000a6 	bne	348093cc <do_test+0x3cc>
				expr = last_expr && expr;
34809130:	e3570000 	cmp	r7, #0
34809134:	03a0a000 	moveq	sl, #0
34809138:	120aa001 	andne	sl, sl, #1
3480913c:	ea0000a2 	b	348093cc <do_test+0x3cc>
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
34809140:	e5940004 	ldr	r0, [r4, #4]
34809144:	e59f12fc 	ldr	r1, [pc, #764]	; 34809448 <do_test+0x448>
34809148:	eb004c5e 	bl	3481c2c8 <strcmp>
3480914c:	e3500000 	cmp	r0, #0
34809150:	e284a004 	add	sl, r4, #4
34809154:	1a000005 	bne	34809170 <do_test+0x170>
				expr = strcmp(ap[0], ap[2]) == 0;
34809158:	e5940000 	ldr	r0, [r4]
3480915c:	e5941008 	ldr	r1, [r4, #8]
34809160:	eb004c58 	bl	3481c2c8 <strcmp>
34809164:	e270a001 	rsbs	sl, r0, #1
34809168:	33a0a000 	movcc	sl, #0
3480916c:	ea00008a 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "!=") == 0)
34809170:	e5940004 	ldr	r0, [r4, #4]
34809174:	e59f12d0 	ldr	r1, [pc, #720]	; 3480944c <do_test+0x44c>
34809178:	eb004c52 	bl	3481c2c8 <strcmp>
3480917c:	e3500000 	cmp	r0, #0
34809180:	1a000005 	bne	3480919c <do_test+0x19c>
				expr = strcmp(ap[0], ap[2]) != 0;
34809184:	e5940000 	ldr	r0, [r4]
34809188:	e5941008 	ldr	r1, [r4, #8]
3480918c:	eb004c4d 	bl	3481c2c8 <strcmp>
34809190:	e250a000 	subs	sl, r0, #0
34809194:	13a0a001 	movne	sl, #1
34809198:	ea00007f 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], ">") == 0)
3480919c:	e59a0000 	ldr	r0, [sl]
348091a0:	e59f12a8 	ldr	r1, [pc, #680]	; 34809450 <do_test+0x450>
348091a4:	eb004c47 	bl	3481c2c8 <strcmp>
348091a8:	e3500000 	cmp	r0, #0
348091ac:	1a000006 	bne	348091cc <do_test+0x1cc>
				expr = strcmp(ap[0], ap[2]) > 0;
348091b0:	e5940000 	ldr	r0, [r4]
348091b4:	e5941008 	ldr	r1, [r4, #8]
348091b8:	eb004c42 	bl	3481c2c8 <strcmp>
348091bc:	e3500000 	cmp	r0, #0
348091c0:	d3a0a000 	movle	sl, #0
348091c4:	c3a0a001 	movgt	sl, #1
348091c8:	ea000073 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "<") == 0)
348091cc:	e59a0000 	ldr	r0, [sl]
348091d0:	e59f127c 	ldr	r1, [pc, #636]	; 34809454 <do_test+0x454>
348091d4:	eb004c3b 	bl	3481c2c8 <strcmp>
348091d8:	e3500000 	cmp	r0, #0
348091dc:	1a000004 	bne	348091f4 <do_test+0x1f4>
				expr = strcmp(ap[0], ap[2]) < 0;
348091e0:	e5940000 	ldr	r0, [r4]
348091e4:	e5941008 	ldr	r1, [r4, #8]
348091e8:	eb004c36 	bl	3481c2c8 <strcmp>
348091ec:	e1a0afa0 	lsr	sl, r0, #31
348091f0:	ea000069 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-eq") == 0)
348091f4:	e59a0000 	ldr	r0, [sl]
348091f8:	e59f1258 	ldr	r1, [pc, #600]	; 34809458 <do_test+0x458>
348091fc:	eb004c31 	bl	3481c2c8 <strcmp>
34809200:	e2509000 	subs	r9, r0, #0
34809204:	1a00000c 	bne	3480923c <do_test+0x23c>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
34809208:	e1a01009 	mov	r1, r9
3480920c:	e3a0200a 	mov	r2, #10
34809210:	e5940000 	ldr	r0, [r4]
34809214:	eb00503b 	bl	3481d308 <simple_strtol>
34809218:	e1a01009 	mov	r1, r9
3480921c:	e1a0a000 	mov	sl, r0
34809220:	e3a0200a 	mov	r2, #10
34809224:	e5940008 	ldr	r0, [r4, #8]
34809228:	eb005036 	bl	3481d308 <simple_strtol>
3480922c:	e15a0000 	cmp	sl, r0
34809230:	13a0a000 	movne	sl, #0
34809234:	03a0a001 	moveq	sl, #1
34809238:	ea000057 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-ne") == 0)
3480923c:	e59a0000 	ldr	r0, [sl]
34809240:	e59f1214 	ldr	r1, [pc, #532]	; 3480945c <do_test+0x45c>
34809244:	eb004c1f 	bl	3481c2c8 <strcmp>
34809248:	e2509000 	subs	r9, r0, #0
3480924c:	1a00000b 	bne	34809280 <do_test+0x280>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
34809250:	e1a01009 	mov	r1, r9
34809254:	e3a0200a 	mov	r2, #10
34809258:	e5940000 	ldr	r0, [r4]
3480925c:	eb005029 	bl	3481d308 <simple_strtol>
34809260:	e1a01009 	mov	r1, r9
34809264:	e1a0a000 	mov	sl, r0
34809268:	e3a0200a 	mov	r2, #10
3480926c:	e5940008 	ldr	r0, [r4, #8]
34809270:	eb005024 	bl	3481d308 <simple_strtol>
34809274:	e05aa000 	subs	sl, sl, r0
34809278:	13a0a001 	movne	sl, #1
3480927c:	ea000046 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-lt") == 0)
34809280:	e59a0000 	ldr	r0, [sl]
34809284:	e59f11d4 	ldr	r1, [pc, #468]	; 34809460 <do_test+0x460>
34809288:	eb004c0e 	bl	3481c2c8 <strcmp>
3480928c:	e2509000 	subs	r9, r0, #0
34809290:	1a00000c 	bne	348092c8 <do_test+0x2c8>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
34809294:	e1a01009 	mov	r1, r9
34809298:	e3a0200a 	mov	r2, #10
3480929c:	e5940000 	ldr	r0, [r4]
348092a0:	eb005018 	bl	3481d308 <simple_strtol>
348092a4:	e1a01009 	mov	r1, r9
348092a8:	e1a0a000 	mov	sl, r0
348092ac:	e3a0200a 	mov	r2, #10
348092b0:	e5940008 	ldr	r0, [r4, #8]
348092b4:	eb005013 	bl	3481d308 <simple_strtol>
348092b8:	e15a0000 	cmp	sl, r0
348092bc:	a3a0a000 	movge	sl, #0
348092c0:	b3a0a001 	movlt	sl, #1
348092c4:	ea000034 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-le") == 0)
348092c8:	e59a0000 	ldr	r0, [sl]
348092cc:	e59f1190 	ldr	r1, [pc, #400]	; 34809464 <do_test+0x464>
348092d0:	eb004bfc 	bl	3481c2c8 <strcmp>
348092d4:	e3500000 	cmp	r0, #0
348092d8:	1a00000c 	bne	34809310 <do_test+0x310>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
348092dc:	e3a01000 	mov	r1, #0
348092e0:	e3a0200a 	mov	r2, #10
348092e4:	e5940000 	ldr	r0, [r4]
348092e8:	eb005006 	bl	3481d308 <simple_strtol>
348092ec:	e3a01000 	mov	r1, #0
348092f0:	e1a0a000 	mov	sl, r0
348092f4:	e3a0200a 	mov	r2, #10
348092f8:	e5940008 	ldr	r0, [r4, #8]
348092fc:	eb005001 	bl	3481d308 <simple_strtol>
34809300:	e15a0000 	cmp	sl, r0
34809304:	c3a0a000 	movgt	sl, #0
34809308:	d3a0a001 	movle	sl, #1
3480930c:	ea000022 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-gt") == 0)
34809310:	e59a0000 	ldr	r0, [sl]
34809314:	e59f114c 	ldr	r1, [pc, #332]	; 34809468 <do_test+0x468>
34809318:	eb004bea 	bl	3481c2c8 <strcmp>
3480931c:	e2509000 	subs	r9, r0, #0
34809320:	1a00000c 	bne	34809358 <do_test+0x358>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
34809324:	e1a01009 	mov	r1, r9
34809328:	e3a0200a 	mov	r2, #10
3480932c:	e5940000 	ldr	r0, [r4]
34809330:	eb004ff4 	bl	3481d308 <simple_strtol>
34809334:	e1a01009 	mov	r1, r9
34809338:	e1a0a000 	mov	sl, r0
3480933c:	e3a0200a 	mov	r2, #10
34809340:	e5940008 	ldr	r0, [r4, #8]
34809344:	eb004fef 	bl	3481d308 <simple_strtol>
34809348:	e15a0000 	cmp	sl, r0
3480934c:	d3a0a000 	movle	sl, #0
34809350:	c3a0a001 	movgt	sl, #1
34809354:	ea000010 	b	3480939c <do_test+0x39c>
			else if (strcmp(ap[1], "-ge") == 0)
34809358:	e59a0000 	ldr	r0, [sl]
3480935c:	e59f1108 	ldr	r1, [pc, #264]	; 3480946c <do_test+0x46c>
34809360:	eb004bd8 	bl	3481c2c8 <strcmp>
34809364:	e2509000 	subs	r9, r0, #0
34809368:	1a00001d 	bne	348093e4 <do_test+0x3e4>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
3480936c:	e1a01009 	mov	r1, r9
34809370:	e3a0200a 	mov	r2, #10
34809374:	e5940000 	ldr	r0, [r4]
34809378:	eb004fe2 	bl	3481d308 <simple_strtol>
3480937c:	e1a01009 	mov	r1, r9
34809380:	e1a0a000 	mov	sl, r0
34809384:	e3a0200a 	mov	r2, #10
34809388:	e5940008 	ldr	r0, [r4, #8]
3480938c:	eb004fdd 	bl	3481d308 <simple_strtol>
34809390:	e15a0000 	cmp	sl, r0
34809394:	b3a0a000 	movlt	sl, #0
34809398:	a3a0a001 	movge	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
3480939c:	e3550000 	cmp	r5, #0
348093a0:	1a000003 	bne	348093b4 <do_test+0x3b4>
				expr = last_expr || expr;
348093a4:	e19aa007 	orrs	sl, sl, r7
348093a8:	03a0a000 	moveq	sl, #0
348093ac:	13a0a001 	movne	sl, #1
348093b0:	ea000004 	b	348093c8 <do_test+0x3c8>
			else if (last_cmp == 1)
348093b4:	e3550001 	cmp	r5, #1
348093b8:	1a000002 	bne	348093c8 <do_test+0x3c8>
				expr = last_expr && expr;
348093bc:	e3570000 	cmp	r7, #0
348093c0:	03a0a000 	moveq	sl, #0
348093c4:	120aa001 	andne	sl, sl, #1
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
348093c8:	e3a09003 	mov	r9, #3
				expr = last_expr && expr;
			last_cmp = -1;
348093cc:	e3e05000 	mvn	r5, #0
		}

		ap += adv; left -= adv;
348093d0:	e0696006 	rsb	r6, r9, r6
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {
348093d4:	e3560000 	cmp	r6, #0
348093d8:	da000002 	ble	348093e8 <do_test+0x3e8>
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
348093dc:	e0844109 	add	r4, r4, r9, lsl #2
348093e0:	eaffff16 	b	34809040 <do_test+0x40>
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
348093e4:	e3a0a001 	mov	sl, #1
		}

		ap += adv; left -= adv;
	}

	if (neg)
348093e8:	e35b0000 	cmp	fp, #0
348093ec:	0a000001 	beq	348093f8 <do_test+0x3f8>
		expr = !expr;
348093f0:	e27aa001 	rsbs	sl, sl, #1
348093f4:	33a0a000 	movcc	sl, #0

	expr = !expr;
348093f8:	e27a0001 	rsbs	r0, sl, #1
348093fc:	33a00000 	movcc	r0, #0

	debug (": returns %d\n", expr);

	return expr;
34809400:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;
34809404:	e3a00001 	mov	r0, #1
	expr = !expr;

	debug (": returns %d\n", expr);

	return expr;
}
34809408:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
3480940c:	e5940000 	ldr	r0, [r4]
34809410:	e59f1020 	ldr	r1, [pc, #32]	; 34809438 <do_test+0x438>
34809414:	eb004bab 	bl	3481c2c8 <strcmp>
34809418:	e2505000 	subs	r5, r0, #0
3480941c:	0a000001 	beq	34809428 <do_test+0x428>
34809420:	eaffff1f 	b	348090a4 <do_test+0xa4>
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
34809424:	e3a05001 	mov	r5, #1

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
34809428:	e1a0700a 	mov	r7, sl
3480942c:	e3a09001 	mov	r9, #1
34809430:	eaffffe6 	b	348093d0 <do_test+0x3d0>
34809434:	348270b5 	.word	0x348270b5
34809438:	34825e09 	.word	0x34825e09
3480943c:	34825e0c 	.word	0x34825e0c
34809440:	34825e0f 	.word	0x34825e0f
34809444:	34825e12 	.word	0x34825e12
34809448:	3482393e 	.word	0x3482393e
3480944c:	3482393d 	.word	0x3482393d
34809450:	34823941 	.word	0x34823941
34809454:	3482392c 	.word	0x3482392c
34809458:	34823932 	.word	0x34823932
3480945c:	34823939 	.word	0x34823939
34809460:	34823928 	.word	0x34823928
34809464:	3482394a 	.word	0x3482394a
34809468:	3482392e 	.word	0x3482392e
3480946c:	34823943 	.word	0x34823943

34809470 <do_version>:
#include <linux/compiler.h>

const char __weak version_string[] = U_BOOT_VERSION_STRING;

int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34809470:	e92d4008 	push	{r3, lr}
	printf("\n%s\n", version_string);
34809474:	e59f101c 	ldr	r1, [pc, #28]	; 34809498 <do_version+0x28>
34809478:	e59f001c 	ldr	r0, [pc, #28]	; 3480949c <do_version+0x2c>
3480947c:	eb000191 	bl	34809ac8 <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
34809480:	e59f0018 	ldr	r0, [pc, #24]	; 348094a0 <do_version+0x30>
34809484:	eb000185 	bl	34809aa0 <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
34809488:	e59f0014 	ldr	r0, [pc, #20]	; 348094a4 <do_version+0x34>
3480948c:	eb000183 	bl	34809aa0 <puts>
#endif

	return 0;
}
34809490:	e3a00000 	mov	r0, #0
34809494:	e8bd8008 	pop	{r3, pc}
34809498:	34820260 	.word	0x34820260
3480949c:	34825e77 	.word	0x34825e77
348094a0:	34825e7c 	.word	0x34825e7c
348094a4:	34825ea1 	.word	0x34825ea1

348094a8 <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
348094a8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
348094ac:	e2505000 	subs	r5, r0, #0

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
348094b0:	e1a04002 	mov	r4, r2
348094b4:	e1a06001 	mov	r6, r1
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
348094b8:	01a04005 	moveq	r4, r5
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
348094bc:	0a00001e 	beq	3480953c <find_cmd_tbl+0x94>
		return NULL;
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
348094c0:	e3a0102e 	mov	r1, #46	; 0x2e
348094c4:	eb004b9d 	bl	3481c340 <strchr>
348094c8:	e3500000 	cmp	r0, #0
348094cc:	1065a000 	rsbne	sl, r5, r0
348094d0:	1a000002 	bne	348094e0 <find_cmd_tbl+0x38>
348094d4:	e1a00005 	mov	r0, r5
348094d8:	eb004bae 	bl	3481c398 <strlen>
348094dc:	e1a0a000 	mov	sl, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
348094e0:	e3a09018 	mov	r9, #24
348094e4:	e0296499 	mla	r9, r9, r4, r6
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;
348094e8:	e3a07000 	mov	r7, #0
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
348094ec:	e1a04006 	mov	r4, r6
348094f0:	ea00000c 	b	34809528 <find_cmd_tbl+0x80>
	     cmdtp != table + table_len;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
348094f4:	e1a00005 	mov	r0, r5
348094f8:	e5941000 	ldr	r1, [r4]
348094fc:	e1a0200a 	mov	r2, sl
34809500:	eb004b7c 	bl	3481c2f8 <strncmp>
34809504:	e3500000 	cmp	r0, #0
34809508:	1a000005 	bne	34809524 <find_cmd_tbl+0x7c>
			if (len == strlen (cmdtp->name))
3480950c:	e5940000 	ldr	r0, [r4]
34809510:	eb004ba0 	bl	3481c398 <strlen>
34809514:	e15a0000 	cmp	sl, r0
34809518:	0a000007 	beq	3480953c <find_cmd_tbl+0x94>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
3480951c:	e2877001 	add	r7, r7, #1
34809520:	e1a06004 	mov	r6, r4
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
	     cmdtp != table + table_len;
	     cmdtp++) {
34809524:	e2844018 	add	r4, r4, #24
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
34809528:	e1540009 	cmp	r4, r9
3480952c:	1afffff0 	bne	348094f4 <find_cmd_tbl+0x4c>
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
34809530:	e3570001 	cmp	r7, #1
34809534:	01a04006 	moveq	r4, r6
34809538:	13a04000 	movne	r4, #0
}
3480953c:	e1a00004 	mov	r0, r4
34809540:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34809544 <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809544:	e59f1014 	ldr	r1, [pc, #20]	; 34809560 <find_cmd+0x1c>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34809548:	e59f3014 	ldr	r3, [pc, #20]	; 34809564 <find_cmd+0x20>
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
3480954c:	e59f2014 	ldr	r2, [pc, #20]	; 34809568 <find_cmd+0x24>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34809550:	e0613003 	rsb	r3, r1, r3
34809554:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809558:	e0020392 	mul	r2, r2, r3
3480955c:	eaffffd1 	b	348094a8 <find_cmd_tbl>
	...
34809568:	aaaaaaab 	.word	0xaaaaaaab

3480956c <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
3480956c:	e92d4010 	push	{r4, lr}
34809570:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
34809574:	e5941000 	ldr	r1, [r4]
34809578:	e5942010 	ldr	r2, [r4, #16]
3480957c:	e59f0038 	ldr	r0, [pc, #56]	; 348095bc <cmd_usage+0x50>
34809580:	eb000150 	bl	34809ac8 <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
34809584:	e59f0034 	ldr	r0, [pc, #52]	; 348095c0 <cmd_usage+0x54>
34809588:	e5941000 	ldr	r1, [r4]
3480958c:	eb00014d 	bl	34809ac8 <printf>

	if (!cmdtp->help) {
34809590:	e5940014 	ldr	r0, [r4, #20]
34809594:	e3500000 	cmp	r0, #0
34809598:	1a000002 	bne	348095a8 <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
3480959c:	e59f0020 	ldr	r0, [pc, #32]	; 348095c4 <cmd_usage+0x58>
348095a0:	eb00013e 	bl	34809aa0 <puts>
		return 1;
348095a4:	ea000002 	b	348095b4 <cmd_usage+0x48>
	}

	puts (cmdtp->help);
348095a8:	eb00013c 	bl	34809aa0 <puts>
	putc ('\n');
348095ac:	e3a0000a 	mov	r0, #10
348095b0:	eb000130 	bl	34809a78 <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
348095b4:	e3a00001 	mov	r0, #1
348095b8:	e8bd8010 	pop	{r4, pc}
348095bc:	34825ef3 	.word	0x34825ef3
348095c0:	34825efd 	.word	0x34825efd
348095c4:	34825f08 	.word	0x34825f08

348095c8 <_do_help>:
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
348095c8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348095cc:	e28db01c 	add	fp, sp, #28
348095d0:	e24dd010 	sub	sp, sp, #16
348095d4:	e59b9004 	ldr	r9, [fp, #4]
348095d8:	e1a0a000 	mov	sl, r0
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
348095dc:	e3590001 	cmp	r9, #1
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
348095e0:	e1a04001 	mov	r4, r1
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
348095e4:	159b7008 	ldrne	r7, [fp, #8]
348095e8:	13a05000 	movne	r5, #0
348095ec:	13a06001 	movne	r6, #1
348095f0:	1a00004f 	bne	34809734 <_do_help+0x16c>
		cmd_tbl_t *cmd_array[cmd_items];
348095f4:	e1a03101 	lsl	r3, r1, #2
348095f8:	e283300e 	add	r3, r3, #14
348095fc:	e3c33007 	bic	r3, r3, #7
	      flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34809600:	e50bd024 	str	sp, [fp, #-36]	; 0x24
		cmd_tbl_t *cmd_array[cmd_items];
34809604:	e04dd003 	sub	sp, sp, r3
34809608:	e1a0300d 	mov	r3, sp
3480960c:	e50bd020 	str	sp, [fp, #-32]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809610:	e1a0100d 	mov	r1, sp
34809614:	e3a02000 	mov	r2, #0
34809618:	ea000002 	b	34809628 <_do_help+0x60>
			cmd_array[i] = cmdtp++;
3480961c:	e481a004 	str	sl, [r1], #4
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809620:	e2822001 	add	r2, r2, #1
			cmd_array[i] = cmdtp++;
34809624:	e28aa018 	add	sl, sl, #24
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809628:	e1520004 	cmp	r2, r4
3480962c:	bafffffa 	blt	3480961c <_do_help+0x54>
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34809630:	e2446001 	sub	r6, r4, #1
34809634:	ea000017 	b	34809698 <_do_help+0xd0>
34809638:	e3a07000 	mov	r7, #0
3480963c:	e1a05003 	mov	r5, r3
34809640:	e1a0a007 	mov	sl, r7
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34809644:	e5952000 	ldr	r2, [r5]
					    cmd_array[j + 1]->name) > 0) {
34809648:	e5b59004 	ldr	r9, [r5, #4]!

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
3480964c:	e5920000 	ldr	r0, [r2]
34809650:	e5991000 	ldr	r1, [r9]
34809654:	e50b2028 	str	r2, [fp, #-40]	; 0x28
34809658:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
3480965c:	eb004b19 	bl	3481c2c8 <strcmp>
34809660:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
34809664:	e3500000 	cmp	r0, #0
					    cmd_array[j + 1]->name) > 0) {
34809668:	e28aa001 	add	sl, sl, #1

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
3480966c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
34809670:	c2877001 	addgt	r7, r7, #1
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
34809674:	c5059004 	strgt	r9, [r5, #-4]
					cmd_array[j + 1] = tmp;
34809678:	c5852000 	strgt	r2, [r5]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
3480967c:	e15a0006 	cmp	sl, r6
34809680:	baffffef 	blt	34809644 <_do_help+0x7c>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
34809684:	e3570000 	cmp	r7, #0
34809688:	1a000001 	bne	34809694 <_do_help+0xcc>
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
3480968c:	e3a05000 	mov	r5, #0
34809690:	ea000012 	b	348096e0 <_do_help+0x118>
34809694:	e2466001 	sub	r6, r6, #1
34809698:	e3560000 	cmp	r6, #0
3480969c:	caffffe5 	bgt	34809638 <_do_help+0x70>
348096a0:	eafffff9 	b	3480968c <_do_help+0xc4>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;
348096a4:	e51b3020 	ldr	r3, [fp, #-32]
348096a8:	e4937004 	ldr	r7, [r3], #4
348096ac:	e50b3020 	str	r3, [fp, #-32]
348096b0:	e5976010 	ldr	r6, [r7, #16]

			/* allow user abort */
			if (ctrlc ())
348096b4:	eb000128 	bl	34809b5c <ctrlc>
348096b8:	e3500000 	cmp	r0, #0
348096bc:	1a00000b 	bne	348096f0 <_do_help+0x128>
				return 1;
			if (usage == NULL)
348096c0:	e3560000 	cmp	r6, #0
348096c4:	0a000004 	beq	348096dc <_do_help+0x114>
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
348096c8:	e59f0078 	ldr	r0, [pc, #120]	; 34809748 <_do_help+0x180>
348096cc:	e3a01008 	mov	r1, #8
348096d0:	e5972000 	ldr	r2, [r7]
348096d4:	e1a03006 	mov	r3, r6
348096d8:	eb0000fa 	bl	34809ac8 <printf>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
348096dc:	e2855001 	add	r5, r5, #1
348096e0:	e1550004 	cmp	r5, r4
348096e4:	baffffee 	blt	348096a4 <_do_help+0xdc>
			if (usage == NULL)
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
			       cmd_array[i]->name, usage);
		}
		return 0;
348096e8:	e3a05000 	mov	r5, #0
348096ec:	ea000000 	b	348096f4 <_do_help+0x12c>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
348096f0:	e3a05001 	mov	r5, #1
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
348096f4:	e51bd024 	ldr	sp, [fp, #-36]	; 0x24
348096f8:	ea00000f 	b	3480973c <_do_help+0x174>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
348096fc:	e5b70004 	ldr	r0, [r7, #4]!
34809700:	e1a0100a 	mov	r1, sl
34809704:	e1a02004 	mov	r2, r4
34809708:	ebffff66 	bl	348094a8 <find_cmd_tbl>
3480970c:	e3500000 	cmp	r0, #0
34809710:	0a000002 	beq	34809720 <_do_help+0x158>
			rcode |= cmd_usage(cmdtp);
34809714:	ebffff94 	bl	3480956c <cmd_usage>
34809718:	e1855000 	orr	r5, r5, r0
3480971c:	ea000003 	b	34809730 <_do_help+0x168>
		} else {
			printf ("Unknown command '%s' - try 'help'"
34809720:	e59f0024 	ldr	r0, [pc, #36]	; 3480974c <_do_help+0x184>
34809724:	e5971000 	ldr	r1, [r7]
34809728:	eb0000e6 	bl	34809ac8 <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
3480972c:	e3a05001 	mov	r5, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
34809730:	e2866001 	add	r6, r6, #1
34809734:	e1560009 	cmp	r6, r9
34809738:	baffffef 	blt	348096fc <_do_help+0x134>
					);
			rcode = 1;
		}
	}
	return rcode;
}
3480973c:	e1a00005 	mov	r0, r5
34809740:	e24bd01c 	sub	sp, fp, #28
34809744:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809748:	34825f29 	.word	0x34825f29
3480974c:	34825f33 	.word	0x34825f33

34809750 <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
34809750:	e92d4038 	push	{r3, r4, r5, lr}
34809754:	e1a04000 	mov	r4, r0
34809758:	e1a05001 	mov	r5, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
3480975c:	eb004b0d 	bl	3481c398 <strlen>
	if (len > 2 && arg[len-2] == '.') {
34809760:	e3500002 	cmp	r0, #2
34809764:	da00000a 	ble	34809794 <cmd_get_data_size+0x44>
34809768:	e0844000 	add	r4, r4, r0
3480976c:	e5543002 	ldrb	r3, [r4, #-2]
34809770:	e353002e 	cmp	r3, #46	; 0x2e
34809774:	1a000006 	bne	34809794 <cmd_get_data_size+0x44>
		switch(arg[len-1]) {
34809778:	e5543001 	ldrb	r3, [r4, #-1]
3480977c:	e2433062 	sub	r3, r3, #98	; 0x62
34809780:	e6ef3073 	uxtb	r3, r3
34809784:	e3530015 	cmp	r3, #21
34809788:	959f200c 	ldrls	r2, [pc, #12]	; 3480979c <cmd_get_data_size+0x4c>
3480978c:	83e05000 	mvnhi	r5, #0
34809790:	97925103 	ldrls	r5, [r2, r3, lsl #2]
		default:
			return -1;
		}
	}
	return default_size;
}
34809794:	e1a00005 	mov	r0, r5
34809798:	e8bd8038 	pop	{r3, r4, r5, pc}
3480979c:	34820288 	.word	0x34820288

348097a0 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
348097a0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
348097a4:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
348097a8:	e5920000 	ldr	r0, [r2]
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
348097ac:	e1a0a001 	mov	sl, r1
348097b0:	e1a06002 	mov	r6, r2
348097b4:	e1a07003 	mov	r7, r3
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
348097b8:	ebffff61 	bl	34809544 <find_cmd>
	if (cmdtp == NULL) {
348097bc:	e2504000 	subs	r4, r0, #0
348097c0:	1a000003 	bne	348097d4 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
348097c4:	e5961000 	ldr	r1, [r6]
348097c8:	e59f0078 	ldr	r0, [pc, #120]	; 34809848 <cmd_process+0xa8>
348097cc:	eb0000bd 	bl	34809ac8 <printf>
348097d0:	ea00000b 	b	34809804 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
348097d4:	e5943004 	ldr	r3, [r4, #4]
348097d8:	e15a0003 	cmp	sl, r3
348097dc:	ca00000a 	bgt	3480980c <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
348097e0:	e594c00c 	ldr	ip, [r4, #12]
348097e4:	e59f3060 	ldr	r3, [pc, #96]	; 3480984c <cmd_process+0xac>
348097e8:	e15c0003 	cmp	ip, r3
348097ec:	1a000009 	bne	34809818 <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
348097f0:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
348097f4:	03855002 	orreq	r5, r5, #2
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
348097f8:	0a000006 	beq	34809818 <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
348097fc:	e59f004c 	ldr	r0, [pc, #76]	; 34809850 <cmd_process+0xb0>
34809800:	eb0000a6 	bl	34809aa0 <puts>
			rc = CMD_RET_FAILURE;
34809804:	e3a00001 	mov	r0, #1
34809808:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
3480980c:	e1a00004 	mov	r0, r4
	return rc;
}
34809810:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34809814:	eaffff54 	b	3480956c <cmd_usage>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
34809818:	e1a0200a 	mov	r2, sl
3480981c:	e1a03006 	mov	r3, r6
34809820:	e1a00004 	mov	r0, r4
34809824:	e1a01005 	mov	r1, r5
34809828:	e12fff3c 	blx	ip
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
3480982c:	e5972000 	ldr	r2, [r7]
34809830:	e5943008 	ldr	r3, [r4, #8]
	}
	if (rc == CMD_RET_USAGE)
34809834:	e3700001 	cmn	r0, #1
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34809838:	e0023003 	and	r3, r2, r3
3480983c:	e5873000 	str	r3, [r7]
	}
	if (rc == CMD_RET_USAGE)
34809840:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
34809844:	eafffff0 	b	3480980c <cmd_process+0x6c>
34809848:	34825f88 	.word	0x34825f88
3480984c:	348024ac 	.word	0x348024ac
34809850:	34825fab 	.word	0x34825fab

34809854 <console_setfile>:
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34809854:	e92d4038 	push	{r3, r4, r5, lr}
	int error = 0;

	if (dev == NULL)
34809858:	e2515000 	subs	r5, r1, #0
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
3480985c:	e1a04000 	mov	r4, r0
	int error = 0;

	if (dev == NULL)
		return -1;
34809860:	03e00000 	mvneq	r0, #0

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
34809864:	08bd8038 	popeq	{r3, r4, r5, pc}
		return -1;

	switch (file) {
34809868:	e3540002 	cmp	r4, #2
3480986c:	8a00001d 	bhi	348098e8 <console_setfile+0x94>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
34809870:	e5950018 	ldr	r0, [r5, #24]
34809874:	e3500000 	cmp	r0, #0
34809878:	0a000002 	beq	34809888 <console_setfile+0x34>
			error = dev->start();
3480987c:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
34809880:	e3500000 	cmp	r0, #0
34809884:	b8bd8038 	poplt	{r3, r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34809888:	e59f3060 	ldr	r3, [pc, #96]	; 348098f0 <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
3480988c:	e3540000 	cmp	r4, #0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34809890:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34809894:	0a000002 	beq	348098a4 <console_setfile+0x50>
34809898:	e3540001 	cmp	r4, #1
3480989c:	18bd8038 	popne	{r3, r4, r5, pc}
348098a0:	ea000006 	b	348098c0 <console_setfile+0x6c>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
348098a4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348098a8:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
			gd->jt[XF_tstc] = dev->tstc;
348098ac:	e5983054 	ldr	r3, [r8, #84]	; 0x54
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
		case stdin:
			gd->jt[XF_getc] = dev->getc;
348098b0:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
348098b4:	e5952028 	ldr	r2, [r5, #40]	; 0x28
348098b8:	e5832008 	str	r2, [r3, #8]
			break;
348098bc:	e8bd8038 	pop	{r3, r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
348098c0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348098c4:	e5951020 	ldr	r1, [r5, #32]
348098c8:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
348098cc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348098d0:	e5951024 	ldr	r1, [r5, #36]	; 0x24
			gd->jt[XF_printf] = printf;
348098d4:	e5983054 	ldr	r3, [r8, #84]	; 0x54
			gd->jt[XF_getc] = dev->getc;
			gd->jt[XF_tstc] = dev->tstc;
			break;
		case stdout:
			gd->jt[XF_putc] = dev->putc;
			gd->jt[XF_puts] = dev->puts;
348098d8:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
348098dc:	e59f2010 	ldr	r2, [pc, #16]	; 348098f4 <console_setfile+0xa0>
348098e0:	e5832014 	str	r2, [r3, #20]
			break;
348098e4:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
348098e8:	e3e00000 	mvn	r0, #0
	}
	return error;
}
348098ec:	e8bd8038 	pop	{r3, r4, r5, pc}
348098f0:	3482b524 	.word	0x3482b524
348098f4:	34809ac8 	.word	0x34809ac8

348098f8 <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
348098f8:	e92d000f 	push	{r0, r1, r2, r3}
348098fc:	e92d4030 	push	{r4, r5, lr}
34809900:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809904:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809908:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
3480990c:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
34809910:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809914:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809918:	eb004ed6 	bl	3481d478 <vsprintf>
3480991c:	e1a05000 	mov	r5, r0
	va_end(args);

	serial_puts(printbuffer);
34809920:	e1a00004 	mov	r0, r4
34809924:	eb00153e 	bl	3480ee24 <serial_puts>
	return i;
}
34809928:	e1a00005 	mov	r0, r5
3480992c:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809930:	e8bd4030 	pop	{r4, r5, lr}
34809934:	e28dd010 	add	sp, sp, #16
34809938:	e12fff1e 	bx	lr

3480993c <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
3480993c:	e3500002 	cmp	r0, #2
	serial_puts(printbuffer);
	return i;
}

int fgetc(int file)
{
34809940:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES) {
34809944:	ca000004 	bgt	3480995c <fgetc+0x20>
	iomux_doenv(file, dev->name);
}
#else
static inline int console_getc(int file)
{
	return stdio_devices[file]->getc();
34809948:	e59f3014 	ldr	r3, [pc, #20]	; 34809964 <fgetc+0x28>
3480994c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34809950:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34809954:	e12fff33 	blx	r3
			 */
			 udelay(1);
#endif
		}
#else
		return console_getc(file);
34809958:	e8bd8008 	pop	{r3, pc}
#endif
	}

	return -1;
3480995c:	e3e00000 	mvn	r0, #0
}
34809960:	e8bd8008 	pop	{r3, pc}
34809964:	3482b524 	.word	0x3482b524

34809968 <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
34809968:	e3500002 	cmp	r0, #2

	return -1;
}

int ftstc(int file)
{
3480996c:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809970:	ca000004 	bgt	34809988 <ftstc+0x20>
	return stdio_devices[file]->getc();
}

static inline int console_tstc(int file)
{
	return stdio_devices[file]->tstc();
34809974:	e59f3014 	ldr	r3, [pc, #20]	; 34809990 <ftstc+0x28>
34809978:	e7933100 	ldr	r3, [r3, r0, lsl #2]
3480997c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34809980:	e12fff33 	blx	r3
}

int ftstc(int file)
{
	if (file < MAX_FILES)
		return console_tstc(file);
34809984:	e8bd8008 	pop	{r3, pc}

	return -1;
34809988:	e3e00000 	mvn	r0, #0
}
3480998c:	e8bd8008 	pop	{r3, pc}
34809990:	3482b524 	.word	0x3482b524

34809994 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
34809994:	e3500002 	cmp	r0, #2

	return -1;
}

void fputc(int file, const char c)
{
34809998:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
3480999c:	c8bd8008 	popgt	{r3, pc}
	return stdio_devices[file]->tstc();
}

static inline void console_putc(int file, const char c)
{
	stdio_devices[file]->putc(c);
348099a0:	e59f2010 	ldr	r2, [pc, #16]	; 348099b8 <fputc+0x24>
348099a4:	e7923100 	ldr	r3, [r2, r0, lsl #2]
348099a8:	e1a00001 	mov	r0, r1
348099ac:	e5933020 	ldr	r3, [r3, #32]
348099b0:	e12fff33 	blx	r3
348099b4:	e8bd8008 	pop	{r3, pc}
348099b8:	3482b524 	.word	0x3482b524

348099bc <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
348099bc:	e3500002 	cmp	r0, #2
	if (file < MAX_FILES)
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
348099c0:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
348099c4:	c8bd8008 	popgt	{r3, pc}
	stdio_devices[file]->putc(c);
}

static inline void console_puts(int file, const char *s)
{
	stdio_devices[file]->puts(s);
348099c8:	e59f2010 	ldr	r2, [pc, #16]	; 348099e0 <fputs+0x24>
348099cc:	e7923100 	ldr	r3, [r2, r0, lsl #2]
348099d0:	e1a00001 	mov	r0, r1
348099d4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
348099d8:	e12fff33 	blx	r3
348099dc:	e8bd8008 	pop	{r3, pc}
348099e0:	3482b524 	.word	0x3482b524

348099e4 <fprintf>:
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
348099e4:	e92d000e 	push	{r1, r2, r3}
348099e8:	e92d4070 	push	{r4, r5, r6, lr}
348099ec:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348099f0:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
348099f4:	e28d2e1a 	add	r2, sp, #416	; 0x1a0
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
348099f8:	e1a05000 	mov	r5, r0
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348099fc:	e59d119c 	ldr	r1, [sp, #412]	; 0x19c
34809a00:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809a04:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809a08:	eb004e9a 	bl	3481d478 <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34809a0c:	e1a01004 	mov	r1, r4
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809a10:	e1a06000 	mov	r6, r0
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34809a14:	e1a00005 	mov	r0, r5
34809a18:	ebffffe7 	bl	348099bc <fputs>
	return i;
}
34809a1c:	e1a00006 	mov	r0, r6
34809a20:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809a24:	e8bd4070 	pop	{r4, r5, r6, lr}
34809a28:	e28dd00c 	add	sp, sp, #12
34809a2c:	e12fff1e 	bx	lr

34809a30 <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34809a30:	e598000c 	ldr	r0, [r8, #12]
34809a34:	e3500000 	cmp	r0, #0
34809a38:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34809a3c:	e5983004 	ldr	r3, [r8, #4]
34809a40:	e3130002 	tst	r3, #2
34809a44:	0a000001 	beq	34809a50 <getc+0x20>
		/* Get from the standard input */
		return fgetc(stdin);
34809a48:	e3a00000 	mov	r0, #0
34809a4c:	eaffffba 	b	3480993c <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc();
34809a50:	ea0014e2 	b	3480ede0 <serial_getc>

34809a54 <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34809a54:	e598000c 	ldr	r0, [r8, #12]
34809a58:	e3500000 	cmp	r0, #0
34809a5c:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34809a60:	e5983004 	ldr	r3, [r8, #4]
34809a64:	e3130002 	tst	r3, #2
34809a68:	0a000001 	beq	34809a74 <tstc+0x20>
		/* Test the standard input */
		return ftstc(stdin);
34809a6c:	e3a00000 	mov	r0, #0
34809a70:	eaffffbc 	b	34809968 <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc();
34809a74:	ea0014de 	b	3480edf4 <serial_tstc>

34809a78 <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809a78:	e598200c 	ldr	r2, [r8, #12]
static inline void pre_console_puts(const char *s) {}
static inline void print_pre_console_buffer(void) {}
#endif

void putc(const char c)
{
34809a7c:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809a80:	e3520000 	cmp	r2, #0
34809a84:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
34809a88:	e5983004 	ldr	r3, [r8, #4]
34809a8c:	e3130002 	tst	r3, #2
34809a90:	0a000001 	beq	34809a9c <putc+0x24>
		/* Send to the standard output */
		fputc(stdout, c);
34809a94:	e3a00001 	mov	r0, #1
34809a98:	eaffffbd 	b	34809994 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc(c);
34809a9c:	ea0014d9 	b	3480ee08 <serial_putc>

34809aa0 <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809aa0:	e598200c 	ldr	r2, [r8, #12]
		serial_putc(c);
	}
}

void puts(const char *s)
{
34809aa4:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809aa8:	e3520000 	cmp	r2, #0
34809aac:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
34809ab0:	e5983004 	ldr	r3, [r8, #4]
34809ab4:	e3130002 	tst	r3, #2
34809ab8:	0a000001 	beq	34809ac4 <puts+0x24>
		/* Send to the standard output */
		fputs(stdout, s);
34809abc:	e3a00001 	mov	r0, #1
34809ac0:	eaffffbd 	b	348099bc <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts(s);
34809ac4:	ea0014d6 	b	3480ee24 <serial_puts>

34809ac8 <printf>:
	}
}

int printf(const char *fmt, ...)
{
34809ac8:	e92d000f 	push	{r0, r1, r2, r3}
34809acc:	e92d4030 	push	{r4, r5, lr}
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809ad0:	e598500c 	ldr	r5, [r8, #12]
		serial_puts(s);
	}
}

int printf(const char *fmt, ...)
{
34809ad4:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809ad8:	e3550000 	cmp	r5, #0
34809adc:	0a000008 	beq	34809b04 <printf+0x3c>
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809ae0:	e28d4004 	add	r4, sp, #4
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34809ae4:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809ae8:	e1a00004 	mov	r0, r4
34809aec:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34809af0:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809af4:	eb004e5f 	bl	3481d478 <vsprintf>
34809af8:	e1a05000 	mov	r5, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
34809afc:	e1a00004 	mov	r0, r4
34809b00:	ebffffe6 	bl	34809aa0 <puts>
	return i;
}
34809b04:	e1a00005 	mov	r0, r5
34809b08:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809b0c:	e8bd4030 	pop	{r4, r5, lr}
34809b10:	e28dd010 	add	sp, sp, #16
34809b14:	e12fff1e 	bx	lr

34809b18 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
34809b18:	e92d4030 	push	{r4, r5, lr}
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809b1c:	e598500c 	ldr	r5, [r8, #12]
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34809b20:	e24ddf61 	sub	sp, sp, #388	; 0x184
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809b24:	e3550000 	cmp	r5, #0
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34809b28:	e1a03000 	mov	r3, r0
34809b2c:	e1a02001 	mov	r2, r1
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809b30:	0a000006 	beq	34809b50 <vprintf+0x38>
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809b34:	e1a0000d 	mov	r0, sp
34809b38:	e1a01003 	mov	r1, r3
34809b3c:	eb004e4d 	bl	3481d478 <vsprintf>
34809b40:	e1a05000 	mov	r5, r0

	/* Print the string */
	puts(printbuffer);
34809b44:	e1a0000d 	mov	r0, sp
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809b48:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts(printbuffer);
34809b4c:	ebffffd3 	bl	34809aa0 <puts>
	return i;
}
34809b50:	e1a00005 	mov	r0, r5
34809b54:	e28ddf61 	add	sp, sp, #388	; 0x184
34809b58:	e8bd8030 	pop	{r4, r5, pc}

34809b5c <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
34809b5c:	e92d4038 	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled && gd->have_console) {
34809b60:	e59f503c 	ldr	r5, [pc, #60]	; 34809ba4 <ctrlc+0x48>
34809b64:	e5954000 	ldr	r4, [r5]
34809b68:	e3540000 	cmp	r4, #0
			default:
				break;
			}
		}
	}
	return 0;
34809b6c:	13a00000 	movne	r0, #0
/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled && gd->have_console) {
34809b70:	18bd8038 	popne	{r3, r4, r5, pc}
34809b74:	e598000c 	ldr	r0, [r8, #12]
34809b78:	e3500000 	cmp	r0, #0
34809b7c:	08bd8038 	popeq	{r3, r4, r5, pc}
		if (tstc()) {
34809b80:	ebffffb3 	bl	34809a54 <tstc>
34809b84:	e3500000 	cmp	r0, #0
34809b88:	08bd8038 	popeq	{r3, r4, r5, pc}
			switch (getc()) {
34809b8c:	ebffffa7 	bl	34809a30 <getc>
34809b90:	e3500003 	cmp	r0, #3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
34809b94:	03a00001 	moveq	r0, #1
34809b98:	05850004 	streq	r0, [r5, #4]
			default:
				break;
			}
		}
	}
	return 0;
34809b9c:	11a00004 	movne	r0, r4
}
34809ba0:	e8bd8038 	pop	{r3, r4, r5, pc}
34809ba4:	34829cd8 	.word	0x34829cd8

34809ba8 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
34809ba8:	e59f300c 	ldr	r3, [pc, #12]	; 34809bbc <disable_ctrlc+0x14>
34809bac:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
34809bb0:	e5830000 	str	r0, [r3]
	return prev;
}
34809bb4:	e1a00002 	mov	r0, r2
34809bb8:	e12fff1e 	bx	lr
34809bbc:	34829cd8 	.word	0x34829cd8

34809bc0 <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
34809bc0:	e59f3004 	ldr	r3, [pc, #4]	; 34809bcc <had_ctrlc+0xc>
34809bc4:	e5930004 	ldr	r0, [r3, #4]
34809bc8:	e12fff1e 	bx	lr
34809bcc:	34829cd8 	.word	0x34829cd8

34809bd0 <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
34809bd0:	e59f3008 	ldr	r3, [pc, #8]	; 34809be0 <clear_ctrlc+0x10>
34809bd4:	e3a02000 	mov	r2, #0
34809bd8:	e5832004 	str	r2, [r3, #4]
}
34809bdc:	e12fff1e 	bx	lr
34809be0:	34829cd8 	.word	0x34829cd8

34809be4 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
34809be4:	e92d000f 	push	{r0, r1, r2, r3}
}
34809be8:	e28dd010 	add	sp, sp, #16
34809bec:	e12fff1e 	bx	lr

34809bf0 <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
34809bf0:	e92d4010 	push	{r4, lr}
34809bf4:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
34809bf8:	e1a00001 	mov	r0, r1
34809bfc:	eb001492 	bl	3480ee4c <stdio_get_by_name>

	if (dev && (dev->flags & flags))
34809c00:	e3500000 	cmp	r0, #0
34809c04:	08bd8010 	popeq	{r4, pc}
34809c08:	e5903000 	ldr	r3, [r0]
34809c0c:	e0144003 	ands	r4, r4, r3
		return dev;

	return NULL;
34809c10:	01a00004 	moveq	r0, r4
}
34809c14:	e8bd8010 	pop	{r4, pc}

34809c18 <console_assign>:

int console_assign(int file, const char *devname)
{
34809c18:	e92d4010 	push	{r4, lr}
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
34809c1c:	e2504000 	subs	r4, r0, #0
	case stdin:
		flag = DEV_FLAGS_INPUT;
34809c20:	03a00001 	moveq	r0, #1
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
34809c24:	0a000003 	beq	34809c38 <console_assign+0x20>
34809c28:	ba000008 	blt	34809c50 <console_assign+0x38>
34809c2c:	e3540002 	cmp	r4, #2
34809c30:	ca000006 	bgt	34809c50 <console_assign+0x38>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
34809c34:	e3a00002 	mov	r0, #2
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
34809c38:	ebffffec 	bl	34809bf0 <search_device>

	if (dev)
34809c3c:	e2501000 	subs	r1, r0, #0
34809c40:	0a000002 	beq	34809c50 <console_assign+0x38>
		return console_setfile(file, dev);
34809c44:	e1a00004 	mov	r0, r4

	return -1;
}
34809c48:	e8bd4010 	pop	{r4, lr}
	/* Check for valid device name */

	dev = search_device(flag, devname);

	if (dev)
		return console_setfile(file, dev);
34809c4c:	eaffff00 	b	34809854 <console_setfile>

	return -1;
}
34809c50:	e3e00000 	mvn	r0, #0
34809c54:	e8bd8010 	pop	{r4, pc}

34809c58 <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
34809c58:	e3a02001 	mov	r2, #1
34809c5c:	e588200c 	str	r2, [r8, #12]
#endif

	print_pre_console_buffer();

	return 0;
}
34809c60:	e3a00000 	mov	r0, #0
34809c64:	e12fff1e 	bx	lr

34809c68 <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
34809c68:	e92d4010 	push	{r4, lr}
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	/* Print information */
	puts("In:    ");
34809c6c:	e59f008c 	ldr	r0, [pc, #140]	; 34809d00 <stdio_print_current_devices+0x98>
34809c70:	ebffff8a 	bl	34809aa0 <puts>
	if (stdio_devices[stdin] == NULL) {
34809c74:	e59f3088 	ldr	r3, [pc, #136]	; 34809d04 <stdio_print_current_devices+0x9c>
34809c78:	e5931000 	ldr	r1, [r3]
34809c7c:	e3510000 	cmp	r1, #0
34809c80:	1a000002 	bne	34809c90 <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
34809c84:	e59f007c 	ldr	r0, [pc, #124]	; 34809d08 <stdio_print_current_devices+0xa0>
34809c88:	ebffff84 	bl	34809aa0 <puts>
34809c8c:	ea000002 	b	34809c9c <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
34809c90:	e59f0074 	ldr	r0, [pc, #116]	; 34809d0c <stdio_print_current_devices+0xa4>
34809c94:	e2811008 	add	r1, r1, #8
34809c98:	ebffff8a 	bl	34809ac8 <printf>
	}

	puts("Out:   ");
34809c9c:	e59f006c 	ldr	r0, [pc, #108]	; 34809d10 <stdio_print_current_devices+0xa8>
34809ca0:	ebffff7e 	bl	34809aa0 <puts>
	if (stdio_devices[stdout] == NULL) {
34809ca4:	e59f3058 	ldr	r3, [pc, #88]	; 34809d04 <stdio_print_current_devices+0x9c>
34809ca8:	e5931004 	ldr	r1, [r3, #4]
34809cac:	e3510000 	cmp	r1, #0
34809cb0:	1a000002 	bne	34809cc0 <stdio_print_current_devices+0x58>
		puts("No output devices available!\n");
34809cb4:	e59f0058 	ldr	r0, [pc, #88]	; 34809d14 <stdio_print_current_devices+0xac>
34809cb8:	ebffff78 	bl	34809aa0 <puts>
34809cbc:	ea000002 	b	34809ccc <stdio_print_current_devices+0x64>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
34809cc0:	e59f0044 	ldr	r0, [pc, #68]	; 34809d0c <stdio_print_current_devices+0xa4>
34809cc4:	e2811008 	add	r1, r1, #8
34809cc8:	ebffff7e 	bl	34809ac8 <printf>
	}

	puts("Err:   ");
34809ccc:	e59f0044 	ldr	r0, [pc, #68]	; 34809d18 <stdio_print_current_devices+0xb0>
34809cd0:	ebffff72 	bl	34809aa0 <puts>
	if (stdio_devices[stderr] == NULL) {
34809cd4:	e59f3028 	ldr	r3, [pc, #40]	; 34809d04 <stdio_print_current_devices+0x9c>
34809cd8:	e5931008 	ldr	r1, [r3, #8]
34809cdc:	e3510000 	cmp	r1, #0
34809ce0:	1a000002 	bne	34809cf0 <stdio_print_current_devices+0x88>
		puts("No error devices available!\n");
34809ce4:	e59f0030 	ldr	r0, [pc, #48]	; 34809d1c <stdio_print_current_devices+0xb4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809ce8:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
34809cec:	eaffff6b 	b	34809aa0 <puts>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809cf0:	e59f0014 	ldr	r0, [pc, #20]	; 34809d0c <stdio_print_current_devices+0xa4>
34809cf4:	e2811008 	add	r1, r1, #8
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809cf8:	e8bd4010 	pop	{r4, lr}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809cfc:	eaffff71 	b	34809ac8 <printf>
34809d00:	34825fc7 	.word	0x34825fc7
34809d04:	3482b524 	.word	0x3482b524
34809d08:	34825fcf 	.word	0x34825fcf
34809d0c:	34825e78 	.word	0x34825e78
34809d10:	34825fec 	.word	0x34825fec
34809d14:	34825ff4 	.word	0x34825ff4
34809d18:	34826012 	.word	0x34826012
34809d1c:	3482601a 	.word	0x3482601a

34809d20 <console_init_r>:
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
34809d20:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809d24:	e59f1124 	ldr	r1, [pc, #292]	; 34809e50 <console_init_r+0x130>
}

#ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
34809d28:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
34809d2c:	e5821004 	str	r1, [r2, #4]
	gd->jt[XF_tstc] = serial_tstc;
34809d30:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809d34:	e59f1118 	ldr	r1, [pc, #280]	; 34809e54 <console_init_r+0x134>
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
34809d38:	e59f0118 	ldr	r0, [pc, #280]	; 34809e58 <console_init_r+0x138>
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
34809d3c:	e5821008 	str	r1, [r2, #8]
	gd->jt[XF_putc] = serial_putc;
34809d40:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809d44:	e59f1110 	ldr	r1, [pc, #272]	; 34809e5c <console_init_r+0x13c>
34809d48:	e582100c 	str	r1, [r2, #12]
	gd->jt[XF_puts] = serial_puts;
34809d4c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809d50:	e59f1108 	ldr	r1, [pc, #264]	; 34809e60 <console_init_r+0x140>
	gd->jt[XF_printf] = serial_printf;
34809d54:	e5983054 	ldr	r3, [r8, #84]	; 0x54

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
	gd->jt[XF_putc] = serial_putc;
	gd->jt[XF_puts] = serial_puts;
34809d58:	e5821010 	str	r1, [r2, #16]
	gd->jt[XF_printf] = serial_printf;
34809d5c:	e59f2100 	ldr	r2, [pc, #256]	; 34809e64 <console_init_r+0x144>
34809d60:	e5832014 	str	r2, [r3, #20]

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
34809d64:	ebfff869 	bl	34807f10 <getenv>
34809d68:	e1a04000 	mov	r4, r0
	stdoutname = getenv("stdout");
34809d6c:	e59f00f4 	ldr	r0, [pc, #244]	; 34809e68 <console_init_r+0x148>
34809d70:	ebfff866 	bl	34807f10 <getenv>
34809d74:	e1a06000 	mov	r6, r0
	stderrname = getenv("stderr");
34809d78:	e59f00ec 	ldr	r0, [pc, #236]	; 34809e6c <console_init_r+0x14c>
34809d7c:	ebfff863 	bl	34807f10 <getenv>

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809d80:	e1a01004 	mov	r1, r4

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");
34809d84:	e1a05000 	mov	r5, r0

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809d88:	e3a00001 	mov	r0, #1
34809d8c:	ebffff97 	bl	34809bf0 <search_device>
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809d90:	e1a01006 	mov	r1, r6
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809d94:	e1a04000 	mov	r4, r0
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809d98:	e3a00002 	mov	r0, #2
34809d9c:	ebffff93 	bl	34809bf0 <search_device>
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809da0:	e1a01005 	mov	r1, r5
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809da4:	e1a06000 	mov	r6, r0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809da8:	e3a00002 	mov	r0, #2
34809dac:	ebffff8f 	bl	34809bf0 <search_device>
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809db0:	e3540000 	cmp	r4, #0
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809db4:	e1a05000 	mov	r5, r0
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809db8:	1a000003 	bne	34809dcc <console_init_r+0xac>
		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
34809dbc:	e3a00001 	mov	r0, #1
34809dc0:	e59f10a8 	ldr	r1, [pc, #168]	; 34809e70 <console_init_r+0x150>
34809dc4:	ebffff89 	bl	34809bf0 <search_device>
34809dc8:	e1a04000 	mov	r4, r0
	}
	if (outputdev == NULL) {
34809dcc:	e3560000 	cmp	r6, #0
34809dd0:	1a000003 	bne	34809de4 <console_init_r+0xc4>
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809dd4:	e3a00002 	mov	r0, #2
34809dd8:	e59f1090 	ldr	r1, [pc, #144]	; 34809e70 <console_init_r+0x150>
34809ddc:	ebffff83 	bl	34809bf0 <search_device>
34809de0:	e1a06000 	mov	r6, r0
	}
	if (errdev == NULL) {
34809de4:	e3550000 	cmp	r5, #0
34809de8:	1a000003 	bne	34809dfc <console_init_r+0xdc>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809dec:	e3a00002 	mov	r0, #2
34809df0:	e59f1078 	ldr	r1, [pc, #120]	; 34809e70 <console_init_r+0x150>
34809df4:	ebffff7d 	bl	34809bf0 <search_device>
34809df8:	e1a05000 	mov	r5, r0
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
34809dfc:	e3560000 	cmp	r6, #0
34809e00:	0a000002 	beq	34809e10 <console_init_r+0xf0>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809e04:	e3a00001 	mov	r0, #1
34809e08:	e1a01006 	mov	r1, r6
34809e0c:	ebfffe90 	bl	34809854 <console_setfile>
	/* Initializes output console first */
	if (outputdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stdout, outputdev);
	}
	if (errdev != NULL) {
34809e10:	e3550000 	cmp	r5, #0
34809e14:	0a000002 	beq	34809e24 <console_init_r+0x104>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809e18:	e3a00002 	mov	r0, #2
34809e1c:	e1a01005 	mov	r1, r5
34809e20:	ebfffe8b 	bl	34809854 <console_setfile>
	}
	if (errdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stderr, errdev);
	}
	if (inputdev != NULL) {
34809e24:	e3540000 	cmp	r4, #0
34809e28:	0a000002 	beq	34809e38 <console_init_r+0x118>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809e2c:	e3a00000 	mov	r0, #0
34809e30:	e1a01004 	mov	r1, r4
34809e34:	ebfffe86 	bl	34809854 <console_setfile>

#ifdef CONFIG_CONSOLE_MUX
done:
#endif

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
34809e38:	e5982004 	ldr	r2, [r8, #4]
34809e3c:	e3822002 	orr	r2, r2, #2
34809e40:	e5882004 	str	r2, [r8, #4]

	stdio_print_current_devices();
34809e44:	ebffff87 	bl	34809c68 <stdio_print_current_devices>
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif
	return 0;
}
34809e48:	e3a00000 	mov	r0, #0
34809e4c:	e8bd8070 	pop	{r4, r5, r6, pc}
34809e50:	3480ede0 	.word	0x3480ede0
34809e54:	3480edf4 	.word	0x3480edf4
34809e58:	34825239 	.word	0x34825239
34809e5c:	3480ee08 	.word	0x3480ee08
34809e60:	3480ee24 	.word	0x3480ee24
34809e64:	348098f8 	.word	0x348098f8
34809e68:	3482523f 	.word	0x3482523f
34809e6c:	34825246 	.word	0x34825246
34809e70:	34826037 	.word	0x34826037

34809e74 <sbrk>:
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809e74:	e92d4038 	push	{r3, r4, r5, lr}
	ulong old = mem_malloc_brk;
34809e78:	e59f304c 	ldr	r3, [pc, #76]	; 34809ecc <sbrk+0x58>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809e7c:	e3500000 	cmp	r0, #0
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
34809e80:	e5935000 	ldr	r5, [r3]
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809e84:	e1a02000 	mov	r2, r0
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
34809e88:	e0804005 	add	r4, r0, r5

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809e8c:	aa000003 	bge	34809ea0 <sbrk+0x2c>
		memset((void *)new, 0, -increment);
34809e90:	e1a00004 	mov	r0, r4
34809e94:	e3a01000 	mov	r1, #0
34809e98:	e2622000 	rsb	r2, r2, #0
34809e9c:	eb0049dd 	bl	3481c618 <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809ea0:	e59f3024 	ldr	r3, [pc, #36]	; 34809ecc <sbrk+0x58>
34809ea4:	e5932004 	ldr	r2, [r3, #4]
34809ea8:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;
34809eac:	33e00000 	mvncc	r0, #0
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809eb0:	38bd8038 	popcc	{r3, r4, r5, pc}
34809eb4:	e5932008 	ldr	r2, [r3, #8]
34809eb8:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
34809ebc:	95834000 	strls	r4, [r3]

	return (void *)old;
34809ec0:	91a00005 	movls	r0, r5
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
		return (void *)MORECORE_FAILURE;
34809ec4:	83e00000 	mvnhi	r0, #0

	mem_malloc_brk = new;

	return (void *)old;
}
34809ec8:	e8bd8038 	pop	{r3, r4, r5, pc}
34809ecc:	34829ce0 	.word	0x34829ce0

34809ed0 <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
34809ed0:	e1a02001 	mov	r2, r1
	mem_malloc_start = start;
34809ed4:	e59f1010 	ldr	r1, [pc, #16]	; 34809eec <mem_malloc_init+0x1c>
	mem_malloc_end = start + size;
34809ed8:	e082c000 	add	ip, r2, r0
	return (void *)old;
}

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
34809edc:	e9811001 	stmib	r1, {r0, ip}
	mem_malloc_end = start + size;
	mem_malloc_brk = start;
34809ee0:	e5810000 	str	r0, [r1]

	memset((void *)mem_malloc_start, 0, size);
34809ee4:	e3a01000 	mov	r1, #0
34809ee8:	ea0049ca 	b	3481c618 <memset>
34809eec:	34829ce0 	.word	0x34829ce0

34809ef0 <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
34809ef0:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
34809ef4:	e59f40bc 	ldr	r4, [pc, #188]	; 34809fb8 <malloc_trim+0xc8>
34809ef8:	e5943008 	ldr	r3, [r4, #8]
34809efc:	e5936004 	ldr	r6, [r3, #4]
34809f00:	e3c66003 	bic	r6, r6, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
34809f04:	e0605006 	rsb	r5, r0, r6
34809f08:	e2855efe 	add	r5, r5, #4064	; 0xfe0
34809f0c:	e285500f 	add	r5, r5, #15
34809f10:	e3c55eff 	bic	r5, r5, #4080	; 0xff0
34809f14:	e3c5500f 	bic	r5, r5, #15
34809f18:	e2455a01 	sub	r5, r5, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
34809f1c:	e3550a01 	cmp	r5, #4096	; 0x1000
34809f20:	ba000020 	blt	34809fa8 <malloc_trim+0xb8>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
34809f24:	e3a00000 	mov	r0, #0
34809f28:	ebffffd1 	bl	34809e74 <sbrk>
    if (current_brk != (char*)(top) + top_size)
34809f2c:	e5943008 	ldr	r3, [r4, #8]
34809f30:	e0833006 	add	r3, r3, r6
34809f34:	e1500003 	cmp	r0, r3
34809f38:	1a00001a 	bne	34809fa8 <malloc_trim+0xb8>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
34809f3c:	e2650000 	rsb	r0, r5, #0
34809f40:	ebffffcb 	bl	34809e74 <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
34809f44:	e3700001 	cmn	r0, #1
34809f48:	1a00000c 	bne	34809f80 <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
34809f4c:	e2800001 	add	r0, r0, #1
34809f50:	ebffffc7 	bl	34809e74 <sbrk>
	top_size = current_brk - (char*)top;
34809f54:	e5943008 	ldr	r3, [r4, #8]
34809f58:	e0632000 	rsb	r2, r3, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
34809f5c:	e352000f 	cmp	r2, #15
34809f60:	da000012 	ble	34809fb0 <malloc_trim+0xc0>
	{
	  sbrked_mem = current_brk - sbrk_base;
34809f64:	e5941408 	ldr	r1, [r4, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
34809f68:	e3822001 	orr	r2, r2, #1
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
34809f6c:	e0610000 	rsb	r0, r1, r0
34809f70:	e59f1044 	ldr	r1, [pc, #68]	; 34809fbc <malloc_trim+0xcc>
	  set_head(top, top_size | PREV_INUSE);
34809f74:	e5832004 	str	r2, [r3, #4]
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
34809f78:	e581000c 	str	r0, [r1, #12]
34809f7c:	ea000009 	b	34809fa8 <malloc_trim+0xb8>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
34809f80:	e5943008 	ldr	r3, [r4, #8]
34809f84:	e0656006 	rsb	r6, r5, r6
34809f88:	e3866001 	orr	r6, r6, #1
34809f8c:	e5836004 	str	r6, [r3, #4]
	sbrked_mem -= extra;
34809f90:	e59f3024 	ldr	r3, [pc, #36]	; 34809fbc <malloc_trim+0xcc>
	check_chunk(top);
	return 1;
34809f94:	e3a00001 	mov	r0, #1

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
	sbrked_mem -= extra;
34809f98:	e593200c 	ldr	r2, [r3, #12]
34809f9c:	e0655002 	rsb	r5, r5, r2
34809fa0:	e583500c 	str	r5, [r3, #12]
	check_chunk(top);
	return 1;
34809fa4:	e8bd8070 	pop	{r4, r5, r6, pc}
  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
      return 0;     /* Apparently we don't own memory; must fail */
34809fa8:	e3a00000 	mov	r0, #0
34809fac:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
	}
	check_chunk(top);
	return 0;
34809fb0:	e3a00000 	mov	r0, #0
	check_chunk(top);
	return 1;
      }
    }
  }
}
34809fb4:	e8bd8070 	pop	{r4, r5, r6, pc}
34809fb8:	34828514 	.word	0x34828514
34809fbc:	34829ce0 	.word	0x34829ce0

34809fc0 <free>:
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
34809fc0:	e92d4070 	push	{r4, r5, r6, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
34809fc4:	e2504000 	subs	r4, r0, #0
34809fc8:	08bd8070 	popeq	{r4, r5, r6, pc}
    return;

  p = mem2chunk(mem);
  hd = p->size;
34809fcc:	e5140004 	ldr	r0, [r4, #-4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
34809fd0:	e59f51fc 	ldr	r5, [pc, #508]	; 3480a1d4 <free+0x214>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
34809fd4:	e3c02001 	bic	r2, r0, #1
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  p = mem2chunk(mem);
34809fd8:	e2443008 	sub	r3, r4, #8
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
34809fdc:	e0831002 	add	r1, r3, r2
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
34809fe0:	e5956008 	ldr	r6, [r5, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809fe4:	e591c004 	ldr	ip, [r1, #4]

  if (next == top)                            /* merge with top */
34809fe8:	e1510006 	cmp	r1, r6

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809fec:	e3ccc003 	bic	ip, ip, #3
34809ff0:	e2000001 	and	r0, r0, #1

  if (next == top)                            /* merge with top */
34809ff4:	1a000014 	bne	3480a04c <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809ff8:	e3500000 	cmp	r0, #0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
34809ffc:	e08c2002 	add	r2, ip, r2

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a000:	1a000006 	bne	3480a020 <free+0x60>
    {
      prevsz = p->prev_size;
3480a004:	e5141008 	ldr	r1, [r4, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
3480a008:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
      unlink(p, bck, fwd);
3480a00c:	e5930008 	ldr	r0, [r3, #8]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
3480a010:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
3480a014:	e593100c 	ldr	r1, [r3, #12]
3480a018:	e580100c 	str	r1, [r0, #12]
3480a01c:	e5810008 	str	r0, [r1, #8]
    }

    set_head(p, sz | PREV_INUSE);
3480a020:	e3821001 	orr	r1, r2, #1
3480a024:	e5831004 	str	r1, [r3, #4]
    top = p;
3480a028:	e59f11a4 	ldr	r1, [pc, #420]	; 3480a1d4 <free+0x214>
3480a02c:	e5813008 	str	r3, [r1, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
3480a030:	e591340c 	ldr	r3, [r1, #1036]	; 0x40c
3480a034:	e1520003 	cmp	r2, r3
3480a038:	38bd8070 	popcc	{r4, r5, r6, pc}
      malloc_trim(top_pad);
3480a03c:	e59f3194 	ldr	r3, [pc, #404]	; 3480a1d8 <free+0x218>
3480a040:	e5930034 	ldr	r0, [r3, #52]	; 0x34

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
3480a044:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
3480a048:	eaffffa8 	b	34809ef0 <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a04c:	e3500000 	cmp	r0, #0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
3480a050:	e581c004 	str	ip, [r1, #4]

  islr = 0;
3480a054:	13a00000 	movne	r0, #0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a058:	1a000009 	bne	3480a084 <free+0xc4>
  {
    prevsz = p->prev_size;
3480a05c:	e5144008 	ldr	r4, [r4, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
3480a060:	e2855008 	add	r5, r5, #8
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
3480a064:	e0643003 	rsb	r3, r4, r3
    sz += prevsz;
3480a068:	e0822004 	add	r2, r2, r4

    if (p->fd == last_remainder)             /* keep as last_remainder */
3480a06c:	e5934008 	ldr	r4, [r3, #8]
3480a070:	e1540005 	cmp	r4, r5
      islr = 1;
    else
      unlink(p, bck, fwd);
3480a074:	1593500c 	ldrne	r5, [r3, #12]
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
3480a078:	03a00001 	moveq	r0, #1
    else
      unlink(p, bck, fwd);
3480a07c:	1584500c 	strne	r5, [r4, #12]
3480a080:	15854008 	strne	r4, [r5, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
3480a084:	e081400c 	add	r4, r1, ip
3480a088:	e5944004 	ldr	r4, [r4, #4]
3480a08c:	e3140001 	tst	r4, #1
3480a090:	1a000010 	bne	3480a0d8 <free+0x118>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
3480a094:	e3500000 	cmp	r0, #0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
3480a098:	e082200c 	add	r2, r2, ip

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
3480a09c:	1a000009 	bne	3480a0c8 <free+0x108>
3480a0a0:	e591c008 	ldr	ip, [r1, #8]
3480a0a4:	e59f4130 	ldr	r4, [pc, #304]	; 3480a1dc <free+0x21c>
3480a0a8:	e15c0004 	cmp	ip, r4
3480a0ac:	1a000005 	bne	3480a0c8 <free+0x108>
    {
      islr = 1;
      link_last_remainder(p);
3480a0b0:	e58c300c 	str	r3, [ip, #12]
3480a0b4:	e58c3008 	str	r3, [ip, #8]
3480a0b8:	e583c00c 	str	ip, [r3, #12]
3480a0bc:	e583c008 	str	ip, [r3, #8]
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
3480a0c0:	e2800001 	add	r0, r0, #1
      link_last_remainder(p);
3480a0c4:	ea000003 	b	3480a0d8 <free+0x118>
    }
    else
      unlink(next, bck, fwd);
3480a0c8:	e591c00c 	ldr	ip, [r1, #12]
3480a0cc:	e5911008 	ldr	r1, [r1, #8]
3480a0d0:	e581c00c 	str	ip, [r1, #12]
3480a0d4:	e58c1008 	str	r1, [ip, #8]
  }


  set_head(p, sz | PREV_INUSE);
3480a0d8:	e3821001 	orr	r1, r2, #1
  set_foot(p, sz);
  if (!islr)
3480a0dc:	e3500000 	cmp	r0, #0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
3480a0e0:	e5831004 	str	r1, [r3, #4]
  set_foot(p, sz);
3480a0e4:	e7832002 	str	r2, [r3, r2]
  if (!islr)
3480a0e8:	18bd8070 	popne	{r4, r5, r6, pc}
    frontlink(p, sz, idx, bck, fwd);
3480a0ec:	e3520c02 	cmp	r2, #512	; 0x200
3480a0f0:	2a000009 	bcs	3480a11c <free+0x15c>
3480a0f4:	e59f10d8 	ldr	r1, [pc, #216]	; 3480a1d4 <free+0x214>
3480a0f8:	e1a021a2 	lsr	r2, r2, #3
3480a0fc:	e591c004 	ldr	ip, [r1, #4]
3480a100:	e1a00142 	asr	r0, r2, #2
3480a104:	e3a04001 	mov	r4, #1
3480a108:	e18c0014 	orr	r0, ip, r4, lsl r0
3480a10c:	e0812182 	add	r2, r1, r2, lsl #3
3480a110:	e5810004 	str	r0, [r1, #4]
3480a114:	e5921008 	ldr	r1, [r2, #8]
3480a118:	ea000028 	b	3480a1c0 <free+0x200>
3480a11c:	e1a004a2 	lsr	r0, r2, #9
3480a120:	e3500004 	cmp	r0, #4
3480a124:	91a00322 	lsrls	r0, r2, #6
3480a128:	92800038 	addls	r0, r0, #56	; 0x38
3480a12c:	9a00000f 	bls	3480a170 <free+0x1b0>
3480a130:	e3500014 	cmp	r0, #20
3480a134:	9280005b 	addls	r0, r0, #91	; 0x5b
3480a138:	9a00000c 	bls	3480a170 <free+0x1b0>
3480a13c:	e3500054 	cmp	r0, #84	; 0x54
3480a140:	91a00622 	lsrls	r0, r2, #12
3480a144:	9280006e 	addls	r0, r0, #110	; 0x6e
3480a148:	9a000008 	bls	3480a170 <free+0x1b0>
3480a14c:	e3500f55 	cmp	r0, #340	; 0x154
3480a150:	91a007a2 	lsrls	r0, r2, #15
3480a154:	92800077 	addls	r0, r0, #119	; 0x77
3480a158:	9a000004 	bls	3480a170 <free+0x1b0>
3480a15c:	e3001554 	movw	r1, #1364	; 0x554
3480a160:	e1500001 	cmp	r0, r1
3480a164:	91a00922 	lsrls	r0, r2, #18
3480a168:	9280007c 	addls	r0, r0, #124	; 0x7c
3480a16c:	83a0007e 	movhi	r0, #126	; 0x7e
3480a170:	e59fc05c 	ldr	ip, [pc, #92]	; 3480a1d4 <free+0x214>
3480a174:	e08c4180 	add	r4, ip, r0, lsl #3
3480a178:	e5941008 	ldr	r1, [r4, #8]
3480a17c:	e1510004 	cmp	r1, r4
3480a180:	1a000009 	bne	3480a1ac <free+0x1ec>
3480a184:	e59c2004 	ldr	r2, [ip, #4]
3480a188:	e1a00140 	asr	r0, r0, #2
3480a18c:	e3a04001 	mov	r4, #1
3480a190:	e1820014 	orr	r0, r2, r4, lsl r0
3480a194:	e1a02001 	mov	r2, r1
3480a198:	e58c0004 	str	r0, [ip, #4]
3480a19c:	ea000007 	b	3480a1c0 <free+0x200>
3480a1a0:	e5911008 	ldr	r1, [r1, #8]
3480a1a4:	e1510004 	cmp	r1, r4
3480a1a8:	0a000003 	beq	3480a1bc <free+0x1fc>
3480a1ac:	e5910004 	ldr	r0, [r1, #4]
3480a1b0:	e3c00003 	bic	r0, r0, #3
3480a1b4:	e1520000 	cmp	r2, r0
3480a1b8:	3afffff8 	bcc	3480a1a0 <free+0x1e0>
3480a1bc:	e591200c 	ldr	r2, [r1, #12]
3480a1c0:	e583200c 	str	r2, [r3, #12]
3480a1c4:	e5831008 	str	r1, [r3, #8]
3480a1c8:	e5823008 	str	r3, [r2, #8]
3480a1cc:	e581300c 	str	r3, [r1, #12]
3480a1d0:	e8bd8070 	pop	{r4, r5, r6, pc}
3480a1d4:	34828514 	.word	0x34828514
3480a1d8:	34829ce0 	.word	0x34829ce0
3480a1dc:	3482851c 	.word	0x3482851c

3480a1e0 <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
3480a1e0:	eaffff76 	b	34809fc0 <free>

3480a1e4 <malloc>:
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a1e4:	e59f35a0 	ldr	r3, [pc, #1440]	; 3480a78c <malloc+0x5a8>
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
3480a1e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a1ec:	e5932004 	ldr	r2, [r3, #4]
3480a1f0:	e3520000 	cmp	r2, #0
3480a1f4:	1a000003 	bne	3480a208 <malloc+0x24>
3480a1f8:	e5933008 	ldr	r3, [r3, #8]
3480a1fc:	e3530000 	cmp	r3, #0
    /* not initialized yet */
    return 0;
3480a200:	01a00003 	moveq	r0, r3
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a204:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
    /* not initialized yet */
    return 0;
  }

  if ((long)bytes < 0) return 0;
3480a208:	e3500000 	cmp	r0, #0
3480a20c:	b3a00000 	movlt	r0, #0
3480a210:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}

  nb = request2size(bytes);  /* padded request size; */
3480a214:	e280400b 	add	r4, r0, #11
3480a218:	e3540016 	cmp	r4, #22
3480a21c:	d3a04010 	movle	r4, #16
3480a220:	da000002 	ble	3480a230 <malloc+0x4c>
3480a224:	e3c44007 	bic	r4, r4, #7

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
3480a228:	e3540f7e 	cmp	r4, #504	; 0x1f8
3480a22c:	2a00000d 	bcs	3480a268 <malloc+0x84>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
3480a230:	e59f3558 	ldr	r3, [pc, #1368]	; 3480a790 <malloc+0x5ac>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
3480a234:	e1a011a4 	lsr	r1, r4, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
3480a238:	e0833181 	add	r3, r3, r1, lsl #3
    victim = last(q);
3480a23c:	e593000c 	ldr	r0, [r3, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
3480a240:	e1500003 	cmp	r0, r3
3480a244:	1a000004 	bne	3480a25c <malloc+0x78>
    {
      q = next_bin(q);
3480a248:	e2803008 	add	r3, r0, #8
      victim = last(q);
3480a24c:	e593000c 	ldr	r0, [r3, #12]
    }
    if (victim != q)
3480a250:	e1500003 	cmp	r0, r3
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
3480a254:	02811002 	addeq	r1, r1, #2
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
    }
    if (victim != q)
3480a258:	0a00002e 	beq	3480a318 <malloc+0x134>
    {
      victim_size = chunksize(victim);
3480a25c:	e5903004 	ldr	r3, [r0, #4]
3480a260:	e3c33003 	bic	r3, r3, #3
3480a264:	ea000022 	b	3480a2f4 <malloc+0x110>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
3480a268:	e1b014a4 	lsrs	r1, r4, #9
3480a26c:	01a011a4 	lsreq	r1, r4, #3
3480a270:	0a000013 	beq	3480a2c4 <malloc+0xe0>
3480a274:	e3510004 	cmp	r1, #4
3480a278:	91a01324 	lsrls	r1, r4, #6
3480a27c:	92811038 	addls	r1, r1, #56	; 0x38
3480a280:	9a00000f 	bls	3480a2c4 <malloc+0xe0>
3480a284:	e3510014 	cmp	r1, #20
3480a288:	9281105b 	addls	r1, r1, #91	; 0x5b
3480a28c:	9a00000c 	bls	3480a2c4 <malloc+0xe0>
3480a290:	e3510054 	cmp	r1, #84	; 0x54
3480a294:	91a01624 	lsrls	r1, r4, #12
3480a298:	9281106e 	addls	r1, r1, #110	; 0x6e
3480a29c:	9a000008 	bls	3480a2c4 <malloc+0xe0>
3480a2a0:	e3510f55 	cmp	r1, #340	; 0x154
3480a2a4:	91a017a4 	lsrls	r1, r4, #15
3480a2a8:	92811077 	addls	r1, r1, #119	; 0x77
3480a2ac:	9a000004 	bls	3480a2c4 <malloc+0xe0>
3480a2b0:	e3003554 	movw	r3, #1364	; 0x554
3480a2b4:	e1510003 	cmp	r1, r3
3480a2b8:	91a01924 	lsrls	r1, r4, #18
3480a2bc:	9281107c 	addls	r1, r1, #124	; 0x7c
3480a2c0:	83a0107e 	movhi	r1, #126	; 0x7e
    bin = bin_at(idx);
3480a2c4:	e59f24c4 	ldr	r2, [pc, #1220]	; 3480a790 <malloc+0x5ac>
3480a2c8:	e0822181 	add	r2, r2, r1, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
3480a2cc:	e592000c 	ldr	r0, [r2, #12]
3480a2d0:	ea00000d 	b	3480a30c <malloc+0x128>
    {
      victim_size = chunksize(victim);
3480a2d4:	e5903004 	ldr	r3, [r0, #4]
3480a2d8:	e3c33003 	bic	r3, r3, #3
      remainder_size = victim_size - nb;
3480a2dc:	e064c003 	rsb	ip, r4, r3

      if (remainder_size >= (long)MINSIZE) /* too big */
3480a2e0:	e35c000f 	cmp	ip, #15
      {
	--idx; /* adjust to rescan below after checking last remainder */
3480a2e4:	c2411001 	subgt	r1, r1, #1
	break;
3480a2e8:	ca000009 	bgt	3480a314 <malloc+0x130>
      }

      else if (remainder_size >= 0) /* exact fit */
3480a2ec:	e35c0000 	cmp	ip, #0
3480a2f0:	ba000004 	blt	3480a308 <malloc+0x124>
      {
	unlink(victim, bck, fwd);
3480a2f4:	e590200c 	ldr	r2, [r0, #12]
3480a2f8:	e5901008 	ldr	r1, [r0, #8]
3480a2fc:	e581200c 	str	r2, [r1, #12]
3480a300:	e5821008 	str	r1, [r2, #8]
3480a304:	ea00001c 	b	3480a37c <malloc+0x198>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
3480a308:	e590000c 	ldr	r0, [r0, #12]
3480a30c:	e1500002 	cmp	r0, r2
3480a310:	1affffef 	bne	3480a2d4 <malloc+0xf0>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
3480a314:	e2811001 	add	r1, r1, #1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
3480a318:	e59f5470 	ldr	r5, [pc, #1136]	; 3480a790 <malloc+0x5ac>
3480a31c:	e2852008 	add	r2, r5, #8
3480a320:	e5920008 	ldr	r0, [r2, #8]
3480a324:	e1500002 	cmp	r0, r2
3480a328:	0a000050 	beq	3480a470 <malloc+0x28c>
  {
    victim_size = chunksize(victim);
3480a32c:	e5903004 	ldr	r3, [r0, #4]
3480a330:	e3c33003 	bic	r3, r3, #3
    remainder_size = victim_size - nb;
3480a334:	e064c003 	rsb	ip, r4, r3

    if (remainder_size >= (long)MINSIZE) /* re-split */
3480a338:	e35c000f 	cmp	ip, #15
3480a33c:	da00000a 	ble	3480a36c <malloc+0x188>
    {
      remainder = chunk_at_offset(victim, nb);
3480a340:	e0803004 	add	r3, r0, r4
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
3480a344:	e582300c 	str	r3, [r2, #12]
3480a348:	e5823008 	str	r3, [r2, #8]
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
3480a34c:	e3844001 	orr	r4, r4, #1
      link_last_remainder(remainder);
3480a350:	e583200c 	str	r2, [r3, #12]
3480a354:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
3480a358:	e38c2001 	orr	r2, ip, #1
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
3480a35c:	e5804004 	str	r4, [r0, #4]
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
3480a360:	e783c00c 	str	ip, [r3, ip]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
3480a364:	e5832004 	str	r2, [r3, #4]
3480a368:	ea000103 	b	3480a77c <malloc+0x598>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
3480a36c:	e35c0000 	cmp	ip, #0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
3480a370:	e582200c 	str	r2, [r2, #12]
3480a374:	e5822008 	str	r2, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
3480a378:	ba000004 	blt	3480a390 <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
3480a37c:	e0803003 	add	r3, r0, r3
3480a380:	e5932004 	ldr	r2, [r3, #4]
3480a384:	e3822001 	orr	r2, r2, #1
3480a388:	e5832004 	str	r2, [r3, #4]
3480a38c:	ea0000fa 	b	3480a77c <malloc+0x598>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
3480a390:	e3530c02 	cmp	r3, #512	; 0x200
3480a394:	2a000008 	bcs	3480a3bc <malloc+0x1d8>
3480a398:	e1a031a3 	lsr	r3, r3, #3
3480a39c:	e5956004 	ldr	r6, [r5, #4]
3480a3a0:	e1a0c143 	asr	ip, r3, #2
3480a3a4:	e3a07001 	mov	r7, #1
3480a3a8:	e186cc17 	orr	ip, r6, r7, lsl ip
3480a3ac:	e0853183 	add	r3, r5, r3, lsl #3
3480a3b0:	e585c004 	str	ip, [r5, #4]
3480a3b4:	e593c008 	ldr	ip, [r3, #8]
3480a3b8:	ea000028 	b	3480a460 <malloc+0x27c>
3480a3bc:	e1a064a3 	lsr	r6, r3, #9
3480a3c0:	e3560004 	cmp	r6, #4
3480a3c4:	91a06323 	lsrls	r6, r3, #6
3480a3c8:	92866038 	addls	r6, r6, #56	; 0x38
3480a3cc:	9a00000f 	bls	3480a410 <malloc+0x22c>
3480a3d0:	e3560014 	cmp	r6, #20
3480a3d4:	9286605b 	addls	r6, r6, #91	; 0x5b
3480a3d8:	9a00000c 	bls	3480a410 <malloc+0x22c>
3480a3dc:	e3560054 	cmp	r6, #84	; 0x54
3480a3e0:	91a06623 	lsrls	r6, r3, #12
3480a3e4:	9286606e 	addls	r6, r6, #110	; 0x6e
3480a3e8:	9a000008 	bls	3480a410 <malloc+0x22c>
3480a3ec:	e3560f55 	cmp	r6, #340	; 0x154
3480a3f0:	91a067a3 	lsrls	r6, r3, #15
3480a3f4:	92866077 	addls	r6, r6, #119	; 0x77
3480a3f8:	9a000004 	bls	3480a410 <malloc+0x22c>
3480a3fc:	e300c554 	movw	ip, #1364	; 0x554
3480a400:	e156000c 	cmp	r6, ip
3480a404:	91a06923 	lsrls	r6, r3, #18
3480a408:	9286607c 	addls	r6, r6, #124	; 0x7c
3480a40c:	83a0607e 	movhi	r6, #126	; 0x7e
3480a410:	e0857186 	add	r7, r5, r6, lsl #3
3480a414:	e597c008 	ldr	ip, [r7, #8]
3480a418:	e15c0007 	cmp	ip, r7
3480a41c:	1a00000a 	bne	3480a44c <malloc+0x268>
3480a420:	e59f3368 	ldr	r3, [pc, #872]	; 3480a790 <malloc+0x5ac>
3480a424:	e1a06146 	asr	r6, r6, #2
3480a428:	e5937004 	ldr	r7, [r3, #4]
3480a42c:	e3a0a001 	mov	sl, #1
3480a430:	e187661a 	orr	r6, r7, sl, lsl r6
3480a434:	e5836004 	str	r6, [r3, #4]
3480a438:	e1a0300c 	mov	r3, ip
3480a43c:	ea000007 	b	3480a460 <malloc+0x27c>
3480a440:	e59cc008 	ldr	ip, [ip, #8]
3480a444:	e15c0007 	cmp	ip, r7
3480a448:	0a000003 	beq	3480a45c <malloc+0x278>
3480a44c:	e59c6004 	ldr	r6, [ip, #4]
3480a450:	e3c66003 	bic	r6, r6, #3
3480a454:	e1530006 	cmp	r3, r6
3480a458:	3afffff8 	bcc	3480a440 <malloc+0x25c>
3480a45c:	e59c300c 	ldr	r3, [ip, #12]
3480a460:	e580300c 	str	r3, [r0, #12]
3480a464:	e580c008 	str	ip, [r0, #8]
3480a468:	e5830008 	str	r0, [r3, #8]
3480a46c:	e58c000c 	str	r0, [ip, #12]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks_r)
3480a470:	e3a00001 	mov	r0, #1
3480a474:	e1a03141 	asr	r3, r1, #2
3480a478:	e1a03310 	lsl	r3, r0, r3
3480a47c:	e59f030c 	ldr	r0, [pc, #780]	; 3480a790 <malloc+0x5ac>
3480a480:	e5900004 	ldr	r0, [r0, #4]
3480a484:	e1530000 	cmp	r3, r0
3480a488:	8a00004a 	bhi	3480a5b8 <malloc+0x3d4>
  {

    /* Get to the first marked block */

    if ( (block & binblocks_r) == 0)
3480a48c:	e1130000 	tst	r3, r0
3480a490:	1a000004 	bne	3480a4a8 <malloc+0x2c4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
3480a494:	e3c11003 	bic	r1, r1, #3
      block <<= 1;
      while ((block & binblocks_r) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
3480a498:	e1a03083 	lsl	r3, r3, #1
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
3480a49c:	e1130000 	tst	r3, r0
      {
	idx += BINBLOCKWIDTH;
3480a4a0:	e2811004 	add	r1, r1, #4
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
3480a4a4:	0afffffb 	beq	3480a498 <malloc+0x2b4>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480a4a8:	e59fa2e0 	ldr	sl, [pc, #736]	; 3480a790 <malloc+0x5ac>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
3480a4ac:	e0859181 	add	r9, r5, r1, lsl #3
3480a4b0:	e1a07009 	mov	r7, r9
3480a4b4:	e1a06001 	mov	r6, r1
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a4b8:	e597000c 	ldr	r0, [r7, #12]
3480a4bc:	ea000020 	b	3480a544 <malloc+0x360>
	{
	  victim_size = chunksize(victim);
3480a4c0:	e590b004 	ldr	fp, [r0, #4]
3480a4c4:	e3cbb003 	bic	fp, fp, #3
	  remainder_size = victim_size - nb;
3480a4c8:	e064c00b 	rsb	ip, r4, fp

	  if (remainder_size >= (long)MINSIZE) /* split */
3480a4cc:	e35c000f 	cmp	ip, #15
3480a4d0:	da00000f 	ble	3480a514 <malloc+0x330>
	  {
	    remainder = chunk_at_offset(victim, nb);
3480a4d4:	e0803004 	add	r3, r0, r4
	    set_head(victim, nb | PREV_INUSE);
3480a4d8:	e3844001 	orr	r4, r4, #1
	    unlink(victim, bck, fwd);
3480a4dc:	e590100c 	ldr	r1, [r0, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
3480a4e0:	e5804004 	str	r4, [r0, #4]
	    unlink(victim, bck, fwd);
3480a4e4:	e5b04008 	ldr	r4, [r0, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
3480a4e8:	e783c00c 	str	ip, [r3, ip]

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
3480a4ec:	e584100c 	str	r1, [r4, #12]
3480a4f0:	e5814008 	str	r4, [r1, #8]
	    link_last_remainder(remainder);
3480a4f4:	e582300c 	str	r3, [r2, #12]
3480a4f8:	e5823008 	str	r3, [r2, #8]
3480a4fc:	e59f2290 	ldr	r2, [pc, #656]	; 3480a794 <malloc+0x5b0>
3480a500:	e583200c 	str	r2, [r3, #12]
3480a504:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
3480a508:	e38c2001 	orr	r2, ip, #1
3480a50c:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
3480a510:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	  }

	  else if (remainder_size >= 0)  /* take */
3480a514:	e35c0000 	cmp	ip, #0
3480a518:	ba000008 	blt	3480a540 <malloc+0x35c>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
3480a51c:	e080b00b 	add	fp, r0, fp
3480a520:	e59b3004 	ldr	r3, [fp, #4]
3480a524:	e3833001 	orr	r3, r3, #1
3480a528:	e58b3004 	str	r3, [fp, #4]
	    unlink(victim, bck, fwd);
3480a52c:	e590300c 	ldr	r3, [r0, #12]
3480a530:	e5b02008 	ldr	r2, [r0, #8]!
3480a534:	e582300c 	str	r3, [r2, #12]
3480a538:	e5832008 	str	r2, [r3, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
3480a53c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a540:	e590000c 	ldr	r0, [r0, #12]
3480a544:	e1500007 	cmp	r0, r7
3480a548:	1affffdc 	bne	3480a4c0 <malloc+0x2dc>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
3480a54c:	e2866001 	add	r6, r6, #1
3480a550:	e3160003 	tst	r6, #3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
3480a554:	12877008 	addne	r7, r7, #8
3480a558:	1affffd6 	bne	3480a4b8 <malloc+0x2d4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
3480a55c:	e3110003 	tst	r1, #3
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480a560:	059a1004 	ldreq	r1, [sl, #4]
3480a564:	01c11003 	biceq	r1, r1, r3
3480a568:	058a1004 	streq	r1, [sl, #4]
	  break;
3480a56c:	0a000004 	beq	3480a584 <malloc+0x3a0>
	}
	--startidx;
       q = prev_bin(q);
3480a570:	e1a00009 	mov	r0, r9
      } while (first(q) == q);
3480a574:	e4109008 	ldr	r9, [r0], #-8
3480a578:	e1590000 	cmp	r9, r0
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
	  break;
	}
	--startidx;
3480a57c:	02411001 	subeq	r1, r1, #1
3480a580:	0afffff5 	beq	3480a55c <malloc+0x378>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
3480a584:	e59a0004 	ldr	r0, [sl, #4]
3480a588:	e1a03083 	lsl	r3, r3, #1
3480a58c:	e1530000 	cmp	r3, r0
3480a590:	8a000008 	bhi	3480a5b8 <malloc+0x3d4>
3480a594:	e3530000 	cmp	r3, #0
3480a598:	0a000006 	beq	3480a5b8 <malloc+0x3d4>
3480a59c:	e1a01006 	mov	r1, r6
3480a5a0:	ea000001 	b	3480a5ac <malloc+0x3c8>
      {
	while ((block & binblocks_r) == 0)
	{
	  idx += BINBLOCKWIDTH;
3480a5a4:	e2811004 	add	r1, r1, #4
	  block <<= 1;
3480a5a8:	e1a03083 	lsl	r3, r3, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
      {
	while ((block & binblocks_r) == 0)
3480a5ac:	e1130000 	tst	r3, r0
3480a5b0:	1affffbd 	bne	3480a4ac <malloc+0x2c8>
3480a5b4:	eafffffa 	b	3480a5a4 <malloc+0x3c0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a5b8:	e59f21d0 	ldr	r2, [pc, #464]	; 3480a790 <malloc+0x5ac>
3480a5bc:	e5927008 	ldr	r7, [r2, #8]
3480a5c0:	e5979004 	ldr	r9, [r7, #4]
3480a5c4:	e3c99003 	bic	r9, r9, #3
3480a5c8:	e0643009 	rsb	r3, r4, r9
3480a5cc:	e353000f 	cmp	r3, #15
3480a5d0:	ca000061 	bgt	3480a75c <malloc+0x578>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a5d4:	e59f31b0 	ldr	r3, [pc, #432]	; 3480a78c <malloc+0x5a8>
3480a5d8:	e593a034 	ldr	sl, [r3, #52]	; 0x34

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
3480a5dc:	e5923408 	ldr	r3, [r2, #1032]	; 0x408
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a5e0:	e28aa010 	add	sl, sl, #16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
3480a5e4:	e3730001 	cmn	r3, #1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a5e8:	e08aa004 	add	sl, sl, r4
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
3480a5ec:	128aaeff 	addne	sl, sl, #4080	; 0xff0
3480a5f0:	128aa00f 	addne	sl, sl, #15
3480a5f4:	13caaeff 	bicne	sl, sl, #4080	; 0xff0
3480a5f8:	13caa00f 	bicne	sl, sl, #15

  brk = (char*)(MORECORE (sbrk_size));
3480a5fc:	e1a0000a 	mov	r0, sl
3480a600:	ebfffe1b 	bl	34809e74 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a604:	e3700001 	cmn	r0, #1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
3480a608:	e1a06000 	mov	r6, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a60c:	0a00004b 	beq	3480a740 <malloc+0x55c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
3480a610:	e0872009 	add	r2, r7, r9
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a614:	e1500002 	cmp	r0, r2
3480a618:	2a000001 	bcs	3480a624 <malloc+0x440>
      (brk < old_end && old_top != initial_top))
3480a61c:	e1570005 	cmp	r7, r5
3480a620:	1a000046 	bne	3480a740 <malloc+0x55c>
    return;

  sbrked_mem += sbrk_size;
3480a624:	e59f3160 	ldr	r3, [pc, #352]	; 3480a78c <malloc+0x5a8>

  if (brk == old_end) /* can just add bytes to current top */
3480a628:	e1560002 	cmp	r6, r2
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
3480a62c:	e593000c 	ldr	r0, [r3, #12]
3480a630:	e59f1158 	ldr	r1, [pc, #344]	; 3480a790 <malloc+0x5ac>
3480a634:	e08a0000 	add	r0, sl, r0
3480a638:	e583000c 	str	r0, [r3, #12]

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
3480a63c:	05913008 	ldreq	r3, [r1, #8]

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
3480a640:	008aa009 	addeq	sl, sl, r9
    set_head(top, top_size | PREV_INUSE);
3480a644:	038aa001 	orreq	sl, sl, #1
3480a648:	0583a004 	streq	sl, [r3, #4]
3480a64c:	0a000032 	beq	3480a71c <malloc+0x538>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
3480a650:	e591c408 	ldr	ip, [r1, #1032]	; 0x408
3480a654:	e37c0001 	cmn	ip, #1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
3480a658:	10860000 	addne	r0, r6, r0
3480a65c:	10622000 	rsbne	r2, r2, r0
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
3480a660:	05816408 	streq	r6, [r1, #1032]	; 0x408
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
3480a664:	1583200c 	strne	r2, [r3, #12]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
3480a668:	e2163007 	ands	r3, r6, #7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
3480a66c:	12633008 	rsbne	r3, r3, #8
      brk += correction;
3480a670:	10866003 	addne	r6, r6, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
3480a674:	e086a00a 	add	sl, r6, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));
3480a678:	e06a3003 	rsb	r3, sl, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
3480a67c:	e28aaeff 	add	sl, sl, #4080	; 0xff0
3480a680:	e28aa00f 	add	sl, sl, #15
3480a684:	e3caaeff 	bic	sl, sl, #4080	; 0xff0
3480a688:	e3caa00f 	bic	sl, sl, #15
3480a68c:	e083a00a 	add	sl, r3, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
3480a690:	e1a0000a 	mov	r0, sl
3480a694:	ebfffdf6 	bl	34809e74 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
3480a698:	e3700001 	cmn	r0, #1
3480a69c:	0a000027 	beq	3480a740 <malloc+0x55c>

    sbrked_mem += correction;
3480a6a0:	e59f30e4 	ldr	r3, [pc, #228]	; 3480a78c <malloc+0x5a8>

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
3480a6a4:	e0660000 	rsb	r0, r6, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
3480a6a8:	e593200c 	ldr	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
3480a6ac:	e1570005 	cmp	r7, r5

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
3480a6b0:	e08a2002 	add	r2, sl, r2
3480a6b4:	e583200c 	str	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
3480a6b8:	e08aa000 	add	sl, sl, r0
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
3480a6bc:	e59f30cc 	ldr	r3, [pc, #204]	; 3480a790 <malloc+0x5ac>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
3480a6c0:	e38aa001 	orr	sl, sl, #1
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
3480a6c4:	e5836008 	str	r6, [r3, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
3480a6c8:	e586a004 	str	sl, [r6, #4]

    if (old_top != initial_top)
3480a6cc:	0a000012 	beq	3480a71c <malloc+0x538>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
3480a6d0:	e359000f 	cmp	r9, #15
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
3480a6d4:	95933008 	ldrls	r3, [r3, #8]
3480a6d8:	93a02001 	movls	r2, #1
3480a6dc:	95832004 	strls	r2, [r3, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
3480a6e0:	9a000016 	bls	3480a740 <malloc+0x55c>
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
3480a6e4:	e5973004 	ldr	r3, [r7, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
3480a6e8:	e249900c 	sub	r9, r9, #12
3480a6ec:	e3c99007 	bic	r9, r9, #7
      set_head_size(old_top, old_top_size);
3480a6f0:	e2033001 	and	r3, r3, #1
3480a6f4:	e1893003 	orr	r3, r9, r3
3480a6f8:	e5873004 	str	r3, [r7, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
3480a6fc:	e3a02005 	mov	r2, #5
3480a700:	e0873009 	add	r3, r7, r9
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
3480a704:	e359000f 	cmp	r9, #15
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
3480a708:	e5832004 	str	r2, [r3, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
3480a70c:	e5832008 	str	r2, [r3, #8]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
3480a710:	9a000001 	bls	3480a71c <malloc+0x538>
	fREe(chunk2mem(old_top));
3480a714:	e2870008 	add	r0, r7, #8
3480a718:	ebfffe28 	bl	34809fc0 <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
3480a71c:	e59f2068 	ldr	r2, [pc, #104]	; 3480a78c <malloc+0x5a8>
3480a720:	e592300c 	ldr	r3, [r2, #12]
3480a724:	e5921038 	ldr	r1, [r2, #56]	; 0x38
3480a728:	e1530001 	cmp	r3, r1
    max_sbrked_mem = sbrked_mem;
3480a72c:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
3480a730:	e59f2054 	ldr	r2, [pc, #84]	; 3480a78c <malloc+0x5a8>
3480a734:	e592103c 	ldr	r1, [r2, #60]	; 0x3c
3480a738:	e1530001 	cmp	r3, r1
    max_total_mem = mmapped_mem + sbrked_mem;
3480a73c:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a740:	e59f3048 	ldr	r3, [pc, #72]	; 3480a790 <malloc+0x5ac>
3480a744:	e5933008 	ldr	r3, [r3, #8]
3480a748:	e5933004 	ldr	r3, [r3, #4]
3480a74c:	e3c33003 	bic	r3, r3, #3
3480a750:	e0643003 	rsb	r3, r4, r3
3480a754:	e353000f 	cmp	r3, #15
3480a758:	da000009 	ble	3480a784 <malloc+0x5a0>
      return 0; /* propagate failure */
  }

  victim = top;
3480a75c:	e59f202c 	ldr	r2, [pc, #44]	; 3480a790 <malloc+0x5ac>
  set_head(victim, nb | PREV_INUSE);
3480a760:	e3841001 	orr	r1, r4, #1
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
3480a764:	e5920008 	ldr	r0, [r2, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
3480a768:	e3833001 	orr	r3, r3, #1
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
3480a76c:	e0804004 	add	r4, r0, r4
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
3480a770:	e5801004 	str	r1, [r0, #4]
  top = chunk_at_offset(victim, nb);
3480a774:	e5824008 	str	r4, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
3480a778:	e5843004 	str	r3, [r4, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
3480a77c:	e2800008 	add	r0, r0, #8
3480a780:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
3480a784:	e3a00000 	mov	r0, #0
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);

}
3480a788:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480a78c:	34829ce0 	.word	0x34829ce0
3480a790:	34828514 	.word	0x34828514
3480a794:	3482851c 	.word	0x3482851c

3480a798 <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
3480a798:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
3480a79c:	e59f30d0 	ldr	r3, [pc, #208]	; 3480a874 <calloc+0xdc>
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
3480a7a0:	e1a06000 	mov	r6, r0
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
3480a7a4:	e5935008 	ldr	r5, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
3480a7a8:	e0000190 	mul	r0, r0, r1


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
3480a7ac:	e5957004 	ldr	r7, [r5, #4]
#endif
  Void_t* mem = mALLOc (sz);
3480a7b0:	ebfffe8b 	bl	3480a1e4 <malloc>

  if ((long)n < 0) return 0;
3480a7b4:	e3560000 	cmp	r6, #0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
3480a7b8:	e1a04000 	mov	r4, r0

  if ((long)n < 0) return 0;
3480a7bc:	b3a04000 	movlt	r4, #0
3480a7c0:	ba000029 	blt	3480a86c <calloc+0xd4>

  if (mem == 0)
3480a7c4:	e3540000 	cmp	r4, #0
3480a7c8:	0a000027 	beq	3480a86c <calloc+0xd4>

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
3480a7cc:	e5142004 	ldr	r2, [r4, #-4]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
3480a7d0:	e3c77003 	bic	r7, r7, #3

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
3480a7d4:	e3c22003 	bic	r2, r2, #3

  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480a7d8:	e2443008 	sub	r3, r4, #8
#endif

    csz = chunksize(p);

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
3480a7dc:	e1530005 	cmp	r3, r5
3480a7e0:	13a05000 	movne	r5, #0
3480a7e4:	03a05001 	moveq	r5, #1
3480a7e8:	e1520007 	cmp	r2, r7
3480a7ec:	93a05000 	movls	r5, #0
3480a7f0:	e3550000 	cmp	r5, #0
3480a7f4:	11a02007 	movne	r2, r7
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
3480a7f8:	e2422004 	sub	r2, r2, #4
3480a7fc:	e3520024 	cmp	r2, #36	; 0x24
3480a800:	8a000017 	bhi	3480a864 <calloc+0xcc>
3480a804:	e3520013 	cmp	r2, #19
3480a808:	e1a03004 	mov	r3, r4
3480a80c:	9a00000e 	bls	3480a84c <calloc+0xb4>
3480a810:	e3a01000 	mov	r1, #0
3480a814:	e1a00004 	mov	r0, r4
3480a818:	e4801004 	str	r1, [r0], #4
3480a81c:	e352001b 	cmp	r2, #27
3480a820:	e5841004 	str	r1, [r4, #4]
3480a824:	e2803004 	add	r3, r0, #4
3480a828:	9a000007 	bls	3480a84c <calloc+0xb4>
3480a82c:	e5801004 	str	r1, [r0, #4]
3480a830:	e2830004 	add	r0, r3, #4
3480a834:	e5831004 	str	r1, [r3, #4]
3480a838:	e3520024 	cmp	r2, #36	; 0x24
3480a83c:	e2803004 	add	r3, r0, #4
3480a840:	05801004 	streq	r1, [r0, #4]
3480a844:	05831004 	streq	r1, [r3, #4]
3480a848:	02833008 	addeq	r3, r3, #8
3480a84c:	e3a01000 	mov	r1, #0
3480a850:	e1a02003 	mov	r2, r3
3480a854:	e4821004 	str	r1, [r2], #4
3480a858:	e5831004 	str	r1, [r3, #4]
3480a85c:	e5821004 	str	r1, [r2, #4]
3480a860:	ea000001 	b	3480a86c <calloc+0xd4>
3480a864:	e3a01000 	mov	r1, #0
3480a868:	eb00476a 	bl	3481c618 <memset>
    return mem;
  }
}
3480a86c:	e1a00004 	mov	r0, r4
3480a870:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480a874:	34828514 	.word	0x34828514

3480a878 <memalign>:
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
3480a878:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480a87c:	e1a04000 	mov	r4, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
3480a880:	e2510000 	subs	r0, r1, #0
3480a884:	b3a00000 	movlt	r0, #0
3480a888:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480a88c:	e3540008 	cmp	r4, #8
3480a890:	8a000001 	bhi	3480a89c <memalign+0x24>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
3480a894:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return 0;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480a898:	eafffe51 	b	3480a1e4 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
3480a89c:	e280700b 	add	r7, r0, #11

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
3480a8a0:	e354000f 	cmp	r4, #15
3480a8a4:	93a04010 	movls	r4, #16

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
3480a8a8:	e3570016 	cmp	r7, #22
3480a8ac:	c3c77007 	bicgt	r7, r7, #7
3480a8b0:	d3a07010 	movle	r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
3480a8b4:	e2840010 	add	r0, r4, #16
3480a8b8:	e0800007 	add	r0, r0, r7
3480a8bc:	ebfffe48 	bl	3480a1e4 <malloc>

  if (m == 0) return 0; /* propagate failure */
3480a8c0:	e2506000 	subs	r6, r0, #0
3480a8c4:	0a00002d 	beq	3480a980 <memalign+0x108>

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480a8c8:	e1a01004 	mov	r1, r4
3480a8cc:	eb005538 	bl	3481fdb4 <__aeabi_uidivmod>
3480a8d0:	e3510000 	cmp	r1, #0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);
3480a8d4:	e2465008 	sub	r5, r6, #8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480a8d8:	0a000018 	beq	3480a940 <memalign+0xc8>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
3480a8dc:	e244a001 	sub	sl, r4, #1
3480a8e0:	e2643000 	rsb	r3, r4, #0
3480a8e4:	e086a00a 	add	sl, r6, sl
3480a8e8:	e00aa003 	and	sl, sl, r3
3480a8ec:	e24aa008 	sub	sl, sl, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480a8f0:	e065300a 	rsb	r3, r5, sl
3480a8f4:	e353000f 	cmp	r3, #15

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
3480a8f8:	e5163004 	ldr	r3, [r6, #-4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480a8fc:	908aa004 	addls	sl, sl, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
3480a900:	e065500a 	rsb	r5, r5, sl
    newsize = chunksize(p) - leadsize;
3480a904:	e3c33003 	bic	r3, r3, #3
3480a908:	e0653003 	rsb	r3, r5, r3
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
3480a90c:	e3832001 	orr	r2, r3, #1
3480a910:	e58a2004 	str	r2, [sl, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480a914:	e08a3003 	add	r3, sl, r3
3480a918:	e5932004 	ldr	r2, [r3, #4]
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
3480a91c:	e1a00006 	mov	r0, r6
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
3480a920:	e3822001 	orr	r2, r2, #1
3480a924:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
3480a928:	e5163004 	ldr	r3, [r6, #-4]
3480a92c:	e2033001 	and	r3, r3, #1
3480a930:	e1855003 	orr	r5, r5, r3
3480a934:	e5065004 	str	r5, [r6, #-4]
    fREe(chunk2mem(p));
3480a938:	ebfffda0 	bl	34809fc0 <free>
3480a93c:	e1a0500a 	mov	r5, sl
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
3480a940:	e5953004 	ldr	r3, [r5, #4]
3480a944:	e3c33003 	bic	r3, r3, #3
3480a948:	e0673003 	rsb	r3, r7, r3

  if (remainder_size >= (long)MINSIZE)
3480a94c:	e353000f 	cmp	r3, #15
3480a950:	da000008 	ble	3480a978 <memalign+0x100>
  {
    remainder = chunk_at_offset(p, nb);
3480a954:	e0850007 	add	r0, r5, r7
    set_head(remainder, remainder_size | PREV_INUSE);
3480a958:	e3833001 	orr	r3, r3, #1
3480a95c:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
3480a960:	e5953004 	ldr	r3, [r5, #4]
    fREe(chunk2mem(remainder));
3480a964:	e2800008 	add	r0, r0, #8

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_head_size(p, nb);
3480a968:	e2033001 	and	r3, r3, #1
3480a96c:	e1877003 	orr	r7, r7, r3
3480a970:	e5857004 	str	r7, [r5, #4]
    fREe(chunk2mem(remainder));
3480a974:	ebfffd91 	bl	34809fc0 <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
3480a978:	e2850008 	add	r0, r5, #8
3480a97c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */
3480a980:	e1a00006 	mov	r0, r6
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
3480a984:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3480a988 <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
3480a988:	e2801eff 	add	r1, r0, #4080	; 0xff0
3480a98c:	e281100f 	add	r1, r1, #15
3480a990:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
3480a994:	e3a00a01 	mov	r0, #4096	; 0x1000
3480a998:	e3c1100f 	bic	r1, r1, #15
3480a99c:	eaffffb5 	b	3480a878 <memalign>

3480a9a0 <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
3480a9a0:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
3480a9a4:	e3a00a01 	mov	r0, #4096	; 0x1000
3480a9a8:	eaffffb2 	b	3480a878 <memalign>

3480a9ac <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
3480a9ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480a9b0:	e1a05000 	mov	r5, r0

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480a9b4:	e2510000 	subs	r0, r1, #0
3480a9b8:	ba00010b 	blt	3480adec <realloc+0x440>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480a9bc:	e3550000 	cmp	r5, #0
3480a9c0:	1a000001 	bne	3480a9cc <realloc+0x20>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480a9c4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480a9c8:	eafffe05 	b	3480a1e4 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
3480a9cc:	e280600b 	add	r6, r0, #11

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480a9d0:	e5151004 	ldr	r1, [r5, #-4]


  nb = request2size(bytes);
3480a9d4:	e3560016 	cmp	r6, #22

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480a9d8:	e3c19003 	bic	r9, r1, #3


  nb = request2size(bytes);
3480a9dc:	c3c66007 	bicgt	r6, r6, #7
3480a9e0:	d3a06010 	movle	r6, #16
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a9e4:	e1590006 	cmp	r9, r6
  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
3480a9e8:	e245b008 	sub	fp, r5, #8
  newsize = oldsize = chunksize(oldp);
3480a9ec:	a1a0a009 	movge	sl, r9
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a9f0:	aa0000e2 	bge	3480ad80 <realloc+0x3d4>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480a9f4:	e59f23fc 	ldr	r2, [pc, #1020]	; 3480adf8 <realloc+0x44c>
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
3480a9f8:	e08b3009 	add	r3, fp, r9
    if (next == top || !inuse(next))
3480a9fc:	e592c008 	ldr	ip, [r2, #8]
3480aa00:	e153000c 	cmp	r3, ip
3480aa04:	0a000007 	beq	3480aa28 <realloc+0x7c>
3480aa08:	e5932004 	ldr	r2, [r3, #4]
3480aa0c:	e3c22001 	bic	r2, r2, #1
3480aa10:	e0832002 	add	r2, r3, r2
3480aa14:	e5922004 	ldr	r2, [r2, #4]
3480aa18:	e3120001 	tst	r2, #1
      }
    }
    else
    {
      next = 0;
      nextsize = 0;
3480aa1c:	13a02000 	movne	r2, #0
	goto split;
      }
    }
    else
    {
      next = 0;
3480aa20:	11a03002 	movne	r3, r2
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480aa24:	1a000019 	bne	3480aa90 <realloc+0xe4>
    {
      nextsize = chunksize(next);
3480aa28:	e5932004 	ldr	r2, [r3, #4]

      /* Forward into top only if a remainder */
      if (next == top)
3480aa2c:	e153000c 	cmp	r3, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
3480aa30:	e3c22003 	bic	r2, r2, #3
3480aa34:	e082a009 	add	sl, r2, r9

      /* Forward into top only if a remainder */
      if (next == top)
3480aa38:	1a00000e 	bne	3480aa78 <realloc+0xcc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
3480aa3c:	e2864010 	add	r4, r6, #16
3480aa40:	e15a0004 	cmp	sl, r4
3480aa44:	ba000011 	blt	3480aa90 <realloc+0xe4>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480aa48:	e59f33a8 	ldr	r3, [pc, #936]	; 3480adf8 <realloc+0x44c>
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480aa4c:	e066a00a 	rsb	sl, r6, sl
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480aa50:	e08bb006 	add	fp, fp, r6
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480aa54:	e38aa001 	orr	sl, sl, #1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480aa58:	e583b008 	str	fp, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480aa5c:	e58ba004 	str	sl, [fp, #4]
	  set_head_size(oldp, nb);
3480aa60:	e5153004 	ldr	r3, [r5, #-4]
	  return chunk2mem(oldp);
3480aa64:	e1a07005 	mov	r7, r5
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
3480aa68:	e2033001 	and	r3, r3, #1
3480aa6c:	e1866003 	orr	r6, r6, r3
3480aa70:	e5056004 	str	r6, [r5, #-4]
	  return chunk2mem(oldp);
3480aa74:	ea0000dd 	b	3480adf0 <realloc+0x444>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
3480aa78:	e15a0006 	cmp	sl, r6
      {
	unlink(next, bck, fwd);
3480aa7c:	a593200c 	ldrge	r2, [r3, #12]
3480aa80:	a5933008 	ldrge	r3, [r3, #8]
3480aa84:	a583200c 	strge	r2, [r3, #12]
3480aa88:	a5823008 	strge	r3, [r2, #8]
3480aa8c:	aa0000bb 	bge	3480ad80 <realloc+0x3d4>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
3480aa90:	e3110001 	tst	r1, #1
3480aa94:	1a00007e 	bne	3480ac94 <realloc+0x2e8>
    {
      prev = prev_chunk(oldp);
3480aa98:	e5154008 	ldr	r4, [r5, #-8]
      prevsize = chunksize(prev);

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480aa9c:	e3530000 	cmp	r3, #0

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
3480aaa0:	e064400b 	rsb	r4, r4, fp
      prevsize = chunksize(prev);
3480aaa4:	e5941004 	ldr	r1, [r4, #4]
3480aaa8:	e3c11003 	bic	r1, r1, #3

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480aaac:	0a000047 	beq	3480abd0 <realloc+0x224>
      {
	/* into top */
	if (next == top)
3480aab0:	e153000c 	cmp	r3, ip
3480aab4:	e081a009 	add	sl, r1, r9
3480aab8:	1a00003d 	bne	3480abb4 <realloc+0x208>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
3480aabc:	e08aa002 	add	sl, sl, r2
3480aac0:	e2863010 	add	r3, r6, #16
3480aac4:	e15a0003 	cmp	sl, r3
3480aac8:	ba000040 	blt	3480abd0 <realloc+0x224>
	  {
	    unlink(prev, bck, fwd);
3480aacc:	e1a07004 	mov	r7, r4
3480aad0:	e5b72008 	ldr	r2, [r7, #8]!
3480aad4:	e594300c 	ldr	r3, [r4, #12]
3480aad8:	e582300c 	str	r3, [r2, #12]
3480aadc:	e5832008 	str	r2, [r3, #8]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480aae0:	e2492004 	sub	r2, r9, #4
3480aae4:	e3520024 	cmp	r2, #36	; 0x24
3480aae8:	8a000023 	bhi	3480ab7c <realloc+0x1d0>
3480aaec:	e3520013 	cmp	r2, #19
3480aaf0:	e1a03007 	mov	r3, r7
3480aaf4:	9a000017 	bls	3480ab58 <realloc+0x1ac>
3480aaf8:	e1a01005 	mov	r1, r5
3480aafc:	e4913004 	ldr	r3, [r1], #4
3480ab00:	e352001b 	cmp	r2, #27
3480ab04:	e5843008 	str	r3, [r4, #8]
3480ab08:	e5953004 	ldr	r3, [r5, #4]
3480ab0c:	e2815004 	add	r5, r1, #4
3480ab10:	e584300c 	str	r3, [r4, #12]
3480ab14:	e2843010 	add	r3, r4, #16
3480ab18:	9a00000e 	bls	3480ab58 <realloc+0x1ac>
3480ab1c:	e5913004 	ldr	r3, [r1, #4]
3480ab20:	e3520024 	cmp	r2, #36	; 0x24
3480ab24:	e5843010 	str	r3, [r4, #16]
3480ab28:	e5953004 	ldr	r3, [r5, #4]
3480ab2c:	e2851004 	add	r1, r5, #4
3480ab30:	e5843014 	str	r3, [r4, #20]
3480ab34:	e2815004 	add	r5, r1, #4
3480ab38:	e2843018 	add	r3, r4, #24
3480ab3c:	1a000005 	bne	3480ab58 <realloc+0x1ac>
3480ab40:	e5913004 	ldr	r3, [r1, #4]
3480ab44:	e5843018 	str	r3, [r4, #24]
3480ab48:	e5953004 	ldr	r3, [r5, #4]
3480ab4c:	e2855008 	add	r5, r5, #8
3480ab50:	e584301c 	str	r3, [r4, #28]
3480ab54:	e2843020 	add	r3, r4, #32
3480ab58:	e1a01005 	mov	r1, r5
3480ab5c:	e4910004 	ldr	r0, [r1], #4
3480ab60:	e1a02003 	mov	r2, r3
3480ab64:	e4820004 	str	r0, [r2], #4
3480ab68:	e5950004 	ldr	r0, [r5, #4]
3480ab6c:	e5830004 	str	r0, [r3, #4]
3480ab70:	e5913004 	ldr	r3, [r1, #4]
3480ab74:	e5823004 	str	r3, [r2, #4]
3480ab78:	ea000002 	b	3480ab88 <realloc+0x1dc>
3480ab7c:	e1a00007 	mov	r0, r7
3480ab80:	e1a01005 	mov	r1, r5
3480ab84:	eb0046c7 	bl	3481c6a8 <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ab88:	e066a00a 	rsb	sl, r6, sl
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480ab8c:	e59f2264 	ldr	r2, [pc, #612]	; 3480adf8 <realloc+0x44c>
3480ab90:	e0843006 	add	r3, r4, r6
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ab94:	e38aa001 	orr	sl, sl, #1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480ab98:	e5823008 	str	r3, [r2, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ab9c:	e583a004 	str	sl, [r3, #4]
	    set_head_size(newp, nb);
3480aba0:	e5943004 	ldr	r3, [r4, #4]
3480aba4:	e2033001 	and	r3, r3, #1
3480aba8:	e1866003 	orr	r6, r6, r3
3480abac:	e5846004 	str	r6, [r4, #4]
	    return newmem;
3480abb0:	ea00008e 	b	3480adf0 <realloc+0x444>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
3480abb4:	e08aa002 	add	sl, sl, r2
3480abb8:	e15a0006 	cmp	sl, r6
	{
	  unlink(next, bck, fwd);
3480abbc:	a593200c 	ldrge	r2, [r3, #12]
3480abc0:	a5933008 	ldrge	r3, [r3, #8]
3480abc4:	a583200c 	strge	r2, [r3, #12]
3480abc8:	a5823008 	strge	r3, [r2, #8]
3480abcc:	aa000002 	bge	3480abdc <realloc+0x230>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
3480abd0:	e081a009 	add	sl, r1, r9
3480abd4:	e15a0006 	cmp	sl, r6
3480abd8:	ba00002d 	blt	3480ac94 <realloc+0x2e8>
      {
	unlink(prev, bck, fwd);
3480abdc:	e1a00004 	mov	r0, r4
3480abe0:	e5b02008 	ldr	r2, [r0, #8]!
3480abe4:	e594300c 	ldr	r3, [r4, #12]
3480abe8:	e582300c 	str	r3, [r2, #12]
3480abec:	e5832008 	str	r2, [r3, #8]
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480abf0:	e2492004 	sub	r2, r9, #4
3480abf4:	e3520024 	cmp	r2, #36	; 0x24
3480abf8:	8a000022 	bhi	3480ac88 <realloc+0x2dc>
3480abfc:	e3520013 	cmp	r2, #19
3480ac00:	9a000017 	bls	3480ac64 <realloc+0x2b8>
3480ac04:	e1a03005 	mov	r3, r5
3480ac08:	e4931004 	ldr	r1, [r3], #4
3480ac0c:	e352001b 	cmp	r2, #27
3480ac10:	e5841008 	str	r1, [r4, #8]
3480ac14:	e5951004 	ldr	r1, [r5, #4]
3480ac18:	e2840010 	add	r0, r4, #16
3480ac1c:	e584100c 	str	r1, [r4, #12]
3480ac20:	e2835004 	add	r5, r3, #4
3480ac24:	9a00000e 	bls	3480ac64 <realloc+0x2b8>
3480ac28:	e5933004 	ldr	r3, [r3, #4]
3480ac2c:	e3520024 	cmp	r2, #36	; 0x24
3480ac30:	e5843010 	str	r3, [r4, #16]
3480ac34:	e5951004 	ldr	r1, [r5, #4]
3480ac38:	e2853004 	add	r3, r5, #4
3480ac3c:	e5841014 	str	r1, [r4, #20]
3480ac40:	e2840018 	add	r0, r4, #24
3480ac44:	e2835004 	add	r5, r3, #4
3480ac48:	1a000005 	bne	3480ac64 <realloc+0x2b8>
3480ac4c:	e5933004 	ldr	r3, [r3, #4]
3480ac50:	e2840020 	add	r0, r4, #32
3480ac54:	e5843018 	str	r3, [r4, #24]
3480ac58:	e5953004 	ldr	r3, [r5, #4]
3480ac5c:	e2855008 	add	r5, r5, #8
3480ac60:	e584301c 	str	r3, [r4, #28]
3480ac64:	e1a02005 	mov	r2, r5
3480ac68:	e4921004 	ldr	r1, [r2], #4
3480ac6c:	e1a03000 	mov	r3, r0
3480ac70:	e4831004 	str	r1, [r3], #4
3480ac74:	e5951004 	ldr	r1, [r5, #4]
3480ac78:	e5801004 	str	r1, [r0, #4]
3480ac7c:	e5922004 	ldr	r2, [r2, #4]
3480ac80:	e5832004 	str	r2, [r3, #4]
3480ac84:	ea00003e 	b	3480ad84 <realloc+0x3d8>
3480ac88:	e1a01005 	mov	r1, r5
3480ac8c:	eb004685 	bl	3481c6a8 <memcpy>
3480ac90:	ea00003b 	b	3480ad84 <realloc+0x3d8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
3480ac94:	ebfffd52 	bl	3480a1e4 <malloc>

    if (newmem == 0)  /* propagate failure */
3480ac98:	e2507000 	subs	r7, r0, #0
3480ac9c:	0a000053 	beq	3480adf0 <realloc+0x444>
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480aca0:	e5153004 	ldr	r3, [r5, #-4]
3480aca4:	e2472008 	sub	r2, r7, #8
3480aca8:	e3c33001 	bic	r3, r3, #1
3480acac:	e08b3003 	add	r3, fp, r3
3480acb0:	e1520003 	cmp	r2, r3
    {
      newsize += chunksize(newp);
3480acb4:	0517a004 	ldreq	sl, [r7, #-4]
3480acb8:	03caa003 	biceq	sl, sl, #3
3480acbc:	008aa009 	addeq	sl, sl, r9
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480acc0:	0a00002e 	beq	3480ad80 <realloc+0x3d4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480acc4:	e2492004 	sub	r2, r9, #4
3480acc8:	e3520024 	cmp	r2, #36	; 0x24
3480accc:	8a000026 	bhi	3480ad6c <realloc+0x3c0>
3480acd0:	e3520013 	cmp	r2, #19
3480acd4:	e1a01005 	mov	r1, r5
3480acd8:	e1a03007 	mov	r3, r7
3480acdc:	9a000019 	bls	3480ad48 <realloc+0x39c>
3480ace0:	e1a0c005 	mov	ip, r5
3480ace4:	e49c3004 	ldr	r3, [ip], #4
3480ace8:	e1a00007 	mov	r0, r7
3480acec:	e4803004 	str	r3, [r0], #4
3480acf0:	e5953004 	ldr	r3, [r5, #4]
3480acf4:	e352001b 	cmp	r2, #27
3480acf8:	e5873004 	str	r3, [r7, #4]
3480acfc:	e28c1004 	add	r1, ip, #4
3480ad00:	e2803004 	add	r3, r0, #4
3480ad04:	9a00000f 	bls	3480ad48 <realloc+0x39c>
3480ad08:	e59cc004 	ldr	ip, [ip, #4]
3480ad0c:	e3520024 	cmp	r2, #36	; 0x24
3480ad10:	e580c004 	str	ip, [r0, #4]
3480ad14:	e281c004 	add	ip, r1, #4
3480ad18:	e5911004 	ldr	r1, [r1, #4]
3480ad1c:	e2830004 	add	r0, r3, #4
3480ad20:	e5831004 	str	r1, [r3, #4]
3480ad24:	e2803004 	add	r3, r0, #4
3480ad28:	e28c1004 	add	r1, ip, #4
3480ad2c:	1a000005 	bne	3480ad48 <realloc+0x39c>
3480ad30:	e59c2004 	ldr	r2, [ip, #4]
3480ad34:	e5802004 	str	r2, [r0, #4]
3480ad38:	e5912004 	ldr	r2, [r1, #4]
3480ad3c:	e2811008 	add	r1, r1, #8
3480ad40:	e5832004 	str	r2, [r3, #4]
3480ad44:	e2833008 	add	r3, r3, #8
3480ad48:	e1a00001 	mov	r0, r1
3480ad4c:	e490c004 	ldr	ip, [r0], #4
3480ad50:	e1a02003 	mov	r2, r3
3480ad54:	e482c004 	str	ip, [r2], #4
3480ad58:	e5911004 	ldr	r1, [r1, #4]
3480ad5c:	e5831004 	str	r1, [r3, #4]
3480ad60:	e5903004 	ldr	r3, [r0, #4]
3480ad64:	e5823004 	str	r3, [r2, #4]
3480ad68:	ea000001 	b	3480ad74 <realloc+0x3c8>
3480ad6c:	e1a01005 	mov	r1, r5
3480ad70:	eb00464c 	bl	3481c6a8 <memcpy>
    fREe(oldmem);
3480ad74:	e1a00005 	mov	r0, r5
3480ad78:	ebfffc90 	bl	34809fc0 <free>
    return newmem;
3480ad7c:	ea00001b 	b	3480adf0 <realloc+0x444>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480ad80:	e1a0400b 	mov	r4, fp
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
3480ad84:	e066300a 	rsb	r3, r6, sl
3480ad88:	e353000f 	cmp	r3, #15
3480ad8c:	e5942004 	ldr	r2, [r4, #4]
3480ad90:	9a00000c 	bls	3480adc8 <realloc+0x41c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ad94:	e2022001 	and	r2, r2, #1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
3480ad98:	e0840006 	add	r0, r4, r6
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ad9c:	e1866002 	orr	r6, r6, r2
    set_head(remainder, remainder_size | PREV_INUSE);
3480ada0:	e3832001 	orr	r2, r3, #1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ada4:	e5846004 	str	r6, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480ada8:	e0803003 	add	r3, r0, r3
  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
3480adac:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
3480adb0:	e5932004 	ldr	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480adb4:	e2800008 	add	r0, r0, #8
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480adb8:	e3822001 	orr	r2, r2, #1
3480adbc:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480adc0:	ebfffc7e 	bl	34809fc0 <free>
3480adc4:	ea000006 	b	3480ade4 <realloc+0x438>
  }
  else
  {
    set_head_size(newp, newsize);
3480adc8:	e2022001 	and	r2, r2, #1
3480adcc:	e18a2002 	orr	r2, sl, r2
3480add0:	e5842004 	str	r2, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480add4:	e084a00a 	add	sl, r4, sl
3480add8:	e59a3004 	ldr	r3, [sl, #4]
3480addc:	e3833001 	orr	r3, r3, #1
3480ade0:	e58a3004 	str	r3, [sl, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
3480ade4:	e2847008 	add	r7, r4, #8
3480ade8:	ea000000 	b	3480adf0 <realloc+0x444>

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480adec:	e3a07000 	mov	r7, #0
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480adf0:	e1a00007 	mov	r0, r7
3480adf4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480adf8:	34828514 	.word	0x34828514

3480adfc <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
3480adfc:	e3500000 	cmp	r0, #0
3480ae00:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
3480ae04:	e5103004 	ldr	r3, [r0, #-4]
  mchunkptr p;
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480ae08:	e2401008 	sub	r1, r0, #8
    if(!chunk_is_mmapped(p))
3480ae0c:	e3130002 	tst	r3, #2
3480ae10:	1a000006 	bne	3480ae30 <malloc_usable_size+0x34>
    {
      if (!inuse(p)) return 0;
3480ae14:	e3c32001 	bic	r2, r3, #1
3480ae18:	e0812002 	add	r2, r1, r2
3480ae1c:	e5920004 	ldr	r0, [r2, #4]
3480ae20:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
3480ae24:	13c30003 	bicne	r0, r3, #3
3480ae28:	12400004 	subne	r0, r0, #4
3480ae2c:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
3480ae30:	e3c30003 	bic	r0, r3, #3
3480ae34:	e2400008 	sub	r0, r0, #8
  }
}
3480ae38:	e12fff1e 	bx	lr

3480ae3c <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
3480ae3c:	e2800004 	add	r0, r0, #4
3480ae40:	e3500003 	cmp	r0, #3
3480ae44:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480ae48:	ea000012 	b	3480ae98 <mallopt+0x5c>
3480ae4c:	3480ae80 	.word	0x3480ae80
3480ae50:	3480ae74 	.word	0x3480ae74
3480ae54:	3480ae68 	.word	0x3480ae68
3480ae58:	3480ae5c 	.word	0x3480ae5c
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
3480ae5c:	e59f3044 	ldr	r3, [pc, #68]	; 3480aea8 <mallopt+0x6c>
3480ae60:	e583140c 	str	r1, [r3, #1036]	; 0x40c
3480ae64:	ea000009 	b	3480ae90 <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
3480ae68:	e59f303c 	ldr	r3, [pc, #60]	; 3480aeac <mallopt+0x70>
3480ae6c:	e5831034 	str	r1, [r3, #52]	; 0x34
3480ae70:	ea000006 	b	3480ae90 <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
3480ae74:	e59f302c 	ldr	r3, [pc, #44]	; 3480aea8 <mallopt+0x6c>
3480ae78:	e5831410 	str	r1, [r3, #1040]	; 0x410
3480ae7c:	ea000003 	b	3480ae90 <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480ae80:	e3510000 	cmp	r1, #0
3480ae84:	1a000005 	bne	3480aea0 <mallopt+0x64>
3480ae88:	e59f301c 	ldr	r3, [pc, #28]	; 3480aeac <mallopt+0x70>
3480ae8c:	e5831040 	str	r1, [r3, #64]	; 0x40
3480ae90:	e3a00001 	mov	r0, #1
3480ae94:	e12fff1e 	bx	lr
#endif

    default:
      return 0;
3480ae98:	e3a00000 	mov	r0, #0
3480ae9c:	e12fff1e 	bx	lr
      mmap_threshold = value; return 1;
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480aea0:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
3480aea4:	e12fff1e 	bx	lr
3480aea8:	34828514 	.word	0x34828514
3480aeac:	34829ce0 	.word	0x34829ce0

3480aeb0 <env_get_char_spec>:
	.apply = env_check_apply,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
3480aeb0:	e5983010 	ldr	r3, [r8, #16]
}
3480aeb4:	e7d00003 	ldrb	r0, [r0, r3]
3480aeb8:	e12fff1e 	bx	lr

3480aebc <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
3480aebc:	e5982014 	ldr	r2, [r8, #20]
3480aec0:	e1a03008 	mov	r3, r8
3480aec4:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
3480aec8:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
3480aecc:	059f3008 	ldreq	r3, [pc, #8]	; 3480aedc <env_get_addr+0x20>
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
		return (uchar *)(gd->env_addr + index);
3480aed0:	10800003 	addne	r0, r0, r3
	else
		return &default_environment[index];
3480aed4:	00830000 	addeq	r0, r3, r0
}
3480aed8:	e12fff1e 	bx	lr
3480aedc:	348202e0 	.word	0x348202e0

3480aee0 <env_get_char_memory>:
	else
		return default_environment[index];
}

uchar env_get_char_memory(int index)
{
3480aee0:	e92d4008 	push	{r3, lr}
	return *env_get_addr(index);
3480aee4:	ebfffff4 	bl	3480aebc <env_get_addr>
}
3480aee8:	e5d00000 	ldrb	r0, [r0]
3480aeec:	e8bd8008 	pop	{r3, pc}

3480aef0 <env_get_char>:

uchar env_get_char(int index)
{
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
3480aef0:	e5981004 	ldr	r1, [r8, #4]
3480aef4:	e3110001 	tst	r1, #1
3480aef8:	0a000000 	beq	3480af00 <env_get_char+0x10>
		return env_get_char_memory(index);
3480aefc:	eafffff7 	b	3480aee0 <env_get_char_memory>
	__attribute__((weak, alias("__env_get_char_spec")));

static uchar env_get_char_init(int index)
{
	/* if crc was bad, use the default environment */
	if (gd->env_valid)
3480af00:	e5983014 	ldr	r3, [r8, #20]
3480af04:	e3530000 	cmp	r3, #0
3480af08:	0a000000 	beq	3480af10 <env_get_char+0x20>
		return env_get_char_spec(index);
3480af0c:	eaffffe7 	b	3480aeb0 <env_get_char_spec>
	else
		return default_environment[index];
3480af10:	e59f3008 	ldr	r3, [pc, #8]	; 3480af20 <env_get_char+0x30>
3480af14:	e0832000 	add	r2, r3, r0
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
		return env_get_char_memory(index);
	else
		return env_get_char_init(index);
}
3480af18:	e5d206f9 	ldrb	r0, [r2, #1785]	; 0x6f9
3480af1c:	e12fff1e 	bx	lr
3480af20:	348202e0 	.word	0x348202e0

3480af24 <set_default_env>:
	else
		return &default_environment[index];
}

void set_default_env(const char *s)
{
3480af24:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
3480af28:	e2504000 	subs	r4, r0, #0
3480af2c:	0a00000a 	beq	3480af5c <set_default_env+0x38>
		if (*s == '!') {
3480af30:	e5d43000 	ldrb	r3, [r4]
3480af34:	e3530021 	cmp	r3, #33	; 0x21
3480af38:	1a000004 	bne	3480af50 <set_default_env+0x2c>
			printf("*** Warning - %s, "
3480af3c:	e2841001 	add	r1, r4, #1
3480af40:	e59f0078 	ldr	r0, [pc, #120]	; 3480afc0 <set_default_env+0x9c>
3480af44:	ebfffadf 	bl	34809ac8 <printf>
{
	/*
	 * By default, do not apply changes as they will eventually
	 * be applied by someone else
	 */
	int do_apply = 0;
3480af48:	e3a04000 	mov	r4, #0
3480af4c:	ea000004 	b	3480af64 <set_default_env+0x40>
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
			puts(s);
3480af50:	ebfffad2 	bl	34809aa0 <puts>
			 * by the user, as opposed to being a recovery
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
3480af54:	e3a04001 	mov	r4, #1
3480af58:	ea000001 	b	3480af64 <set_default_env+0x40>
			puts(s);
		}
	} else {
		puts("Using default environment\n\n");
3480af5c:	e59f0060 	ldr	r0, [pc, #96]	; 3480afc4 <set_default_env+0xa0>
3480af60:	ebffface 	bl	34809aa0 <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
3480af64:	e3a03000 	mov	r3, #0
3480af68:	e59f0058 	ldr	r0, [pc, #88]	; 3480afc8 <set_default_env+0xa4>
3480af6c:	e59f1058 	ldr	r1, [pc, #88]	; 3480afcc <set_default_env+0xa8>
3480af70:	e30026f9 	movw	r2, #1785	; 0x6f9
3480af74:	e58d3000 	str	r3, [sp]
3480af78:	e58d3004 	str	r3, [sp, #4]
3480af7c:	e58d3008 	str	r3, [sp, #8]
3480af80:	e58d400c 	str	r4, [sp, #12]
3480af84:	eb004208 	bl	3481b7ac <himport_r>
3480af88:	e3500000 	cmp	r0, #0
3480af8c:	1a000007 	bne	3480afb0 <set_default_env+0x8c>
			sizeof(default_environment), '\0', 0,
			0, NULL, do_apply) == 0)
		error("Environment import failed: errno = %d\n", errno);
3480af90:	e59f3038 	ldr	r3, [pc, #56]	; 3480afd0 <set_default_env+0xac>
3480af94:	e59f0038 	ldr	r0, [pc, #56]	; 3480afd4 <set_default_env+0xb0>
3480af98:	e58d3000 	str	r3, [sp]
3480af9c:	e59f3034 	ldr	r3, [pc, #52]	; 3480afd8 <set_default_env+0xb4>
3480afa0:	e59f2034 	ldr	r2, [pc, #52]	; 3480afdc <set_default_env+0xb8>
3480afa4:	e5931000 	ldr	r1, [r3]
3480afa8:	e3a030d8 	mov	r3, #216	; 0xd8
3480afac:	ebfffac5 	bl	34809ac8 <printf>

	gd->flags |= GD_FLG_ENV_READY;
3480afb0:	e5982004 	ldr	r2, [r8, #4]
3480afb4:	e3822080 	orr	r2, r2, #128	; 0x80
3480afb8:	e5882004 	str	r2, [r8, #4]
}
3480afbc:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
3480afc0:	3482603e 	.word	0x3482603e
3480afc4:	3482606c 	.word	0x3482606c
3480afc8:	34828928 	.word	0x34828928
3480afcc:	348202e0 	.word	0x348202e0
3480afd0:	348210d4 	.word	0x348210d4
3480afd4:	34825157 	.word	0x34825157
3480afd8:	3482bba0 	.word	0x3482bba0
3480afdc:	34826088 	.word	0x34826088

3480afe0 <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
3480afe0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
3480afe4:	e3a03001 	mov	r3, #1
3480afe8:	e58d3000 	str	r3, [sp]
3480afec:	e98d000b 	stmib	sp, {r0, r1, r3}
3480aff0:	e59f1014 	ldr	r1, [pc, #20]	; 3480b00c <set_default_vars+0x2c>
3480aff4:	e30026f9 	movw	r2, #1785	; 0x6f9
3480aff8:	e3a03000 	mov	r3, #0
3480affc:	e59f000c 	ldr	r0, [pc, #12]	; 3480b010 <set_default_vars+0x30>
3480b000:	eb0041e9 	bl	3481b7ac <himport_r>
				sizeof(default_environment), '\0', H_NOCLEAR,
				nvars, vars, 1 /* do_apply */);
}
3480b004:	e28dd014 	add	sp, sp, #20
3480b008:	e8bd8000 	pop	{pc}
3480b00c:	348202e0 	.word	0x348202e0
3480b010:	34828928 	.word	0x34828928

3480b014 <env_import>:
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480b014:	e92d4010 	push	{r4, lr}
	env_t *ep = (env_t *)buf;

	if (check) {
3480b018:	e3510000 	cmp	r1, #0
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480b01c:	e24dd018 	sub	sp, sp, #24
3480b020:	e1a04000 	mov	r4, r0
	env_t *ep = (env_t *)buf;

	if (check) {
3480b024:	0a00000e 	beq	3480b064 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
3480b028:	e1a01004 	mov	r1, r4
3480b02c:	e3a02004 	mov	r2, #4
3480b030:	e28d0014 	add	r0, sp, #20
3480b034:	eb00459b 	bl	3481c6a8 <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
3480b038:	e3a00000 	mov	r0, #0
3480b03c:	e2841004 	add	r1, r4, #4
3480b040:	e59f208c 	ldr	r2, [pc, #140]	; 3480b0d4 <env_import+0xc0>
3480b044:	eb003e15 	bl	3481a8a0 <crc32>
3480b048:	e59d3014 	ldr	r3, [sp, #20]
3480b04c:	e1500003 	cmp	r0, r3
3480b050:	0a000003 	beq	3480b064 <env_import+0x50>
			set_default_env("!bad CRC");
3480b054:	e59f007c 	ldr	r0, [pc, #124]	; 3480b0d8 <env_import+0xc4>
3480b058:	ebffffb1 	bl	3480af24 <set_default_env>
			return 0;
3480b05c:	e3a00000 	mov	r0, #0
3480b060:	ea000019 	b	3480b0cc <env_import+0xb8>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
3480b064:	e3a03000 	mov	r3, #0
3480b068:	e2841004 	add	r1, r4, #4
3480b06c:	e59f0068 	ldr	r0, [pc, #104]	; 3480b0dc <env_import+0xc8>
3480b070:	e59f205c 	ldr	r2, [pc, #92]	; 3480b0d4 <env_import+0xc0>
3480b074:	e58d3000 	str	r3, [sp]
3480b078:	e58d3004 	str	r3, [sp, #4]
3480b07c:	e58d3008 	str	r3, [sp, #8]
3480b080:	e58d300c 	str	r3, [sp, #12]
3480b084:	eb0041c8 	bl	3481b7ac <himport_r>
3480b088:	e2504000 	subs	r4, r0, #0
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480b08c:	15982004 	ldrne	r2, [r8, #4]
		return 1;
3480b090:	13a00001 	movne	r0, #1
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480b094:	13822080 	orrne	r2, r2, #128	; 0x80
3480b098:	15882004 	strne	r2, [r8, #4]
		return 1;
3480b09c:	1a00000a 	bne	3480b0cc <env_import+0xb8>
	}

	error("Cannot import environment: errno = %d\n", errno);
3480b0a0:	e59f3038 	ldr	r3, [pc, #56]	; 3480b0e0 <env_import+0xcc>
3480b0a4:	e59f2038 	ldr	r2, [pc, #56]	; 3480b0e4 <env_import+0xd0>
3480b0a8:	e58d3000 	str	r3, [sp]
3480b0ac:	e59f3034 	ldr	r3, [pc, #52]	; 3480b0e8 <env_import+0xd4>
3480b0b0:	e59f0034 	ldr	r0, [pc, #52]	; 3480b0ec <env_import+0xd8>
3480b0b4:	e5931000 	ldr	r1, [r3]
3480b0b8:	e3a03f41 	mov	r3, #260	; 0x104
3480b0bc:	ebfffa81 	bl	34809ac8 <printf>

	set_default_env("!import failed");
3480b0c0:	e59f0028 	ldr	r0, [pc, #40]	; 3480b0f0 <env_import+0xdc>
3480b0c4:	ebffff96 	bl	3480af24 <set_default_env>

	return 0;
3480b0c8:	e1a00004 	mov	r0, r4
}
3480b0cc:	e28dd018 	add	sp, sp, #24
3480b0d0:	e8bd8010 	pop	{r4, pc}
3480b0d4:	0003fffc 	.word	0x0003fffc
3480b0d8:	34826095 	.word	0x34826095
3480b0dc:	34828928 	.word	0x34828928
3480b0e0:	348210e4 	.word	0x348210e4
3480b0e4:	34826088 	.word	0x34826088
3480b0e8:	3482bba0 	.word	0x3482bba0
3480b0ec:	3482609e 	.word	0x3482609e
3480b0f0:	348260db 	.word	0x348260db

3480b0f4 <env_relocate>:
void env_relocate(void)
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480b0f4:	e5980014 	ldr	r0, [r8, #20]
3480b0f8:	e3500000 	cmp	r0, #0
3480b0fc:	1a000000 	bne	3480b104 <env_relocate+0x10>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
3480b100:	eaffff87 	b	3480af24 <set_default_env>
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
3480b104:	eaffffff 	b	3480b108 <env_relocate_spec>

3480b108 <env_relocate_spec>:

env_t *env_ptr;

void env_relocate_spec(void)
{
}
3480b108:	e12fff1e 	bx	lr

3480b10c <env_init>:
 *
 * We are still running from ROM, so data use is limited
 */
int env_init(void)
{
	gd->env_addr	= (ulong)&default_environment[0];
3480b10c:	e59f200c 	ldr	r2, [pc, #12]	; 3480b120 <env_init+0x14>
	gd->env_valid	= 0;
3480b110:	e3a00000 	mov	r0, #0
 *
 * We are still running from ROM, so data use is limited
 */
int env_init(void)
{
	gd->env_addr	= (ulong)&default_environment[0];
3480b114:	e5882010 	str	r2, [r8, #16]
	gd->env_valid	= 0;
3480b118:	e5880014 	str	r0, [r8, #20]

	return 0;
}
3480b11c:	e12fff1e 	bx	lr
3480b120:	348202e0 	.word	0x348202e0

3480b124 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
}
3480b124:	e12fff1e 	bx	lr

3480b128 <get_version>:

unsigned long get_version(void)
{
	return XF_VERSION;
}
3480b128:	e3a00006 	mov	r0, #6
3480b12c:	e12fff1e 	bx	lr

3480b130 <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
3480b130:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
3480b134:	e3a00070 	mov	r0, #112	; 0x70
3480b138:	e1a04008 	mov	r4, r8
3480b13c:	ebfffc28 	bl	3480a1e4 <malloc>
3480b140:	e5840054 	str	r0, [r4, #84]	; 0x54
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480b144:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b148:	e59f1124 	ldr	r1, [pc, #292]	; 3480b274 <jumptable_init+0x144>
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
3480b14c:	e59f0124 	ldr	r0, [pc, #292]	; 3480b278 <jumptable_init+0x148>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480b150:	e5821000 	str	r1, [r2]
EXPORT_FUNC(getc)
3480b154:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b158:	e59f111c 	ldr	r1, [pc, #284]	; 3480b27c <jumptable_init+0x14c>
3480b15c:	e5821004 	str	r1, [r2, #4]
EXPORT_FUNC(tstc)
3480b160:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b164:	e59f1114 	ldr	r1, [pc, #276]	; 3480b280 <jumptable_init+0x150>
3480b168:	e5821008 	str	r1, [r2, #8]
EXPORT_FUNC(putc)
3480b16c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b170:	e59f110c 	ldr	r1, [pc, #268]	; 3480b284 <jumptable_init+0x154>
3480b174:	e582100c 	str	r1, [r2, #12]
EXPORT_FUNC(puts)
3480b178:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b17c:	e59f1104 	ldr	r1, [pc, #260]	; 3480b288 <jumptable_init+0x158>
3480b180:	e5821010 	str	r1, [r2, #16]
EXPORT_FUNC(printf)
3480b184:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b188:	e59f10fc 	ldr	r1, [pc, #252]	; 3480b28c <jumptable_init+0x15c>
3480b18c:	e5821014 	str	r1, [r2, #20]
EXPORT_FUNC(install_hdlr)
3480b190:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b194:	e59f20f4 	ldr	r2, [pc, #244]	; 3480b290 <jumptable_init+0x160>
3480b198:	e5812018 	str	r2, [r1, #24]
EXPORT_FUNC(free_hdlr)
3480b19c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1a0:	e581201c 	str	r2, [r1, #28]
EXPORT_FUNC(malloc)
3480b1a4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1a8:	e5810020 	str	r0, [r1, #32]
EXPORT_FUNC(free)
3480b1ac:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1b0:	e59f00dc 	ldr	r0, [pc, #220]	; 3480b294 <jumptable_init+0x164>
3480b1b4:	e5810024 	str	r0, [r1, #36]	; 0x24
EXPORT_FUNC(udelay)
3480b1b8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1bc:	e59f00d4 	ldr	r0, [pc, #212]	; 3480b298 <jumptable_init+0x168>
3480b1c0:	e5810028 	str	r0, [r1, #40]	; 0x28
EXPORT_FUNC(get_timer)
3480b1c4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1c8:	e59f00cc 	ldr	r0, [pc, #204]	; 3480b29c <jumptable_init+0x16c>
3480b1cc:	e581002c 	str	r0, [r1, #44]	; 0x2c
EXPORT_FUNC(vprintf)
3480b1d0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1d4:	e59f00c4 	ldr	r0, [pc, #196]	; 3480b2a0 <jumptable_init+0x170>
3480b1d8:	e5810030 	str	r0, [r1, #48]	; 0x30
EXPORT_FUNC(do_reset)
3480b1dc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1e0:	e59f00bc 	ldr	r0, [pc, #188]	; 3480b2a4 <jumptable_init+0x174>
3480b1e4:	e5810034 	str	r0, [r1, #52]	; 0x34
EXPORT_FUNC(getenv)
3480b1e8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1ec:	e59f00b4 	ldr	r0, [pc, #180]	; 3480b2a8 <jumptable_init+0x178>
3480b1f0:	e5810038 	str	r0, [r1, #56]	; 0x38
EXPORT_FUNC(setenv)
3480b1f4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b1f8:	e59f00ac 	ldr	r0, [pc, #172]	; 3480b2ac <jumptable_init+0x17c>
3480b1fc:	e581003c 	str	r0, [r1, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
3480b200:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b204:	e59f00a4 	ldr	r0, [pc, #164]	; 3480b2b0 <jumptable_init+0x180>
3480b208:	e5810040 	str	r0, [r1, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
3480b20c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b210:	e59f009c 	ldr	r0, [pc, #156]	; 3480b2b4 <jumptable_init+0x184>
3480b214:	e5810044 	str	r0, [r1, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
3480b218:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b21c:	e59f0094 	ldr	r0, [pc, #148]	; 3480b2b8 <jumptable_init+0x188>
3480b220:	e5810048 	str	r0, [r1, #72]	; 0x48
EXPORT_FUNC(strcmp)
3480b224:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b228:	e59f008c 	ldr	r0, [pc, #140]	; 3480b2bc <jumptable_init+0x18c>
3480b22c:	e581004c 	str	r0, [r1, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
3480b230:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b234:	e5812050 	str	r2, [r1, #80]	; 0x50
EXPORT_FUNC(i2c_read)
3480b238:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b23c:	e5812054 	str	r2, [r1, #84]	; 0x54
EXPORT_FUNC(spi_init)
3480b240:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b244:	e5812058 	str	r2, [r1, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
3480b248:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b24c:	e581205c 	str	r2, [r1, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
3480b250:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b254:	e5812060 	str	r2, [r1, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
3480b258:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b25c:	e5812064 	str	r2, [r1, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
3480b260:	e5981054 	ldr	r1, [r8, #84]	; 0x54
EXPORT_FUNC(spi_xfer)
3480b264:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(i2c_read)
EXPORT_FUNC(spi_init)
EXPORT_FUNC(spi_setup_slave)
EXPORT_FUNC(spi_free_slave)
EXPORT_FUNC(spi_claim_bus)
EXPORT_FUNC(spi_release_bus)
3480b268:	e5812068 	str	r2, [r1, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
3480b26c:	e583206c 	str	r2, [r3, #108]	; 0x6c
#include <_exports.h>
}
3480b270:	e8bd8010 	pop	{r4, pc}
3480b274:	3480b128 	.word	0x3480b128
3480b278:	3480a1e4 	.word	0x3480a1e4
3480b27c:	34809a30 	.word	0x34809a30
3480b280:	34809a54 	.word	0x34809a54
3480b284:	34809a78 	.word	0x34809a78
3480b288:	34809aa0 	.word	0x34809aa0
3480b28c:	34809ac8 	.word	0x34809ac8
3480b290:	3480b124 	.word	0x3480b124
3480b294:	34809fc0 	.word	0x34809fc0
3480b298:	3481c8d4 	.word	0x3481c8d4
3480b29c:	348012fc 	.word	0x348012fc
3480b2a0:	34809b18 	.word	0x34809b18
3480b2a4:	3480217c 	.word	0x3480217c
3480b2a8:	34807f10 	.word	0x34807f10
3480b2ac:	34807af0 	.word	0x34807af0
3480b2b0:	3481d1e4 	.word	0x3481d1e4
3480b2b4:	3481d290 	.word	0x3481d290
3480b2b8:	3481d308 	.word	0x3481d308
3480b2bc:	3481c2c8 	.word	0x3481c2c8

3480b2c0 <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480b2c0:	e5903000 	ldr	r3, [r0]
3480b2c4:	e4d32001 	ldrb	r2, [r3], #1
	if (ch=='\0') return EOF;
3480b2c8:	e3520000 	cmp	r2, #0
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480b2cc:	e5803000 	str	r3, [r0]
	if (ch=='\0') return EOF;
	return ch;
}
3480b2d0:	11a00002 	movne	r0, r2
3480b2d4:	03e00000 	mvneq	r0, #0
3480b2d8:	e12fff1e 	bx	lr

3480b2dc <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
3480b2dc:	e5903000 	ldr	r3, [r0]
}
3480b2e0:	e5d30000 	ldrb	r0, [r3]
3480b2e4:	e12fff1e 	bx	lr

3480b2e8 <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
3480b2e8:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
3480b2ec:	e5d30000 	ldrb	r0, [r3]
3480b2f0:	e12fff1e 	bx	lr

3480b2f4 <is_assignment>:
	}
}

static int is_assignment(const char *s)
{
	if (s == NULL)
3480b2f4:	e3500000 	cmp	r0, #0
3480b2f8:	012fff1e 	bxeq	lr
		return 0;

	if (!isalpha(*s)) return 0;
3480b2fc:	e59f3040 	ldr	r3, [pc, #64]	; 3480b344 <is_assignment+0x50>
3480b300:	e5d02000 	ldrb	r2, [r0]
3480b304:	e7d32002 	ldrb	r2, [r3, r2]
3480b308:	e2122003 	ands	r2, r2, #3
3480b30c:	0a00000a 	beq	3480b33c <is_assignment+0x48>
	++s;
	while(isalnum(*s) || *s=='_') ++s;
3480b310:	e1a02003 	mov	r2, r3
3480b314:	e5f03001 	ldrb	r3, [r0, #1]!
3480b318:	e7d21003 	ldrb	r1, [r2, r3]
3480b31c:	e3110007 	tst	r1, #7
3480b320:	1afffffb 	bne	3480b314 <is_assignment+0x20>
3480b324:	e353005f 	cmp	r3, #95	; 0x5f
3480b328:	0afffff9 	beq	3480b314 <is_assignment+0x20>
	return *s=='=';
3480b32c:	e353003d 	cmp	r3, #61	; 0x3d
3480b330:	13a00000 	movne	r0, #0
3480b334:	03a00001 	moveq	r0, #1
3480b338:	e12fff1e 	bx	lr
static int is_assignment(const char *s)
{
	if (s == NULL)
		return 0;

	if (!isalpha(*s)) return 0;
3480b33c:	e1a00002 	mov	r0, r2
	++s;
	while(isalnum(*s) || *s=='_') ++s;
	return *s=='=';
}
3480b340:	e12fff1e 	bx	lr
3480b344:	34821cf4 	.word	0x34821cf4

3480b348 <syntax_err>:
#endif
#define final_printf debug_printf

#ifdef __U_BOOT__
static void syntax_err(void) {
	 printf("syntax error\n");
3480b348:	e59f0000 	ldr	r0, [pc, #0]	; 3480b350 <syntax_err+0x8>
3480b34c:	eafff9dd 	b	34809ac8 <printf>
3480b350:	348260ea 	.word	0x348260ea

3480b354 <do_showvar>:
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480b354:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b358:	e3520001 	cmp	r2, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480b35c:	059f30d0 	ldreq	r3, [pc, #208]	; 3480b434 <do_showvar+0xe0>
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480b360:	e58d2004 	str	r2, [sp, #4]
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b364:	11a09003 	movne	r9, r3
3480b368:	13a04000 	movne	r4, #0
3480b36c:	13a06001 	movne	r6, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480b370:	05934000 	ldreq	r4, [r3]
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b374:	1a000029 	bne	3480b420 <do_showvar+0xcc>
3480b378:	ea000006 	b	3480b398 <do_showvar+0x44>
		for (cur = top_vars; cur; cur = cur->next) {
			printf ("%s=%s\n", cur->name, cur->value);
3480b37c:	e8940006 	ldm	r4, {r1, r2}
3480b380:	e59f00b0 	ldr	r0, [pc, #176]	; 3480b438 <do_showvar+0xe4>
3480b384:	ebfff9cf 	bl	34809ac8 <printf>
			if (ctrlc ()) {
3480b388:	ebfff9f3 	bl	34809b5c <ctrlc>
3480b38c:	e3500000 	cmp	r0, #0
3480b390:	1a000014 	bne	3480b3e8 <do_showvar+0x94>
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
		for (cur = top_vars; cur; cur = cur->next) {
3480b394:	e5944010 	ldr	r4, [r4, #16]
3480b398:	e3540000 	cmp	r4, #0
3480b39c:	1afffff6 	bne	3480b37c <do_showvar+0x28>
3480b3a0:	ea000021 	b	3480b42c <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b3a4:	e59f2088 	ldr	r2, [pc, #136]	; 3480b434 <do_showvar+0xe0>
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
3480b3a8:	e5b97004 	ldr	r7, [r9, #4]!

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b3ac:	e5925000 	ldr	r5, [r2]
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
3480b3b0:	e3e0b000 	mvn	fp, #0
		for (cur = top_vars; cur; cur = cur->next) {
3480b3b4:	ea000010 	b	3480b3fc <do_showvar+0xa8>
			if(strcmp (cur->name, name) == 0) {
3480b3b8:	e5950000 	ldr	r0, [r5]
3480b3bc:	e1a01007 	mov	r1, r7
3480b3c0:	eb0043c0 	bl	3481c2c8 <strcmp>
3480b3c4:	e250a000 	subs	sl, r0, #0
3480b3c8:	1a000003 	bne	3480b3dc <do_showvar+0x88>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
3480b3cc:	e59f0064 	ldr	r0, [pc, #100]	; 3480b438 <do_showvar+0xe4>
3480b3d0:	e8950006 	ldm	r5, {r1, r2}
3480b3d4:	ebfff9bb 	bl	34809ac8 <printf>
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
			if(strcmp (cur->name, name) == 0) {
				k = 0;
3480b3d8:	e1a0b00a 	mov	fp, sl
				printf ("%s=%s\n", cur->name, cur->value);
			}
			if (ctrlc ()) {
3480b3dc:	ebfff9de 	bl	34809b5c <ctrlc>
3480b3e0:	e3500000 	cmp	r0, #0
3480b3e4:	0a000003 	beq	3480b3f8 <do_showvar+0xa4>
				puts ("\n ** Abort\n");
3480b3e8:	e59f004c 	ldr	r0, [pc, #76]	; 3480b43c <do_showvar+0xe8>
3480b3ec:	ebfff9ab 	bl	34809aa0 <puts>
				return 1;
3480b3f0:	e3a04001 	mov	r4, #1
3480b3f4:	ea00000c 	b	3480b42c <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b3f8:	e5955010 	ldr	r5, [r5, #16]
3480b3fc:	e3550000 	cmp	r5, #0
3480b400:	1affffec 	bne	3480b3b8 <do_showvar+0x64>
			if (ctrlc ()) {
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
3480b404:	e37b0001 	cmn	fp, #1
3480b408:	1a000003 	bne	3480b41c <do_showvar+0xc8>
			printf ("## Error: \"%s\" not defined\n", name);
3480b40c:	e59f002c 	ldr	r0, [pc, #44]	; 3480b440 <do_showvar+0xec>
3480b410:	e1a01007 	mov	r1, r7
3480b414:	ebfff9ab 	bl	34809ac8 <printf>
			rcode ++;
3480b418:	e2844001 	add	r4, r4, #1
				return 1;
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480b41c:	e2866001 	add	r6, r6, #1
3480b420:	e59d3004 	ldr	r3, [sp, #4]
3480b424:	e1560003 	cmp	r6, r3
3480b428:	baffffdd 	blt	3480b3a4 <do_showvar+0x50>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
}
3480b42c:	e1a00004 	mov	r0, r4
3480b430:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480b434:	34829d28 	.word	0x34829d28
3480b438:	348251f5 	.word	0x348251f5
3480b43c:	348260f8 	.word	0x348260f8
3480b440:	3482521d 	.word	0x3482521d

3480b444 <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
3480b444:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
3480b448:	ebfffb65 	bl	3480a1e4 <malloc>
3480b44c:	e3500000 	cmp	r0, #0
3480b450:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480b454:	e59f0004 	ldr	r0, [pc, #4]	; 3480b460 <xmalloc+0x1c>
3480b458:	ebfff99a 	bl	34809ac8 <printf>
3480b45c:	eafffffe 	b	3480b45c <xmalloc+0x18>
3480b460:	34826104 	.word	0x34826104

3480b464 <file_get>:
{
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b464:	e5903000 	ldr	r3, [r0]
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480b468:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b46c:	e3530000 	cmp	r3, #0
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480b470:	e1a04000 	mov	r4, r0
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b474:	0a000047 	beq	3480b598 <file_get+0x134>
3480b478:	e5d30000 	ldrb	r0, [r3]
3480b47c:	e3500000 	cmp	r0, #0
3480b480:	0a000044 	beq	3480b598 <file_get+0x134>
3480b484:	ea000056 	b	3480b5e4 <file_get+0x180>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
	if (i->promptmode == 1) {
3480b488:	e5943008 	ldr	r3, [r4, #8]
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480b48c:	e3a02001 	mov	r2, #1
	if (i->promptmode == 1) {
3480b490:	e1530002 	cmp	r3, r2
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480b494:	e5842004 	str	r2, [r4, #4]
	if (i->promptmode == 1) {
		n = readline(CONFIG_SYS_PROMPT);
3480b498:	059f0158 	ldreq	r0, [pc, #344]	; 3480b5f8 <file_get+0x194>
	} else {
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
3480b49c:	159f0158 	ldrne	r0, [pc, #344]	; 3480b5fc <file_get+0x198>
3480b4a0:	eb000c3d 	bl	3480e59c <readline>
#  else
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
3480b4a4:	e3700001 	cmn	r0, #1
		flag_repeat = 0;
		i->__promptme = 0;
3480b4a8:	05846004 	streq	r6, [r4, #4]
	}
	n = strlen(console_buffer);
3480b4ac:	e59f014c 	ldr	r0, [pc, #332]	; 3480b600 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b4b0:	05856004 	streq	r6, [r5, #4]
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480b4b4:	eb0043b7 	bl	3481c398 <strlen>
	console_buffer[n] = '\n';
3480b4b8:	e1a03007 	mov	r3, r7
3480b4bc:	e7e3a000 	strb	sl, [r3, r0]!
	console_buffer[n+1]= '\0';
3480b4c0:	e5c36001 	strb	r6, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
3480b4c4:	ebfff9bd 	bl	34809bc0 <had_ctrlc>
3480b4c8:	e3500000 	cmp	r0, #0
3480b4cc:	15856004 	strne	r6, [r5, #4]
	clear_ctrlc();
3480b4d0:	ebfff9be 	bl	34809bd0 <clear_ctrlc>
	do_repeat = 0;
	if (i->promptmode == 1) {
3480b4d4:	e5949008 	ldr	r9, [r4, #8]
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
3480b4d8:	e5856008 	str	r6, [r5, #8]
	if (i->promptmode == 1) {
3480b4dc:	e3590001 	cmp	r9, #1
3480b4e0:	1a000010 	bne	3480b528 <file_get+0xc4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b4e4:	e5d73000 	ldrb	r3, [r7]
3480b4e8:	e353000a 	cmp	r3, #10
3480b4ec:	1a000007 	bne	3480b510 <file_get+0xac>
3480b4f0:	e5953004 	ldr	r3, [r5, #4]
3480b4f4:	e3530000 	cmp	r3, #0
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
				flag_repeat = 1;
			}
			else {
				do_repeat = 1;
3480b4f8:	15859008 	strne	r9, [r5, #8]
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
	if (i->promptmode == 1) {
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b4fc:	1a000007 	bne	3480b520 <file_get+0xbc>
			strcpy(the_command,console_buffer);
3480b500:	e59f10f8 	ldr	r1, [pc, #248]	; 3480b600 <file_get+0x19c>
3480b504:	e59f00f8 	ldr	r0, [pc, #248]	; 3480b604 <file_get+0x1a0>
3480b508:	eb00433d 	bl	3481c204 <strcpy>
3480b50c:	ea000003 	b	3480b520 <file_get+0xbc>
		}
		else {
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
3480b510:	e59f00ec 	ldr	r0, [pc, #236]	; 3480b604 <file_get+0x1a0>
3480b514:	e59f10e4 	ldr	r1, [pc, #228]	; 3480b600 <file_get+0x19c>
3480b518:	eb004339 	bl	3481c204 <strcpy>
				flag_repeat = 1;
3480b51c:	e5859004 	str	r9, [r5, #4]
			}
			else {
				do_repeat = 1;
			}
		}
		i->p = the_command;
3480b520:	e584b000 	str	fp, [r4]
3480b524:	ea000020 	b	3480b5ac <file_get+0x148>
	}
	else {
		if (console_buffer[0] != '\n') {
3480b528:	e5d73000 	ldrb	r3, [r7]
3480b52c:	e353000a 	cmp	r3, #10
3480b530:	0a000012 	beq	3480b580 <file_get+0x11c>
			if (strlen(the_command) + strlen(console_buffer)
3480b534:	e59f00c8 	ldr	r0, [pc, #200]	; 3480b604 <file_get+0x1a0>
3480b538:	eb004396 	bl	3481c398 <strlen>
3480b53c:	e1a09000 	mov	r9, r0
3480b540:	e59f00b8 	ldr	r0, [pc, #184]	; 3480b600 <file_get+0x19c>
3480b544:	eb004393 	bl	3481c398 <strlen>
3480b548:	e0800009 	add	r0, r0, r9
3480b54c:	e35000ff 	cmp	r0, #255	; 0xff
				n = strlen(the_command);
				the_command[n-1] = ' ';
				strcpy(&the_command[n],console_buffer);
			}
			else {
				the_command[0] = '\n';
3480b550:	85c5a00c 	strbhi	sl, [r5, #12]
				the_command[1] = '\0';
3480b554:	85c5600d 	strbhi	r6, [r5, #13]
				flag_repeat = 0;
3480b558:	85856004 	strhi	r6, [r5, #4]
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480b55c:	8a000007 	bhi	3480b580 <file_get+0x11c>
			    < CONFIG_SYS_CBSIZE) {
				n = strlen(the_command);
3480b560:	e59f009c 	ldr	r0, [pc, #156]	; 3480b604 <file_get+0x1a0>
3480b564:	eb00438b 	bl	3481c398 <strlen>
				the_command[n-1] = ' ';
3480b568:	e3a02020 	mov	r2, #32
3480b56c:	e0853000 	add	r3, r5, r0
3480b570:	e5c3200b 	strb	r2, [r3, #11]
				strcpy(&the_command[n],console_buffer);
3480b574:	e08b0000 	add	r0, fp, r0
3480b578:	e59f1080 	ldr	r1, [pc, #128]	; 3480b600 <file_get+0x19c>
3480b57c:	eb004320 	bl	3481c204 <strcpy>
				the_command[0] = '\n';
				the_command[1] = '\0';
				flag_repeat = 0;
			}
		}
		if (i->__promptme == 0) {
3480b580:	e5943004 	ldr	r3, [r4, #4]
3480b584:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
3480b588:	05c5a00c 	strbeq	sl, [r5, #12]
			the_command[1] = '\0';
3480b58c:	05c5300d 	strbeq	r3, [r5, #13]
		}
		i->p = console_buffer;
3480b590:	e5847000 	str	r7, [r4]
3480b594:	ea000004 	b	3480b5ac <file_get+0x148>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b598:	e59f5068 	ldr	r5, [pc, #104]	; 3480b608 <file_get+0x1a4>
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480b59c:	e59f705c 	ldr	r7, [pc, #92]	; 3480b600 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b5a0:	e3a06000 	mov	r6, #0
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
3480b5a4:	e3a0a00a 	mov	sl, #10
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480b5a8:	e285b00c 	add	fp, r5, #12
		 * more complicated by now, like sourcing or substituting. */
#ifndef __U_BOOT__
		if (i->__promptme && interactive && i->file == stdin) {
			while(! i->p || (interactive && strlen(i->p)==0) ) {
#else
			while(! i->p  || strlen(i->p)==0 ) {
3480b5ac:	e5940000 	ldr	r0, [r4]
3480b5b0:	e3500000 	cmp	r0, #0
3480b5b4:	0affffb3 	beq	3480b488 <file_get+0x24>
3480b5b8:	eb004376 	bl	3481c398 <strlen>
3480b5bc:	e3500000 	cmp	r0, #0
3480b5c0:	0affffb0 	beq	3480b488 <file_get+0x24>
#endif
				get_user_input(i);
			}
			i->promptmode=2;
3480b5c4:	e3a03002 	mov	r3, #2
3480b5c8:	e5843008 	str	r3, [r4, #8]
#ifndef __U_BOOT__
			i->__promptme = 0;
#endif
			if (i->p && *i->p) {
3480b5cc:	e5943000 	ldr	r3, [r4]
3480b5d0:	e3530000 	cmp	r3, #0
3480b5d4:	0a000005 	beq	3480b5f0 <file_get+0x18c>
3480b5d8:	e5d30000 	ldrb	r0, [r3]
3480b5dc:	e3500000 	cmp	r0, #0
3480b5e0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
				ch = *i->p++;
3480b5e4:	e2833001 	add	r3, r3, #1
3480b5e8:	e5843000 	str	r3, [r4]
3480b5ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
	int ch;

	ch = 0;
3480b5f0:	e1a00003 	mov	r0, r3
	}
#ifndef __U_BOOT__
	if (ch == '\n') i->__promptme=1;
#endif
	return ch;
}
3480b5f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b5f8:	34826122 	.word	0x34826122
3480b5fc:	3482612a 	.word	0x3482612a
3480b600:	3482b3dc 	.word	0x3482b3dc
3480b604:	34829d34 	.word	0x34829d34
3480b608:	34829d28 	.word	0x34829d28

3480b60c <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
3480b60c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
3480b610:	e3a05000 	mov	r5, #0
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b614:	e1a04000 	mov	r4, r0
3480b618:	e1a06005 	mov	r6, r5
			child->argv=NULL;
		} else if (child->group) {
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480b61c:	e2819003 	add	r9, r1, #3
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b620:	ea000029 	b	3480b6cc <free_pipe_list+0xc0>
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480b624:	e5943004 	ldr	r3, [r4, #4]
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480b628:	e7932007 	ldr	r2, [r3, r7]
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480b62c:	e083b007 	add	fp, r3, r7
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480b630:	e3520000 	cmp	r2, #0
3480b634:	0a000011 	beq	3480b680 <free_pipe_list+0x74>
			for (a=0,p=child->argv; *p; a++,p++) {
3480b638:	e4923004 	ldr	r3, [r2], #4
3480b63c:	e3530000 	cmp	r3, #0
3480b640:	1afffffc 	bne	3480b638 <free_pipe_list+0x2c>
3480b644:	ea000005 	b	3480b660 <free_pipe_list+0x54>
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
				free(child->argv[a]);
3480b648:	e59b2000 	ldr	r2, [fp]
3480b64c:	e7920103 	ldr	r0, [r2, r3, lsl #2]
3480b650:	e58d3004 	str	r3, [sp, #4]
3480b654:	ebfffa59 	bl	34809fc0 <free>
				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
3480b658:	e59d3004 	ldr	r3, [sp, #4]
3480b65c:	e2833001 	add	r3, r3, #1
3480b660:	e59b2004 	ldr	r2, [fp, #4]
3480b664:	e1530002 	cmp	r3, r2
3480b668:	bafffff6 	blt	3480b648 <free_pipe_list+0x3c>
				free(child->argv[a]);
			}
					free(child->argv);
3480b66c:	e59b0000 	ldr	r0, [fp]
3480b670:	ebfffa52 	bl	34809fc0 <free>
			child->argc = 0;
3480b674:	e58b6004 	str	r6, [fp, #4]
#endif
			child->argv=NULL;
3480b678:	e58b6000 	str	r6, [fp]
3480b67c:	ea000005 	b	3480b698 <free_pipe_list+0x8c>
		} else if (child->group) {
3480b680:	e59b0008 	ldr	r0, [fp, #8]
3480b684:	e3500000 	cmp	r0, #0
3480b688:	0a000002 	beq	3480b698 <free_pipe_list+0x8c>
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480b68c:	e1a01009 	mov	r1, r9
3480b690:	ebffffdd 	bl	3480b60c <free_pipe_list>
3480b694:	e1a05000 	mov	r5, r0
#ifndef __U_BOOT__
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
3480b698:	e28aa001 	add	sl, sl, #1
3480b69c:	e2877014 	add	r7, r7, #20
3480b6a0:	e5943000 	ldr	r3, [r4]
3480b6a4:	e15a0003 	cmp	sl, r3
3480b6a8:	baffffdd 	blt	3480b624 <free_pipe_list+0x18>
			free(r);
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
3480b6ac:	e5940004 	ldr	r0, [r4, #4]
3480b6b0:	ebfffa42 	bl	34809fc0 <free>
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
3480b6b4:	e5947008 	ldr	r7, [r4, #8]
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
	pi->progs=NULL;
3480b6b8:	e5846004 	str	r6, [r4, #4]
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
		pi->next=NULL;
3480b6bc:	e5846008 	str	r6, [r4, #8]
		free(pi);
3480b6c0:	e1a00004 	mov	r0, r4
3480b6c4:	ebfffa3d 	bl	34809fc0 <free>
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b6c8:	e1a04007 	mov	r4, r7
3480b6cc:	e3540000 	cmp	r4, #0
3480b6d0:	13a05000 	movne	r5, #0
3480b6d4:	11a07005 	movne	r7, r5
3480b6d8:	11a0a005 	movne	sl, r5
3480b6dc:	1affffef 	bne	3480b6a0 <free_pipe_list+0x94>
		next=pi->next;
		pi->next=NULL;
		free(pi);
	}
	return rcode;
}
3480b6e0:	e1a00005 	mov	r0, r5
3480b6e4:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480b6e8 <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
3480b6e8:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
3480b6ec:	ebfffcae 	bl	3480a9ac <realloc>
3480b6f0:	e3500000 	cmp	r0, #0
3480b6f4:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480b6f8:	e59f0004 	ldr	r0, [pc, #4]	; 3480b704 <xrealloc+0x1c>
3480b6fc:	ebfff8f1 	bl	34809ac8 <printf>
3480b700:	eafffffe 	b	3480b700 <xrealloc+0x18>
3480b704:	34826104 	.word	0x34826104

3480b708 <done_command>:
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;
3480b708:	e5903000 	ldr	r3, [r0]
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480b70c:	e92d4070 	push	{r4, r5, r6, lr}
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480b710:	e3530000 	cmp	r3, #0
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480b714:	e1a05000 	mov	r5, r0
	/* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
3480b718:	e5904008 	ldr	r4, [r0, #8]
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480b71c:	0a000008 	beq	3480b744 <done_command+0x3c>
3480b720:	e5932008 	ldr	r2, [r3, #8]
3480b724:	e3520000 	cmp	r2, #0
3480b728:	1a000002 	bne	3480b738 <done_command+0x30>
		 && prog->argv == NULL
3480b72c:	e5933000 	ldr	r3, [r3]
3480b730:	e3530000 	cmp	r3, #0
3480b734:	0a000013 	beq	3480b788 <done_command+0x80>
										) {
#endif
		debug_printf("done_command: skipping null command\n");
		return 0;
	} else if (prog) {
		pi->num_progs++;
3480b738:	e5943000 	ldr	r3, [r4]
3480b73c:	e2833001 	add	r3, r3, #1
3480b740:	e5843000 	str	r3, [r4]
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480b744:	e5941000 	ldr	r1, [r4]
3480b748:	e3a06014 	mov	r6, #20
3480b74c:	e2811001 	add	r1, r1, #1
3480b750:	e0010196 	mul	r1, r6, r1
3480b754:	e5940004 	ldr	r0, [r4, #4]
3480b758:	ebffffe2 	bl	3480b6e8 <xrealloc>

	prog = pi->progs + pi->num_progs;
3480b75c:	e5943000 	ldr	r3, [r4]
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480b760:	e3a02000 	mov	r2, #0
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));

	prog = pi->progs + pi->num_progs;
3480b764:	e0060396 	mul	r6, r6, r3
3480b768:	e0803006 	add	r3, r0, r6
		pi->num_progs++;
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480b76c:	e5840004 	str	r0, [r4, #4]

	prog = pi->progs + pi->num_progs;
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480b770:	e7802006 	str	r2, [r0, r6]
#ifndef __U_BOOT__
	prog->is_stopped = 0;
#endif
	prog->group = NULL;
3480b774:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
3480b778:	e583200c 	str	r2, [r3, #12]
	ctx->child = prog;
	prog->type = ctx->type;
3480b77c:	e5952018 	ldr	r2, [r5, #24]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
	ctx->child = prog;
3480b780:	e5853000 	str	r3, [r5]
	prog->type = ctx->type;
3480b784:	e5832010 	str	r2, [r3, #16]

	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}
3480b788:	e3a00000 	mov	r0, #0
3480b78c:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b790 <b_addchr>:
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b790:	e92d4070 	push	{r4, r5, r6, lr}

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b794:	e5903004 	ldr	r3, [r0, #4]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b798:	e1a06001 	mov	r6, r1

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b79c:	e5901008 	ldr	r1, [r0, #8]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b7a0:	e1a04000 	mov	r4, r0

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b7a4:	e1530001 	cmp	r3, r1
3480b7a8:	ba00000a 	blt	3480b7d8 <b_addchr+0x48>
		char *old_data = o->data;
3480b7ac:	e5905000 	ldr	r5, [r0]
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
3480b7b0:	e2813064 	add	r3, r1, #100	; 0x64
3480b7b4:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
3480b7b8:	e2811065 	add	r1, r1, #101	; 0x65
3480b7bc:	e1a00005 	mov	r0, r5
3480b7c0:	ebfffc79 	bl	3480a9ac <realloc>
		if (o->data == NULL) {
3480b7c4:	e3500000 	cmp	r0, #0
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
		char *old_data = o->data;
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
		o->data = realloc(o->data, 1 + o->maxlen);
3480b7c8:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
3480b7cc:	1a000001 	bne	3480b7d8 <b_addchr+0x48>
			free(old_data);
3480b7d0:	e1a00005 	mov	r0, r5
3480b7d4:	ebfff9f9 	bl	34809fc0 <free>
		}
	}
	return o->data == NULL;
3480b7d8:	e5943000 	ldr	r3, [r4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b7dc:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
3480b7e0:	15942004 	ldrne	r2, [r4, #4]
	o->length++;
	o->data[o->length] = '\0';
3480b7e4:	13a00000 	movne	r0, #0

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
3480b7e8:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
3480b7ec:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480b7f0:	15942000 	ldrne	r2, [r4]
static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
	o->length++;
3480b7f4:	12833001 	addne	r3, r3, #1
3480b7f8:	15843004 	strne	r3, [r4, #4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b7fc:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
3480b800:	17c20003 	strbne	r0, [r2, r3]
	return 0;
}
3480b804:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b808 <b_addqchr>:
/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
	if (quote && strchr("*?[\\",ch)) {
3480b808:	e3520000 	cmp	r2, #0

/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
3480b80c:	e92d4070 	push	{r4, r5, r6, lr}
3480b810:	e1a04000 	mov	r4, r0
3480b814:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
3480b818:	0a000008 	beq	3480b840 <b_addqchr+0x38>
3480b81c:	e59f002c 	ldr	r0, [pc, #44]	; 3480b850 <b_addqchr+0x48>
3480b820:	eb0042c6 	bl	3481c340 <strchr>
3480b824:	e3500000 	cmp	r0, #0
3480b828:	0a000004 	beq	3480b840 <b_addqchr+0x38>
		int rc;
		rc = b_addchr(o, '\\');
3480b82c:	e1a00004 	mov	r0, r4
3480b830:	e3a0105c 	mov	r1, #92	; 0x5c
3480b834:	ebffffd5 	bl	3480b790 <b_addchr>
		if (rc) return rc;
3480b838:	e3500000 	cmp	r0, #0
3480b83c:	18bd8070 	popne	{r4, r5, r6, pc}
	}
	return b_addchr(o, ch);
3480b840:	e1a00004 	mov	r0, r4
3480b844:	e1a01005 	mov	r1, r5
}
3480b848:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (quote && strchr("*?[\\",ch)) {
		int rc;
		rc = b_addchr(o, '\\');
		if (rc) return rc;
	}
	return b_addchr(o, ch);
3480b84c:	eaffffcf 	b	3480b790 <b_addchr>
3480b850:	3482612d 	.word	0x3482612d

3480b854 <get_local_var>:
static char *get_dollar_var(char ch);
#endif

/* This is used to get/check local shell variables */
char *get_local_var(const char *s)
{
3480b854:	e92d4038 	push	{r3, r4, r5, lr}
	struct variables *cur;

	if (!s)
3480b858:	e2505000 	subs	r5, r0, #0
3480b85c:	0a00001c 	beq	3480b8d4 <get_local_var+0x80>
		return NULL;

#ifdef __U_BOOT__
	if (*s == '$')
3480b860:	e5d53000 	ldrb	r3, [r5]
3480b864:	e59f4070 	ldr	r4, [pc, #112]	; 3480b8dc <get_local_var+0x88>
3480b868:	e3530024 	cmp	r3, #36	; 0x24
3480b86c:	1a00000a 	bne	3480b89c <get_local_var+0x48>
		return get_dollar_var(s[1]);
3480b870:	e5d53001 	ldrb	r3, [r5, #1]
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480b874:	e3a00000 	mov	r0, #0
	switch (ch) {
3480b878:	e353003f 	cmp	r3, #63	; 0x3f
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480b87c:	e5c4010c 	strb	r0, [r4, #268]	; 0x10c
	switch (ch) {
3480b880:	18bd8038 	popne	{r3, r4, r5, pc}
		case '?':
			sprintf(buf, "%u", (unsigned int)last_return_code);
3480b884:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b888:	e59f1050 	ldr	r1, [pc, #80]	; 3480b8e0 <get_local_var+0x8c>
3480b88c:	e5942134 	ldr	r2, [r4, #308]	; 0x134
3480b890:	eb0046f9 	bl	3481d47c <sprintf>
			break;
		default:
			return NULL;
	}
	return buf;
3480b894:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b898:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480b89c:	e5944000 	ldr	r4, [r4]
3480b8a0:	ea000007 	b	3480b8c4 <get_local_var+0x70>
		if(strcmp(cur->name, s)==0)
3480b8a4:	e5940000 	ldr	r0, [r4]
3480b8a8:	e1a01005 	mov	r1, r5
3480b8ac:	eb004285 	bl	3481c2c8 <strcmp>
3480b8b0:	e3500000 	cmp	r0, #0
3480b8b4:	1a000001 	bne	3480b8c0 <get_local_var+0x6c>
			return cur->value;
3480b8b8:	e5940004 	ldr	r0, [r4, #4]
3480b8bc:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480b8c0:	e5944010 	ldr	r4, [r4, #16]
3480b8c4:	e3540000 	cmp	r4, #0
3480b8c8:	1afffff5 	bne	3480b8a4 <get_local_var+0x50>
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
3480b8cc:	e1a00004 	mov	r0, r4
3480b8d0:	e8bd8038 	pop	{r3, r4, r5, pc}
char *get_local_var(const char *s)
{
	struct variables *cur;

	if (!s)
		return NULL;
3480b8d4:	e1a00005 	mov	r0, r5

	for (cur = top_vars; cur; cur=cur->next)
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
}
3480b8d8:	e8bd8038 	pop	{r3, r4, r5, pc}
3480b8dc:	34829d28 	.word	0x34829d28
3480b8e0:	34824423 	.word	0x34824423

3480b8e4 <set_local_var>:
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480b8e4:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480b8e8:	e59f219c 	ldr	r2, [pc, #412]	; 3480ba8c <set_local_var+0x1a8>
3480b8ec:	e5d03000 	ldrb	r3, [r0]
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480b8f0:	e1a07001 	mov	r7, r1
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480b8f4:	e7d23003 	ldrb	r3, [r2, r3]
3480b8f8:	e3130003 	tst	r3, #3
3480b8fc:	0a00005a 	beq	3480ba6c <set_local_var+0x188>
		return -1;
#endif

	name=strdup(s);
3480b900:	eb0042d9 	bl	3481c46c <strdup>
3480b904:	e1a05000 	mov	r5, r0

#ifdef __U_BOOT__
	if (getenv(name) != NULL) {
3480b908:	ebfff180 	bl	34807f10 <getenv>
3480b90c:	e2504000 	subs	r4, r0, #0
3480b910:	0a000004 	beq	3480b928 <set_local_var+0x44>
		printf ("ERROR: "
3480b914:	e59f0174 	ldr	r0, [pc, #372]	; 3480ba90 <set_local_var+0x1ac>
3480b918:	ebfff86a 	bl	34809ac8 <printf>
				"There is a global environment variable with the same name.\n");
		free(name);
3480b91c:	e1a00005 	mov	r0, r5
3480b920:	ebfff9a6 	bl	34809fc0 <free>
3480b924:	ea000050 	b	3480ba6c <set_local_var+0x188>
	}
#endif
	/* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' */
	value = strchr(name, '=');
3480b928:	e1a00005 	mov	r0, r5
3480b92c:	e3a0103d 	mov	r1, #61	; 0x3d
3480b930:	eb004282 	bl	3481c340 <strchr>
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480b934:	e3500000 	cmp	r0, #0
3480b938:	11a06000 	movne	r6, r0
3480b93c:	03a06001 	moveq	r6, #1

	for(cur = top_vars; cur; cur = cur->next) {
3480b940:	e59f314c 	ldr	r3, [pc, #332]	; 3480ba94 <set_local_var+0x1b0>
	value = strchr(name, '=');
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480b944:	e4c64001 	strb	r4, [r6], #1

	for(cur = top_vars; cur; cur = cur->next) {
3480b948:	e5934000 	ldr	r4, [r3]
3480b94c:	ea000005 	b	3480b968 <set_local_var+0x84>
		if(strcmp(cur->name, name)==0)
3480b950:	e5940000 	ldr	r0, [r4]
3480b954:	e1a01005 	mov	r1, r5
3480b958:	eb00425a 	bl	3481c2c8 <strcmp>
3480b95c:	e3500000 	cmp	r0, #0
3480b960:	0a000003 	beq	3480b974 <set_local_var+0x90>
		free(name);
		return -1;
	}
	*value++ = 0;

	for(cur = top_vars; cur; cur = cur->next) {
3480b964:	e5944010 	ldr	r4, [r4, #16]
3480b968:	e3540000 	cmp	r4, #0
3480b96c:	1afffff7 	bne	3480b950 <set_local_var+0x6c>
3480b970:	ea000040 	b	3480ba78 <set_local_var+0x194>
		if(strcmp(cur->name, name)==0)
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
3480b974:	e5940004 	ldr	r0, [r4, #4]
3480b978:	e1a01006 	mov	r1, r6
3480b97c:	eb004251 	bl	3481c2c8 <strcmp>
3480b980:	e3500000 	cmp	r0, #0
3480b984:	1a000007 	bne	3480b9a8 <set_local_var+0xc4>
			if(flg_export>0 && cur->flg_export==0)
3480b988:	e3570000 	cmp	r7, #0
3480b98c:	da000030 	ble	3480ba54 <set_local_var+0x170>
3480b990:	e5943008 	ldr	r3, [r4, #8]
3480b994:	e3530000 	cmp	r3, #0
				cur->flg_export=flg_export;
3480b998:	05847008 	streq	r7, [r4, #8]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480b99c:	01a04003 	moveq	r4, r3
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
3480b9a0:	0a00002e 	beq	3480ba60 <set_local_var+0x17c>
3480b9a4:	ea00002a 	b	3480ba54 <set_local_var+0x170>
				cur->flg_export=flg_export;
			else
				result++;
		} else {
			if(cur->flg_read_only) {
3480b9a8:	e594300c 	ldr	r3, [r4, #12]
3480b9ac:	e3530000 	cmp	r3, #0
3480b9b0:	0a000003 	beq	3480b9c4 <set_local_var+0xe0>
				error_msg("%s: readonly variable", name);
3480b9b4:	e1a01005 	mov	r1, r5
3480b9b8:	e59f00d8 	ldr	r0, [pc, #216]	; 3480ba98 <set_local_var+0x1b4>
3480b9bc:	ebfff841 	bl	34809ac8 <printf>
3480b9c0:	ea000025 	b	3480ba5c <set_local_var+0x178>
				result = -1;
			} else {
				if(flg_export>0 || cur->flg_export>1)
3480b9c4:	e3570000 	cmp	r7, #0
3480b9c8:	ca000002 	bgt	3480b9d8 <set_local_var+0xf4>
3480b9cc:	e5943008 	ldr	r3, [r4, #8]
3480b9d0:	e3530001 	cmp	r3, #1
3480b9d4:	da000001 	ble	3480b9e0 <set_local_var+0xfc>
					cur->flg_export=1;
3480b9d8:	e3a03001 	mov	r3, #1
3480b9dc:	e5843008 	str	r3, [r4, #8]
				free(cur->value);
3480b9e0:	e5940004 	ldr	r0, [r4, #4]
3480b9e4:	ebfff975 	bl	34809fc0 <free>

				cur->value = strdup(value);
3480b9e8:	e1a00006 	mov	r0, r6
3480b9ec:	eb00429e 	bl	3481c46c <strdup>
3480b9f0:	e5840004 	str	r0, [r4, #4]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480b9f4:	e3a04000 	mov	r4, #0
3480b9f8:	ea000018 	b	3480ba60 <set_local_var+0x17c>
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480b9fc:	e1a00005 	mov	r0, r5
3480ba00:	eb004299 	bl	3481c46c <strdup>
			if(cur->name == 0) {
3480ba04:	e3500000 	cmp	r0, #0
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480ba08:	e58a0000 	str	r0, [sl]
			if(cur->name == 0) {
3480ba0c:	1a000002 	bne	3480ba1c <set_local_var+0x138>
				free(cur);
3480ba10:	e1a0000a 	mov	r0, sl
3480ba14:	ebfff969 	bl	34809fc0 <free>
3480ba18:	ea00000f 	b	3480ba5c <set_local_var+0x178>
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480ba1c:	e59f3070 	ldr	r3, [pc, #112]	; 3480ba94 <set_local_var+0x1b0>
				cur->value = strdup(value);
3480ba20:	e1a00006 	mov	r0, r6
			cur->name = strdup(name);
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480ba24:	e5939000 	ldr	r9, [r3]
				cur->value = strdup(value);
3480ba28:	eb00428f 	bl	3481c46c <strdup>
				cur->next = 0;
3480ba2c:	e58a4010 	str	r4, [sl, #16]
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
				cur->value = strdup(value);
3480ba30:	e98a0081 	stmib	sl, {r0, r7}
				cur->next = 0;
				cur->flg_export = flg_export;
				cur->flg_read_only = 0;
3480ba34:	e58a400c 	str	r4, [sl, #12]
				while(bottom->next) bottom=bottom->next;
3480ba38:	ea000000 	b	3480ba40 <set_local_var+0x15c>
3480ba3c:	e1a09004 	mov	r9, r4
3480ba40:	e5994010 	ldr	r4, [r9, #16]
3480ba44:	e3540000 	cmp	r4, #0
3480ba48:	1afffffb 	bne	3480ba3c <set_local_var+0x158>
				bottom->next = cur;
3480ba4c:	e589a010 	str	sl, [r9, #16]
3480ba50:	ea000002 	b	3480ba60 <set_local_var+0x17c>
	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
				cur->flg_export=flg_export;
			else
				result++;
3480ba54:	e3a04001 	mov	r4, #1
3480ba58:	ea000000 	b	3480ba60 <set_local_var+0x17c>
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
3480ba5c:	e3e04000 	mvn	r4, #0
	if(result==0 && cur->flg_export==1) {
		*(value-1) = '=';
		result = putenv(name);
	} else {
#endif
		free(name);
3480ba60:	e1a00005 	mov	r0, r5
3480ba64:	ebfff955 	bl	34809fc0 <free>
#ifndef __U_BOOT__
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
3480ba68:	ea000000 	b	3480ba70 <set_local_var+0x18c>
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
		return -1;
3480ba6c:	e3e04000 	mvn	r4, #0
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
}
3480ba70:	e1a00004 	mov	r0, r4
3480ba74:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

				cur->value = strdup(value);
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
3480ba78:	e3a00014 	mov	r0, #20
3480ba7c:	ebfff9d8 	bl	3480a1e4 <malloc>
		if(!cur) {
3480ba80:	e250a000 	subs	sl, r0, #0
3480ba84:	1affffdc 	bne	3480b9fc <set_local_var+0x118>
3480ba88:	eafffff3 	b	3480ba5c <set_local_var+0x178>
3480ba8c:	34821cf4 	.word	0x34821cf4
3480ba90:	34826132 	.word	0x34826132
3480ba94:	34829d28 	.word	0x34829d28
3480ba98:	34826175 	.word	0x34826175

3480ba9c <insert_var_value_sub>:
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480ba9c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;
3480baa0:	e3a04000 	mov	r4, #0
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480baa4:	e1a09000 	mov	r9, r0
3480baa8:	e58d100c 	str	r1, [sp, #12]
	int res_str_len = 0;
	int len;
	int done = 0;
3480baac:	e1a05004 	mov	r5, r4
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
	int res_str_len = 0;
3480bab0:	e1a07004 	mov	r7, r4
3480bab4:	e1a06004 	mov	r6, r4
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480bab8:	ea00008a 	b	3480bce8 <insert_var_value_sub+0x24c>
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
3480babc:	e15b0009 	cmp	fp, r9
3480bac0:	0a00000a 	beq	3480baf0 <insert_var_value_sub+0x54>
			/* copy any charachters to the result string */
			len = p - inp;
3480bac4:	e069500b 	rsb	r5, r9, fp
			res_str = xrealloc(res_str, (res_str_len + len));
3480bac8:	e0854007 	add	r4, r5, r7
3480bacc:	e1a00006 	mov	r0, r6
3480bad0:	e1a01004 	mov	r1, r4
3480bad4:	ebffff03 	bl	3480b6e8 <xrealloc>
			strncpy((res_str + res_str_len), inp, len);
3480bad8:	e1a01009 	mov	r1, r9
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
			/* copy any charachters to the result string */
			len = p - inp;
			res_str = xrealloc(res_str, (res_str_len + len));
3480badc:	e1a06000 	mov	r6, r0
			strncpy((res_str + res_str_len), inp, len);
3480bae0:	e1a02005 	mov	r2, r5
3480bae4:	e0800007 	add	r0, r0, r7
3480bae8:	eb0041cc 	bl	3481c220 <strncpy>
			res_str_len += len;
3480baec:	e1a07004 	mov	r7, r4
		}
		inp = ++p;
3480baf0:	e28bb001 	add	fp, fp, #1
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480baf4:	e1a0000b 	mov	r0, fp
3480baf8:	e3a01003 	mov	r1, #3
3480bafc:	eb00420f 	bl	3481c340 <strchr>
		*p = '\0';
3480bb00:	e3a03000 	mov	r3, #0
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480bb04:	e35b0000 	cmp	fp, #0
			strncpy((res_str + res_str_len), inp, len);
			res_str_len += len;
		}
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480bb08:	e1a09000 	mov	r9, r0
		*p = '\0';
3480bb0c:	e5c03000 	strb	r3, [r0]
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480bb10:	0a000071 	beq	3480bcdc <insert_var_value_sub+0x240>
		return NULL;

	sep = strchr(src, ':');
3480bb14:	e1a0000b 	mov	r0, fp
3480bb18:	e3a0103a 	mov	r1, #58	; 0x3a
3480bb1c:	eb004207 	bl	3481c340 <strchr>

	if (sep) {
3480bb20:	e250a000 	subs	sl, r0, #0
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480bb24:	01a0500a 	moveq	r5, sl
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
3480bb28:	01a0200a 	moveq	r2, sl
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480bb2c:	01a0400a 	moveq	r4, sl
	if (!src)
		return NULL;

	sep = strchr(src, ':');

	if (sep) {
3480bb30:	0a000013 	beq	3480bb84 <insert_var_value_sub+0xe8>
		*sep = '\0';
3480bb34:	e3a03000 	mov	r3, #0
3480bb38:	e5ca3000 	strb	r3, [sl]
		if (*(sep + 1) == '-')
3480bb3c:	e5da3001 	ldrb	r3, [sl, #1]
3480bb40:	e353002d 	cmp	r3, #45	; 0x2d
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480bb44:	03a05000 	moveq	r5, #0
	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
3480bb48:	028a4002 	addeq	r4, sl, #2
3480bb4c:	01a02005 	moveq	r2, r5

	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
3480bb50:	0a00000b 	beq	3480bb84 <insert_var_value_sub+0xe8>
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480bb54:	e353003d 	cmp	r3, #61	; 0x3d
			default_val = sep+2;
3480bb58:	028a4002 	addeq	r4, sl, #2
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480bb5c:	03a05000 	moveq	r5, #0
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
3480bb60:	03a02001 	moveq	r2, #1

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480bb64:	0a000006 	beq	3480bb84 <insert_var_value_sub+0xe8>
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480bb68:	e353002b 	cmp	r3, #43	; 0x2b
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480bb6c:	13a05000 	movne	r5, #0
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480bb70:	028a4002 	addeq	r4, sl, #2
			expand_empty = 1;
3480bb74:	03a05001 	moveq	r5, #1
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480bb78:	03a02000 	moveq	r2, #0
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480bb7c:	11a02005 	movne	r2, r5
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480bb80:	11a04005 	movne	r4, r5
			default_val = sep+2;
			expand_empty = 1;
		}
	}

	p = getenv(src);
3480bb84:	e1a0000b 	mov	r0, fp
3480bb88:	e58d2004 	str	r2, [sp, #4]
3480bb8c:	ebfff0df 	bl	34807f10 <getenv>
	if (!p)
3480bb90:	e2503000 	subs	r3, r0, #0
3480bb94:	e59d2004 	ldr	r2, [sp, #4]
3480bb98:	1a000004 	bne	3480bbb0 <insert_var_value_sub+0x114>
		p = get_local_var(src);
3480bb9c:	e1a0000b 	mov	r0, fp
3480bba0:	ebffff2b 	bl	3480b854 <get_local_var>

	if (!p || strlen(p) == 0) {
3480bba4:	e2503000 	subs	r3, r0, #0
3480bba8:	e59d2004 	ldr	r2, [sp, #4]
3480bbac:	0a000005 	beq	3480bbc8 <insert_var_value_sub+0x12c>
3480bbb0:	e1a00003 	mov	r0, r3
3480bbb4:	e98d000c 	stmib	sp, {r2, r3}
3480bbb8:	eb0041f6 	bl	3481c398 <strlen>
3480bbbc:	e3500000 	cmp	r0, #0
3480bbc0:	e99d000c 	ldmib	sp, {r2, r3}
3480bbc4:	1a000015 	bne	3480bc20 <insert_var_value_sub+0x184>
		p = default_val;
		if (assign) {
3480bbc8:	e3520000 	cmp	r2, #0
3480bbcc:	0a00001b 	beq	3480bc40 <insert_var_value_sub+0x1a4>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
3480bbd0:	e1a0000b 	mov	r0, fp
3480bbd4:	eb0041ef 	bl	3481c398 <strlen>
3480bbd8:	e1a05000 	mov	r5, r0
3480bbdc:	e1a00004 	mov	r0, r4
3480bbe0:	eb0041ec 	bl	3481c398 <strlen>
3480bbe4:	e0850000 	add	r0, r5, r0
3480bbe8:	e2800002 	add	r0, r0, #2
3480bbec:	ebfff97c 	bl	3480a1e4 <malloc>
			if (var) {
3480bbf0:	e2505000 	subs	r5, r0, #0
3480bbf4:	0a000006 	beq	3480bc14 <insert_var_value_sub+0x178>
				sprintf(var, "%s=%s", src, default_val);
3480bbf8:	e59f1164 	ldr	r1, [pc, #356]	; 3480bd64 <insert_var_value_sub+0x2c8>
3480bbfc:	e1a0200b 	mov	r2, fp
3480bc00:	e1a03004 	mov	r3, r4
3480bc04:	eb00461c 	bl	3481d47c <sprintf>
				set_local_var(var, 0);
3480bc08:	e1a00005 	mov	r0, r5
3480bc0c:	e3a01000 	mov	r1, #0
3480bc10:	ebffff33 	bl	3480b8e4 <set_local_var>
			}
			free(var);
3480bc14:	e1a00005 	mov	r0, r5
3480bc18:	ebfff8e8 	bl	34809fc0 <free>
3480bc1c:	ea000007 	b	3480bc40 <insert_var_value_sub+0x1a4>
		}
	} else if (expand_empty) {
3480bc20:	e3550000 	cmp	r5, #0
3480bc24:	01a04003 	moveq	r4, r3
3480bc28:	0a000004 	beq	3480bc40 <insert_var_value_sub+0x1a4>
		p += strlen(p);
3480bc2c:	e1a00003 	mov	r0, r3
3480bc30:	e58d3008 	str	r3, [sp, #8]
3480bc34:	eb0041d7 	bl	3481c398 <strlen>
3480bc38:	e59d3008 	ldr	r3, [sp, #8]
3480bc3c:	e0834000 	add	r4, r3, r0
	}

	if (sep)
3480bc40:	e35a0000 	cmp	sl, #0
		*sep = ':';
3480bc44:	13a0303a 	movne	r3, #58	; 0x3a
3480bc48:	15ca3000 	strbne	r3, [sl]
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
		*p = '\0';
		/* look up the value to substitute */
		if ((p1 = lookup_param(inp))) {
3480bc4c:	e3540000 	cmp	r4, #0
3480bc50:	0a000021 	beq	3480bcdc <insert_var_value_sub+0x240>
			if (tag_subst)
3480bc54:	e59d300c 	ldr	r3, [sp, #12]
3480bc58:	e3530000 	cmp	r3, #0
3480bc5c:	0a000004 	beq	3480bc74 <insert_var_value_sub+0x1d8>
				len = res_str_len + strlen(p1) + 2;
3480bc60:	e1a00004 	mov	r0, r4
3480bc64:	eb0041cb 	bl	3481c398 <strlen>
3480bc68:	e2875002 	add	r5, r7, #2
3480bc6c:	e0855000 	add	r5, r5, r0
3480bc70:	ea000002 	b	3480bc80 <insert_var_value_sub+0x1e4>
			else
				len = res_str_len + strlen(p1);
3480bc74:	e1a00004 	mov	r0, r4
3480bc78:	eb0041c6 	bl	3481c398 <strlen>
3480bc7c:	e0805007 	add	r5, r0, r7
			res_str = xrealloc(res_str, (1 + len));
3480bc80:	e1a00006 	mov	r0, r6
3480bc84:	e2851001 	add	r1, r5, #1
3480bc88:	ebfffe96 	bl	3480b6e8 <xrealloc>
			if (tag_subst) {
3480bc8c:	e59d300c 	ldr	r3, [sp, #12]
		if ((p1 = lookup_param(inp))) {
			if (tag_subst)
				len = res_str_len + strlen(p1) + 2;
			else
				len = res_str_len + strlen(p1);
			res_str = xrealloc(res_str, (1 + len));
3480bc90:	e1a06000 	mov	r6, r0
			if (tag_subst) {
3480bc94:	e3530000 	cmp	r3, #0
3480bc98:	0a00000b 	beq	3480bccc <insert_var_value_sub+0x230>
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len + 1), p1);
3480bc9c:	e287a001 	add	sl, r7, #1
3480bca0:	e080a00a 	add	sl, r0, sl
3480bca4:	e1a01004 	mov	r1, r4
3480bca8:	e1a0000a 	mov	r0, sl
3480bcac:	eb004154 	bl	3481c204 <strcpy>

				/*
				 * mark the replaced text to be accepted as
				 * is
				 */
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480bcb0:	e3a03004 	mov	r3, #4
3480bcb4:	e7c63007 	strb	r3, [r6, r7]
				res_str[res_str_len + 1 + strlen(p1)] =
3480bcb8:	e1a00004 	mov	r0, r4
3480bcbc:	eb0041b5 	bl	3481c398 <strlen>
3480bcc0:	e3a03004 	mov	r3, #4
3480bcc4:	e7ca3000 	strb	r3, [sl, r0]
3480bcc8:	ea000002 	b	3480bcd8 <insert_var_value_sub+0x23c>
			} else
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len), p1);
3480bccc:	e0800007 	add	r0, r0, r7
3480bcd0:	e1a01004 	mov	r1, r4
3480bcd4:	eb00414a 	bl	3481c204 <strcpy>

			res_str_len = len;
3480bcd8:	e1a07005 	mov	r7, r5
		}
		*p = SPECIAL_VAR_SYMBOL;
3480bcdc:	e3a03003 	mov	r3, #3
3480bce0:	e4c93001 	strb	r3, [r9], #1
		inp = ++p;
		done = 1;
3480bce4:	e3a05001 	mov	r5, #1
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480bce8:	e1a00009 	mov	r0, r9
3480bcec:	e3a01003 	mov	r1, #3
3480bcf0:	eb004192 	bl	3481c340 <strchr>
3480bcf4:	e250b000 	subs	fp, r0, #0
3480bcf8:	1affff6f 	bne	3480babc <insert_var_value_sub+0x20>
		}
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
3480bcfc:	e3550000 	cmp	r5, #0
3480bd00:	e1a04006 	mov	r4, r6
3480bd04:	0a000011 	beq	3480bd50 <insert_var_value_sub+0x2b4>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480bd08:	e1a00009 	mov	r0, r9
3480bd0c:	eb0041a1 	bl	3481c398 <strlen>
3480bd10:	e2871001 	add	r1, r7, #1
3480bd14:	e0811000 	add	r1, r1, r0
3480bd18:	e1a00006 	mov	r0, r6
3480bd1c:	ebfffe71 	bl	3480b6e8 <xrealloc>
		strcpy((res_str + res_str_len), inp);
3480bd20:	e1a01009 	mov	r1, r9
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480bd24:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
3480bd28:	e0800007 	add	r0, r0, r7
3480bd2c:	eb004134 	bl	3481c204 <strcpy>
		while ((p = strchr(res_str, '\n'))) {
			*p = ' ';
3480bd30:	e3a05020 	mov	r5, #32
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480bd34:	ea000000 	b	3480bd3c <insert_var_value_sub+0x2a0>
			*p = ' ';
3480bd38:	e5c05000 	strb	r5, [r0]
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480bd3c:	e1a00004 	mov	r0, r4
3480bd40:	e3a0100a 	mov	r1, #10
3480bd44:	eb00417d 	bl	3481c340 <strchr>
3480bd48:	e3500000 	cmp	r0, #0
3480bd4c:	1afffff9 	bne	3480bd38 <insert_var_value_sub+0x29c>
			*p = ' ';
		}
	}
	return (res_str == NULL) ? inp : res_str;
}
3480bd50:	e3540000 	cmp	r4, #0
3480bd54:	11a00004 	movne	r0, r4
3480bd58:	01a00009 	moveq	r0, r9
3480bd5c:	e28dd010 	add	sp, sp, #16
3480bd60:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480bd64:	3482618b 	.word	0x3482618b

3480bd68 <unset_local_var>:
#endif
	return result;
}

void unset_local_var(const char *name)
{
3480bd68:	e92d4070 	push	{r4, r5, r6, lr}
	struct variables *cur;

	if (name) {
3480bd6c:	e2505000 	subs	r5, r0, #0
		for (cur = top_vars; cur; cur=cur->next) {
3480bd70:	159f3088 	ldrne	r3, [pc, #136]	; 3480be00 <unset_local_var+0x98>
3480bd74:	15934000 	ldrne	r4, [r3]

void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
3480bd78:	1a000006 	bne	3480bd98 <unset_local_var+0x30>
3480bd7c:	e8bd8070 	pop	{r4, r5, r6, pc}
		for (cur = top_vars; cur; cur=cur->next) {
			if(strcmp(cur->name, name)==0)
3480bd80:	e5940000 	ldr	r0, [r4]
3480bd84:	e1a01005 	mov	r1, r5
3480bd88:	eb00414e 	bl	3481c2c8 <strcmp>
3480bd8c:	e3500000 	cmp	r0, #0
3480bd90:	0a000003 	beq	3480bda4 <unset_local_var+0x3c>
void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
		for (cur = top_vars; cur; cur=cur->next) {
3480bd94:	e5944010 	ldr	r4, [r4, #16]
3480bd98:	e3540000 	cmp	r4, #0
3480bd9c:	1afffff7 	bne	3480bd80 <unset_local_var+0x18>
3480bda0:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(strcmp(cur->name, name)==0)
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
3480bda4:	e59f3054 	ldr	r3, [pc, #84]	; 3480be00 <unset_local_var+0x98>
3480bda8:	e5936000 	ldr	r6, [r3]
			if(cur->flg_read_only) {
3480bdac:	e594300c 	ldr	r3, [r4, #12]
3480bdb0:	e3530000 	cmp	r3, #0
3480bdb4:	0a000003 	beq	3480bdc8 <unset_local_var+0x60>
				error_msg("%s: readonly variable", name);
3480bdb8:	e59f0044 	ldr	r0, [pc, #68]	; 3480be04 <unset_local_var+0x9c>
3480bdbc:	e1a01005 	mov	r1, r5
				next->next = cur->next;
			}
			free(cur);
		}
	}
}
3480bdc0:	e8bd4070 	pop	{r4, r5, r6, lr}
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
			if(cur->flg_read_only) {
				error_msg("%s: readonly variable", name);
3480bdc4:	eafff73f 	b	34809ac8 <printf>
			} else {
#ifndef __U_BOOT__
				if(cur->flg_export)
					unsetenv(cur->name);
#endif
				free(cur->name);
3480bdc8:	e5940000 	ldr	r0, [r4]
3480bdcc:	ebfff87b 	bl	34809fc0 <free>
				free(cur->value);
3480bdd0:	e5940004 	ldr	r0, [r4, #4]
3480bdd4:	ebfff879 	bl	34809fc0 <free>
				while (next->next != cur)
3480bdd8:	ea000000 	b	3480bde0 <unset_local_var+0x78>
3480bddc:	e1a06003 	mov	r6, r3
3480bde0:	e5963010 	ldr	r3, [r6, #16]
3480bde4:	e1530004 	cmp	r3, r4
3480bde8:	1afffffb 	bne	3480bddc <unset_local_var+0x74>
					next = next->next;
				next->next = cur->next;
3480bdec:	e5943010 	ldr	r3, [r4, #16]
			}
			free(cur);
3480bdf0:	e1a00004 	mov	r0, r4
#endif
				free(cur->name);
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
3480bdf4:	e5863010 	str	r3, [r6, #16]
			}
			free(cur);
		}
	}
}
3480bdf8:	e8bd4070 	pop	{r4, r5, r6, lr}
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
			}
			free(cur);
3480bdfc:	eafff86f 	b	34809fc0 <free>
3480be00:	34829d28 	.word	0x34829d28
3480be04:	34826175 	.word	0x34826175

3480be08 <new_pipe>:
	}
	return 0;
}
#endif

struct pipe *new_pipe(void) {
3480be08:	e92d4008 	push	{r3, lr}
	struct pipe *pi;
	pi = xmalloc(sizeof(struct pipe));
3480be0c:	e3a00014 	mov	r0, #20
3480be10:	ebfffd8b 	bl	3480b444 <xmalloc>
	pi->num_progs = 0;
3480be14:	e3a02000 	mov	r2, #0
3480be18:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
3480be1c:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
3480be20:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
3480be24:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
3480be28:	e5802010 	str	r2, [r0, #16]
	return pi;
}
3480be2c:	e8bd8008 	pop	{r3, pc}

3480be30 <done_pipe>:
	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}

static int done_pipe(struct p_context *ctx, pipe_style type)
{
3480be30:	e92d4038 	push	{r3, r4, r5, lr}
3480be34:	e1a04000 	mov	r4, r0
3480be38:	e1a05001 	mov	r5, r1
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
3480be3c:	ebfffe31 	bl	3480b708 <done_command>
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480be40:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
3480be44:	e594200c 	ldr	r2, [r4, #12]
static int done_pipe(struct p_context *ctx, pipe_style type)
{
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480be48:	e583500c 	str	r5, [r3, #12]
	ctx->pipe->r_mode = ctx->w;
3480be4c:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
3480be50:	ebffffec 	bl	3480be08 <new_pipe>
	ctx->pipe->next = new_p;
3480be54:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe = new_p;
	ctx->child = NULL;
3480be58:	e3a05000 	mov	r5, #0
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
	ctx->pipe->r_mode = ctx->w;
	new_p=new_pipe();
	ctx->pipe->next = new_p;
3480be5c:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
3480be60:	e5840008 	str	r0, [r4, #8]
	ctx->child = NULL;
3480be64:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
3480be68:	e1a00004 	mov	r0, r4
3480be6c:	ebfffe25 	bl	3480b708 <done_command>
	return 0;
}
3480be70:	e1a00005 	mov	r0, r5
3480be74:	e8bd8038 	pop	{r3, r4, r5, pc}

3480be78 <reserved_word>:
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480be78:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	{ "do",    RES_DO,    FLAG_DONE },
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
3480be7c:	e59f719c 	ldr	r7, [pc, #412]	; 3480c020 <reserved_word+0x1a8>
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480be80:	e59f619c 	ldr	r6, [pc, #412]	; 3480c024 <reserved_word+0x1ac>
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480be84:	e1a05000 	mov	r5, r0
3480be88:	e1a04001 	mov	r4, r1
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
3480be8c:	e5950000 	ldr	r0, [r5]
3480be90:	e5961000 	ldr	r1, [r6]
3480be94:	eb00410b 	bl	3481c2c8 <strcmp>
3480be98:	e2509000 	subs	r9, r0, #0
3480be9c:	1a000056 	bne	3480bffc <reserved_word+0x184>
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
3480bea0:	e5963008 	ldr	r3, [r6, #8]
3480bea4:	e3130b02 	tst	r3, #2048	; 0x800
3480bea8:	0a000025 	beq	3480bf44 <reserved_word+0xcc>
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480beac:	e280001c 	add	r0, r0, #28
3480beb0:	ebfffd63 	bl	3480b444 <xmalloc>
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480beb4:	e594700c 	ldr	r7, [r4, #12]
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480beb8:	e1a0a000 	mov	sl, r0
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480bebc:	e357000c 	cmp	r7, #12
3480bec0:	13570006 	cmpne	r7, #6
3480bec4:	13a07000 	movne	r7, #0
3480bec8:	03a07001 	moveq	r7, #1
3480becc:	1a00000a 	bne	3480befc <reserved_word+0x84>
					syntax();
3480bed0:	ebfffd1c 	bl	3480b348 <syntax_err>
					free(new);
3480bed4:	e1a0000a 	mov	r0, sl
3480bed8:	ebfff838 	bl	34809fc0 <free>
					ctx->w = RES_SNTX;
3480bedc:	e3a0300d 	mov	r3, #13
3480bee0:	e584300c 	str	r3, [r4, #12]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480bee4:	e5953000 	ldr	r3, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480bee8:	e5859004 	str	r9, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480beec:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480bef0:	e5859010 	str	r9, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480bef4:	15c39000 	strbne	r9, [r3]
3480bef8:	ea000044 	b	3480c010 <reserved_word+0x198>
					free(new);
					ctx->w = RES_SNTX;
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
3480befc:	e1a0c004 	mov	ip, r4
3480bf00:	e1a0e00a 	mov	lr, sl
3480bf04:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
3480bf08:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
3480bf0c:	e89c0007 	ldm	ip, {r0, r1, r2}
3480bf10:	e88e0007 	stm	lr, {r0, r1, r2}
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480bf14:	e5847008 	str	r7, [r4, #8]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480bf18:	e5847000 	str	r7, [r4]
	ctx->list_head=new_pipe();
3480bf1c:	ebffffb9 	bl	3480be08 <new_pipe>
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480bf20:	e584700c 	str	r7, [r4, #12]
	ctx->pipe=NULL;
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
3480bf24:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
3480bf28:	e5840008 	str	r0, [r4, #8]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
3480bf2c:	e5847014 	str	r7, [r4, #20]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480bf30:	e5847010 	str	r7, [r4, #16]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480bf34:	e1a00004 	mov	r0, r4
3480bf38:	ebfffdf2 	bl	3480b708 <done_command>
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
3480bf3c:	e584a014 	str	sl, [r4, #20]
3480bf40:	ea000011 	b	3480bf8c <reserved_word+0x114>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
3480bf44:	e594300c 	ldr	r3, [r4, #12]
3480bf48:	e3530000 	cmp	r3, #0
3480bf4c:	0a000004 	beq	3480bf64 <reserved_word+0xec>
3480bf50:	e5942010 	ldr	r2, [r4, #16]
3480bf54:	e5963004 	ldr	r3, [r6, #4]
3480bf58:	e1a03352 	asr	r3, r2, r3
3480bf5c:	e3130001 	tst	r3, #1
3480bf60:	1a000009 	bne	3480bf8c <reserved_word+0x114>
				syntax();
3480bf64:	ebfffcf7 	bl	3480b348 <syntax_err>
				ctx->w = RES_SNTX;
3480bf68:	e3a0300d 	mov	r3, #13

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480bf6c:	e5952000 	ldr	r2, [r5]
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
3480bf70:	e584300c 	str	r3, [r4, #12]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480bf74:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480bf78:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480bf7c:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480bf80:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480bf84:	1a00001a 	bne	3480bff4 <reserved_word+0x17c>
3480bf88:	ea000020 	b	3480c010 <reserved_word+0x198>
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
3480bf8c:	e5963004 	ldr	r3, [r6, #4]
3480bf90:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
3480bf94:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
3480bf98:	e3130001 	tst	r3, #1
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
			ctx->old_flag = r->flag;
3480bf9c:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
3480bfa0:	0a00000d 	beq	3480bfdc <reserved_word+0x164>
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
3480bfa4:	e1a00004 	mov	r0, r4
3480bfa8:	e3a01001 	mov	r1, #1
3480bfac:	ebffff9f 	bl	3480be30 <done_pipe>
				old = ctx->stack;
3480bfb0:	e594c014 	ldr	ip, [r4, #20]
				old->child->group = ctx->list_head;
3480bfb4:	e5942004 	ldr	r2, [r4, #4]
3480bfb8:	e59c3000 	ldr	r3, [ip]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480bfbc:	e1a0e00c 	mov	lr, ip
			if (ctx->old_flag & FLAG_END) {
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
				old = ctx->stack;
				old->child->group = ctx->list_head;
3480bfc0:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480bfc4:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
3480bfc8:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
3480bfcc:	e89e0007 	ldm	lr, {r0, r1, r2}
3480bfd0:	e8840007 	stm	r4, {r0, r1, r2}
				free(old);
3480bfd4:	e1a0000c 	mov	r0, ip
3480bfd8:	ebfff7f8 	bl	34809fc0 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480bfdc:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480bfe0:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480bfe4:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480bfe8:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480bfec:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480bff0:	0a000008 	beq	3480c018 <reserved_word+0x1a0>
3480bff4:	e5c23000 	strb	r3, [r2]
3480bff8:	ea000004 	b	3480c010 <reserved_word+0x198>

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
3480bffc:	e286600c 	add	r6, r6, #12
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480c000:	e1560007 	cmp	r6, r7
3480c004:	1affffa0 	bne	3480be8c <reserved_word+0x14>
			}
			b_reset (dest);
			return 1;
		}
	}
	return 0;
3480c008:	e3a00000 	mov	r0, #0
3480c00c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
3480c010:	e3a00001 	mov	r0, #1
3480c014:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
				*ctx = *old;   /* physical copy */
				free(old);
			}
			b_reset (dest);
			return 1;
3480c018:	e3a00001 	mov	r0, #1
		}
	}
	return 0;
}
3480c01c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480c020:	348289bc 	.word	0x348289bc
3480c024:	34828938 	.word	0x34828938

3480c028 <done_word>:

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c028:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c02c:	e5903004 	ldr	r3, [r0, #4]
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c030:	e1a04000 	mov	r4, r0
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c034:	e3530000 	cmp	r3, #0
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c038:	e1a05001 	mov	r5, r1
	struct child_prog *child=ctx->child;
3480c03c:	e5916000 	ldr	r6, [r1]
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c040:	1a000002 	bne	3480c050 <done_word+0x28>
3480c044:	e5900010 	ldr	r0, [r0, #16]
3480c048:	e3500000 	cmp	r0, #0
3480c04c:	08bd86f8 	popeq	{r3, r4, r5, r6, r7, r9, sl, pc}
#ifndef __U_BOOT__
	if (ctx->pending_redirect) {
		glob_target = &ctx->pending_redirect->word;
	} else {
#endif
		if (child->group) {
3480c050:	e5963008 	ldr	r3, [r6, #8]
3480c054:	e3530000 	cmp	r3, #0
3480c058:	0a000001 	beq	3480c064 <done_word+0x3c>
			syntax();
3480c05c:	ebfffcb9 	bl	3480b348 <syntax_err>
3480c060:	ea00004a 	b	3480c190 <done_word+0x168>
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
3480c064:	e5963000 	ldr	r3, [r6]
3480c068:	e3530000 	cmp	r3, #0
3480c06c:	1a00000c 	bne	3480c0a4 <done_word+0x7c>
3480c070:	e5953018 	ldr	r3, [r5, #24]
3480c074:	e3130002 	tst	r3, #2
3480c078:	0a000009 	beq	3480c0a4 <done_word+0x7c>
			debug_printf("checking %s for reserved-ness\n",dest->data);
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
3480c07c:	e1a00004 	mov	r0, r4
3480c080:	e1a01005 	mov	r1, r5
3480c084:	ebffff7b 	bl	3480be78 <reserved_word>
3480c088:	e3500000 	cmp	r0, #0
3480c08c:	0a000004 	beq	3480c0a4 <done_word+0x7c>
3480c090:	e595000c 	ldr	r0, [r5, #12]
3480c094:	e350000d 	cmp	r0, #13
3480c098:	13a00000 	movne	r0, #0
3480c09c:	03a00001 	moveq	r0, #1
3480c0a0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480c0a4:	e5943000 	ldr	r3, [r4]
3480c0a8:	e3a00001 	mov	r0, #1
3480c0ac:	ea000003 	b	3480c0c0 <done_word+0x98>
			if (*s == '\\') s++;
3480c0b0:	e352005c 	cmp	r2, #92	; 0x5c
3480c0b4:	02833001 	addeq	r3, r3, #1
			cnt++;
3480c0b8:	e2800001 	add	r0, r0, #1
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480c0bc:	e2833001 	add	r3, r3, #1
3480c0c0:	e3530000 	cmp	r3, #0
3480c0c4:	0a000002 	beq	3480c0d4 <done_word+0xac>
3480c0c8:	e5d32000 	ldrb	r2, [r3]
3480c0cc:	e3520000 	cmp	r2, #0
3480c0d0:	1afffff6 	bne	3480c0b0 <done_word+0x88>
			if (*s == '\\') s++;
			cnt++;
		}
		str = malloc(cnt);
3480c0d4:	ebfff842 	bl	3480a1e4 <malloc>
		if (!str) return 1;
3480c0d8:	e2507000 	subs	r7, r0, #0
3480c0dc:	0a00002b 	beq	3480c190 <done_word+0x168>
		if ( child->argv == NULL) {
3480c0e0:	e5960000 	ldr	r0, [r6]
3480c0e4:	e3500000 	cmp	r0, #0
			child->argc=0;
3480c0e8:	05860004 	streq	r0, [r6, #4]
		}
		argc = ++child->argc;
3480c0ec:	e5969004 	ldr	r9, [r6, #4]
3480c0f0:	e289a001 	add	sl, r9, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c0f4:	e28a1001 	add	r1, sl, #1
		str = malloc(cnt);
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
3480c0f8:	e586a004 	str	sl, [r6, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c0fc:	e1a01101 	lsl	r1, r1, #2
3480c100:	ebfffa29 	bl	3480a9ac <realloc>
		if (child->argv == NULL) return 1;
3480c104:	e3500000 	cmp	r0, #0
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c108:	e5860000 	str	r0, [r6]
		if (child->argv == NULL) return 1;
3480c10c:	0a00001f 	beq	3480c190 <done_word+0x168>
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
3480c110:	e3a03000 	mov	r3, #0
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
3480c114:	e7807109 	str	r7, [r0, r9, lsl #2]
		child->argv[argc]=NULL;
3480c118:	e780310a 	str	r3, [r0, sl, lsl #2]
		for (s = dest->data; s && *s; s++,str++) {
3480c11c:	e5943000 	ldr	r3, [r4]
3480c120:	ea000003 	b	3480c134 <done_word+0x10c>
			if (*s == '\\') s++;
3480c124:	e352005c 	cmp	r2, #92	; 0x5c
3480c128:	02833001 	addeq	r3, r3, #1
			*str = *s;
3480c12c:	e4d32001 	ldrb	r2, [r3], #1
3480c130:	e4c72001 	strb	r2, [r7], #1
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
		for (s = dest->data; s && *s; s++,str++) {
3480c134:	e3530000 	cmp	r3, #0
3480c138:	0a000002 	beq	3480c148 <done_word+0x120>
3480c13c:	e5d32000 	ldrb	r2, [r3]
3480c140:	e3520000 	cmp	r2, #0
3480c144:	1afffff6 	bne	3480c124 <done_word+0xfc>
			if (*s == '\\') s++;
			*str = *s;
		}
		*str = '\0';
3480c148:	e3a03000 	mov	r3, #0
3480c14c:	e5c73000 	strb	r3, [r7]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c150:	e5942000 	ldr	r2, [r4]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c154:	e5843004 	str	r3, [r4, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c158:	e1520003 	cmp	r2, r3
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480c15c:	e5843010 	str	r3, [r4, #16]
	if (o->data != NULL) *o->data = '\0';
3480c160:	15c23000 	strbne	r3, [r2]
		}
	} else {
		child->argv = glob_target->gl_pathv;
	}
#endif
	if (ctx->w == RES_FOR) {
3480c164:	e595300c 	ldr	r3, [r5, #12]
3480c168:	e3530006 	cmp	r3, #6
3480c16c:	1a000009 	bne	3480c198 <done_word+0x170>
		done_word(dest,ctx);
3480c170:	e1a01005 	mov	r1, r5
3480c174:	e1a00004 	mov	r0, r4
3480c178:	ebffffaa 	bl	3480c028 <done_word>
		done_pipe(ctx,PIPE_SEQ);
3480c17c:	e1a00005 	mov	r0, r5
3480c180:	e3a01001 	mov	r1, #1
3480c184:	ebffff29 	bl	3480be30 <done_pipe>
	}
	return 0;
3480c188:	e3a00000 	mov	r0, #0
3480c18c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
3480c190:	e3a00001 	mov	r0, #1
3480c194:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
	if (ctx->w == RES_FOR) {
		done_word(dest,ctx);
		done_pipe(ctx,PIPE_SEQ);
	}
	return 0;
3480c198:	e3a00000 	mov	r0, #0
}
3480c19c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

3480c1a0 <mapset>:
}

void mapset(const unsigned char *set, int code)
{
	const unsigned char *s;
	for (s=set; *s; s++) map[*s] = code;
3480c1a0:	e59f2018 	ldr	r2, [pc, #24]	; 3480c1c0 <mapset+0x20>
3480c1a4:	ea000001 	b	3480c1b0 <mapset+0x10>
3480c1a8:	e0823003 	add	r3, r2, r3
3480c1ac:	e5c31138 	strb	r1, [r3, #312]	; 0x138
3480c1b0:	e4d03001 	ldrb	r3, [r0], #1
3480c1b4:	e3530000 	cmp	r3, #0
3480c1b8:	1afffffa 	bne	3480c1a8 <mapset+0x8>
}
3480c1bc:	e12fff1e 	bx	lr
3480c1c0:	34829d28 	.word	0x34829d28

3480c1c4 <update_ifs_map>:

void update_ifs_map(void)
{
3480c1c4:	e92d4013 	push	{r0, r1, r4, lr}
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c1c8:	e59f006c 	ldr	r0, [pc, #108]	; 3480c23c <update_ifs_map+0x78>
3480c1cc:	ebffef4f 	bl	34807f10 <getenv>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480c1d0:	e3500000 	cmp	r0, #0
3480c1d4:	059f2064 	ldreq	r2, [pc, #100]	; 3480c240 <update_ifs_map+0x7c>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c1d8:	e59f3064 	ldr	r3, [pc, #100]	; 3480c244 <update_ifs_map+0x80>
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c1dc:	e59f4060 	ldr	r4, [pc, #96]	; 3480c244 <update_ifs_map+0x80>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c1e0:	e5830238 	str	r0, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c1e4:	e3a01000 	mov	r1, #0

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480c1e8:	05832238 	streq	r2, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c1ec:	e2840f4e 	add	r0, r4, #312	; 0x138
3480c1f0:	e3a02c01 	mov	r2, #256	; 0x100
3480c1f4:	eb004107 	bl	3481c618 <memset>
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c1f8:	e3a03004 	mov	r3, #4
3480c1fc:	e5cd3004 	strb	r3, [sp, #4]
		mapset(subst, 3);       /* never flow through */
3480c200:	e28d0004 	add	r0, sp, #4
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c204:	e3a03000 	mov	r3, #0
		mapset(subst, 3);       /* never flow through */
3480c208:	e3a01003 	mov	r1, #3
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c20c:	e5cd3005 	strb	r3, [sp, #5]
		mapset(subst, 3);       /* never flow through */
3480c210:	ebffffe2 	bl	3480c1a0 <mapset>
	}
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
3480c214:	e59f002c 	ldr	r0, [pc, #44]	; 3480c248 <update_ifs_map+0x84>
3480c218:	e3a01003 	mov	r1, #3
3480c21c:	ebffffdf 	bl	3480c1a0 <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
3480c220:	e59f0024 	ldr	r0, [pc, #36]	; 3480c24c <update_ifs_map+0x88>
3480c224:	e3a01001 	mov	r1, #1
3480c228:	ebffffdc 	bl	3480c1a0 <mapset>
#endif
	mapset(ifs, 2);            /* also flow through if quoted */
3480c22c:	e5940238 	ldr	r0, [r4, #568]	; 0x238
3480c230:	e3a01002 	mov	r1, #2
3480c234:	ebffffd9 	bl	3480c1a0 <mapset>
}
3480c238:	e8bd801c 	pop	{r2, r3, r4, pc}
3480c23c:	34826191 	.word	0x34826191
3480c240:	34826195 	.word	0x34826195
3480c244:	34829d28 	.word	0x34829d28
3480c248:	34826199 	.word	0x34826199
3480c24c:	3482619e 	.word	0x3482619e

3480c250 <parse_string_outer>:
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480c250:	e92d4070 	push	{r4, r5, r6, lr}
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480c254:	e2504000 	subs	r4, r0, #0
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480c258:	e24dd018 	sub	sp, sp, #24
3480c25c:	e1a06001 	mov	r6, r1
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480c260:	0a00002f 	beq	3480c324 <parse_string_outer+0xd4>
3480c264:	e5d43000 	ldrb	r3, [r4]
3480c268:	e3530000 	cmp	r3, #0
3480c26c:	0a00002c 	beq	3480c324 <parse_string_outer+0xd4>
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
3480c270:	e3a0100a 	mov	r1, #10
3480c274:	eb004031 	bl	3481c340 <strchr>
3480c278:	e3500000 	cmp	r0, #0
3480c27c:	0a000002 	beq	3480c28c <parse_string_outer+0x3c>
3480c280:	e5d03001 	ldrb	r3, [r0, #1]
3480c284:	e3530000 	cmp	r3, #0
3480c288:	0a000018 	beq	3480c2f0 <parse_string_outer+0xa0>
		p = xmalloc(strlen(s) + 2);
3480c28c:	e1a00004 	mov	r0, r4
3480c290:	eb004040 	bl	3481c398 <strlen>
3480c294:	e2800002 	add	r0, r0, #2
3480c298:	ebfffc69 	bl	3480b444 <xmalloc>
		strcpy(p, s);
3480c29c:	e1a01004 	mov	r1, r4
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
3480c2a0:	e1a05000 	mov	r5, r0
		strcpy(p, s);
3480c2a4:	eb003fd6 	bl	3481c204 <strcpy>
		strcat(p, "\n");
3480c2a8:	e1a00005 	mov	r0, r5
3480c2ac:	e59f1080 	ldr	r1, [pc, #128]	; 3480c334 <parse_string_outer+0xe4>
3480c2b0:	eb003fe4 	bl	3481c248 <strcat>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c2b4:	e59f307c 	ldr	r3, [pc, #124]	; 3480c338 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c2b8:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c2bc:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480c2c0:	e59f3074 	ldr	r3, [pc, #116]	; 3480c33c <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c2c4:	e5205014 	str	r5, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480c2c8:	e58d3010 	str	r3, [sp, #16]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480c2cc:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480c2d0:	e3a03001 	mov	r3, #1
3480c2d4:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c2d8:	e58d300c 	str	r3, [sp, #12]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480c2dc:	eb000210 	bl	3480cb24 <parse_stream_outer>
3480c2e0:	e1a04000 	mov	r4, r0
		free(p);
3480c2e4:	e1a00005 	mov	r0, r5
3480c2e8:	ebfff734 	bl	34809fc0 <free>
		return rcode;
3480c2ec:	ea00000d 	b	3480c328 <parse_string_outer+0xd8>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c2f0:	e59f3040 	ldr	r3, [pc, #64]	; 3480c338 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c2f4:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c2f8:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480c2fc:	e59f3038 	ldr	r3, [pc, #56]	; 3480c33c <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c300:	e5204014 	str	r4, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480c304:	e58d3010 	str	r3, [sp, #16]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480c308:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480c30c:	e3a03001 	mov	r3, #1
3480c310:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c314:	e58d300c 	str	r3, [sp, #12]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480c318:	eb000201 	bl	3480cb24 <parse_stream_outer>
3480c31c:	e1a04000 	mov	r4, r0
3480c320:	ea000000 	b	3480c328 <parse_string_outer+0xd8>
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
3480c324:	e3a04001 	mov	r4, #1
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
#ifdef __U_BOOT__
	}
#endif
}
3480c328:	e1a00004 	mov	r0, r4
3480c32c:	e28dd018 	add	sp, sp, #24
3480c330:	e8bd8070 	pop	{r4, r5, r6, pc}
3480c334:	34826197 	.word	0x34826197
3480c338:	3480b2dc 	.word	0x3480b2dc
3480c33c:	3480b2c0 	.word	0x3480b2c0

3480c340 <run_list_real>:
#endif
	return -1;
}

static int run_list_real(struct pipe *pi)
{
3480c340:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480c344:	e1a04000 	mov	r4, r0
3480c348:	e24dd038 	sub	sp, sp, #56	; 0x38
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c34c:	e1a05000 	mov	r5, r0
3480c350:	ea000023 	b	3480c3e4 <run_list_real+0xa4>
		if ((rpipe->r_mode == RES_IN ||
3480c354:	e5953010 	ldr	r3, [r5, #16]
3480c358:	e353000c 	cmp	r3, #12
3480c35c:	13a02000 	movne	r2, #0
3480c360:	03a02001 	moveq	r2, #1
3480c364:	e3530006 	cmp	r3, #6
3480c368:	13a03000 	movne	r3, #0
3480c36c:	03a03001 	moveq	r3, #1
3480c370:	e1930002 	orrs	r0, r3, r2
3480c374:	0a000019 	beq	3480c3e0 <run_list_real+0xa0>
		    rpipe->r_mode == RES_FOR) &&
		    (rpipe->next == NULL)) {
3480c378:	e5956008 	ldr	r6, [r5, #8]
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
		if ((rpipe->r_mode == RES_IN ||
		    rpipe->r_mode == RES_FOR) &&
3480c37c:	e3560000 	cmp	r6, #0
3480c380:	1a000003 	bne	3480c394 <run_list_real+0x54>
		    (rpipe->next == NULL)) {
				syntax();
3480c384:	ebfffbef 	bl	3480b348 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480c388:	e59f377c 	ldr	r3, [pc, #1916]	; 3480cb0c <run_list_real+0x7cc>
3480c38c:	e5836004 	str	r6, [r3, #4]
3480c390:	ea0001d7 	b	3480caf4 <run_list_real+0x7b4>
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
3480c394:	e3520000 	cmp	r2, #0
3480c398:	0a000006 	beq	3480c3b8 <run_list_real+0x78>
3480c39c:	e5963010 	ldr	r3, [r6, #16]
3480c3a0:	e353000c 	cmp	r3, #12
3480c3a4:	1a00000d 	bne	3480c3e0 <run_list_real+0xa0>
			(rpipe->next->r_mode == RES_IN &&
			rpipe->next->progs->argv != NULL))||
3480c3a8:	e5963004 	ldr	r3, [r6, #4]
				flag_repeat = 0;
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
			(rpipe->next->r_mode == RES_IN &&
3480c3ac:	e5933000 	ldr	r3, [r3]
3480c3b0:	e3530000 	cmp	r3, #0
3480c3b4:	ea000003 	b	3480c3c8 <run_list_real+0x88>
			rpipe->next->progs->argv != NULL))||
3480c3b8:	e3530000 	cmp	r3, #0
3480c3bc:	0a000007 	beq	3480c3e0 <run_list_real+0xa0>
			(rpipe->r_mode == RES_FOR &&
3480c3c0:	e5963010 	ldr	r3, [r6, #16]
3480c3c4:	e353000c 	cmp	r3, #12
3480c3c8:	0a000004 	beq	3480c3e0 <run_list_real+0xa0>
			rpipe->next->r_mode != RES_IN)) {
				syntax();
3480c3cc:	ebfffbdd 	bl	3480b348 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480c3d0:	e59f3734 	ldr	r3, [pc, #1844]	; 3480cb0c <run_list_real+0x7cc>
3480c3d4:	e3a02000 	mov	r2, #0
3480c3d8:	e5832004 	str	r2, [r3, #4]
3480c3dc:	ea0001c4 	b	3480caf4 <run_list_real+0x7b4>
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c3e0:	e5955008 	ldr	r5, [r5, #8]
3480c3e4:	e3550000 	cmp	r5, #0
3480c3e8:	1affffd9 	bne	3480c354 <run_list_real+0x14>
3480c3ec:	e3a09001 	mov	r9, #1
3480c3f0:	e1a07009 	mov	r7, r9
3480c3f4:	e3a0300b 	mov	r3, #11
3480c3f8:	e58d5028 	str	r5, [sp, #40]	; 0x28
3480c3fc:	e58d5018 	str	r5, [sp, #24]
3480c400:	e58d5014 	str	r5, [sp, #20]
3480c404:	e1a0a005 	mov	sl, r5
3480c408:	e1a0b005 	mov	fp, r5
3480c40c:	e58d5020 	str	r5, [sp, #32]
3480c410:	e1a06005 	mov	r6, r5
3480c414:	e58d501c 	str	r5, [sp, #28]
3480c418:	e1a09005 	mov	r9, r5
3480c41c:	ea0001b1 	b	3480cae8 <run_list_real+0x7a8>
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
3480c420:	e5942010 	ldr	r2, [r4, #16]
3480c424:	e2422006 	sub	r2, r2, #6
3480c428:	e3520002 	cmp	r2, #2
3480c42c:	8a00000a 	bhi	3480c45c <run_list_real+0x11c>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
3480c430:	e58d3008 	str	r3, [sp, #8]
3480c434:	ebfff5c8 	bl	34809b5c <ctrlc>
				if ((had_ctrlc())) {
3480c438:	ebfff5e0 	bl	34809bc0 <had_ctrlc>
3480c43c:	e3500000 	cmp	r0, #0
3480c440:	e59d3008 	ldr	r3, [sp, #8]
3480c444:	1a0001aa 	bne	3480caf4 <run_list_real+0x7b4>
					return 1;
				}
#endif
				flag_restore = 0;
				if (!rpipe) {
3480c448:	e3590000 	cmp	r9, #0
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480c44c:	158d0014 	strne	r0, [sp, #20]
				if (!rpipe) {
3480c450:	01a09004 	moveq	r9, r4
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480c454:	058d0014 	streq	r0, [sp, #20]
				if (!rpipe) {
					flag_rep = 0;
3480c458:	01a0b000 	moveq	fp, r0
					rpipe = pi;
				}
		}
		rmode = pi->r_mode;
3480c45c:	e5945010 	ldr	r5, [r4, #16]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
3480c460:	e1550003 	cmp	r5, r3
3480c464:	13a07000 	movne	r7, #0
3480c468:	02077001 	andeq	r7, r7, #1
3480c46c:	e3570000 	cmp	r7, #0
3480c470:	0a000003 	beq	3480c484 <run_list_real+0x144>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
3480c474:	e594700c 	ldr	r7, [r4, #12]
3480c478:	e2577001 	subs	r7, r7, #1
3480c47c:	13a07001 	movne	r7, #1
3480c480:	ea000194 	b	3480cad8 <run_list_real+0x798>
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c484:	e3550002 	cmp	r5, #2
3480c488:	13a02000 	movne	r2, #0
3480c48c:	03a02001 	moveq	r2, #1
3480c490:	e3550004 	cmp	r5, #4
3480c494:	13a03000 	movne	r3, #0
3480c498:	03a03001 	moveq	r3, #1
3480c49c:	e1931002 	orrs	r1, r3, r2
3480c4a0:	e59d0018 	ldr	r0, [sp, #24]
3480c4a4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480c4a8:	11a00001 	movne	r0, r1
		if (rmode == RES_THEN &&  if_code) continue;
3480c4ac:	e3500000 	cmp	r0, #0
3480c4b0:	03a02000 	moveq	r2, #0
3480c4b4:	12022001 	andne	r2, r2, #1
3480c4b8:	e3520000 	cmp	r2, #0
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c4bc:	e58d0018 	str	r0, [sp, #24]
		if (rmode == RES_THEN &&  if_code) continue;
3480c4c0:	1a000182 	bne	3480cad0 <run_list_real+0x790>
		if (rmode == RES_ELSE && !if_code) continue;
3480c4c4:	e2707001 	rsbs	r7, r0, #1
3480c4c8:	33a07000 	movcc	r7, #0
3480c4cc:	e1170003 	tst	r7, r3
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480c4d0:	13a0300b 	movne	r3, #11
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
		if (rmode == RES_THEN &&  if_code) continue;
		if (rmode == RES_ELSE && !if_code) continue;
3480c4d4:	158d2018 	strne	r2, [sp, #24]
3480c4d8:	1a00017d 	bne	3480cad4 <run_list_real+0x794>
		if (rmode == RES_ELIF && !if_code) break;
3480c4dc:	e3550003 	cmp	r5, #3
3480c4e0:	13a02000 	movne	r2, #0
3480c4e4:	03a02001 	moveq	r2, #1
3480c4e8:	e0177002 	ands	r7, r7, r2
3480c4ec:	e58d202c 	str	r2, [sp, #44]	; 0x2c
3480c4f0:	1a000180 	bne	3480caf8 <run_list_real+0x7b8>
		if (rmode == RES_FOR && pi->num_progs) {
3480c4f4:	e3550006 	cmp	r5, #6
3480c4f8:	1a000082 	bne	3480c708 <run_list_real+0x3c8>
3480c4fc:	e5943000 	ldr	r3, [r4]
3480c500:	e3530000 	cmp	r3, #0
3480c504:	0a00008d 	beq	3480c740 <run_list_real+0x400>
			if (!list) {
3480c508:	e3560000 	cmp	r6, #0
3480c50c:	1a00005f 	bne	3480c690 <run_list_real+0x350>
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
3480c510:	e5943008 	ldr	r3, [r4, #8]
3480c514:	e5933004 	ldr	r3, [r3, #4]
3480c518:	e5933000 	ldr	r3, [r3]
3480c51c:	e3530000 	cmp	r3, #0
3480c520:	0a00016a 	beq	3480cad0 <run_list_real+0x790>
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
3480c524:	e5942004 	ldr	r2, [r4, #4]
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480c528:	e5922000 	ldr	r2, [r2]
3480c52c:	e5922000 	ldr	r2, [r2]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480c530:	e58d3008 	str	r3, [sp, #8]
3480c534:	e1a00002 	mov	r0, r2
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480c538:	e58d2010 	str	r2, [sp, #16]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480c53c:	eb003f95 	bl	3481c398 <strlen>
3480c540:	e58d001c 	str	r0, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480c544:	e3a00004 	mov	r0, #4
3480c548:	ebfffbbd 	bl	3480b444 <xmalloc>
3480c54c:	e59d3008 	ldr	r3, [sp, #8]
3480c550:	e58d9024 	str	r9, [sp, #36]	; 0x24
3480c554:	e58d300c 	str	r3, [sp, #12]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c558:	e59d301c 	ldr	r3, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480c55c:	e1a06000 	mov	r6, r0
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c560:	e2833002 	add	r3, r3, #2
3480c564:	e58d3020 	str	r3, [sp, #32]
3480c568:	e58da030 	str	sl, [sp, #48]	; 0x30
3480c56c:	e58d5034 	str	r5, [sp, #52]	; 0x34
3480c570:	e1a09004 	mov	r9, r4
3480c574:	ea000034 	b	3480c64c <run_list_real+0x30c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c578:	e3a01000 	mov	r1, #0
3480c57c:	ebfffd46 	bl	3480ba9c <insert_var_value_sub>
3480c580:	e1a0b000 	mov	fp, r0
3480c584:	e1a0a000 	mov	sl, r0
3480c588:	ea000026 	b	3480c628 <run_list_real+0x2e8>
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480c58c:	e3530020 	cmp	r3, #32
				p1++;
3480c590:	028bb001 	addeq	fp, fp, #1
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480c594:	0a000023 	beq	3480c628 <run_list_real+0x2e8>
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480c598:	e1a0000b 	mov	r0, fp
3480c59c:	e3a01020 	mov	r1, #32
3480c5a0:	eb003f66 	bl	3481c340 <strchr>
3480c5a4:	e2505000 	subs	r5, r0, #0
				len = p2 - p1;
3480c5a8:	106b4005 	rsbne	r4, fp, r5
		while (*p1) {
			if ((*p1 == ' ')) {
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480c5ac:	1a000003 	bne	3480c5c0 <run_list_real+0x280>
				len = p2 - p1;
			} else {
				len = strlen(p1);
3480c5b0:	e1a0000b 	mov	r0, fp
3480c5b4:	eb003f77 	bl	3481c398 <strlen>
3480c5b8:	e1a04000 	mov	r4, r0
				p2 = p1 + len;
3480c5bc:	e08b5000 	add	r5, fp, r0
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c5c0:	e2871002 	add	r1, r7, #2
3480c5c4:	e1a00006 	mov	r0, r6
3480c5c8:	e1a01101 	lsl	r1, r1, #2
3480c5cc:	ebfffc45 	bl	3480b6e8 <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
3480c5d0:	e59d1020 	ldr	r1, [sp, #32]
				len = strlen(p1);
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c5d4:	e1a06000 	mov	r6, r0
			list[n] = xmalloc(2 + name_len + len);
3480c5d8:	e0810004 	add	r0, r1, r4
3480c5dc:	ebfffb98 	bl	3480b444 <xmalloc>
			strcpy(list[n], name);
3480c5e0:	e59d1010 	ldr	r1, [sp, #16]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c5e4:	e7860107 	str	r0, [r6, r7, lsl #2]
			strcpy(list[n], name);
3480c5e8:	eb003f05 	bl	3481c204 <strcpy>
			strcat(list[n], "=");
3480c5ec:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480c5f0:	e59f1518 	ldr	r1, [pc, #1304]	; 3480cb10 <run_list_real+0x7d0>
3480c5f4:	eb003f13 	bl	3481c248 <strcat>
			strncat(list[n], p1, len);
3480c5f8:	e1a02004 	mov	r2, r4
3480c5fc:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480c600:	e1a0100b 	mov	r1, fp
3480c604:	eb003f1b 	bl	3481c278 <strncat>
			list[n++][name_len + len + 1] = '\0';
3480c608:	e7963107 	ldr	r3, [r6, r7, lsl #2]
3480c60c:	e59d201c 	ldr	r2, [sp, #28]
3480c610:	e2877001 	add	r7, r7, #1
3480c614:	e0833002 	add	r3, r3, r2
3480c618:	e0834004 	add	r4, r3, r4
3480c61c:	e3a03000 	mov	r3, #0
3480c620:	e5c43001 	strb	r3, [r4, #1]
			p1 = p2;
3480c624:	e1a0b005 	mov	fp, r5
	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
3480c628:	e5db3000 	ldrb	r3, [fp]
3480c62c:	e3530000 	cmp	r3, #0
3480c630:	1affffd5 	bne	3480c58c <run_list_real+0x24c>
			strcat(list[n], "=");
			strncat(list[n], p1, len);
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
3480c634:	e59d000c 	ldr	r0, [sp, #12]
3480c638:	e5103004 	ldr	r3, [r0, #-4]
3480c63c:	e15a0003 	cmp	sl, r3
3480c640:	0a000001 	beq	3480c64c <run_list_real+0x30c>
3480c644:	e1a0000a 	mov	r0, sl
3480c648:	ebfff65c 	bl	34809fc0 <free>
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
3480c64c:	e59d100c 	ldr	r1, [sp, #12]
3480c650:	e4910004 	ldr	r0, [r1], #4
3480c654:	e3500000 	cmp	r0, #0
3480c658:	e58d100c 	str	r1, [sp, #12]
3480c65c:	1affffc5 	bne	3480c578 <run_list_real+0x238>
3480c660:	e1a04009 	mov	r4, r9
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c664:	e5943004 	ldr	r3, [r4, #4]
3480c668:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480c66c:	e5933000 	ldr	r3, [r3]
3480c670:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
3480c674:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
	}
	list[n] = NULL;
3480c678:	e7860107 	str	r0, [r6, r7, lsl #2]
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c67c:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
3480c680:	e3a0b001 	mov	fp, #1
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c684:	e58d201c 	str	r2, [sp, #28]
				pi->progs->argv[0] = NULL;
3480c688:	e5830000 	str	r0, [r3]
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
3480c68c:	e58d6020 	str	r6, [sp, #32]
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
3480c690:	e5962000 	ldr	r2, [r6]
3480c694:	e5943004 	ldr	r3, [r4, #4]
3480c698:	e3520000 	cmp	r2, #0
3480c69c:	1a00000f 	bne	3480c6e0 <run_list_real+0x3a0>
				free(pi->progs->argv[0]);
3480c6a0:	e5933000 	ldr	r3, [r3]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480c6a4:	e3a07001 	mov	r7, #1
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
3480c6a8:	e5930000 	ldr	r0, [r3]
3480c6ac:	e58d2008 	str	r2, [sp, #8]
3480c6b0:	ebfff642 	bl	34809fc0 <free>
				free(save_list);
3480c6b4:	e59d0020 	ldr	r0, [sp, #32]
3480c6b8:	ebfff640 	bl	34809fc0 <free>
				list = NULL;
				flag_rep = 0;
				pi->progs->argv[0] = save_name;
3480c6bc:	e5943004 	ldr	r3, [r4, #4]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480c6c0:	e59d2008 	ldr	r2, [sp, #8]
				pi->progs->argv[0] = save_name;
3480c6c4:	e5933000 	ldr	r3, [r3]
3480c6c8:	e59d001c 	ldr	r0, [sp, #28]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480c6cc:	e1a0b002 	mov	fp, r2
				pi->progs->argv[0] = save_name;
3480c6d0:	e5830000 	str	r0, [r3]
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
3480c6d4:	e1a06002 	mov	r6, r2
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480c6d8:	e3a0300b 	mov	r3, #11
				pi->progs->argv[0] = save_name;
#ifndef __U_BOOT__
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
				continue;
3480c6dc:	ea0000fd 	b	3480cad8 <run_list_real+0x798>
			} else {
				/* insert new value from list for variable */
				if (pi->progs->argv[0])
3480c6e0:	e5933000 	ldr	r3, [r3]
3480c6e4:	e5930000 	ldr	r0, [r3]
3480c6e8:	e3500000 	cmp	r0, #0
3480c6ec:	0a000000 	beq	3480c6f4 <run_list_real+0x3b4>
					free(pi->progs->argv[0]);
3480c6f0:	ebfff632 	bl	34809fc0 <free>
				pi->progs->argv[0] = *list++;
3480c6f4:	e5943004 	ldr	r3, [r4, #4]
3480c6f8:	e4962004 	ldr	r2, [r6], #4
3480c6fc:	e5933000 	ldr	r3, [r3]
3480c700:	e5832000 	str	r2, [r3]
3480c704:	ea00000d 	b	3480c740 <run_list_real+0x400>
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
			}
		}
		if (rmode == RES_IN) continue;
3480c708:	e355000c 	cmp	r5, #12
3480c70c:	0a0000ef 	beq	3480cad0 <run_list_real+0x790>
		if (rmode == RES_DO) {
3480c710:	e3550009 	cmp	r5, #9
3480c714:	1a000002 	bne	3480c724 <run_list_real+0x3e4>
			if (!flag_rep) continue;
3480c718:	e35b0000 	cmp	fp, #0
3480c71c:	0a0000eb 	beq	3480cad0 <run_list_real+0x790>
3480c720:	ea000006 	b	3480c740 <run_list_real+0x400>
		}
		if ((rmode == RES_DONE)) {
3480c724:	e355000a 	cmp	r5, #10
3480c728:	1a000004 	bne	3480c740 <run_list_real+0x400>
			if (flag_rep) {
				flag_restore = 1;
3480c72c:	e59d1014 	ldr	r1, [sp, #20]
3480c730:	e35b0000 	cmp	fp, #0
3480c734:	13a01001 	movne	r1, #1
3480c738:	e58d1014 	str	r1, [sp, #20]
3480c73c:	03a09000 	moveq	r9, #0
			} else {
				rpipe = NULL;
			}
		}
		if (pi->num_progs == 0) continue;
3480c740:	e5943000 	ldr	r3, [r4]
3480c744:	e3530000 	cmp	r3, #0
3480c748:	0a0000e0 	beq	3480cad0 <run_list_real+0x790>
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480c74c:	e59f23b8 	ldr	r2, [pc, #952]	; 3480cb0c <run_list_real+0x7cc>

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480c750:	e3530001 	cmp	r3, #1
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480c754:	e5922008 	ldr	r2, [r2, #8]
3480c758:	e58d2010 	str	r2, [sp, #16]

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480c75c:	1a0000e8 	bne	3480cb04 <run_list_real+0x7c4>
3480c760:	e5947004 	ldr	r7, [r4, #4]
		/* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? */
		rcode = run_list_real(child->group);
		restore_redirects(squirrel);
#else
		if (pi->num_progs == 1 && child->group) {
3480c764:	e5970008 	ldr	r0, [r7, #8]
3480c768:	e3500000 	cmp	r0, #0
3480c76c:	0a000001 	beq	3480c778 <run_list_real+0x438>
		int rcode;
		debug_printf("non-subshell grouping\n");
		rcode = run_list_real(child->group);
3480c770:	ebfffef2 	bl	3480c340 <run_list_real>
3480c774:	ea0000b3 	b	3480ca48 <run_list_real+0x708>
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
3480c778:	e5972000 	ldr	r2, [r7]
3480c77c:	e3520000 	cmp	r2, #0
3480c780:	0a0000df 	beq	3480cb04 <run_list_real+0x7c4>
3480c784:	e1a01007 	mov	r1, r7
3480c788:	e1a0c004 	mov	ip, r4
3480c78c:	e1a0a000 	mov	sl, r0
3480c790:	e1a07005 	mov	r7, r5
3480c794:	e1a04002 	mov	r4, r2
3480c798:	ea000000 	b	3480c7a0 <run_list_real+0x460>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
3480c79c:	e28aa001 	add	sl, sl, #1
3480c7a0:	e4945004 	ldr	r5, [r4], #4
3480c7a4:	e58d1008 	str	r1, [sp, #8]
3480c7a8:	e1a00005 	mov	r0, r5
3480c7ac:	e58dc004 	str	ip, [sp, #4]
3480c7b0:	ebfffacf 	bl	3480b2f4 <is_assignment>
3480c7b4:	e3500000 	cmp	r0, #0
3480c7b8:	e59d1008 	ldr	r1, [sp, #8]
3480c7bc:	e59dc004 	ldr	ip, [sp, #4]
3480c7c0:	1afffff5 	bne	3480c79c <run_list_real+0x45c>
		if (i!=0 && child->argv[i]==NULL) {
3480c7c4:	e35a0000 	cmp	sl, #0
3480c7c8:	e1a03005 	mov	r3, r5
3480c7cc:	e1a0400c 	mov	r4, ip
3480c7d0:	e1a05007 	mov	r5, r7
3480c7d4:	e1a07001 	mov	r7, r1
3480c7d8:	0a000035 	beq	3480c8b4 <run_list_real+0x574>
3480c7dc:	e3530000 	cmp	r3, #0
3480c7e0:	01a0a003 	moveq	sl, r3
3480c7e4:	1a000031 	bne	3480c8b0 <run_list_real+0x570>
3480c7e8:	ea000018 	b	3480c850 <run_list_real+0x510>
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. */
				int export_me=0;
				char *name, *value;
				name = xstrdup(child->argv[i]);
3480c7ec:	eb003f1e 	bl	3481c46c <strdup>
				debug_printf("Local environment set: %s\n", name);
				value = strchr(name, '=');
3480c7f0:	e3a0103d 	mov	r1, #61	; 0x3d
3480c7f4:	e58d0008 	str	r0, [sp, #8]
3480c7f8:	eb003ed0 	bl	3481c340 <strchr>
				if (value)
3480c7fc:	e59d3008 	ldr	r3, [sp, #8]
3480c800:	e3500000 	cmp	r0, #0
					*value=0;
3480c804:	13a01000 	movne	r1, #0
3480c808:	15c01000 	strbne	r1, [r0]
#ifndef __U_BOOT__
				if ( get_local_var(name)) {
					export_me=1;
				}
#endif
				free(name);
3480c80c:	e1a00003 	mov	r0, r3
3480c810:	ebfff5ea 	bl	34809fc0 <free>
				p = insert_var_value(child->argv[i]);
3480c814:	e5973000 	ldr	r3, [r7]
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c818:	e3a01000 	mov	r1, #0
3480c81c:	e793000a 	ldr	r0, [r3, sl]
3480c820:	ebfffc9d 	bl	3480ba9c <insert_var_value_sub>
					export_me=1;
				}
#endif
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
3480c824:	e3a01000 	mov	r1, #0
3480c828:	e58d0008 	str	r0, [sp, #8]
3480c82c:	ebfffc2c 	bl	3480b8e4 <set_local_var>
				if (p != child->argv[i]) free(p);
3480c830:	e5972000 	ldr	r2, [r7]
3480c834:	e59d3008 	ldr	r3, [sp, #8]
3480c838:	e792200a 	ldr	r2, [r2, sl]
3480c83c:	e1530002 	cmp	r3, r2
3480c840:	0a000001 	beq	3480c84c <run_list_real+0x50c>
3480c844:	e1a00003 	mov	r0, r3
3480c848:	ebfff5dc 	bl	34809fc0 <free>
3480c84c:	e28aa004 	add	sl, sl, #4
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
			/* assignments, but no command: set the local environment */
			for (i=0; child->argv[i]!=NULL; i++) {
3480c850:	e5973000 	ldr	r3, [r7]
3480c854:	e793000a 	ldr	r0, [r3, sl]
3480c858:	e3500000 	cmp	r0, #0
3480c85c:	1affffe2 	bne	3480c7ec <run_list_real+0x4ac>
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
3480c860:	e1a0a000 	mov	sl, r0
3480c864:	ea000080 	b	3480ca6c <run_list_real+0x72c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c868:	e1a00003 	mov	r0, r3
3480c86c:	e3a01000 	mov	r1, #0
3480c870:	ebfffc89 	bl	3480ba9c <insert_var_value_sub>
		for (i = 0; is_assignment(child->argv[i]); i++) {
			p = insert_var_value(child->argv[i]);
#ifndef __U_BOOT__
			putenv(strdup(p));
#else
			set_local_var(p, 0);
3480c874:	e3a01000 	mov	r1, #0
3480c878:	e58d0008 	str	r0, [sp, #8]
3480c87c:	ebfffc18 	bl	3480b8e4 <set_local_var>
#endif
			if (p != child->argv[i]) {
3480c880:	e5972000 	ldr	r2, [r7]
3480c884:	e59d3008 	ldr	r3, [sp, #8]
3480c888:	e792200a 	ldr	r2, [r2, sl]
3480c88c:	e1530002 	cmp	r3, r2
3480c890:	0a000004 	beq	3480c8a8 <run_list_real+0x568>
				child->sp--;
3480c894:	e597200c 	ldr	r2, [r7, #12]
				free(p);
3480c898:	e1a00003 	mov	r0, r3
			putenv(strdup(p));
#else
			set_local_var(p, 0);
#endif
			if (p != child->argv[i]) {
				child->sp--;
3480c89c:	e2422001 	sub	r2, r2, #1
3480c8a0:	e587200c 	str	r2, [r7, #12]
				free(p);
3480c8a4:	ebfff5c5 	bl	34809fc0 <free>
3480c8a8:	e28aa004 	add	sl, sl, #4
3480c8ac:	ea000000 	b	3480c8b4 <run_list_real+0x574>
		rcode = run_list_real(child->group);
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
3480c8b0:	e1a0a000 	mov	sl, r0
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
		}
		for (i = 0; is_assignment(child->argv[i]); i++) {
3480c8b4:	e5973000 	ldr	r3, [r7]
3480c8b8:	e083200a 	add	r2, r3, sl
3480c8bc:	e793300a 	ldr	r3, [r3, sl]
3480c8c0:	e58d200c 	str	r2, [sp, #12]
3480c8c4:	e1a00003 	mov	r0, r3
3480c8c8:	e58d3008 	str	r3, [sp, #8]
3480c8cc:	ebfffa88 	bl	3480b2f4 <is_assignment>
3480c8d0:	e2502000 	subs	r2, r0, #0
3480c8d4:	e59d3008 	ldr	r3, [sp, #8]
3480c8d8:	1affffe2 	bne	3480c868 <run_list_real+0x528>
			if (p != child->argv[i]) {
				child->sp--;
				free(p);
			}
		}
		if (child->sp) {
3480c8dc:	e597100c 	ldr	r1, [r7, #12]
3480c8e0:	e3510000 	cmp	r1, #0
3480c8e4:	0a000046 	beq	3480ca04 <run_list_real+0x6c4>
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
3480c8e8:	e59f0224 	ldr	r0, [pc, #548]	; 3480cb14 <run_list_real+0x7d4>
3480c8ec:	e58d2008 	str	r2, [sp, #8]
3480c8f0:	ebfffbd7 	bl	3480b854 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c8f4:	e3500000 	cmp	r0, #0
3480c8f8:	e59d2008 	ldr	r2, [sp, #8]
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c8fc:	058d0010 	streq	r0, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c900:	0a000006 	beq	3480c920 <run_list_real+0x5e0>
3480c904:	e5d03000 	ldrb	r3, [r0]
3480c908:	e3530030 	cmp	r3, #48	; 0x30
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c90c:	058d2010 	streq	r2, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c910:	0a000002 	beq	3480c920 <run_list_real+0x5e0>
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c914:	e2533000 	subs	r3, r3, #0
3480c918:	13a03001 	movne	r3, #1
3480c91c:	e58d3010 	str	r3, [sp, #16]
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480c920:	e3a03002 	mov	r3, #2
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480c924:	e3a0a000 	mov	sl, #0
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480c928:	e58d3024 	str	r3, [sp, #36]	; 0x24

/* Make new string for parser */
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
3480c92c:	e1a0700a 	mov	r7, sl
3480c930:	e58d6030 	str	r6, [sp, #48]	; 0x30
3480c934:	ea00001c 	b	3480c9ac <run_list_real+0x66c>

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
3480c938:	e1a00003 	mov	r0, r3
3480c93c:	e59d1010 	ldr	r1, [sp, #16]
3480c940:	ebfffc55 	bl	3480ba9c <insert_var_value_sub>
3480c944:	e1a06000 	mov	r6, r0
		str = xrealloc(str, (len + strlen(p)));
3480c948:	eb003e92 	bl	3481c398 <strlen>
3480c94c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3480c950:	e0801002 	add	r1, r0, r2
3480c954:	e1a00007 	mov	r0, r7
3480c958:	ebfffb62 	bl	3480b6e8 <xrealloc>
		if (n) {
3480c95c:	e35a0000 	cmp	sl, #0
	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
3480c960:	e1a07000 	mov	r7, r0
		if (n) {
			strcat(str, " ");
		} else {
			*str = '\0';
3480c964:	05c0a000 	strbeq	sl, [r0]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
		if (n) {
3480c968:	0a000001 	beq	3480c974 <run_list_real+0x634>
			strcat(str, " ");
3480c96c:	e59f11a4 	ldr	r1, [pc, #420]	; 3480cb18 <run_list_real+0x7d8>
3480c970:	eb003e34 	bl	3481c248 <strcat>
		} else {
			*str = '\0';
		}
		strcat(str, p);
3480c974:	e1a01006 	mov	r1, r6
3480c978:	e1a00007 	mov	r0, r7
3480c97c:	eb003e31 	bl	3481c248 <strcat>
		len = strlen(str) + 3;
3480c980:	e1a00007 	mov	r0, r7
3480c984:	eb003e83 	bl	3481c398 <strlen>
3480c988:	e2800003 	add	r0, r0, #3
3480c98c:	e58d0024 	str	r0, [sp, #36]	; 0x24
		if (p != inp[n]) free(p);
3480c990:	e59d000c 	ldr	r0, [sp, #12]
3480c994:	e5103004 	ldr	r3, [r0, #-4]
3480c998:	e1560003 	cmp	r6, r3
3480c99c:	0a000001 	beq	3480c9a8 <run_list_real+0x668>
3480c9a0:	e1a00006 	mov	r0, r6
3480c9a4:	ebfff585 	bl	34809fc0 <free>
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480c9a8:	e28aa001 	add	sl, sl, #1
3480c9ac:	e59d100c 	ldr	r1, [sp, #12]
3480c9b0:	e4913004 	ldr	r3, [r1], #4
3480c9b4:	e3530000 	cmp	r3, #0
3480c9b8:	e58d100c 	str	r1, [sp, #12]
3480c9bc:	1affffdd 	bne	3480c938 <run_list_real+0x5f8>
		}
		strcat(str, p);
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
3480c9c0:	e1a00007 	mov	r0, r7
3480c9c4:	e58d3008 	str	r3, [sp, #8]
3480c9c8:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3480c9cc:	eb003e71 	bl	3481c398 <strlen>
	*(str + len) = '\n';
3480c9d0:	e1a02007 	mov	r2, r7
3480c9d4:	e3a0100a 	mov	r1, #10
3480c9d8:	e7e21000 	strb	r1, [r2, r0]!
	*(str + len + 1) = '\0';
3480c9dc:	e59d3008 	ldr	r3, [sp, #8]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c9e0:	e3a01005 	mov	r1, #5
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
	*(str + len) = '\n';
	*(str + len + 1) = '\0';
3480c9e4:	e5c23001 	strb	r3, [r2, #1]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c9e8:	e1a00007 	mov	r0, r7
3480c9ec:	ebfffe17 	bl	3480c250 <parse_string_outer>
			free(str);
3480c9f0:	e1a00007 	mov	r0, r7
3480c9f4:	ebfff571 	bl	34809fc0 <free>
			return last_return_code;
3480c9f8:	e59f210c 	ldr	r2, [pc, #268]	; 3480cb0c <run_list_real+0x7cc>
3480c9fc:	e592a134 	ldr	sl, [r2, #308]	; 0x134
3480ca00:	ea000011 	b	3480ca4c <run_list_real+0x70c>
		}
#else
		/* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 */
		if (strchr(child->argv[i], ';')) {
3480ca04:	e1a00003 	mov	r0, r3
3480ca08:	e3a0103b 	mov	r1, #59	; 0x3b
3480ca0c:	eb003e4b 	bl	3481c340 <strchr>
3480ca10:	e3500000 	cmp	r0, #0
3480ca14:	0a000004 	beq	3480ca2c <run_list_real+0x6ec>
			printf("Unknown command '%s' - try 'help' or use "
3480ca18:	e5973000 	ldr	r3, [r7]
3480ca1c:	e59f00f8 	ldr	r0, [pc, #248]	; 3480cb1c <run_list_real+0x7dc>
3480ca20:	e793100a 	ldr	r1, [r3, sl]
3480ca24:	ebfff427 	bl	34809ac8 <printf>
3480ca28:	ea000035 	b	3480cb04 <run_list_real+0x7c4>
					"'run' command\n", child->argv[i]);
			return -1;
		}
		/* Process the command */
		return cmd_process(flag, child->argc, child->argv,
3480ca2c:	e59d3010 	ldr	r3, [sp, #16]
3480ca30:	e5971004 	ldr	r1, [r7, #4]
3480ca34:	e2530000 	subs	r0, r3, #0
3480ca38:	13a00001 	movne	r0, #1
3480ca3c:	e5972000 	ldr	r2, [r7]
3480ca40:	e59f30d8 	ldr	r3, [pc, #216]	; 3480cb20 <run_list_real+0x7e0>
3480ca44:	ebfff355 	bl	348097a0 <cmd_process>
3480ca48:	e1a0a000 	mov	sl, r0
			}
			debug_printf("checkjobs returned %d\n",rcode);
		}
		last_return_code=rcode;
#else
		if (rcode < -1) {
3480ca4c:	e37a0001 	cmn	sl, #1
3480ca50:	aa000005 	bge	3480ca6c <run_list_real+0x72c>
			last_return_code = -rcode - 2;
3480ca54:	e3e03001 	mvn	r3, #1
3480ca58:	e59f20ac 	ldr	r2, [pc, #172]	; 3480cb0c <run_list_real+0x7cc>
3480ca5c:	e06a3003 	rsb	r3, sl, r3
3480ca60:	e5823134 	str	r3, [r2, #308]	; 0x134
			return -2;	/* exit */
3480ca64:	e3e0a001 	mvn	sl, #1
3480ca68:	ea000022 	b	3480caf8 <run_list_real+0x7b8>
		last_return_code=(rcode == 0) ? 0 : 1;
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480ca6c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480ca70:	e25a3000 	subs	r3, sl, #0
3480ca74:	13a03001 	movne	r3, #1
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480ca78:	e3550001 	cmp	r5, #1
3480ca7c:	03822001 	orreq	r2, r2, #1
3480ca80:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480ca84:	e3520000 	cmp	r2, #0
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480ca88:	e59f007c 	ldr	r0, [pc, #124]	; 3480cb0c <run_list_real+0x7cc>
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480ca8c:	11a0100a 	movne	r1, sl
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480ca90:	e3550007 	cmp	r5, #7
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480ca94:	e5803134 	str	r3, [r0, #308]	; 0x134
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480ca98:	e58d1028 	str	r1, [sp, #40]	; 0x28
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
			flag_rep = !last_return_code;
3480ca9c:	0223b001 	eoreq	fp, r3, #1
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480caa0:	0a000001 	beq	3480caac <run_list_real+0x76c>
			flag_rep = !last_return_code;
		if (rmode == RES_UNTIL)
			flag_rep = last_return_code;
3480caa4:	e3550008 	cmp	r5, #8
3480caa8:	01a0b003 	moveq	fp, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480caac:	e35a0000 	cmp	sl, #0
3480cab0:	e594300c 	ldr	r3, [r4, #12]
3480cab4:	1a000001 	bne	3480cac0 <run_list_real+0x780>
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480cab8:	e3530003 	cmp	r3, #3
3480cabc:	ea000000 	b	3480cac4 <run_list_real+0x784>
3480cac0:	e3530002 	cmp	r3, #2
3480cac4:	01a03005 	moveq	r3, r5
3480cac8:	13a0300b 	movne	r3, #11
3480cacc:	ea000000 	b	3480cad4 <run_list_real+0x794>
3480cad0:	e3a0300b 	mov	r3, #11
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480cad4:	e3a07001 	mov	r7, #1
				flag_repeat = 0;
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480cad8:	e59d2014 	ldr	r2, [sp, #20]
3480cadc:	e3520000 	cmp	r2, #0
3480cae0:	05944008 	ldreq	r4, [r4, #8]
3480cae4:	11a04009 	movne	r4, r9
3480cae8:	e3540000 	cmp	r4, #0
3480caec:	1afffe4b 	bne	3480c420 <run_list_real+0xe0>
3480caf0:	ea000000 	b	3480caf8 <run_list_real+0x7b8>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
3480caf4:	e3a0a001 	mov	sl, #1
#ifndef __U_BOOT__
		checkjobs(NULL);
#endif
	}
	return rcode;
}
3480caf8:	e1a0000a 	mov	r0, sl
3480cafc:	e28dd038 	add	sp, sp, #56	; 0x38
3480cb00:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		/* If there isn't another process, nextin is garbage
		   but it doesn't matter */
		nextin = pipefds[0];
	}
#endif
	return -1;
3480cb04:	e3e0a000 	mvn	sl, #0
3480cb08:	eaffffd7 	b	3480ca6c <run_list_real+0x72c>
3480cb0c:	34829d28 	.word	0x34829d28
3480cb10:	3482393e 	.word	0x3482393e
3480cb14:	348261a3 	.word	0x348261a3
3480cb18:	348263ac 	.word	0x348263ac
3480cb1c:	348261b0 	.word	0x348261b0
3480cb20:	34829d2c 	.word	0x34829d2c

3480cb24 <parse_stream_outer>:
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480cb24:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480cb28:	e24dd038 	sub	sp, sp, #56	; 0x38

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480cb2c:	e28d5024 	add	r5, sp, #36	; 0x24
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480cb30:	e58d1004 	str	r1, [sp, #4]
3480cb34:	e1a04000 	mov	r4, r0

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480cb38:	e3a01000 	mov	r1, #0
3480cb3c:	e1a00005 	mov	r0, r5
3480cb40:	e3a02014 	mov	r2, #20
3480cb44:	eb003eb3 	bl	3481c618 <memset>
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
3480cb48:	e3a07000 	mov	r7, #0
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
3480cb4c:	e28d6008 	add	r6, sp, #8
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480cb50:	e59d2004 	ldr	r2, [sp, #4]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480cb54:	e3a0a000 	mov	sl, #0
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480cb58:	e58d2020 	str	r2, [sp, #32]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480cb5c:	e58da010 	str	sl, [sp, #16]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480cb60:	e58da008 	str	sl, [sp, #8]
	ctx->list_head=new_pipe();
3480cb64:	ebfffca7 	bl	3480be08 <new_pipe>
3480cb68:	e58d000c 	str	r0, [sp, #12]
	ctx->pipe=ctx->list_head;
3480cb6c:	e58d0010 	str	r0, [sp, #16]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
#ifdef __U_BOOT__
	ctx->old_flag=0;
#endif
	done_command(ctx);   /* creates the memory for working child */
3480cb70:	e1a00006 	mov	r0, r6
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480cb74:	e58da014 	str	sl, [sp, #20]
	ctx->stack=NULL;
3480cb78:	e58da01c 	str	sl, [sp, #28]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480cb7c:	e58da018 	str	sl, [sp, #24]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480cb80:	ebfffae0 	bl	3480b708 <done_command>
	int code = 0;
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
3480cb84:	ebfffd8e 	bl	3480c1c4 <update_ifs_map>
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
3480cb88:	e59d2004 	ldr	r2, [sp, #4]
3480cb8c:	e2023006 	and	r3, r2, #6
3480cb90:	e3530002 	cmp	r3, #2
3480cb94:	0a000002 	beq	3480cba4 <parse_stream_outer+0x80>
3480cb98:	e59f05e0 	ldr	r0, [pc, #1504]	; 3480d180 <parse_stream_outer+0x65c>
3480cb9c:	e1a0100a 	mov	r1, sl
3480cba0:	ebfffd7e 	bl	3480c1a0 <mapset>
		inp->promptmode=1;
3480cba4:	e3a03001 	mov	r3, #1
3480cba8:	e5843008 	str	r3, [r4, #8]
3480cbac:	ea00010a 	b	3480cfdc <parse_stream_outer+0x4b8>
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
3480cbb0:	e59f25cc 	ldr	r2, [pc, #1484]	; 3480d184 <parse_stream_outer+0x660>
3480cbb4:	e082300a 	add	r3, r2, sl
3480cbb8:	e5d3b138 	ldrb	fp, [r3, #312]	; 0x138
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
3480cbbc:	e5943004 	ldr	r3, [r4, #4]
3480cbc0:	e3530000 	cmp	r3, #0
3480cbc4:	0a00010b 	beq	3480cff8 <parse_stream_outer+0x4d4>
#endif
		next = (ch == '\n') ? 0 : b_peek(input);
3480cbc8:	e35a000a 	cmp	sl, #10
3480cbcc:	03a09000 	moveq	r9, #0
3480cbd0:	0a000003 	beq	3480cbe4 <parse_stream_outer+0xc0>
3480cbd4:	e5943010 	ldr	r3, [r4, #16]
3480cbd8:	e1a00004 	mov	r0, r4
3480cbdc:	e12fff33 	blx	r3
3480cbe0:	e1a09000 	mov	r9, r0

		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d - %c\n",
			ch >= ' ' ? ch : '.', ch, m,
			dest->quote, ctx->stack == NULL ? '*' : '.');

		if (m==0 || ((m==1 || m==2) && dest->quote)) {
3480cbe4:	e35b0000 	cmp	fp, #0
3480cbe8:	0a000005 	beq	3480cc04 <parse_stream_outer+0xe0>
3480cbec:	e24b3001 	sub	r3, fp, #1
3480cbf0:	e3530001 	cmp	r3, #1
3480cbf4:	8a000012 	bhi	3480cc44 <parse_stream_outer+0x120>
3480cbf8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cbfc:	e3530000 	cmp	r3, #0
3480cc00:	0a000002 	beq	3480cc10 <parse_stream_outer+0xec>
			b_addqchr(dest, ch, dest->quote);
3480cc04:	e1a00005 	mov	r0, r5
3480cc08:	e1a0100a 	mov	r1, sl
3480cc0c:	ea000042 	b	3480cd1c <parse_stream_outer+0x1f8>
		} else {
			if (m==2) {  /* unquoted IFS */
3480cc10:	e35b0002 	cmp	fp, #2
3480cc14:	1a00000a 	bne	3480cc44 <parse_stream_outer+0x120>
				if (done_word(dest, ctx)) {
3480cc18:	e1a00005 	mov	r0, r5
3480cc1c:	e1a01006 	mov	r1, r6
3480cc20:	ebfffd00 	bl	3480c028 <done_word>
3480cc24:	e3500000 	cmp	r0, #0
3480cc28:	1a0000f2 	bne	3480cff8 <parse_stream_outer+0x4d4>
					return 1;
				}
				/* If we aren't performing a substitution, treat a newline as a
				 * command separator.  */
				if (end_trigger != '\0' && ch=='\n')
3480cc2c:	e35a000a 	cmp	sl, #10
3480cc30:	1a0000e9 	bne	3480cfdc <parse_stream_outer+0x4b8>
					done_pipe(ctx,PIPE_SEQ);
3480cc34:	e1a00006 	mov	r0, r6
3480cc38:	e3a01001 	mov	r1, #1
3480cc3c:	ebfffc7b 	bl	3480be30 <done_pipe>
3480cc40:	ea000001 	b	3480cc4c <parse_stream_outer+0x128>
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480cc44:	e35a000a 	cmp	sl, #10
3480cc48:	1a000005 	bne	3480cc64 <parse_stream_outer+0x140>
3480cc4c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cc50:	e3530000 	cmp	r3, #0
3480cc54:	1a000002 	bne	3480cc64 <parse_stream_outer+0x140>
3480cc58:	e59d3014 	ldr	r3, [sp, #20]
3480cc5c:	e3530000 	cmp	r3, #0
3480cc60:	0a000141 	beq	3480d16c <parse_stream_outer+0x648>
				done_pipe(ctx,PIPE_SEQ);
				run_list(ctx->list_head);
				initialize_context(ctx);
			}
#endif
			if (m!=2) switch (ch) {
3480cc64:	e35b0002 	cmp	fp, #2
3480cc68:	0a0000db 	beq	3480cfdc <parse_stream_outer+0x4b8>
3480cc6c:	e35a0026 	cmp	sl, #38	; 0x26
3480cc70:	0a0000af 	beq	3480cf34 <parse_stream_outer+0x410>
3480cc74:	8a00000a 	bhi	3480cca4 <parse_stream_outer+0x180>
3480cc78:	e35a0022 	cmp	sl, #34	; 0x22
3480cc7c:	0a00009f 	beq	3480cf00 <parse_stream_outer+0x3dc>
3480cc80:	8a000002 	bhi	3480cc90 <parse_stream_outer+0x16c>
3480cc84:	e35a0004 	cmp	sl, #4
3480cc88:	1a0000d1 	bne	3480cfd4 <parse_stream_outer+0x4b0>
3480cc8c:	ea0000bf 	b	3480cf90 <parse_stream_outer+0x46c>
3480cc90:	e35a0023 	cmp	sl, #35	; 0x23
3480cc94:	0a00000d 	beq	3480ccd0 <parse_stream_outer+0x1ac>
3480cc98:	e35a0024 	cmp	sl, #36	; 0x24
3480cc9c:	1a0000cc 	bne	3480cfd4 <parse_stream_outer+0x4b0>
3480cca0:	ea00002c 	b	3480cd58 <parse_stream_outer+0x234>
3480cca4:	e35a003b 	cmp	sl, #59	; 0x3b
3480cca8:	0a00009b 	beq	3480cf1c <parse_stream_outer+0x3f8>
3480ccac:	8a000002 	bhi	3480ccbc <parse_stream_outer+0x198>
3480ccb0:	e35a0027 	cmp	sl, #39	; 0x27
3480ccb4:	1a0000c6 	bne	3480cfd4 <parse_stream_outer+0x4b0>
3480ccb8:	ea000080 	b	3480cec0 <parse_stream_outer+0x39c>
3480ccbc:	e35a005c 	cmp	sl, #92	; 0x5c
3480ccc0:	0a000018 	beq	3480cd28 <parse_stream_outer+0x204>
3480ccc4:	e35a007c 	cmp	sl, #124	; 0x7c
3480ccc8:	1a0000c1 	bne	3480cfd4 <parse_stream_outer+0x4b0>
3480cccc:	ea0000a3 	b	3480cf60 <parse_stream_outer+0x43c>
		case '#':
			if (dest->length == 0 && !dest->quote) {
3480ccd0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3480ccd4:	e3530000 	cmp	r3, #0
3480ccd8:	1a00000d 	bne	3480cd14 <parse_stream_outer+0x1f0>
3480ccdc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cce0:	e3530000 	cmp	r3, #0
3480cce4:	0a000003 	beq	3480ccf8 <parse_stream_outer+0x1d4>
3480cce8:	ea000009 	b	3480cd14 <parse_stream_outer+0x1f0>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
3480ccec:	e594300c 	ldr	r3, [r4, #12]
3480ccf0:	e1a00004 	mov	r0, r4
3480ccf4:	e12fff33 	blx	r3
3480ccf8:	e5943010 	ldr	r3, [r4, #16]
3480ccfc:	e1a00004 	mov	r0, r4
3480cd00:	e12fff33 	blx	r3
3480cd04:	e350000a 	cmp	r0, #10
3480cd08:	13700001 	cmnne	r0, #1
3480cd0c:	1afffff6 	bne	3480ccec <parse_stream_outer+0x1c8>
3480cd10:	ea0000b1 	b	3480cfdc <parse_stream_outer+0x4b8>
			} else {
				b_addqchr(dest, ch, dest->quote);
3480cd14:	e1a00005 	mov	r0, r5
3480cd18:	e3a01023 	mov	r1, #35	; 0x23
3480cd1c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480cd20:	ebfffab8 	bl	3480b808 <b_addqchr>
3480cd24:	ea0000ac 	b	3480cfdc <parse_stream_outer+0x4b8>
			}
			break;
		case '\\':
			if (next == EOF) {
3480cd28:	e3790001 	cmn	r9, #1
3480cd2c:	0a0000a8 	beq	3480cfd4 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addqchr(dest, '\\', dest->quote);
3480cd30:	e1a0100a 	mov	r1, sl
3480cd34:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480cd38:	e1a00005 	mov	r0, r5
3480cd3c:	ebfffab1 	bl	3480b808 <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
3480cd40:	e594300c 	ldr	r3, [r4, #12]
3480cd44:	e1a00004 	mov	r0, r4
3480cd48:	e12fff33 	blx	r3
3480cd4c:	e1a01000 	mov	r1, r0
3480cd50:	e1a00005 	mov	r0, r5
3480cd54:	eafffff0 	b	3480cd1c <parse_stream_outer+0x1f8>
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480cd58:	e5943010 	ldr	r3, [r4, #16]
3480cd5c:	e1a00004 	mov	r0, r4
3480cd60:	e12fff33 	blx	r3
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480cd64:	e59f241c 	ldr	r2, [pc, #1052]	; 3480d188 <parse_stream_outer+0x664>
3480cd68:	e6ef3070 	uxtb	r3, r0
3480cd6c:	e7d23003 	ldrb	r3, [r2, r3]
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480cd70:	e1a09000 	mov	r9, r0
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480cd74:	e3130003 	tst	r3, #3
3480cd78:	0a00001b 	beq	3480cdec <parse_stream_outer+0x2c8>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480cd7c:	e1a00005 	mov	r0, r5
3480cd80:	e3a01003 	mov	r1, #3
3480cd84:	ebfffa81 	bl	3480b790 <b_addchr>
		ctx->child->sp++;
3480cd88:	e59d3008 	ldr	r3, [sp, #8]
3480cd8c:	e593200c 	ldr	r2, [r3, #12]
3480cd90:	e2822001 	add	r2, r2, #1
3480cd94:	e583200c 	str	r2, [r3, #12]
3480cd98:	ea000005 	b	3480cdb4 <parse_stream_outer+0x290>
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
			b_getch(input);
3480cd9c:	e594300c 	ldr	r3, [r4, #12]
3480cda0:	e1a00004 	mov	r0, r4
3480cda4:	e12fff33 	blx	r3
			b_addchr(dest,ch);
3480cda8:	e1a00005 	mov	r0, r5
3480cdac:	e1a0100a 	mov	r1, sl
3480cdb0:	ebfffa76 	bl	3480b790 <b_addchr>
	int ch = input->peek(input);  /* first character after the $ */
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
		ctx->child->sp++;
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
3480cdb4:	e5943010 	ldr	r3, [r4, #16]
3480cdb8:	e1a00004 	mov	r0, r4
3480cdbc:	e12fff33 	blx	r3
3480cdc0:	e59f23c0 	ldr	r2, [pc, #960]	; 3480d188 <parse_stream_outer+0x664>
3480cdc4:	e6ef3070 	uxtb	r3, r0
3480cdc8:	e7d23003 	ldrb	r3, [r2, r3]
3480cdcc:	e1a0a000 	mov	sl, r0
3480cdd0:	e2133007 	ands	r3, r3, #7
3480cdd4:	13a03001 	movne	r3, #1
3480cdd8:	e350005f 	cmp	r0, #95	; 0x5f
3480cddc:	03833001 	orreq	r3, r3, #1
3480cde0:	e3530000 	cmp	r3, #0
3480cde4:	1affffec 	bne	3480cd9c <parse_stream_outer+0x278>
3480cde8:	ea000030 	b	3480ceb0 <parse_stream_outer+0x38c>
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480cdec:	e350003f 	cmp	r0, #63	; 0x3f
3480cdf0:	0a000004 	beq	3480ce08 <parse_stream_outer+0x2e4>
3480cdf4:	e350007b 	cmp	r0, #123	; 0x7b
			error_msg("unhandled syntax: $%c",ch);
			return 1;
			break;
#endif
		default:
			b_addqchr(dest,'$',dest->quote);
3480cdf8:	11a00005 	movne	r0, r5
3480cdfc:	13a01024 	movne	r1, #36	; 0x24
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480ce00:	1affffc5 	bne	3480cd1c <parse_stream_outer+0x1f8>
3480ce04:	ea000013 	b	3480ce58 <parse_stream_outer+0x334>
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480ce08:	e59d3008 	ldr	r3, [sp, #8]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ce0c:	e1a00005 	mov	r0, r5
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480ce10:	e593200c 	ldr	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ce14:	e3a01003 	mov	r1, #3
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480ce18:	e2822001 	add	r2, r2, #1
3480ce1c:	e583200c 	str	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ce20:	ebfffa5a 	bl	3480b790 <b_addchr>
			b_addchr(dest, '$');
3480ce24:	e1a0100a 	mov	r1, sl
3480ce28:	e1a00005 	mov	r0, r5
3480ce2c:	ebfffa57 	bl	3480b790 <b_addchr>
			b_addchr(dest, '?');
3480ce30:	e1a01009 	mov	r1, r9
3480ce34:	e1a00005 	mov	r0, r5
3480ce38:	ebfffa54 	bl	3480b790 <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ce3c:	e1a00005 	mov	r0, r5
3480ce40:	e3a01003 	mov	r1, #3
3480ce44:	ebfffa51 	bl	3480b790 <b_addchr>
	/* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 */
	if (advance) b_getch(input);
3480ce48:	e594300c 	ldr	r3, [r4, #12]
3480ce4c:	e1a00004 	mov	r0, r4
3480ce50:	e12fff33 	blx	r3
3480ce54:	ea000060 	b	3480cfdc <parse_stream_outer+0x4b8>
			b_adduint(dest,global_argc ? global_argc-1 : 0);
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ce58:	e1a00005 	mov	r0, r5
3480ce5c:	e3a01003 	mov	r1, #3
3480ce60:	ebfffa4a 	bl	3480b790 <b_addchr>
			ctx->child->sp++;
3480ce64:	e59d3008 	ldr	r3, [sp, #8]
			b_getch(input);
3480ce68:	e1a00004 	mov	r0, r4
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
3480ce6c:	e593200c 	ldr	r2, [r3, #12]
3480ce70:	e2822001 	add	r2, r2, #1
3480ce74:	e583200c 	str	r2, [r3, #12]
			b_getch(input);
3480ce78:	e594300c 	ldr	r3, [r4, #12]
3480ce7c:	e12fff33 	blx	r3
3480ce80:	ea000001 	b	3480ce8c <parse_stream_outer+0x368>
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
				b_addchr(dest,ch);
3480ce84:	e1a00005 	mov	r0, r5
3480ce88:	ebfffa40 	bl	3480b790 <b_addchr>
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
			b_getch(input);
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
3480ce8c:	e594300c 	ldr	r3, [r4, #12]
3480ce90:	e1a00004 	mov	r0, r4
3480ce94:	e12fff33 	blx	r3
3480ce98:	e350007d 	cmp	r0, #125	; 0x7d
3480ce9c:	13700001 	cmnne	r0, #1
3480cea0:	e1a01000 	mov	r1, r0
3480cea4:	1afffff6 	bne	3480ce84 <parse_stream_outer+0x360>
				b_addchr(dest,ch);
			}
			if (ch != '}') {
3480cea8:	e350007d 	cmp	r0, #125	; 0x7d
3480ceac:	1a000048 	bne	3480cfd4 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480ceb0:	e1a00005 	mov	r0, r5
3480ceb4:	e3a01003 	mov	r1, #3
3480ceb8:	ebfffa34 	bl	3480b790 <b_addchr>
3480cebc:	ea000046 	b	3480cfdc <parse_stream_outer+0x4b8>
			break;
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
3480cec0:	e3a03001 	mov	r3, #1
3480cec4:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480cec8:	ea000004 	b	3480cee0 <parse_stream_outer+0x3bc>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
#ifdef __U_BOOT__
				if(input->__promptme == 0) return 1;
3480cecc:	e5943004 	ldr	r3, [r4, #4]
3480ced0:	e3530000 	cmp	r3, #0
3480ced4:	0a000047 	beq	3480cff8 <parse_stream_outer+0x4d4>
#endif
				b_addchr(dest,ch);
3480ced8:	e1a00005 	mov	r0, r5
3480cedc:	ebfffa2b 	bl	3480b790 <b_addchr>
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
3480cee0:	e594300c 	ldr	r3, [r4, #12]
3480cee4:	e1a00004 	mov	r0, r4
3480cee8:	e12fff33 	blx	r3
3480ceec:	e3500027 	cmp	r0, #39	; 0x27
3480cef0:	13700001 	cmnne	r0, #1
3480cef4:	e1a01000 	mov	r1, r0
3480cef8:	1afffff3 	bne	3480cecc <parse_stream_outer+0x3a8>
3480cefc:	ea000032 	b	3480cfcc <parse_stream_outer+0x4a8>
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
			dest->quote = !dest->quote;
3480cf00:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480cf04:	e3a02001 	mov	r2, #1
			dest->quote = !dest->quote;
3480cf08:	e2733001 	rsbs	r3, r3, #1
3480cf0c:	33a03000 	movcc	r3, #0
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480cf10:	e58d2034 	str	r2, [sp, #52]	; 0x34
			dest->quote = !dest->quote;
3480cf14:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480cf18:	ea00002f 	b	3480cfdc <parse_stream_outer+0x4b8>
			}
			setup_redirect(ctx, redir_fd, redir_style, input);
			break;
#endif
		case ';':
			done_word(dest, ctx);
3480cf1c:	e1a01006 	mov	r1, r6
3480cf20:	e1a00005 	mov	r0, r5
3480cf24:	ebfffc3f 	bl	3480c028 <done_word>
			done_pipe(ctx,PIPE_SEQ);
3480cf28:	e1a00006 	mov	r0, r6
3480cf2c:	e3a01001 	mov	r1, #1
3480cf30:	ea000014 	b	3480cf88 <parse_stream_outer+0x464>
			break;
		case '&':
			done_word(dest, ctx);
3480cf34:	e1a00005 	mov	r0, r5
3480cf38:	e1a01006 	mov	r1, r6
3480cf3c:	ebfffc39 	bl	3480c028 <done_word>
			if (next=='&') {
3480cf40:	e3590026 	cmp	r9, #38	; 0x26
3480cf44:	1a000022 	bne	3480cfd4 <parse_stream_outer+0x4b0>
				b_getch(input);
3480cf48:	e594300c 	ldr	r3, [r4, #12]
3480cf4c:	e1a00004 	mov	r0, r4
3480cf50:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
3480cf54:	e1a00006 	mov	r0, r6
3480cf58:	e3a01002 	mov	r1, #2
3480cf5c:	ea000009 	b	3480cf88 <parse_stream_outer+0x464>
				return 1;
#endif
			}
			break;
		case '|':
			done_word(dest, ctx);
3480cf60:	e1a00005 	mov	r0, r5
3480cf64:	e1a01006 	mov	r1, r6
3480cf68:	ebfffc2e 	bl	3480c028 <done_word>
			if (next=='|') {
3480cf6c:	e359007c 	cmp	r9, #124	; 0x7c
3480cf70:	1a000017 	bne	3480cfd4 <parse_stream_outer+0x4b0>
				b_getch(input);
3480cf74:	e594300c 	ldr	r3, [r4, #12]
3480cf78:	e1a00004 	mov	r0, r4
3480cf7c:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
3480cf80:	e1a00006 	mov	r0, r6
3480cf84:	e3a01003 	mov	r1, #3
3480cf88:	ebfffba8 	bl	3480be30 <done_pipe>
3480cf8c:	ea000012 	b	3480cfdc <parse_stream_outer+0x4b8>
			syntax();   /* Proper use of this character caught by end_trigger */
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
3480cf90:	e3a03001 	mov	r3, #1
3480cf94:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480cf98:	ea000004 	b	3480cfb0 <parse_stream_outer+0x48c>
			while (ch = b_getch(input), ch != EOF &&
			    ch != SUBSTED_VAR_SYMBOL) {
				debug_printf("subst, pass=%d\n", ch);
				if (input->__promptme == 0)
3480cf9c:	e5943004 	ldr	r3, [r4, #4]
3480cfa0:	e3530000 	cmp	r3, #0
3480cfa4:	0a000013 	beq	3480cff8 <parse_stream_outer+0x4d4>
					return 1;
				b_addchr(dest, ch);
3480cfa8:	e1a00005 	mov	r0, r5
3480cfac:	ebfff9f7 	bl	3480b790 <b_addchr>
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
			while (ch = b_getch(input), ch != EOF &&
3480cfb0:	e594300c 	ldr	r3, [r4, #12]
3480cfb4:	e1a00004 	mov	r0, r4
3480cfb8:	e12fff33 	blx	r3
3480cfbc:	e3500004 	cmp	r0, #4
3480cfc0:	13700001 	cmnne	r0, #1
3480cfc4:	e1a01000 	mov	r1, r0
3480cfc8:	1afffff3 	bne	3480cf9c <parse_stream_outer+0x478>
				if (input->__promptme == 0)
					return 1;
				b_addchr(dest, ch);
			}
			debug_printf("subst, term=%d\n", ch);
			if (ch == EOF) {
3480cfcc:	e3710001 	cmn	r1, #1
3480cfd0:	1a000001 	bne	3480cfdc <parse_stream_outer+0x4b8>
				syntax();
				return 1;
			}
			break;
		default:
			syntax();   /* this is really an internal logic error */
3480cfd4:	ebfff8db 	bl	3480b348 <syntax_err>
3480cfd8:	ea000006 	b	3480cff8 <parse_stream_outer+0x4d4>
	/* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
3480cfdc:	e594300c 	ldr	r3, [r4, #12]
3480cfe0:	e1a00004 	mov	r0, r4
3480cfe4:	e12fff33 	blx	r3
3480cfe8:	e3700001 	cmn	r0, #1
3480cfec:	e1a0a000 	mov	sl, r0
3480cff0:	1afffeee 	bne	3480cbb0 <parse_stream_outer+0x8c>
3480cff4:	ea00005d 	b	3480d170 <parse_stream_outer+0x64c>
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
3480cff8:	e59f2184 	ldr	r2, [pc, #388]	; 3480d184 <parse_stream_outer+0x660>
3480cffc:	e3a03000 	mov	r3, #0
3480d000:	e5823004 	str	r3, [r2, #4]
3480d004:	e3a0a001 	mov	sl, #1
3480d008:	ea000028 	b	3480d0b0 <parse_stream_outer+0x58c>
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
3480d00c:	ebfff8cd 	bl	3480b348 <syntax_err>
#ifdef __U_BOOT__
			flag_repeat = 0;
3480d010:	e59f216c 	ldr	r2, [pc, #364]	; 3480d184 <parse_stream_outer+0x660>
3480d014:	e3a03000 	mov	r3, #0
3480d018:	e5823004 	str	r3, [r2, #4]
3480d01c:	ea00004e 	b	3480d15c <parse_stream_outer+0x638>
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
3480d020:	e1a01006 	mov	r1, r6
3480d024:	e1a00005 	mov	r0, r5
3480d028:	ebfffbfe 	bl	3480c028 <done_word>
			done_pipe(&ctx,PIPE_SEQ);
3480d02c:	e3a01001 	mov	r1, #1
3480d030:	e1a00006 	mov	r0, r6
3480d034:	ebfffb7d 	bl	3480be30 <done_pipe>
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
3480d038:	e59db00c 	ldr	fp, [sp, #12]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480d03c:	e1a0000b 	mov	r0, fp
3480d040:	ebfffcbe 	bl	3480c340 <run_list_real>
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480d044:	e1a01009 	mov	r1, r9
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480d048:	e1a07000 	mov	r7, r0
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480d04c:	e1a0000b 	mov	r0, fp
3480d050:	ebfff96d 	bl	3480b60c <free_pipe_list>
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
3480d054:	e3770002 	cmn	r7, #2
3480d058:	1a000010 	bne	3480d0a0 <parse_stream_outer+0x57c>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d05c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d060:	e58d9028 	str	r9, [sp, #40]	; 0x28
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d064:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480d068:	e58d9034 	str	r9, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d06c:	15c39000 	strbne	r9, [r3]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480d070:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480d074:	ebfff3d1 	bl	34809fc0 <free>
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d078:	e5943010 	ldr	r3, [r4, #16]
3480d07c:	e59f2108 	ldr	r2, [pc, #264]	; 3480d18c <parse_stream_outer+0x668>

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480d080:	e3a07000 	mov	r7, #0
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d084:	e1530002 	cmp	r3, r2

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480d088:	e58d7024 	str	r7, [sp, #36]	; 0x24
	o->maxlen = 0;
3480d08c:	e58d702c 	str	r7, [sp, #44]	; 0x2c
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d090:	1a00002d 	bne	3480d14c <parse_stream_outer+0x628>
					printf("exit not allowed from main input shell.\n");
3480d094:	e59f00f4 	ldr	r0, [pc, #244]	; 3480d190 <parse_stream_outer+0x66c>
3480d098:	ebfff28a 	bl	34809ac8 <printf>
					continue;
3480d09c:	ea000025 	b	3480d138 <parse_stream_outer+0x614>
				}
				break;
			}
			if (code == -1)
3480d0a0:	e3770001 	cmn	r7, #1
			    flag_repeat = 0;
3480d0a4:	059f30d8 	ldreq	r3, [pc, #216]	; 3480d184 <parse_stream_outer+0x660>
3480d0a8:	05839004 	streq	r9, [r3, #4]
3480d0ac:	ea000016 	b	3480d10c <parse_stream_outer+0x5e8>
#endif
		} else {
			if (ctx.old_flag != 0) {
3480d0b0:	e59d3018 	ldr	r3, [sp, #24]
3480d0b4:	e3530000 	cmp	r3, #0
3480d0b8:	0a000007 	beq	3480d0dc <parse_stream_outer+0x5b8>
				free(ctx.stack);
3480d0bc:	e59d001c 	ldr	r0, [sp, #28]
3480d0c0:	ebfff3be 	bl	34809fc0 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d0c4:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d0c8:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d0cc:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d0d0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480d0d4:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d0d8:	15c23000 	strbne	r3, [r2]
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
3480d0dc:	e5943004 	ldr	r3, [r4, #4]
3480d0e0:	e3530000 	cmp	r3, #0
3480d0e4:	1a000001 	bne	3480d0f0 <parse_stream_outer+0x5cc>
3480d0e8:	e59f00a4 	ldr	r0, [pc, #164]	; 3480d194 <parse_stream_outer+0x670>
3480d0ec:	ebfff275 	bl	34809ac8 <printf>
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480d0f0:	e3a01000 	mov	r1, #0
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
3480d0f4:	e3a03001 	mov	r3, #1
3480d0f8:	e884000a 	stm	r4, {r1, r3}
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480d0fc:	e59d000c 	ldr	r0, [sp, #12]
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480d100:	e58d1034 	str	r1, [sp, #52]	; 0x34
			temp.quote = 0;
3480d104:	e58d1030 	str	r1, [sp, #48]	; 0x30
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480d108:	ebfff93f 	bl	3480b60c <free_pipe_list>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d10c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d110:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d114:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d118:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480d11c:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d120:	15c23000 	strbne	r3, [r2]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480d124:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480d128:	ebfff3a4 	bl	34809fc0 <free>
	o->data = NULL;
3480d12c:	e3a03000 	mov	r3, #0
3480d130:	e58d3024 	str	r3, [sp, #36]	; 0x24
	o->maxlen = 0;
3480d134:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
3480d138:	e37a0001 	cmn	sl, #1
3480d13c:	0a000002 	beq	3480d14c <parse_stream_outer+0x628>
3480d140:	e59d2004 	ldr	r2, [sp, #4]
3480d144:	e3120001 	tst	r2, #1
3480d148:	0afffe80 	beq	3480cb50 <parse_stream_outer+0x2c>
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
3480d14c:	e2570000 	subs	r0, r7, #0
3480d150:	13a00001 	movne	r0, #1
3480d154:	e28dd038 	add	sp, sp, #56	; 0x38
3480d158:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
3480d15c:	e59d9018 	ldr	r9, [sp, #24]
3480d160:	e3590000 	cmp	r9, #0
3480d164:	1affffd1 	bne	3480d0b0 <parse_stream_outer+0x58c>
3480d168:	eaffffac 	b	3480d020 <parse_stream_outer+0x4fc>
				if (end_trigger != '\0' && ch=='\n')
					done_pipe(ctx,PIPE_SEQ);
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
				debug_printf("leaving parse_stream (triggered)\n");
				return 0;
3480d16c:	e1a0a003 	mov	sl, r3
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
3480d170:	e59d3018 	ldr	r3, [sp, #24]
3480d174:	e3530000 	cmp	r3, #0
3480d178:	0afffff7 	beq	3480d15c <parse_stream_outer+0x638>
3480d17c:	eaffffa2 	b	3480d00c <parse_stream_outer+0x4e8>
3480d180:	348261e8 	.word	0x348261e8
3480d184:	34829d28 	.word	0x34829d28
3480d188:	34821cf4 	.word	0x34821cf4
3480d18c:	3480b2e8 	.word	0x3480b2e8
3480d190:	348261ed 	.word	0x348261ed
3480d194:	34826216 	.word	0x34826216

3480d198 <parse_file_outer>:
#ifndef __U_BOOT__
static int parse_file_outer(FILE *f)
#else
int parse_file_outer(void)
#endif
{
3480d198:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480d19c:	e59f3030 	ldr	r3, [pc, #48]	; 3480d1d4 <parse_file_outer+0x3c>
	i->__promptme=1;
	i->promptmode=1;
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480d1a0:	e28d0018 	add	r0, sp, #24
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480d1a4:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
3480d1a8:	e59f3028 	ldr	r3, [pc, #40]	; 3480d1d8 <parse_file_outer+0x40>
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480d1ac:	e3a01002 	mov	r1, #2
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
	i->get = file_get;
3480d1b0:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
3480d1b4:	e3a03001 	mov	r3, #1
3480d1b8:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480d1bc:	e58d300c 	str	r3, [sp, #12]
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480d1c0:	e3a03000 	mov	r3, #0
3480d1c4:	e5203014 	str	r3, [r0, #-20]!
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480d1c8:	ebfffe55 	bl	3480cb24 <parse_stream_outer>
	return rcode;
}
3480d1cc:	e28dd01c 	add	sp, sp, #28
3480d1d0:	e8bd8000 	pop	{pc}
3480d1d4:	3480b2e8 	.word	0x3480b2e8
3480d1d8:	3480b464 	.word	0x3480b464

3480d1dc <u_boot_hush_start>:
	}
}
#endif

int u_boot_hush_start(void)
{
3480d1dc:	e92d4038 	push	{r3, r4, r5, lr}
	if (top_vars == NULL) {
3480d1e0:	e59f503c 	ldr	r5, [pc, #60]	; 3480d224 <u_boot_hush_start+0x48>
3480d1e4:	e5954000 	ldr	r4, [r5]
3480d1e8:	e3540000 	cmp	r4, #0
3480d1ec:	1a00000a 	bne	3480d21c <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
3480d1f0:	e3a00014 	mov	r0, #20
3480d1f4:	ebfff3fa 	bl	3480a1e4 <malloc>
		top_vars->name = "HUSH_VERSION";
3480d1f8:	e59f3028 	ldr	r3, [pc, #40]	; 3480d228 <u_boot_hush_start+0x4c>
#endif

int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
3480d1fc:	e5850000 	str	r0, [r5]
		top_vars->name = "HUSH_VERSION";
3480d200:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
3480d204:	e59f3020 	ldr	r3, [pc, #32]	; 3480d22c <u_boot_hush_start+0x50>
		top_vars->next = 0;
3480d208:	e5804010 	str	r4, [r0, #16]
int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
3480d20c:	e5803004 	str	r3, [r0, #4]
		top_vars->next = 0;
		top_vars->flg_export = 0;
		top_vars->flg_read_only = 1;
3480d210:	e3a03001 	mov	r3, #1
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
		top_vars->next = 0;
		top_vars->flg_export = 0;
3480d214:	e5804008 	str	r4, [r0, #8]
		top_vars->flg_read_only = 1;
3480d218:	e580300c 	str	r3, [r0, #12]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		u_boot_hush_reloc();
#endif
	}
	return 0;
}
3480d21c:	e3a00000 	mov	r0, #0
3480d220:	e8bd8038 	pop	{r3, r4, r5, pc}
3480d224:	34829d28 	.word	0x34829d28
3480d228:	34826223 	.word	0x34826223
3480d22c:	34826230 	.word	0x34826230

3480d230 <__fswab32>:
3480d230:	e6bf0f30 	rev	r0, r0
3480d234:	e12fff1e 	bx	lr

3480d238 <image_check_magic.clone.8>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
3480d238:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
3480d23c:	ebfffffb 	bl	3480d230 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480d240:	e59f300c 	ldr	r3, [pc, #12]	; 3480d254 <image_check_magic.clone.8+0x1c>
3480d244:	e1500003 	cmp	r0, r3
3480d248:	13a00000 	movne	r0, #0
3480d24c:	03a00001 	moveq	r0, #1
3480d250:	e8bd8008 	pop	{r3, pc}
3480d254:	27051956 	.word	0x27051956

3480d258 <image_get_data_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480d258:	eafffff4 	b	3480d230 <__fswab32>

3480d25c <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
3480d25c:	e92d4030 	push	{r4, r5, lr}
3480d260:	e1a04000 	mov	r4, r0
3480d264:	e24dd044 	sub	sp, sp, #68	; 0x44
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
3480d268:	e1a01004 	mov	r1, r4
3480d26c:	e1a0000d 	mov	r0, sp
3480d270:	e3a02040 	mov	r2, #64	; 0x40
3480d274:	eb003d28 	bl	3481c71c <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
3480d278:	e1a0100d 	mov	r1, sp
3480d27c:	e3a02040 	mov	r2, #64	; 0x40
	static inline void image_set_##f(image_header_t *hdr, uint32_t val) \
	{ \
		hdr->ih_##f = cpu_to_uimage(val); \
	}
image_set_hdr_l(magic)		/* image_set_magic */
image_set_hdr_l(hcrc)		/* image_set_hcrc */
3480d280:	e3a00000 	mov	r0, #0
3480d284:	e58d0004 	str	r0, [sp, #4]
3480d288:	eb003584 	bl	3481a8a0 <crc32>
3480d28c:	e1a05000 	mov	r5, r0
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
3480d290:	e5940004 	ldr	r0, [r4, #4]
3480d294:	ebffffe5 	bl	3480d230 <__fswab32>

	return (hcrc == image_get_hcrc(hdr));
}
3480d298:	e1550000 	cmp	r5, r0
3480d29c:	13a00000 	movne	r0, #0
3480d2a0:	03a00001 	moveq	r0, #1
3480d2a4:	e28dd044 	add	sp, sp, #68	; 0x44
3480d2a8:	e8bd8030 	pop	{r4, r5, pc}

3480d2ac <image_check_dcrc>:

int image_check_dcrc(const image_header_t *hdr)
{
3480d2ac:	e92d4038 	push	{r3, r4, r5, lr}
3480d2b0:	e1a04000 	mov	r4, r0
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480d2b4:	e590000c 	ldr	r0, [r0, #12]
3480d2b8:	ebffffe6 	bl	3480d258 <image_get_data_size.clone.10>
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480d2bc:	e2841040 	add	r1, r4, #64	; 0x40
}

int image_check_dcrc(const image_header_t *hdr)
{
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480d2c0:	e1a02000 	mov	r2, r0
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480d2c4:	e3a03801 	mov	r3, #65536	; 0x10000
3480d2c8:	e3a00000 	mov	r0, #0
3480d2cc:	eb003578 	bl	3481a8b4 <crc32_wd>
3480d2d0:	e1a05000 	mov	r5, r0
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
image_get_hdr_l(ep)		/* image_get_ep */
image_get_hdr_l(dcrc)		/* image_get_dcrc */
3480d2d4:	e5940018 	ldr	r0, [r4, #24]
3480d2d8:	ebffffd4 	bl	3480d230 <__fswab32>

	return (dcrc == image_get_dcrc(hdr));
}
3480d2dc:	e1550000 	cmp	r5, r0
3480d2e0:	13a00000 	movne	r0, #0
3480d2e4:	03a00001 	moveq	r0, #1
3480d2e8:	e8bd8038 	pop	{r3, r4, r5, pc}

3480d2ec <image_multi_count>:
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
3480d2ec:	e280303c 	add	r3, r0, #60	; 0x3c
3480d2f0:	e3a00000 	mov	r0, #0
3480d2f4:	ea000000 	b	3480d2fc <image_multi_count+0x10>
3480d2f8:	e2800001 	add	r0, r0, #1
3480d2fc:	e5b32004 	ldr	r2, [r3, #4]!
3480d300:	e3520000 	cmp	r2, #0
3480d304:	1afffffb 	bne	3480d2f8 <image_multi_count+0xc>
		count++;

	return count;
}
3480d308:	e12fff1e 	bx	lr

3480d30c <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
3480d30c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480d310:	e1a0a003 	mov	sl, r3
3480d314:	e1a05001 	mov	r5, r1
3480d318:	e1a06002 	mov	r6, r2
3480d31c:	e1a04000 	mov	r4, r0
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480d320:	ebfffff1 	bl	3480d2ec <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480d324:	e1550000 	cmp	r5, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
3480d328:	23a03000 	movcs	r3, #0
3480d32c:	258a3000 	strcs	r3, [sl]
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480d330:	e1a0b000 	mov	fp, r0

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
		*data = 0;
3480d334:	25863000 	strcs	r3, [r6]

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480d338:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480d33c:	e2849040 	add	r9, r4, #64	; 0x40
		*len = uimage_to_cpu(size[idx]);
3480d340:	e7990105 	ldr	r0, [r9, r5, lsl #2]
3480d344:	ebffffb9 	bl	3480d230 <__fswab32>
		offset = 0;
3480d348:	e3a07000 	mov	r7, #0
	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
3480d34c:	e58a0000 	str	r0, [sl]
3480d350:	e284403c 	add	r4, r4, #60	; 0x3c
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480d354:	e1a0a007 	mov	sl, r7
3480d358:	ea000005 	b	3480d374 <image_multi_getimg+0x68>
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
3480d35c:	e5b40004 	ldr	r0, [r4, #4]!
3480d360:	ebffffb2 	bl	3480d230 <__fswab32>
3480d364:	e2800003 	add	r0, r0, #3
3480d368:	e3c00003 	bic	r0, r0, #3
3480d36c:	e0877000 	add	r7, r7, r0
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480d370:	e28aa001 	add	sl, sl, #1
3480d374:	e15a0005 	cmp	sl, r5
3480d378:	1afffff7 	bne	3480d35c <image_multi_getimg+0x50>
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
3480d37c:	e28bb001 	add	fp, fp, #1
3480d380:	e089910b 	add	r9, r9, fp, lsl #2
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
3480d384:	e0897007 	add	r7, r9, r7
3480d388:	e5867000 	str	r7, [r6]
3480d38c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480d390 <getenv_yesno>:
/*****************************************************************************/
/* Shared dual-format routines */
/*****************************************************************************/
#ifndef USE_HOSTCC
int getenv_yesno(char *var)
{
3480d390:	e92d4008 	push	{r3, lr}
	char *s = getenv(var);
3480d394:	ebffeadd 	bl	34807f10 <getenv>
	return (s && (*s == 'n')) ? 0 : 1;
3480d398:	e3500000 	cmp	r0, #0
3480d39c:	0a000003 	beq	3480d3b0 <getenv_yesno+0x20>
3480d3a0:	e5d00000 	ldrb	r0, [r0]
3480d3a4:	e250006e 	subs	r0, r0, #110	; 0x6e
3480d3a8:	13a00001 	movne	r0, #1
3480d3ac:	e8bd8008 	pop	{r3, pc}
3480d3b0:	e3a00001 	mov	r0, #1
}
3480d3b4:	e8bd8008 	pop	{r3, pc}

3480d3b8 <getenv_bootm_low>:

ulong getenv_bootm_low(void)
{
3480d3b8:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
3480d3bc:	e59f0020 	ldr	r0, [pc, #32]	; 3480d3e4 <getenv_bootm_low+0x2c>
3480d3c0:	ebffead2 	bl	34807f10 <getenv>
	if (s) {
3480d3c4:	e3500000 	cmp	r0, #0
3480d3c8:	0a000003 	beq	3480d3dc <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d3cc:	e3a01000 	mov	r1, #0
3480d3d0:	e3a02010 	mov	r2, #16
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480d3d4:	e8bd4010 	pop	{r4, lr}

ulong getenv_bootm_low(void)
{
	char *s = getenv("bootm_low");
	if (s) {
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d3d8:	ea003f81 	b	3481d1e4 <simple_strtoul>
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480d3dc:	e3a00202 	mov	r0, #536870912	; 0x20000000
3480d3e0:	e8bd8010 	pop	{r4, pc}
3480d3e4:	348262f6 	.word	0x348262f6

3480d3e8 <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
3480d3e8:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
3480d3ec:	e59f0048 	ldr	r0, [pc, #72]	; 3480d43c <getenv_bootm_size+0x54>
3480d3f0:	ebffeac6 	bl	34807f10 <getenv>
	if (s) {
3480d3f4:	e2504000 	subs	r4, r0, #0
3480d3f8:	0a000003 	beq	3480d40c <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d3fc:	e3a02010 	mov	r2, #16
3480d400:	e3a01000 	mov	r1, #0
3480d404:	eb003fe6 	bl	3481d3a4 <simple_strtoull>
		return tmp;
3480d408:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
3480d40c:	e59f002c 	ldr	r0, [pc, #44]	; 3480d440 <getenv_bootm_size+0x58>
3480d410:	ebffeabe 	bl	34807f10 <getenv>
	if (s)
3480d414:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
3480d418:	01a00003 	moveq	r0, r3
	if (s) {
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
		return tmp;
	}
	s = getenv("bootm_low");
	if (s)
3480d41c:	0a000002 	beq	3480d42c <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d420:	e1a01004 	mov	r1, r4
3480d424:	e3a02010 	mov	r2, #16
3480d428:	eb003fdd 	bl	3481d3a4 <simple_strtoull>
	else
		tmp = 0;


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
3480d42c:	e5983000 	ldr	r3, [r8]
3480d430:	e593301c 	ldr	r3, [r3, #28]
3480d434:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
3480d438:	e8bd8010 	pop	{r4, pc}
3480d43c:	34826300 	.word	0x34826300
3480d440:	348262f6 	.word	0x348262f6

3480d444 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
3480d444:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
3480d448:	e59f0020 	ldr	r0, [pc, #32]	; 3480d470 <getenv_bootm_mapsize+0x2c>
3480d44c:	ebffeaaf 	bl	34807f10 <getenv>
	if (s) {
3480d450:	e3500000 	cmp	r0, #0
3480d454:	0a000003 	beq	3480d468 <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d458:	e3a02010 	mov	r2, #16
3480d45c:	e3a01000 	mov	r1, #0
3480d460:	eb003fcf 	bl	3481d3a4 <simple_strtoull>
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
3480d464:	e8bd8010 	pop	{r4, pc}
3480d468:	e8bd4010 	pop	{r4, lr}
	}

#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
3480d46c:	eaffffdd 	b	3480d3e8 <getenv_bootm_size>
3480d470:	3482630b 	.word	0x3482630b

3480d474 <memmove_wd>:
#endif
}

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
3480d474:	e1510000 	cmp	r1, r0
3480d478:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
3480d47c:	ea003ca6 	b	3481c71c <memmove>

3480d480 <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
3480d480:	e92d4010 	push	{r4, lr}
3480d484:	e1a04000 	mov	r4, r0
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
3480d488:	e1a01004 	mov	r1, r4
3480d48c:	e59f0014 	ldr	r0, [pc, #20]	; 3480d4a8 <genimg_print_size+0x28>
3480d490:	ebfff18c 	bl	34809ac8 <printf>
	print_size(size, "\n");
3480d494:	e59f2010 	ldr	r2, [pc, #16]	; 3480d4ac <genimg_print_size+0x2c>
3480d498:	e1a00004 	mov	r0, r4
3480d49c:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
3480d4a0:	e8bd4010 	pop	{r4, lr}

void genimg_print_size(uint32_t size)
{
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
	print_size(size, "\n");
3480d4a4:	ea003515 	b	3481a900 <print_size>
3480d4a8:	34826319 	.word	0x34826319
3480d4ac:	34826197 	.word	0x34826197

3480d4b0 <get_table_entry_name>:
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
3480d4b0:	e1a03000 	mov	r3, r0
	for (; table->id >= 0; ++table) {
3480d4b4:	ea000003 	b	3480d4c8 <get_table_entry_name+0x18>
		if (table->id == id)
3480d4b8:	e1500002 	cmp	r0, r2
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
3480d4bc:	05931008 	ldreq	r1, [r3, #8]
3480d4c0:	0a000003 	beq	3480d4d4 <get_table_entry_name+0x24>
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
3480d4c4:	e283300c 	add	r3, r3, #12
3480d4c8:	e5930000 	ldr	r0, [r3]
3480d4cc:	e3500000 	cmp	r0, #0
3480d4d0:	aafffff8 	bge	3480d4b8 <get_table_entry_name+0x8>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
}
3480d4d4:	e1a00001 	mov	r0, r1
3480d4d8:	e12fff1e 	bx	lr

3480d4dc <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
3480d4dc:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
3480d4e0:	e59f1004 	ldr	r1, [pc, #4]	; 3480d4ec <genimg_get_os_name+0x10>
3480d4e4:	e59f0004 	ldr	r0, [pc, #4]	; 3480d4f0 <genimg_get_os_name+0x14>
3480d4e8:	eafffff0 	b	3480d4b0 <get_table_entry_name>
3480d4ec:	34826325 	.word	0x34826325
3480d4f0:	348210f0 	.word	0x348210f0

3480d4f4 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
3480d4f4:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
3480d4f8:	e59f1004 	ldr	r1, [pc, #4]	; 3480d504 <genimg_get_arch_name+0x10>
3480d4fc:	e59f0004 	ldr	r0, [pc, #4]	; 3480d508 <genimg_get_arch_name+0x14>
3480d500:	eaffffea 	b	3480d4b0 <get_table_entry_name>
3480d504:	34826330 	.word	0x34826330
3480d508:	34821144 	.word	0x34821144

3480d50c <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
3480d50c:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
3480d510:	e59f1004 	ldr	r1, [pc, #4]	; 3480d51c <genimg_get_type_name+0x10>
3480d514:	e59f0004 	ldr	r0, [pc, #4]	; 3480d520 <genimg_get_type_name+0x14>
3480d518:	eaffffe4 	b	3480d4b0 <get_table_entry_name>
3480d51c:	34826345 	.word	0x34826345
3480d520:	34821240 	.word	0x34821240

3480d524 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
3480d524:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
3480d528:	e59f1004 	ldr	r1, [pc, #4]	; 3480d534 <genimg_get_comp_name+0x10>
3480d52c:	e59f0004 	ldr	r0, [pc, #4]	; 3480d538 <genimg_get_comp_name+0x14>
3480d530:	eaffffde 	b	3480d4b0 <get_table_entry_name>
3480d534:	34826353 	.word	0x34826353
3480d538:	3482130c 	.word	0x3482130c

3480d53c <image_print_contents>:
 *
 * returns:
 *     no returned results
 */
void image_print_contents(const void *ptr)
{
3480d53c:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
3480d540:	e1a04000 	mov	r4, r0
	p = "";
#else
	p = "   ";
#endif

	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480d544:	e3a02020 	mov	r2, #32
3480d548:	e0843002 	add	r3, r4, r2
3480d54c:	e59f1138 	ldr	r1, [pc, #312]	; 3480d68c <image_print_contents+0x150>
3480d550:	e59f0138 	ldr	r0, [pc, #312]	; 3480d690 <image_print_contents+0x154>
3480d554:	ebfff15b 	bl	34809ac8 <printf>
#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
3480d558:	e59f112c 	ldr	r1, [pc, #300]	; 3480d68c <image_print_contents+0x150>
3480d55c:	e59f0130 	ldr	r0, [pc, #304]	; 3480d694 <image_print_contents+0x158>
3480d560:	ebfff158 	bl	34809ac8 <printf>

static void image_print_type(const image_header_t *hdr)
{
	const char *os, *arch, *type, *comp;

	os = genimg_get_os_name(image_get_os(hdr));
3480d564:	e5d4001c 	ldrb	r0, [r4, #28]
3480d568:	ebffffdb 	bl	3480d4dc <genimg_get_os_name>
3480d56c:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
3480d570:	e5d4001d 	ldrb	r0, [r4, #29]
3480d574:	ebffffde 	bl	3480d4f4 <genimg_get_arch_name>
3480d578:	e1a07000 	mov	r7, r0
	type = genimg_get_type_name(image_get_type(hdr));
3480d57c:	e5d4001e 	ldrb	r0, [r4, #30]
3480d580:	ebffffe1 	bl	3480d50c <genimg_get_type_name>
3480d584:	e1a05000 	mov	r5, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
3480d588:	e5d4001f 	ldrb	r0, [r4, #31]
3480d58c:	ebffffe4 	bl	3480d524 <genimg_get_comp_name>

	printf("%s %s %s (%s)\n", arch, os, type, comp);
3480d590:	e1a03005 	mov	r3, r5
3480d594:	e1a02006 	mov	r2, r6
3480d598:	e58d0000 	str	r0, [sp]
3480d59c:	e1a01007 	mov	r1, r7
3480d5a0:	e59f00f0 	ldr	r0, [pc, #240]	; 3480d698 <image_print_contents+0x15c>
3480d5a4:	ebfff147 	bl	34809ac8 <printf>
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
3480d5a8:	e59f10dc 	ldr	r1, [pc, #220]	; 3480d68c <image_print_contents+0x150>
3480d5ac:	e59f00e8 	ldr	r0, [pc, #232]	; 3480d69c <image_print_contents+0x160>
3480d5b0:	ebfff144 	bl	34809ac8 <printf>
	genimg_print_size(image_get_data_size(hdr));
3480d5b4:	e594000c 	ldr	r0, [r4, #12]
3480d5b8:	ebffff26 	bl	3480d258 <image_get_data_size.clone.10>
3480d5bc:	ebffffaf 	bl	3480d480 <genimg_print_size>
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
3480d5c0:	e5940010 	ldr	r0, [r4, #16]
3480d5c4:	ebffff19 	bl	3480d230 <__fswab32>
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
3480d5c8:	e59f10bc 	ldr	r1, [pc, #188]	; 3480d68c <image_print_contents+0x150>
3480d5cc:	e1a02000 	mov	r2, r0
3480d5d0:	e59f00c8 	ldr	r0, [pc, #200]	; 3480d6a0 <image_print_contents+0x164>
3480d5d4:	ebfff13b 	bl	34809ac8 <printf>
image_get_hdr_l(ep)		/* image_get_ep */
3480d5d8:	e5940014 	ldr	r0, [r4, #20]
3480d5dc:	ebffff13 	bl	3480d230 <__fswab32>
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
3480d5e0:	e59f10a4 	ldr	r1, [pc, #164]	; 3480d68c <image_print_contents+0x150>
3480d5e4:	e1a02000 	mov	r2, r0
3480d5e8:	e59f00b4 	ldr	r0, [pc, #180]	; 3480d6a4 <image_print_contents+0x168>
3480d5ec:	ebfff135 	bl	34809ac8 <printf>

	return 0;

error:
	return -1;
}
3480d5f0:	e5d4301e 	ldrb	r3, [r4, #30]
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
3480d5f4:	e3530004 	cmp	r3, #4
3480d5f8:	0a000001 	beq	3480d604 <image_print_contents+0xc8>
3480d5fc:	e3530006 	cmp	r3, #6
3480d600:	1a000020 	bne	3480d688 <image_print_contents+0x14c>
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480d604:	e1a00004 	mov	r0, r4
3480d608:	ebffff37 	bl	3480d2ec <image_multi_count>

		printf("%sContents:\n", p);
3480d60c:	e59f1078 	ldr	r1, [pc, #120]	; 3480d68c <image_print_contents+0x150>

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480d610:	e1a06000 	mov	r6, r0

		printf("%sContents:\n", p);
3480d614:	e59f008c 	ldr	r0, [pc, #140]	; 3480d6a8 <image_print_contents+0x16c>
3480d618:	ebfff12a 	bl	34809ac8 <printf>
		for (i = 0; i < count; i++) {
3480d61c:	e3a05000 	mov	r5, #0
			image_multi_getimg(hdr, i, &data, &len);
3480d620:	e28d700c 	add	r7, sp, #12
3480d624:	e28da008 	add	sl, sp, #8
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480d628:	ea000014 	b	3480d680 <image_print_contents+0x144>
			image_multi_getimg(hdr, i, &data, &len);
3480d62c:	e1a0300a 	mov	r3, sl
3480d630:	e1a00004 	mov	r0, r4
3480d634:	e1a01005 	mov	r1, r5
3480d638:	e1a02007 	mov	r2, r7
3480d63c:	ebffff32 	bl	3480d30c <image_multi_getimg>

			printf("%s   Image %d: ", p, i);
3480d640:	e59f1044 	ldr	r1, [pc, #68]	; 3480d68c <image_print_contents+0x150>
3480d644:	e1a02005 	mov	r2, r5
3480d648:	e59f005c 	ldr	r0, [pc, #92]	; 3480d6ac <image_print_contents+0x170>
3480d64c:	ebfff11d 	bl	34809ac8 <printf>
			genimg_print_size(len);
3480d650:	e59d0008 	ldr	r0, [sp, #8]
3480d654:	ebffff89 	bl	3480d480 <genimg_print_size>

			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
3480d658:	e5d4301e 	ldrb	r3, [r4, #30]
3480d65c:	e3530006 	cmp	r3, #6
3480d660:	1a000005 	bne	3480d67c <image_print_contents+0x140>
3480d664:	e3550000 	cmp	r5, #0
3480d668:	0a000003 	beq	3480d67c <image_print_contents+0x140>
				/*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
3480d66c:	e59f003c 	ldr	r0, [pc, #60]	; 3480d6b0 <image_print_contents+0x174>
3480d670:	e59f1014 	ldr	r1, [pc, #20]	; 3480d68c <image_print_contents+0x150>
3480d674:	e59d200c 	ldr	r2, [sp, #12]
3480d678:	ebfff112 	bl	34809ac8 <printf>
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480d67c:	e2855001 	add	r5, r5, #1
3480d680:	e1550006 	cmp	r5, r6
3480d684:	3affffe8 	bcc	3480d62c <image_print_contents+0xf0>
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
			}
		}
	}
}
3480d688:	e8bd84ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, sl, pc}
3480d68c:	348263aa 	.word	0x348263aa
3480d690:	34826367 	.word	0x34826367
3480d694:	3482637d 	.word	0x3482637d
3480d698:	3482638e 	.word	0x3482638e
3480d69c:	3482639d 	.word	0x3482639d
3480d6a0:	348263ae 	.word	0x348263ae
3480d6a4:	348263c4 	.word	0x348263c4
3480d6a8:	348263da 	.word	0x348263da
3480d6ac:	348263e7 	.word	0x348263e7
3480d6b0:	348263f7 	.word	0x348263f7

3480d6b4 <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
3480d6b4:	e92d4038 	push	{r3, r4, r5, lr}
3480d6b8:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480d6bc:	e1a04000 	mov	r4, r0
3480d6c0:	ea000009 	b	3480d6ec <get_table_entry_id+0x38>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
3480d6c4:	e5940004 	ldr	r0, [r4, #4]
3480d6c8:	e3500000 	cmp	r0, #0
3480d6cc:	0a000005 	beq	3480d6e8 <get_table_entry_id+0x34>
3480d6d0:	e1a01005 	mov	r1, r5
3480d6d4:	eb003afb 	bl	3481c2c8 <strcmp>
3480d6d8:	e3500000 	cmp	r0, #0
3480d6dc:	1a000001 	bne	3480d6e8 <get_table_entry_id+0x34>
#endif
			return (t->id);
3480d6e0:	e5940000 	ldr	r0, [r4]
3480d6e4:	e8bd8038 	pop	{r3, r4, r5, pc}
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480d6e8:	e284400c 	add	r4, r4, #12
3480d6ec:	e5943000 	ldr	r3, [r4]
3480d6f0:	e3530000 	cmp	r3, #0
3480d6f4:	aafffff2 	bge	3480d6c4 <get_table_entry_id+0x10>
#endif
			return (t->id);
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
3480d6f8:	e3e00000 	mvn	r0, #0
}
3480d6fc:	e8bd8038 	pop	{r3, r4, r5, pc}

3480d700 <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
3480d700:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_os, "OS", name));
3480d704:	e59f1004 	ldr	r1, [pc, #4]	; 3480d710 <genimg_get_os_id+0x10>
3480d708:	e59f0004 	ldr	r0, [pc, #4]	; 3480d714 <genimg_get_os_id+0x14>
3480d70c:	eaffffe8 	b	3480d6b4 <get_table_entry_id>
3480d710:	34826828 	.word	0x34826828
3480d714:	348210f0 	.word	0x348210f0

3480d718 <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
3480d718:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_arch, "CPU", name));
3480d71c:	e59f1004 	ldr	r1, [pc, #4]	; 3480d728 <genimg_get_arch_id+0x10>
3480d720:	e59f0004 	ldr	r0, [pc, #4]	; 3480d72c <genimg_get_arch_id+0x14>
3480d724:	eaffffe2 	b	3480d6b4 <get_table_entry_id>
3480d728:	34822d8d 	.word	0x34822d8d
3480d72c:	34821144 	.word	0x34821144

3480d730 <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
3480d730:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_type, "Image", name));
3480d734:	e59f1004 	ldr	r1, [pc, #4]	; 3480d740 <genimg_get_type_id+0x10>
3480d738:	e59f0004 	ldr	r0, [pc, #4]	; 3480d744 <genimg_get_type_id+0x14>
3480d73c:	eaffffdc 	b	3480d6b4 <get_table_entry_id>
3480d740:	3482666b 	.word	0x3482666b
3480d744:	34821240 	.word	0x34821240

3480d748 <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
3480d748:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_comp, "Compression", name));
3480d74c:	e59f1004 	ldr	r1, [pc, #4]	; 3480d758 <genimg_get_comp_id+0x10>
3480d750:	e59f0004 	ldr	r0, [pc, #4]	; 3480d75c <genimg_get_comp_id+0x14>
3480d754:	eaffffd6 	b	3480d6b4 <get_table_entry_id>
3480d758:	3482635b 	.word	0x3482635b
3480d75c:	3482130c 	.word	0x3482130c

3480d760 <genimg_get_format>:
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 */
int genimg_get_format(void *img_addr)
{
3480d760:	e92d4008 	push	{r3, lr}
#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
	char *fit_hdr;
#endif

	hdr = (const image_header_t *)img_addr;
	if (image_check_magic(hdr))
3480d764:	e5900000 	ldr	r0, [r0]
3480d768:	ebfffeb2 	bl	3480d238 <image_check_magic.clone.8>
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
3480d76c:	e2500000 	subs	r0, r0, #0
3480d770:	13a00001 	movne	r0, #1
3480d774:	e8bd8008 	pop	{r3, pc}

3480d778 <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
3480d778:	e12fff1e 	bx	lr

3480d77c <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
3480d77c:	e3a00000 	mov	r0, #0
3480d780:	e12fff1e 	bx	lr

3480d784 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480d784:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3480d788:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
3480d78c:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480d790:	e3a09000 	mov	r9, #0

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d794:	e3500002 	cmp	r0, #2
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480d798:	e5879000 	str	r9, [r7]
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480d79c:	e1a06001 	mov	r6, r1
3480d7a0:	e1a04002 	mov	r4, r2
3480d7a4:	e1a0a003 	mov	sl, r3
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
	*rd_end = 0;
3480d7a8:	e5859000 	str	r9, [r5]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d7ac:	da000006 	ble	3480d7cc <boot_get_ramdisk+0x48>
3480d7b0:	e5910008 	ldr	r0, [r1, #8]
3480d7b4:	e59f11d0 	ldr	r1, [pc, #464]	; 3480d98c <boot_get_ramdisk+0x208>
3480d7b8:	eb003ac2 	bl	3481c2c8 <strcmp>
3480d7bc:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
3480d7c0:	058d0004 	streq	r0, [sp, #4]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d7c4:	0a000044 	beq	3480d8dc <boot_get_ramdisk+0x158>
3480d7c8:	ea000065 	b	3480d964 <boot_get_ramdisk+0x1e0>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d7cc:	e5923044 	ldr	r3, [r2, #68]	; 0x44
3480d7d0:	e3530000 	cmp	r3, #0
3480d7d4:	1a000046 	bne	3480d8f4 <boot_get_ramdisk+0x170>
3480d7d8:	ea000053 	b	3480d92c <boot_get_ramdisk+0x1a8>
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
3480d7dc:	e1a01006 	mov	r1, r6
3480d7e0:	e59f01a8 	ldr	r0, [pc, #424]	; 3480d990 <boot_get_ramdisk+0x20c>
3480d7e4:	ebfff0b7 	bl	34809ac8 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d7e8:	e3a00009 	mov	r0, #9
3480d7ec:	eb00012c 	bl	3480dca4 <__show_boot_progress>
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480d7f0:	e5960000 	ldr	r0, [r6]
3480d7f4:	ebfffe8f 	bl	3480d238 <image_check_magic.clone.8>
3480d7f8:	e3500000 	cmp	r0, #0
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
					"Image at %08lx ...\n", rd_addr);

			bootstage_mark(BOOTSTAGE_ID_CHECK_RAMDISK);
			rd_hdr = image_get_ramdisk(rd_addr, arch,
3480d7fc:	e5944084 	ldr	r4, [r4, #132]	; 0x84
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480d800:	1a000003 	bne	3480d814 <boot_get_ramdisk+0x90>
		puts("Bad Magic Number\n");
3480d804:	e59f0188 	ldr	r0, [pc, #392]	; 3480d994 <boot_get_ramdisk+0x210>
3480d808:	ebfff0a4 	bl	34809aa0 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d80c:	e3e00009 	mvn	r0, #9
3480d810:	ea000006 	b	3480d830 <boot_get_ramdisk+0xac>
		bootstage_error(BOOTSTAGE_ID_RD_MAGIC);
		return NULL;
	}

	if (!image_check_hcrc(rd_hdr)) {
3480d814:	e1a00006 	mov	r0, r6
3480d818:	ebfffe8f 	bl	3480d25c <image_check_hcrc>
3480d81c:	e3500000 	cmp	r0, #0
3480d820:	1a000004 	bne	3480d838 <boot_get_ramdisk+0xb4>
		puts("Bad Header Checksum\n");
3480d824:	e59f016c 	ldr	r0, [pc, #364]	; 3480d998 <boot_get_ramdisk+0x214>
3480d828:	ebfff09c 	bl	34809aa0 <puts>
3480d82c:	e3e0000a 	mvn	r0, #10
3480d830:	eb00011b 	bl	3480dca4 <__show_boot_progress>
3480d834:	ea000048 	b	3480d95c <boot_get_ramdisk+0x1d8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d838:	e3a0000a 	mov	r0, #10
3480d83c:	eb000118 	bl	3480dca4 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_RD_HDR_CHECKSUM);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_RD_MAGIC);
	image_print_contents(rd_hdr);
3480d840:	e1a00006 	mov	r0, r6
3480d844:	ebffff3c 	bl	3480d53c <image_print_contents>

	if (verify) {
3480d848:	e3540000 	cmp	r4, #0
3480d84c:	0a00000b 	beq	3480d880 <boot_get_ramdisk+0xfc>
		puts("   Verifying Checksum ... ");
3480d850:	e59f0144 	ldr	r0, [pc, #324]	; 3480d99c <boot_get_ramdisk+0x218>
3480d854:	ebfff091 	bl	34809aa0 <puts>
		if (!image_check_dcrc(rd_hdr)) {
3480d858:	e1a00006 	mov	r0, r6
3480d85c:	ebfffe92 	bl	3480d2ac <image_check_dcrc>
3480d860:	e3500000 	cmp	r0, #0
3480d864:	1a000003 	bne	3480d878 <boot_get_ramdisk+0xf4>
			puts("Bad Data CRC\n");
3480d868:	e59f0130 	ldr	r0, [pc, #304]	; 3480d9a0 <boot_get_ramdisk+0x21c>
3480d86c:	ebfff08b 	bl	34809aa0 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d870:	e3e0000b 	mvn	r0, #11
3480d874:	eaffffed 	b	3480d830 <boot_get_ramdisk+0xac>
			bootstage_error(BOOTSTAGE_ID_RD_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
3480d878:	e59f0124 	ldr	r0, [pc, #292]	; 3480d9a4 <boot_get_ramdisk+0x220>
3480d87c:	ebfff087 	bl	34809aa0 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d880:	e3a0000b 	mov	r0, #11
3480d884:	eb000106 	bl	3480dca4 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_RD_HDR_CHECKSUM);

	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
3480d888:	e5d6301c 	ldrb	r3, [r6, #28]
3480d88c:	e3530005 	cmp	r3, #5
3480d890:	1a000005 	bne	3480d8ac <boot_get_ramdisk+0x128>
3480d894:	e5d6301d 	ldrb	r3, [r6, #29]
3480d898:	e153000a 	cmp	r3, sl
3480d89c:	1a000002 	bne	3480d8ac <boot_get_ramdisk+0x128>
	    !image_check_arch(rd_hdr, arch) ||
3480d8a0:	e5d6301e 	ldrb	r3, [r6, #30]
3480d8a4:	e3530003 	cmp	r3, #3
3480d8a8:	0a000007 	beq	3480d8cc <boot_get_ramdisk+0x148>
	    !image_check_type(rd_hdr, IH_TYPE_RAMDISK)) {
		printf("No Linux %s Ramdisk Image\n",
3480d8ac:	e1a0000a 	mov	r0, sl
3480d8b0:	ebffff0f 	bl	3480d4f4 <genimg_get_arch_name>
3480d8b4:	e1a01000 	mov	r1, r0
3480d8b8:	e59f00e8 	ldr	r0, [pc, #232]	; 3480d9a8 <boot_get_ramdisk+0x224>
3480d8bc:	ebfff081 	bl	34809ac8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d8c0:	e3e0000c 	mvn	r0, #12
3480d8c4:	eb0000f6 	bl	3480dca4 <__show_boot_progress>
3480d8c8:	ea000007 	b	3480d8ec <boot_get_ramdisk+0x168>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480d8cc:	e2863040 	add	r3, r6, #64	; 0x40

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
			rd_len = image_get_data_size(rd_hdr);
3480d8d0:	e596000c 	ldr	r0, [r6, #12]
							images->verify);

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
3480d8d4:	e58d3004 	str	r3, [sp, #4]
			rd_len = image_get_data_size(rd_hdr);
3480d8d8:	ebfffe5e 	bl	3480d258 <image_get_data_size.clone.10>
3480d8dc:	e58d0000 	str	r0, [sp]
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d8e0:	ea000016 	b	3480d940 <boot_get_ramdisk+0x1bc>
				rd_len = simple_strtoul(++end, NULL, 16);
				rd_data = rd_addr;
			} else
#endif
			{
				puts("Wrong Ramdisk Image Format\n");
3480d8e4:	e59f00c0 	ldr	r0, [pc, #192]	; 3480d9ac <boot_get_ramdisk+0x228>
3480d8e8:	ebfff06c 	bl	34809aa0 <puts>
				rd_data = rd_len = rd_load = 0;
				return 1;
3480d8ec:	e3a09001 	mov	r9, #1
3480d8f0:	ea000019 	b	3480d95c <boot_get_ramdisk+0x1d8>
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d8f4:	e5d23022 	ldrb	r3, [r2, #34]	; 0x22
3480d8f8:	e3530004 	cmp	r3, #4
3480d8fc:	1a00000a 	bne	3480d92c <boot_get_ramdisk+0x1a8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d900:	e3a0000d 	mov	r0, #13
3480d904:	eb0000e6 	bl	3480dca4 <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
3480d908:	e5941000 	ldr	r1, [r4]
3480d90c:	e59f009c 	ldr	r0, [pc, #156]	; 3480d9b0 <boot_get_ramdisk+0x22c>
3480d910:	ebfff06c 	bl	34809ac8 <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
3480d914:	e5940000 	ldr	r0, [r4]
3480d918:	e3a01001 	mov	r1, #1
3480d91c:	e28d2004 	add	r2, sp, #4
3480d920:	e1a0300d 	mov	r3, sp
3480d924:	ebfffe78 	bl	3480d30c <image_multi_getimg>
3480d928:	ea000004 	b	3480d940 <boot_get_ramdisk+0x1bc>
3480d92c:	e3a0000e 	mov	r0, #14
3480d930:	eb0000db 	bl	3480dca4 <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
3480d934:	e3a03000 	mov	r3, #0
3480d938:	e58d3004 	str	r3, [sp, #4]
3480d93c:	e58d3000 	str	r3, [sp]
	}

	if (!rd_data) {
3480d940:	e59d9004 	ldr	r9, [sp, #4]
3480d944:	e3590000 	cmp	r9, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
3480d948:	15879000 	strne	r9, [r7]
		*rd_end = rd_data + rd_len;
3480d94c:	159d3000 	ldrne	r3, [sp]
3480d950:	10839009 	addne	r9, r3, r9
3480d954:	15859000 	strne	r9, [r5]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
3480d958:	13a09000 	movne	r9, #0
}
3480d95c:	e1a00009 	mov	r0, r9
3480d960:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr);
			} else
#endif
			{
				rd_addr = simple_strtoul(argv[2], NULL, 16);
3480d964:	e1a01009 	mov	r1, r9
3480d968:	e5960008 	ldr	r0, [r6, #8]
3480d96c:	e3a02010 	mov	r2, #16
3480d970:	eb003e1b 	bl	3481d1e4 <simple_strtoul>
3480d974:	e1a06000 	mov	r6, r0
		/*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
3480d978:	ebffff78 	bl	3480d760 <genimg_get_format>
3480d97c:	e3500001 	cmp	r0, #1
3480d980:	e1a09000 	mov	r9, r0
3480d984:	1affffd6 	bne	3480d8e4 <boot_get_ramdisk+0x160>
3480d988:	eaffff93 	b	3480d7dc <boot_get_ramdisk+0x58>
3480d98c:	34827404 	.word	0x34827404
3480d990:	3482640f 	.word	0x3482640f
3480d994:	34822e56 	.word	0x34822e56
3480d998:	34822e6b 	.word	0x34822e6b
3480d99c:	34822e80 	.word	0x34822e80
3480d9a0:	34822e9e 	.word	0x34822e9e
3480d9a4:	34822eac 	.word	0x34822eac
3480d9a8:	34826447 	.word	0x34826447
3480d9ac:	34826462 	.word	0x34826462
3480d9b0:	3482647e 	.word	0x3482647e

3480d9b4 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480d9b4:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3480d9b8:	e1a0a000 	mov	sl, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d9bc:	e59f010c 	ldr	r0, [pc, #268]	; 3480dad0 <boot_ramdisk_high+0x11c>
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480d9c0:	e1a05003 	mov	r5, r3
3480d9c4:	e1a04001 	mov	r4, r1
3480d9c8:	e1a06002 	mov	r6, r2
3480d9cc:	e59d9020 	ldr	r9, [sp, #32]
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d9d0:	ebffe94e 	bl	34807f10 <getenv>
3480d9d4:	e3500000 	cmp	r0, #0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480d9d8:	03a07001 	moveq	r7, #1
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {
		/* not set, no restrictions to load high */
		initrd_high = ~0;
3480d9dc:	03e03000 	mvneq	r3, #0
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d9e0:	0a000005 	beq	3480d9fc <boot_ramdisk_high+0x48>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
3480d9e4:	e3a01000 	mov	r1, #0
3480d9e8:	e3a02010 	mov	r2, #16
3480d9ec:	eb003dfc 	bl	3481d1e4 <simple_strtoul>
3480d9f0:	e1a03000 	mov	r3, r0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480d9f4:	e2907001 	adds	r7, r0, #1
3480d9f8:	13a07001 	movne	r7, #1
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
3480d9fc:	e3540000 	cmp	r4, #0
3480da00:	0a00002e 	beq	3480dac0 <boot_ramdisk_high+0x10c>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
3480da04:	e3570000 	cmp	r7, #0
3480da08:	1a000008 	bne	3480da30 <boot_ramdisk_high+0x7c>
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480da0c:	e0863004 	add	r3, r6, r4
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
3480da10:	e5854000 	str	r4, [r5]
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
3480da14:	e1a0000a 	mov	r0, sl

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480da18:	e5893000 	str	r3, [r9]
			lmb_reserve(lmb, rd_data, rd_len);
3480da1c:	e1a01004 	mov	r1, r4
3480da20:	e1a02006 	mov	r2, r6
3480da24:	eb003912 	bl	3481be74 <lmb_reserve>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480da28:	e1a00007 	mov	r0, r7
3480da2c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
		} else {
			if (initrd_high)
3480da30:	e3530000 	cmp	r3, #0
3480da34:	0a000004 	beq	3480da4c <boot_ramdisk_high+0x98>
				*initrd_start = (ulong)lmb_alloc_base(lmb,
3480da38:	e1a0000a 	mov	r0, sl
3480da3c:	e1a01006 	mov	r1, r6
3480da40:	e3a02a01 	mov	r2, #4096	; 0x1000
3480da44:	eb00396d 	bl	3481c000 <lmb_alloc_base>
3480da48:	ea000003 	b	3480da5c <boot_ramdisk_high+0xa8>
						rd_len, 0x1000, initrd_high);
			else
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
3480da4c:	e1a0000a 	mov	r0, sl
3480da50:	e1a01006 	mov	r1, r6
3480da54:	e3a02a01 	mov	r2, #4096	; 0x1000
3480da58:	eb003975 	bl	3481c034 <lmb_alloc>
3480da5c:	e5850000 	str	r0, [r5]
								 0x1000);

			if (*initrd_start == 0) {
3480da60:	e5953000 	ldr	r3, [r5]
3480da64:	e3530000 	cmp	r3, #0
3480da68:	1a000003 	bne	3480da7c <boot_ramdisk_high+0xc8>
				puts("ramdisk - allocation error\n");
3480da6c:	e59f0060 	ldr	r0, [pc, #96]	; 3480dad4 <boot_ramdisk_high+0x120>
3480da70:	ebfff00a 	bl	34809aa0 <puts>
			*initrd_start, *initrd_end);

	return 0;

error:
	return -1;
3480da74:	e3e00000 	mvn	r0, #0
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
								 0x1000);

			if (*initrd_start == 0) {
				puts("ramdisk - allocation error\n");
				goto error;
3480da78:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480da7c:	e3a0000c 	mov	r0, #12
3480da80:	eb000087 	bl	3480dca4 <__show_boot_progress>
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480da84:	e5952000 	ldr	r2, [r5]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480da88:	e59f0048 	ldr	r0, [pc, #72]	; 3480dad8 <boot_ramdisk_high+0x124>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480da8c:	e0862002 	add	r2, r6, r2
3480da90:	e5892000 	str	r2, [r9]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480da94:	e5951000 	ldr	r1, [r5]
3480da98:	ebfff00a 	bl	34809ac8 <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
3480da9c:	e5950000 	ldr	r0, [r5]
3480daa0:	e1a01004 	mov	r1, r4
3480daa4:	e1a02006 	mov	r2, r6
3480daa8:	e3a03801 	mov	r3, #65536	; 0x10000
3480daac:	ebfffe70 	bl	3480d474 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
3480dab0:	e59f0024 	ldr	r0, [pc, #36]	; 3480dadc <boot_ramdisk_high+0x128>
3480dab4:	ebffeff9 	bl	34809aa0 <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480dab8:	e3a00000 	mov	r0, #0
3480dabc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
3480dac0:	e5854000 	str	r4, [r5]
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480dac4:	e1a00004 	mov	r0, r4
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
		*initrd_end = 0;
3480dac8:	e5894000 	str	r4, [r9]

	return 0;

error:
	return -1;
}
3480dacc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480dad0:	348264c6 	.word	0x348264c6
3480dad4:	348264d2 	.word	0x348264d2
3480dad8:	348264ee 	.word	0x348264ee
3480dadc:	34822eac 	.word	0x34822eac

3480dae0 <delete_char>:
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480dae0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480dae4:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
3480dae8:	e5933000 	ldr	r3, [r3]
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480daec:	e1a04000 	mov	r4, r0
	char *s;

	if (*np == 0) {
3480daf0:	e3530000 	cmp	r3, #0
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480daf4:	e1a05001 	mov	r5, r1
3480daf8:	e1a06002 	mov	r6, r2
3480dafc:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
3480db00:	0a000028 	beq	3480dba8 <delete_char+0xc8>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480db04:	e5753001 	ldrb	r3, [r5, #-1]!
3480db08:	e3530009 	cmp	r3, #9
3480db0c:	1a00001d 	bne	3480db88 <delete_char+0xa8>
3480db10:	ea000004 	b	3480db28 <delete_char+0x48>
		while (*colp > plen) {
			puts (erase_seq);
3480db14:	e59f0094 	ldr	r0, [pc, #148]	; 3480dbb0 <delete_char+0xd0>
3480db18:	ebffefe0 	bl	34809aa0 <puts>
			(*colp)--;
3480db1c:	e5963000 	ldr	r3, [r6]
3480db20:	e2433001 	sub	r3, r3, #1
3480db24:	e5863000 	str	r3, [r6]
	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
3480db28:	e5963000 	ldr	r3, [r6]
3480db2c:	e153000a 	cmp	r3, sl
3480db30:	cafffff7 	bgt	3480db14 <delete_char+0x34>
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
3480db34:	e59fa078 	ldr	sl, [pc, #120]	; 3480dbb4 <delete_char+0xd4>
3480db38:	ea00000f 	b	3480db7c <delete_char+0x9c>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
3480db3c:	e4d43001 	ldrb	r3, [r4], #1
3480db40:	e5960000 	ldr	r0, [r6]
3480db44:	e3530009 	cmp	r3, #9
3480db48:	1a000007 	bne	3480db6c <delete_char+0x8c>
				puts (tab_seq+((*colp) & 07));
3480db4c:	e2000007 	and	r0, r0, #7
3480db50:	e08a0000 	add	r0, sl, r0
3480db54:	ebffefd1 	bl	34809aa0 <puts>
				*colp += 8 - ((*colp) & 07);
3480db58:	e5963000 	ldr	r3, [r6]
3480db5c:	e3c33007 	bic	r3, r3, #7
3480db60:	e2833008 	add	r3, r3, #8
3480db64:	e5863000 	str	r3, [r6]
3480db68:	ea000003 	b	3480db7c <delete_char+0x9c>
			} else {
				++(*colp);
3480db6c:	e2800001 	add	r0, r0, #1
3480db70:	e5860000 	str	r0, [r6]
				putc (*s);
3480db74:	e5540001 	ldrb	r0, [r4, #-1]
3480db78:	ebffefbe 	bl	34809a78 <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
3480db7c:	e1550004 	cmp	r5, r4
3480db80:	8affffed 	bhi	3480db3c <delete_char+0x5c>
3480db84:	ea000004 	b	3480db9c <delete_char+0xbc>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
3480db88:	e59f0020 	ldr	r0, [pc, #32]	; 3480dbb0 <delete_char+0xd0>
3480db8c:	ebffefc3 	bl	34809aa0 <puts>
		(*colp)--;
3480db90:	e5963000 	ldr	r3, [r6]
3480db94:	e2433001 	sub	r3, r3, #1
3480db98:	e5863000 	str	r3, [r6]
	}
	(*np)--;
3480db9c:	e5973000 	ldr	r3, [r7]
3480dba0:	e2433001 	sub	r3, r3, #1
3480dba4:	e5873000 	str	r3, [r7]
	return (p);
}
3480dba8:	e1a00005 	mov	r0, r5
3480dbac:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480dbb0:	34821354 	.word	0x34821354
3480dbb4:	34821358 	.word	0x34821358

3480dbb8 <cread_add_char>:
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480dbb8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480dbbc:	e3510000 	cmp	r1, #0
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480dbc0:	e1a04002 	mov	r4, r2
3480dbc4:	e1a05000 	mov	r5, r0
3480dbc8:	e59d6018 	ldr	r6, [sp, #24]
3480dbcc:	e59d201c 	ldr	r2, [sp, #28]
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480dbd0:	1a000003 	bne	3480dbe4 <cread_add_char+0x2c>
3480dbd4:	e594c000 	ldr	ip, [r4]
3480dbd8:	e5930000 	ldr	r0, [r3]
3480dbdc:	e15c0000 	cmp	ip, r0
3480dbe0:	1a000023 	bne	3480dc74 <cread_add_char+0xbc>
		if (*eol_num > len - 1) {
3480dbe4:	e5937000 	ldr	r7, [r3]
3480dbe8:	e2422001 	sub	r2, r2, #1
3480dbec:	e1570002 	cmp	r7, r2
3480dbf0:	9a000002 	bls	3480dc00 <cread_add_char+0x48>
			getcmd_cbeep();
3480dbf4:	e3a00007 	mov	r0, #7
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}
3480dbf8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
3480dbfc:	eaffef9d 	b	34809a78 <putc>
			return;
		}
		(*eol_num)++;
3480dc00:	e2877001 	add	r7, r7, #1
	}

	if (insert) {
3480dc04:	e3510000 	cmp	r1, #0
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
3480dc08:	e5837000 	str	r7, [r3]
	}

	if (insert) {
3480dc0c:	0a000018 	beq	3480dc74 <cread_add_char+0xbc>
		wlen = *eol_num - *num;
3480dc10:	e5941000 	ldr	r1, [r4]
3480dc14:	e0617007 	rsb	r7, r1, r7
		if (wlen > 1) {
3480dc18:	e3570001 	cmp	r7, #1
3480dc1c:	9a000004 	bls	3480dc34 <cread_add_char+0x7c>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
3480dc20:	e2810001 	add	r0, r1, #1
3480dc24:	e0860000 	add	r0, r6, r0
3480dc28:	e0861001 	add	r1, r6, r1
3480dc2c:	e2472001 	sub	r2, r7, #1
3480dc30:	eb003ab9 	bl	3481c71c <memmove>
		}

		buf[*num] = ichar;
3480dc34:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480dc38:	e59f0060 	ldr	r0, [pc, #96]	; 3480dca0 <cread_add_char+0xe8>
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
3480dc3c:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480dc40:	e5942000 	ldr	r2, [r4]
3480dc44:	e1a01007 	mov	r1, r7
3480dc48:	e0862002 	add	r2, r6, r2
3480dc4c:	ebffef9d 	bl	34809ac8 <printf>
		(*num)++;
3480dc50:	e5943000 	ldr	r3, [r4]
3480dc54:	e2833001 	add	r3, r3, #1
3480dc58:	e5843000 	str	r3, [r4]
		while (--wlen) {
3480dc5c:	ea000001 	b	3480dc68 <cread_add_char+0xb0>
			getcmd_putch(CTL_BACKSPACE);
3480dc60:	e3a00008 	mov	r0, #8
3480dc64:	ebffef83 	bl	34809a78 <putc>
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
3480dc68:	e2577001 	subs	r7, r7, #1
3480dc6c:	1afffffb 	bne	3480dc60 <cread_add_char+0xa8>
3480dc70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480dc74:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480dc78:	e59f0020 	ldr	r0, [pc, #32]	; 3480dca0 <cread_add_char+0xe8>
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480dc7c:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480dc80:	e5942000 	ldr	r2, [r4]
3480dc84:	e3a01001 	mov	r1, #1
3480dc88:	e0862002 	add	r2, r6, r2
3480dc8c:	ebffef8d 	bl	34809ac8 <printf>
		(*num)++;
3480dc90:	e5943000 	ldr	r3, [r4]
3480dc94:	e2833001 	add	r3, r3, #1
3480dc98:	e5843000 	str	r3, [r4]
3480dc9c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
3480dca0:	3482686c 	.word	0x3482686c

3480dca4 <__show_boot_progress>:
#endif

/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 */
void inline __show_boot_progress (int val) {}
3480dca4:	e12fff1e 	bx	lr

3480dca8 <readline_into_buffer>:
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480dca8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480dcac:	e5983004 	ldr	r3, [r8, #4]
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480dcb0:	e24dd040 	sub	sp, sp, #64	; 0x40
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480dcb4:	e2133001 	ands	r3, r3, #1
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480dcb8:	e1a06000 	mov	r6, r0
3480dcbc:	e1a04001 	mov	r4, r1
3480dcc0:	e58d201c 	str	r2, [sp, #28]
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480dcc4:	0a0001b7 	beq	3480e3a8 <readline_into_buffer+0x700>
		if (!initted) {
3480dcc8:	e59f28a0 	ldr	r2, [pc, #2208]	; 3480e570 <readline_into_buffer+0x8c8>
3480dccc:	e5923000 	ldr	r3, [r2]
3480dcd0:	e3530000 	cmp	r3, #0
3480dcd4:	1a000010 	bne	3480dd1c <readline_into_buffer+0x74>
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
3480dcd8:	e59f1894 	ldr	r1, [pc, #2196]	; 3480e574 <readline_into_buffer+0x8cc>
3480dcdc:	e3e00000 	mvn	r0, #0
3480dce0:	e5810000 	str	r0, [r1]
	hist_num = 0;
3480dce4:	e59f188c 	ldr	r1, [pc, #2188]	; 3480e578 <readline_into_buffer+0x8d0>

	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
3480dce8:	e59f088c 	ldr	r0, [pc, #2188]	; 3480e57c <readline_into_buffer+0x8d4>

static void hist_init(void)
{
	int i;

	hist_max = 0;
3480dcec:	e5823004 	str	r3, [r2, #4]
	hist_add_idx = 0;
3480dcf0:	e5823008 	str	r3, [r2, #8]
	hist_cur = -1;
	hist_num = 0;
3480dcf4:	e582300c 	str	r3, [r2, #12]

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
3480dcf8:	e2822010 	add	r2, r2, #16
3480dcfc:	e5a12004 	str	r2, [r1, #4]!
		hist_list[i][0] = '\0';
3480dd00:	e4c23100 	strb	r3, [r2], #256	; 0x100
3480dd04:	e2822001 	add	r2, r2, #1
	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
3480dd08:	e1520000 	cmp	r2, r0
3480dd0c:	1afffffa 	bne	3480dcfc <readline_into_buffer+0x54>
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
		if (!initted) {
			hist_init();
			initted = 1;
3480dd10:	e59f3858 	ldr	r3, [pc, #2136]	; 3480e570 <readline_into_buffer+0x8c8>
3480dd14:	e3a02001 	mov	r2, #1
3480dd18:	e5832000 	str	r2, [r3]
		}

		if (prompt)
3480dd1c:	e3560000 	cmp	r6, #0
3480dd20:	0a000001 	beq	3480dd2c <readline_into_buffer+0x84>
			puts (prompt);
3480dd24:	e1a00006 	mov	r0, r6
3480dd28:	ebffef5c 	bl	34809aa0 <puts>
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480dd2c:	e3a03000 	mov	r3, #0
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480dd30:	e1a00004 	mov	r0, r4
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480dd34:	e58d3034 	str	r3, [sp, #52]	; 0x34
	unsigned long eol_num = 0;
3480dd38:	e58d3030 	str	r3, [sp, #48]	; 0x30
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480dd3c:	eb003995 	bl	3481c398 <strlen>
	int first = 1;

	if (init_len)
3480dd40:	e2505000 	subs	r5, r0, #0
3480dd44:	1a000011 	bne	3480dd90 <readline_into_buffer+0xe8>
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480dd48:	e59d101c 	ldr	r1, [sp, #28]
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480dd4c:	e3a0b001 	mov	fp, #1
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480dd50:	e1a00001 	mov	r0, r1
3480dd54:	e1a01fc0 	asr	r1, r0, #31
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480dd58:	e3a0a000 	mov	sl, #0
3480dd5c:	e1a0700b 	mov	r7, fp
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480dd60:	e1cd02f0 	strd	r0, [sp, #32]

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480dd64:	e59f5808 	ldr	r5, [pc, #2056]	; 3480e574 <readline_into_buffer+0x8cc>
		return NULL;

	if (hist_cur == hist_add_idx)
3480dd68:	e59f6800 	ldr	r6, [pc, #2048]	; 3480e570 <readline_into_buffer+0x8c8>
3480dd6c:	ea00000f 	b	3480ddb0 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480dd70:	e4d60001 	ldrb	r0, [r6], #1
3480dd74:	e3a01001 	mov	r1, #1
3480dd78:	e1a02007 	mov	r2, r7
3480dd7c:	e1a0300a 	mov	r3, sl
3480dd80:	e88d0210 	stm	sp, {r4, r9}
		str++;
3480dd84:	e2455001 	sub	r5, r5, #1

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480dd88:	ebffff8a 	bl	3480dbb8 <cread_add_char>
3480dd8c:	ea000003 	b	3480dda0 <readline_into_buffer+0xf8>
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
	int first = 1;

	if (init_len)
3480dd90:	e1a06004 	mov	r6, r4
		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
3480dd94:	e28d7034 	add	r7, sp, #52	; 0x34
3480dd98:	e28da030 	add	sl, sp, #48	; 0x30

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480dd9c:	e3a09c01 	mov	r9, #256	; 0x100
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480dda0:	e3550000 	cmp	r5, #0
3480dda4:	1afffff1 	bne	3480dd70 <readline_into_buffer+0xc8>
3480dda8:	eaffffe6 	b	3480dd48 <readline_into_buffer+0xa0>
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;
3480ddac:	e3a0a000 	mov	sl, #0
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
3480ddb0:	e59d201c 	ldr	r2, [sp, #28]
3480ddb4:	e3520000 	cmp	r2, #0
3480ddb8:	03a03000 	moveq	r3, #0
3480ddbc:	120b3001 	andne	r3, fp, #1
3480ddc0:	e3530000 	cmp	r3, #0
3480ddc4:	0a000017 	beq	3480de28 <readline_into_buffer+0x180>
			uint64_t etime = endtick(timeout);
3480ddc8:	ebffcd6f 	bl	3480138c <get_ticks>
3480ddcc:	e1cd01f0 	strd	r0, [sp, #16]
3480ddd0:	ebffcd71 	bl	3480139c <get_tbclk>
3480ddd4:	e59d101c 	ldr	r1, [sp, #28]
3480ddd8:	e0832190 	umull	r2, r3, r0, r1
3480dddc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3480dde0:	e0233190 	mla	r3, r0, r1, r3
3480dde4:	e1cd01d0 	ldrd	r0, [sp, #16]
3480dde8:	e0900002 	adds	r0, r0, r2
3480ddec:	e0a11003 	adc	r1, r1, r3
3480ddf0:	e1cd01f0 	strd	r0, [sp, #16]
3480ddf4:	ea000007 	b	3480de18 <readline_into_buffer+0x170>

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
3480ddf8:	ebffcd63 	bl	3480138c <get_ticks>
3480ddfc:	e59d2014 	ldr	r2, [sp, #20]
3480de00:	e1520001 	cmp	r2, r1
3480de04:	8a000003 	bhi	3480de18 <readline_into_buffer+0x170>
3480de08:	1a000164 	bne	3480e3a0 <readline_into_buffer+0x6f8>
3480de0c:	e59d3010 	ldr	r3, [sp, #16]
3480de10:	e1530000 	cmp	r3, r0
3480de14:	9a000161 	bls	3480e3a0 <readline_into_buffer+0x6f8>
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
3480de18:	ebffef0d 	bl	34809a54 <tstc>
3480de1c:	e3500000 	cmp	r0, #0
3480de20:	0afffff4 	beq	3480ddf8 <readline_into_buffer+0x150>
				if (get_ticks() >= etime)
					return -2;	/* timed out */
				WATCHDOG_RESET();
			}
			first = 0;
3480de24:	e3a0b000 	mov	fp, #0
		}

		ichar = getcmd_getch();
3480de28:	ebffef00 	bl	34809a30 <getc>
3480de2c:	e6ef0070 	uxtb	r0, r0

		if ((ichar == '\n') || (ichar == '\r')) {
3480de30:	e350000a 	cmp	r0, #10
3480de34:	1350000d 	cmpne	r0, #13
3480de38:	13a09000 	movne	r9, #0
3480de3c:	03a09001 	moveq	r9, #1
3480de40:	1a000009 	bne	3480de6c <readline_into_buffer+0x1c4>
			putc('\n');
3480de44:	e3a0000a 	mov	r0, #10
3480de48:	ebffef0a 	bl	34809a78 <putc>
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
3480de4c:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
	buf[eol_num] = '\0';	/* lose the newline */
3480de50:	e3a03000 	mov	r3, #0
3480de54:	e7c43006 	strb	r3, [r4, r6]

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
3480de58:	e5d43000 	ldrb	r3, [r4]
3480de5c:	e3530021 	cmp	r3, #33	; 0x21
3480de60:	13530000 	cmpne	r3, #0
3480de64:	0a000147 	beq	3480e388 <readline_into_buffer+0x6e0>
3480de68:	ea000134 	b	3480e340 <readline_into_buffer+0x698>
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
3480de6c:	e35a0000 	cmp	sl, #0
3480de70:	0a000032 	beq	3480df40 <readline_into_buffer+0x298>
			if (esc_len == 1) {
3480de74:	e35a0001 	cmp	sl, #1
3480de78:	1a00000d 	bne	3480deb4 <readline_into_buffer+0x20c>
				if (ichar == '[') {
3480de7c:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
3480de80:	05cd0029 	strbeq	r0, [sp, #41]	; 0x29
					esc_len = 2;
3480de84:	03a0a002 	moveq	sl, #2
		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
3480de88:	0affffc8 	beq	3480ddb0 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480de8c:	e3a03c01 	mov	r3, #256	; 0x100
3480de90:	e58d3004 	str	r3, [sp, #4]
3480de94:	e5dd0028 	ldrb	r0, [sp, #40]	; 0x28
3480de98:	e1a01007 	mov	r1, r7
3480de9c:	e28d2034 	add	r2, sp, #52	; 0x34
3480dea0:	e28d3030 	add	r3, sp, #48	; 0x30
3480dea4:	e58d4000 	str	r4, [sp]
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
3480dea8:	e1a0a009 	mov	sl, r9

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480deac:	ebffff41 	bl	3480dbb8 <cread_add_char>
3480deb0:	eaffffbe 	b	3480ddb0 <readline_into_buffer+0x108>
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {
3480deb4:	e2403041 	sub	r3, r0, #65	; 0x41
3480deb8:	e3530007 	cmp	r3, #7
3480debc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480dec0:	ea000007 	b	3480dee4 <readline_into_buffer+0x23c>
3480dec4:	3480e1d8 	.word	0x3480e1d8
3480dec8:	3480e21c 	.word	0x3480e21c
3480decc:	3480df34 	.word	0x3480df34
3480ded0:	3480e034 	.word	0x3480e034
3480ded4:	3480dee4 	.word	0x3480dee4
3480ded8:	3480dee4 	.word	0x3480dee4
3480dedc:	3480dee4 	.word	0x3480dee4
3480dee0:	3480e000 	.word	0x3480e000
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
3480dee4:	e28d1040 	add	r1, sp, #64	; 0x40
3480dee8:	e081300a 	add	r3, r1, sl
3480deec:	e5430018 	strb	r0, [r3, #-24]
3480def0:	e28aa001 	add	sl, sl, #1
				cread_add_str(esc_save, esc_len, insert,
3480def4:	e28d9028 	add	r9, sp, #40	; 0x28

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480def8:	e3a0cc01 	mov	ip, #256	; 0x100
3480defc:	ea000009 	b	3480df28 <readline_into_buffer+0x280>
3480df00:	e4d90001 	ldrb	r0, [r9], #1
3480df04:	e1a01007 	mov	r1, r7
3480df08:	e28d2034 	add	r2, sp, #52	; 0x34
3480df0c:	e28d3030 	add	r3, sp, #48	; 0x30
3480df10:	e58dc004 	str	ip, [sp, #4]
3480df14:	e58dc00c 	str	ip, [sp, #12]
3480df18:	e58d4000 	str	r4, [sp]
3480df1c:	ebffff25 	bl	3480dbb8 <cread_add_char>
		str++;
3480df20:	e59dc00c 	ldr	ip, [sp, #12]
3480df24:	e24aa001 	sub	sl, sl, #1
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480df28:	e35a0000 	cmp	sl, #0
3480df2c:	1afffff3 	bne	3480df00 <readline_into_buffer+0x258>
3480df30:	eaffff9e 	b	3480ddb0 <readline_into_buffer+0x108>
			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
3480df34:	e3a00006 	mov	r0, #6
3480df38:	e350000b 	cmp	r0, #11
3480df3c:	ea000001 	b	3480df48 <readline_into_buffer+0x2a0>
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480df40:	e350000b 	cmp	r0, #11
3480df44:	0a00005e 	beq	3480e0c4 <readline_into_buffer+0x41c>
3480df48:	8a00000f 	bhi	3480df8c <readline_into_buffer+0x2e4>
3480df4c:	e3500004 	cmp	r0, #4
3480df50:	0a00003f 	beq	3480e054 <readline_into_buffer+0x3ac>
3480df54:	8a000005 	bhi	3480df70 <readline_into_buffer+0x2c8>
3480df58:	e3500002 	cmp	r0, #2
3480df5c:	0a000034 	beq	3480e034 <readline_into_buffer+0x38c>
3480df60:	8a00013e 	bhi	3480e460 <readline_into_buffer+0x7b8>
3480df64:	e3500001 	cmp	r0, #1
3480df68:	1a0000ec 	bne	3480e320 <readline_into_buffer+0x678>
3480df6c:	ea000023 	b	3480e000 <readline_into_buffer+0x358>
3480df70:	e3500006 	cmp	r0, #6
3480df74:	0a000025 	beq	3480e010 <readline_into_buffer+0x368>
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
3480df78:	359d2034 	ldrcc	r2, [sp, #52]	; 0x34
3480df7c:	359d1030 	ldrcc	r1, [sp, #48]	; 0x30
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480df80:	3a0000dd 	bcc	3480e2fc <readline_into_buffer+0x654>
3480df84:	e3500008 	cmp	r0, #8
3480df88:	ea000015 	b	3480dfe4 <readline_into_buffer+0x33c>
3480df8c:	e3500015 	cmp	r0, #21
3480df90:	0a000061 	beq	3480e11c <readline_into_buffer+0x474>
3480df94:	8a000007 	bhi	3480dfb8 <readline_into_buffer+0x310>
3480df98:	e350000f 	cmp	r0, #15
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
3480df9c:	02277001 	eoreq	r7, r7, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480dfa0:	0affff81 	beq	3480ddac <readline_into_buffer+0x104>
3480dfa4:	e3500010 	cmp	r0, #16
3480dfa8:	0a00008a 	beq	3480e1d8 <readline_into_buffer+0x530>
3480dfac:	e350000e 	cmp	r0, #14
3480dfb0:	1a0000da 	bne	3480e320 <readline_into_buffer+0x678>
3480dfb4:	ea000098 	b	3480e21c <readline_into_buffer+0x574>
3480dfb8:	e350001b 	cmp	r0, #27
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
3480dfbc:	05cd0028 	strbeq	r0, [sp, #40]	; 0x28
				esc_len = 1;
3480dfc0:	03a0a001 	moveq	sl, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480dfc4:	0affff79 	beq	3480ddb0 <readline_into_buffer+0x108>
3480dfc8:	8a000002 	bhi	3480dfd8 <readline_into_buffer+0x330>
3480dfcc:	e3500018 	cmp	r0, #24
3480dfd0:	1a0000d2 	bne	3480e320 <readline_into_buffer+0x678>
3480dfd4:	ea000050 	b	3480e11c <readline_into_buffer+0x474>
3480dfd8:	e350007f 	cmp	r0, #127	; 0x7f
3480dfdc:	0a000061 	beq	3480e168 <readline_into_buffer+0x4c0>
3480dfe0:	e35000ff 	cmp	r0, #255	; 0xff
3480dfe4:	1a0000cd 	bne	3480e320 <readline_into_buffer+0x678>
3480dfe8:	ea00005e 	b	3480e168 <readline_into_buffer+0x4c0>
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480dfec:	e3a00008 	mov	r0, #8
3480dff0:	ebffeea0 	bl	34809a78 <putc>
3480dff4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480dff8:	e2433001 	sub	r3, r3, #1
3480dffc:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e000:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e004:	e35a0000 	cmp	sl, #0
3480e008:	1afffff7 	bne	3480dfec <readline_into_buffer+0x344>
3480e00c:	eaffff67 	b	3480ddb0 <readline_into_buffer+0x108>
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
3480e010:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e014:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480e018:	e1530002 	cmp	r3, r2
3480e01c:	2affff62 	bcs	3480ddac <readline_into_buffer+0x104>
				getcmd_putch(buf[num]);
3480e020:	e7d40003 	ldrb	r0, [r4, r3]
3480e024:	ebffee93 	bl	34809a78 <putc>
				num++;
3480e028:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e02c:	e2833001 	add	r3, r3, #1
3480e030:	ea0000b8 	b	3480e318 <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('b'):
			if (num) {
3480e034:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e038:	e35a0000 	cmp	sl, #0
3480e03c:	0affff5b 	beq	3480ddb0 <readline_into_buffer+0x108>
				getcmd_putch(CTL_BACKSPACE);
3480e040:	e3a00008 	mov	r0, #8
3480e044:	ebffee8b 	bl	34809a78 <putc>
				num--;
3480e048:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e04c:	e2433001 	sub	r3, r3, #1
3480e050:	ea0000b0 	b	3480e318 <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
3480e054:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3480e058:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480e05c:	e150000a 	cmp	r0, sl
3480e060:	2affff51 	bcs	3480ddac <readline_into_buffer+0x104>
				wlen = eol_num - num - 1;
3480e064:	e24aa001 	sub	sl, sl, #1
				if (wlen) {
3480e068:	e05aa000 	subs	sl, sl, r0
3480e06c:	0a000009 	beq	3480e098 <readline_into_buffer+0x3f0>
					memmove(&buf[num], &buf[num+1], wlen);
3480e070:	e2801001 	add	r1, r0, #1
3480e074:	e0841001 	add	r1, r4, r1
3480e078:	e1a0200a 	mov	r2, sl
3480e07c:	e0840000 	add	r0, r4, r0
3480e080:	eb0039a5 	bl	3481c71c <memmove>
					putnstr(buf + num, wlen);
3480e084:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e088:	e59f04f0 	ldr	r0, [pc, #1264]	; 3480e580 <readline_into_buffer+0x8d8>
3480e08c:	e1a0100a 	mov	r1, sl
3480e090:	e0842002 	add	r2, r4, r2
3480e094:	ebffee8b 	bl	34809ac8 <printf>
				}

				getcmd_putch(' ');
3480e098:	e3a00020 	mov	r0, #32
3480e09c:	ebffee75 	bl	34809a78 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480e0a0:	e3a00008 	mov	r0, #8
3480e0a4:	ebffee73 	bl	34809a78 <putc>
				} while (wlen--);
3480e0a8:	e25aa001 	subs	sl, sl, #1
3480e0ac:	2afffffb 	bcs	3480e0a0 <readline_into_buffer+0x3f8>
				eol_num--;
3480e0b0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e0b4:	e28aa001 	add	sl, sl, #1
3480e0b8:	e2433001 	sub	r3, r3, #1
3480e0bc:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e0c0:	eaffff3a 	b	3480ddb0 <readline_into_buffer+0x108>
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
3480e0c4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e0c8:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e0cc:	e1530001 	cmp	r3, r1
3480e0d0:	2affff36 	bcs	3480ddb0 <readline_into_buffer+0x108>
3480e0d4:	e59f04a8 	ldr	r0, [pc, #1192]	; 3480e584 <readline_into_buffer+0x8dc>
3480e0d8:	e0631001 	rsb	r1, r3, r1
3480e0dc:	e59f24a4 	ldr	r2, [pc, #1188]	; 3480e588 <readline_into_buffer+0x8e0>
3480e0e0:	ebffee78 	bl	34809ac8 <printf>
3480e0e4:	e3a00008 	mov	r0, #8
3480e0e8:	ebffee62 	bl	34809a78 <putc>
3480e0ec:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e0f0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e0f4:	e2433001 	sub	r3, r3, #1
3480e0f8:	e1530002 	cmp	r3, r2
3480e0fc:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e100:	8afffff7 	bhi	3480e0e4 <readline_into_buffer+0x43c>
3480e104:	eaffff28 	b	3480ddac <readline_into_buffer+0x104>
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
		case CTL_CH('u'):
			BEGINNING_OF_LINE();
3480e108:	e3a00008 	mov	r0, #8
3480e10c:	ebffee59 	bl	34809a78 <putc>
3480e110:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e114:	e2433001 	sub	r3, r3, #1
3480e118:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e11c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e120:	e3530000 	cmp	r3, #0
3480e124:	1afffff7 	bne	3480e108 <readline_into_buffer+0x460>
			ERASE_TO_EOL();
3480e128:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e12c:	e3510000 	cmp	r1, #0
3480e130:	01a0a001 	moveq	sl, r1
3480e134:	0affff1d 	beq	3480ddb0 <readline_into_buffer+0x108>
3480e138:	e59f0444 	ldr	r0, [pc, #1092]	; 3480e584 <readline_into_buffer+0x8dc>
3480e13c:	e59f2444 	ldr	r2, [pc, #1092]	; 3480e588 <readline_into_buffer+0x8e0>
3480e140:	ebffee60 	bl	34809ac8 <printf>
3480e144:	e3a00008 	mov	r0, #8
3480e148:	ebffee4a 	bl	34809a78 <putc>
3480e14c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e150:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e154:	e2433001 	sub	r3, r3, #1
3480e158:	e1530002 	cmp	r3, r2
3480e15c:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e160:	8afffff7 	bhi	3480e144 <readline_into_buffer+0x49c>
3480e164:	eaffff10 	b	3480ddac <readline_into_buffer+0x104>
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
3480e168:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e16c:	e35a0000 	cmp	sl, #0
3480e170:	0affff0e 	beq	3480ddb0 <readline_into_buffer+0x108>
				wlen = eol_num - num;
3480e174:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
				num--;
3480e178:	e24a0001 	sub	r0, sl, #1
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
3480e17c:	e06a9009 	rsb	r9, sl, r9
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
3480e180:	e084100a 	add	r1, r4, sl
3480e184:	e1a02009 	mov	r2, r9
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
3480e188:	e58d0034 	str	r0, [sp, #52]	; 0x34
				memmove(&buf[num], &buf[num+1], wlen);
3480e18c:	e0840000 	add	r0, r4, r0
3480e190:	eb003961 	bl	3481c71c <memmove>
				getcmd_putch(CTL_BACKSPACE);
3480e194:	e3a00008 	mov	r0, #8
3480e198:	ebffee36 	bl	34809a78 <putc>
				putnstr(buf + num, wlen);
3480e19c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e1a0:	e59f03d8 	ldr	r0, [pc, #984]	; 3480e580 <readline_into_buffer+0x8d8>
3480e1a4:	e1a01009 	mov	r1, r9
3480e1a8:	e0842002 	add	r2, r4, r2
3480e1ac:	ebffee45 	bl	34809ac8 <printf>
				getcmd_putch(' ');
3480e1b0:	e3a00020 	mov	r0, #32
3480e1b4:	ebffee2f 	bl	34809a78 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480e1b8:	e3a00008 	mov	r0, #8
3480e1bc:	ebffee2d 	bl	34809a78 <putc>
				} while (wlen--);
3480e1c0:	e2599001 	subs	r9, r9, #1
3480e1c4:	2afffffb 	bcs	3480e1b8 <readline_into_buffer+0x510>
				eol_num--;
3480e1c8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e1cc:	e2433001 	sub	r3, r3, #1
3480e1d0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e1d4:	eafffef4 	b	3480ddac <readline_into_buffer+0x104>
static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
3480e1d8:	e5953000 	ldr	r3, [r5]
3480e1dc:	e3530000 	cmp	r3, #0
3480e1e0:	ba000024 	blt	3480e278 <readline_into_buffer+0x5d0>
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
3480e1e4:	e2432001 	sub	r2, r3, #1
3480e1e8:	e3720001 	cmn	r2, #1
3480e1ec:	e5852000 	str	r2, [r5]
		hist_cur = hist_max;
3480e1f0:	05962004 	ldreq	r2, [r6, #4]

	if (hist_cur == hist_add_idx) {
3480e1f4:	e5961008 	ldr	r1, [r6, #8]
	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;
3480e1f8:	05852000 	streq	r2, [r5]

	if (hist_cur == hist_add_idx) {
3480e1fc:	e5952000 	ldr	r2, [r5]
3480e200:	e1520001 	cmp	r2, r1
		hist_cur = old_cur;
3480e204:	05853000 	streq	r3, [r5]

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
3480e208:	0a00001a 	beq	3480e278 <readline_into_buffer+0x5d0>
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];
3480e20c:	e59f3378 	ldr	r3, [pc, #888]	; 3480e58c <readline_into_buffer+0x8e4>
3480e210:	e0832102 	add	r2, r3, r2, lsl #2
3480e214:	e512abd4 	ldr	sl, [r2, #-3028]	; 0xbd4
3480e218:	ea000011 	b	3480e264 <readline_into_buffer+0x5bc>

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480e21c:	e5953000 	ldr	r3, [r5]
3480e220:	e3530000 	cmp	r3, #0
3480e224:	ba000013 	blt	3480e278 <readline_into_buffer+0x5d0>
		return NULL;

	if (hist_cur == hist_add_idx)
3480e228:	e5962008 	ldr	r2, [r6, #8]
3480e22c:	e1530002 	cmp	r3, r2
3480e230:	0a000010 	beq	3480e278 <readline_into_buffer+0x5d0>
		return NULL;

	if (++hist_cur > hist_max)
3480e234:	e5961004 	ldr	r1, [r6, #4]
3480e238:	e2833001 	add	r3, r3, #1
3480e23c:	e1530001 	cmp	r3, r1
		hist_cur = 0;
3480e240:	c3a00000 	movgt	r0, #0
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
3480e244:	e5853000 	str	r3, [r5]
		hist_cur = 0;
3480e248:	c5850000 	strgt	r0, [r5]

	if (hist_cur == hist_add_idx) {
3480e24c:	e5953000 	ldr	r3, [r5]
3480e250:	e1530002 	cmp	r3, r2
3480e254:	0a000005 	beq	3480e270 <readline_into_buffer+0x5c8>
		ret = "";
	} else
		ret = hist_list[hist_cur];
3480e258:	e59f132c 	ldr	r1, [pc, #812]	; 3480e58c <readline_into_buffer+0x8e4>
3480e25c:	e0813103 	add	r3, r1, r3, lsl #2
3480e260:	e513abd4 	ldr	sl, [r3, #-3028]	; 0xbd4
			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
3480e264:	e35a0000 	cmp	sl, #0
3480e268:	1a00000a 	bne	3480e298 <readline_into_buffer+0x5f0>
3480e26c:	ea000001 	b	3480e278 <readline_into_buffer+0x5d0>

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
3480e270:	e59fa310 	ldr	sl, [pc, #784]	; 3480e588 <readline_into_buffer+0x8e0>
3480e274:	ea000007 	b	3480e298 <readline_into_buffer+0x5f0>
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
3480e278:	e3a00007 	mov	r0, #7
3480e27c:	ebffedfd 	bl	34809a78 <putc>
3480e280:	eafffec9 	b	3480ddac <readline_into_buffer+0x104>
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();
3480e284:	e3a00008 	mov	r0, #8
3480e288:	ebffedfa 	bl	34809a78 <putc>
3480e28c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e290:	e2433001 	sub	r3, r3, #1
3480e294:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e298:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e29c:	e3530000 	cmp	r3, #0
3480e2a0:	1afffff7 	bne	3480e284 <readline_into_buffer+0x5dc>

			/* erase to end of line */
			ERASE_TO_EOL();
3480e2a4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e2a8:	e3510000 	cmp	r1, #0
3480e2ac:	0a00000a 	beq	3480e2dc <readline_into_buffer+0x634>
3480e2b0:	e59f02cc 	ldr	r0, [pc, #716]	; 3480e584 <readline_into_buffer+0x8dc>
3480e2b4:	e59f22cc 	ldr	r2, [pc, #716]	; 3480e588 <readline_into_buffer+0x8e0>
3480e2b8:	ebffee02 	bl	34809ac8 <printf>
3480e2bc:	e3a00008 	mov	r0, #8
3480e2c0:	ebffedec 	bl	34809a78 <putc>
3480e2c4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e2c8:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e2cc:	e2433001 	sub	r3, r3, #1
3480e2d0:	e1530002 	cmp	r3, r2
3480e2d4:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e2d8:	8afffff7 	bhi	3480e2bc <readline_into_buffer+0x614>

			/* copy new line into place and display */
			strcpy(buf, hline);
3480e2dc:	e1a0100a 	mov	r1, sl
3480e2e0:	e1a00004 	mov	r0, r4
3480e2e4:	eb0037c6 	bl	3481c204 <strcpy>
			eol_num = strlen(buf);
3480e2e8:	e1a00004 	mov	r0, r4
3480e2ec:	eb003829 	bl	3481c398 <strlen>
			REFRESH_TO_EOL();
3480e2f0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
3480e2f4:	e1a01000 	mov	r1, r0
3480e2f8:	e58d0030 	str	r0, [sp, #48]	; 0x30
			REFRESH_TO_EOL();
3480e2fc:	e1520001 	cmp	r2, r1
3480e300:	2afffea9 	bcs	3480ddac <readline_into_buffer+0x104>
3480e304:	e0621001 	rsb	r1, r2, r1
3480e308:	e59f0270 	ldr	r0, [pc, #624]	; 3480e580 <readline_into_buffer+0x8d8>
3480e30c:	e0842002 	add	r2, r4, r2
3480e310:	ebffedec 	bl	34809ac8 <printf>
3480e314:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e318:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e31c:	eafffea2 	b	3480ddac <readline_into_buffer+0x104>
			}
			break;
		}
#endif
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
3480e320:	e3a03c01 	mov	r3, #256	; 0x100
3480e324:	e58d3004 	str	r3, [sp, #4]
3480e328:	e1a01007 	mov	r1, r7
3480e32c:	e28d2034 	add	r2, sp, #52	; 0x34
3480e330:	e28d3030 	add	r3, sp, #48	; 0x30
3480e334:	e58d4000 	str	r4, [sp]
3480e338:	ebfffe1e 	bl	3480dbb8 <cread_add_char>
3480e33c:	eafffe9a 	b	3480ddac <readline_into_buffer+0x104>
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);
3480e340:	e59f5228 	ldr	r5, [pc, #552]	; 3480e570 <readline_into_buffer+0x8c8>
3480e344:	e59f3240 	ldr	r3, [pc, #576]	; 3480e58c <readline_into_buffer+0x8e4>
3480e348:	e5952008 	ldr	r2, [r5, #8]
3480e34c:	e1a01004 	mov	r1, r4
3480e350:	e0833102 	add	r3, r3, r2, lsl #2
3480e354:	e5130bd4 	ldr	r0, [r3, #-3028]	; 0xbd4
3480e358:	eb0037a9 	bl	3481c204 <strcpy>

	if (++hist_add_idx >= HIST_MAX)
3480e35c:	e995000c 	ldmib	r5, {r2, r3}
3480e360:	e2833001 	add	r3, r3, #1
		hist_add_idx = 0;
3480e364:	e3530013 	cmp	r3, #19
3480e368:	c3a03000 	movgt	r3, #0

	if (hist_add_idx > hist_max)
3480e36c:	e1530002 	cmp	r3, r2
static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;
3480e370:	e5853008 	str	r3, [r5, #8]

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;
3480e374:	c5853004 	strgt	r3, [r5, #4]

	hist_num++;
3480e378:	e59f31f0 	ldr	r3, [pc, #496]	; 3480e570 <readline_into_buffer+0x8c8>
3480e37c:	e593200c 	ldr	r2, [r3, #12]
3480e380:	e2822001 	add	r2, r2, #1
3480e384:	e583200c 	str	r2, [r3, #12]
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480e388:	e59f31e0 	ldr	r3, [pc, #480]	; 3480e570 <readline_into_buffer+0x8c8>

		if (prompt)
			puts (prompt);

		rc = cread_line(prompt, p, &len, timeout);
		return rc < 0 ? rc : len;
3480e38c:	e1a00006 	mov	r0, r6
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480e390:	e5932008 	ldr	r2, [r3, #8]
3480e394:	e59f31d8 	ldr	r3, [pc, #472]	; 3480e574 <readline_into_buffer+0x8cc>
3480e398:	e5832000 	str	r2, [r3]
3480e39c:	ea000071 	b	3480e568 <readline_into_buffer+0x8c0>
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
					return -2;	/* timed out */
3480e3a0:	e3e00001 	mvn	r0, #1
3480e3a4:	ea00006f 	b	3480e568 <readline_into_buffer+0x8c0>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480e3a8:	e3500000 	cmp	r0, #0
		return rc < 0 ? rc : len;

	} else {
#endif	/* CONFIG_CMDLINE_EDITING */
	char * p_buf = p;
	int	n = 0;				/* buffer index		*/
3480e3ac:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int	plen = 0;			/* prompt length	*/
3480e3b0:	01a05000 	moveq	r5, r0
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480e3b4:	0a000003 	beq	3480e3c8 <readline_into_buffer+0x720>
		plen = strlen (prompt);
3480e3b8:	eb0037f6 	bl	3481c398 <strlen>
3480e3bc:	e1a05000 	mov	r5, r0
		puts (prompt);
3480e3c0:	e1a00006 	mov	r0, r6
3480e3c4:	ebffedb5 	bl	34809aa0 <puts>
	}
	col = plen;
3480e3c8:	e28d6040 	add	r6, sp, #64	; 0x40
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480e3cc:	e59fa1bc 	ldr	sl, [pc, #444]	; 3480e590 <readline_into_buffer+0x8e8>
	/* print prompt */
	if (prompt) {
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;
3480e3d0:	e5265008 	str	r5, [r6, #-8]!
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480e3d4:	e28d703c 	add	r7, sp, #60	; 0x3c
			while (col > plen) {
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480e3d8:	e3a09000 	mov	r9, #0
3480e3dc:	e1a01004 	mov	r1, r4
		while (!tstc()) {
			show_activity(0);
			WATCHDOG_RESET();
		}
#endif
		c = getc();
3480e3e0:	e58d100c 	str	r1, [sp, #12]
3480e3e4:	ebffed91 	bl	34809a30 <getc>
3480e3e8:	e6efb070 	uxtb	fp, r0

		/*
		 * Special character handling
		 */
		switch (c) {
3480e3ec:	e35b000a 	cmp	fp, #10
3480e3f0:	e59d100c 	ldr	r1, [sp, #12]
3480e3f4:	0a000012 	beq	3480e444 <readline_into_buffer+0x79c>
3480e3f8:	8a000006 	bhi	3480e418 <readline_into_buffer+0x770>
3480e3fc:	e35b0003 	cmp	fp, #3
3480e400:	0a000016 	beq	3480e460 <readline_into_buffer+0x7b8>
3480e404:	e35b0008 	cmp	fp, #8
3480e408:	0a000030 	beq	3480e4d0 <readline_into_buffer+0x828>
3480e40c:	e35b0000 	cmp	fp, #0
3480e410:	0afffff2 	beq	3480e3e0 <readline_into_buffer+0x738>
3480e414:	ea000034 	b	3480e4ec <readline_into_buffer+0x844>
3480e418:	e35b0015 	cmp	fp, #21
3480e41c:	0a000018 	beq	3480e484 <readline_into_buffer+0x7dc>
3480e420:	8a000002 	bhi	3480e430 <readline_into_buffer+0x788>
3480e424:	e35b000d 	cmp	fp, #13
3480e428:	1a00002f 	bne	3480e4ec <readline_into_buffer+0x844>
3480e42c:	ea000004 	b	3480e444 <readline_into_buffer+0x79c>
3480e430:	e35b0017 	cmp	fp, #23
3480e434:	0a000018 	beq	3480e49c <readline_into_buffer+0x7f4>
3480e438:	e35b007f 	cmp	fp, #127	; 0x7f
3480e43c:	1a00002a 	bne	3480e4ec <readline_into_buffer+0x844>
3480e440:	ea000022 	b	3480e4d0 <readline_into_buffer+0x828>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480e444:	e3a03000 	mov	r3, #0
3480e448:	e1a0b001 	mov	fp, r1
			puts ("\r\n");
3480e44c:	e59f0140 	ldr	r0, [pc, #320]	; 3480e594 <readline_into_buffer+0x8ec>
		 * Special character handling
		 */
		switch (c) {
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480e450:	e5c13000 	strb	r3, [r1]
			puts ("\r\n");
3480e454:	ebffed91 	bl	34809aa0 <puts>
			return (p - p_buf);
3480e458:	e064000b 	rsb	r0, r4, fp
3480e45c:	ea000041 	b	3480e568 <readline_into_buffer+0x8c0>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
3480e460:	e3a03000 	mov	r3, #0
3480e464:	e5c43000 	strb	r3, [r4]
			return (-1);
3480e468:	e3e00000 	mvn	r0, #0
3480e46c:	ea00003d 	b	3480e568 <readline_into_buffer+0x8c0>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
3480e470:	e59f0120 	ldr	r0, [pc, #288]	; 3480e598 <readline_into_buffer+0x8f0>
3480e474:	ebffed89 	bl	34809aa0 <puts>
				--col;
3480e478:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e47c:	e2433001 	sub	r3, r3, #1
3480e480:	e58d3038 	str	r3, [sp, #56]	; 0x38
		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
3480e484:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e488:	e1530005 	cmp	r3, r5
3480e48c:	cafffff7 	bgt	3480e470 <readline_into_buffer+0x7c8>
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480e490:	e58d903c 	str	r9, [sp, #60]	; 0x3c
			continue;
3480e494:	e1a01004 	mov	r1, r4
3480e498:	eaffffd0 	b	3480e3e0 <readline_into_buffer+0x738>

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(p_buf, p, &col, &n, plen);
3480e49c:	e1a03007 	mov	r3, r7
3480e4a0:	e1a00004 	mov	r0, r4
3480e4a4:	e1a02006 	mov	r2, r6
3480e4a8:	e58d5000 	str	r5, [sp]
3480e4ac:	ebfffd8b 	bl	3480dae0 <delete_char>
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480e4b0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				p=delete_char(p_buf, p, &col, &n, plen);
3480e4b4:	e1a01000 	mov	r1, r0
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480e4b8:	e3530000 	cmp	r3, #0
3480e4bc:	daffffc7 	ble	3480e3e0 <readline_into_buffer+0x738>
3480e4c0:	e5d03000 	ldrb	r3, [r0]
3480e4c4:	e3530020 	cmp	r3, #32
3480e4c8:	1afffff3 	bne	3480e49c <readline_into_buffer+0x7f4>
3480e4cc:	eaffffc3 	b	3480e3e0 <readline_into_buffer+0x738>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480e4d0:	e1a00004 	mov	r0, r4
3480e4d4:	e1a02006 	mov	r2, r6
3480e4d8:	e1a03007 	mov	r3, r7
3480e4dc:	e58d5000 	str	r5, [sp]
3480e4e0:	ebfffd7e 	bl	3480dae0 <delete_char>
3480e4e4:	e1a01000 	mov	r1, r0
			continue;
3480e4e8:	eaffffbc 	b	3480e3e0 <readline_into_buffer+0x738>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CONFIG_SYS_CBSIZE-2) {
3480e4ec:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480e4f0:	e35300fd 	cmp	r3, #253	; 0xfd
3480e4f4:	ca000016 	bgt	3480e554 <readline_into_buffer+0x8ac>
				if (c == '\t') {	/* expand TABs		*/
3480e4f8:	e35b0009 	cmp	fp, #9
3480e4fc:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3480e500:	1a000008 	bne	3480e528 <readline_into_buffer+0x880>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480e504:	e2000007 	and	r0, r0, #7
3480e508:	e08a0000 	add	r0, sl, r0
3480e50c:	e58d100c 	str	r1, [sp, #12]
3480e510:	ebffed62 	bl	34809aa0 <puts>
					col += 8 - (col&07);
3480e514:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e518:	e3c33007 	bic	r3, r3, #7
3480e51c:	e2833008 	add	r3, r3, #8
3480e520:	e58d3038 	str	r3, [sp, #56]	; 0x38
3480e524:	ea000004 	b	3480e53c <readline_into_buffer+0x894>
				} else {
					++col;		/* echo input		*/
3480e528:	e2800001 	add	r0, r0, #1
3480e52c:	e58d0038 	str	r0, [sp, #56]	; 0x38
					putc (c);
3480e530:	e1a0000b 	mov	r0, fp
3480e534:	e58d100c 	str	r1, [sp, #12]
3480e538:	ebffed4e 	bl	34809a78 <putc>
3480e53c:	e59d100c 	ldr	r1, [sp, #12]
				}
				*p++ = c;
3480e540:	e4c1b001 	strb	fp, [r1], #1
				++n;
3480e544:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480e548:	e2833001 	add	r3, r3, #1
3480e54c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3480e550:	eaffffa2 	b	3480e3e0 <readline_into_buffer+0x738>
			} else {			/* Buffer full		*/
				putc ('\a');
3480e554:	e3a00007 	mov	r0, #7
3480e558:	e58d100c 	str	r1, [sp, #12]
3480e55c:	ebffed45 	bl	34809a78 <putc>
3480e560:	e59d100c 	ldr	r1, [sp, #12]
3480e564:	eaffff9d 	b	3480e3e0 <readline_into_buffer+0x738>
		}
	}
#ifdef CONFIG_CMDLINE_EDITING
	}
#endif
}
3480e568:	e28dd040 	add	sp, sp, #64	; 0x40
3480e56c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480e570:	34829f68 	.word	0x34829f68
3480e574:	348289bc 	.word	0x348289bc
3480e578:	3482b388 	.word	0x3482b388
3480e57c:	3482b38c 	.word	0x3482b38c
3480e580:	3482686c 	.word	0x3482686c
3480e584:	34826871 	.word	0x34826871
3480e588:	34823d17 	.word	0x34823d17
3480e58c:	3482bf60 	.word	0x3482bf60
3480e590:	34821358 	.word	0x34821358
3480e594:	34826875 	.word	0x34826875
3480e598:	34821354 	.word	0x34821354

3480e59c <readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480e59c:	e59f300c 	ldr	r3, [pc, #12]	; 3480e5b0 <readline+0x14>

	return readline_into_buffer(prompt, console_buffer, 0);
3480e5a0:	e59f100c 	ldr	r1, [pc, #12]	; 3480e5b4 <readline+0x18>
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480e5a4:	e3a02000 	mov	r2, #0
3480e5a8:	e5432b84 	strb	r2, [r3, #-2948]	; 0xb84

	return readline_into_buffer(prompt, console_buffer, 0);
3480e5ac:	eafffdbd 	b	3480dca8 <readline_into_buffer>
3480e5b0:	3482bf60 	.word	0x3482bf60
3480e5b4:	3482b3dc 	.word	0x3482b3dc

3480e5b8 <parse_line>:
}

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
3480e5b8:	e92d4010 	push	{r4, lr}
	int nargs = 0;
3480e5bc:	e1a0c001 	mov	ip, r1
3480e5c0:	e3a04000 	mov	r4, #0
3480e5c4:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
3480e5c8:	e4d03001 	ldrb	r3, [r0], #1
3480e5cc:	e3530020 	cmp	r3, #32
3480e5d0:	13530009 	cmpne	r3, #9
3480e5d4:	0afffffa 	beq	3480e5c4 <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
3480e5d8:	e3530000 	cmp	r3, #0
3480e5dc:	0a000005 	beq	3480e5f8 <parse_line+0x40>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
3480e5e0:	e48c2004 	str	r2, [ip], #4
3480e5e4:	e2844001 	add	r4, r4, #1

		/* find end of string */
		while (*line && !isblank(*line))
3480e5e8:	e1a00002 	mov	r0, r2
3480e5ec:	e4d23001 	ldrb	r3, [r2], #1
3480e5f0:	e3530000 	cmp	r3, #0
3480e5f4:	1a000001 	bne	3480e600 <parse_line+0x48>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
3480e5f8:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
3480e5fc:	ea00000b 	b	3480e630 <parse_line+0x78>
		}

		argv[nargs++] = line;	/* begin of argument string	*/

		/* find end of string */
		while (*line && !isblank(*line))
3480e600:	e3530009 	cmp	r3, #9
3480e604:	13530020 	cmpne	r3, #32
3480e608:	03a03000 	moveq	r3, #0
3480e60c:	13a03001 	movne	r3, #1
3480e610:	1afffff4 	bne	3480e5e8 <parse_line+0x30>
	int nargs = 0;

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {
3480e614:	e3540010 	cmp	r4, #16
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
3480e618:	e5c03000 	strb	r3, [r0]
3480e61c:	12800001 	addne	r0, r0, #1
3480e620:	1affffe7 	bne	3480e5c4 <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
3480e624:	e59f000c 	ldr	r0, [pc, #12]	; 3480e638 <parse_line+0x80>
3480e628:	e1a01004 	mov	r1, r4
3480e62c:	ebffed25 	bl	34809ac8 <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
3480e630:	e1a00004 	mov	r0, r4
3480e634:	e8bd8010 	pop	{r4, pc}
3480e638:	34826878 	.word	0x34826878

3480e63c <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480e63c:	e3a01003 	mov	r1, #3
3480e640:	eafff702 	b	3480c250 <parse_string_outer>

3480e644 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480e644:	e3710001 	cmn	r1, #1
	return rcode;
}
#endif

int run_command_list(const char *cmd, int len, int flag)
{
3480e648:	e92d4070 	push	{r4, r5, r6, lr}
3480e64c:	e1a06000 	mov	r6, r0
3480e650:	e1a04001 	mov	r4, r1
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480e654:	1a000002 	bne	3480e664 <run_command_list+0x20>
		len = strlen(cmd);
3480e658:	eb00374e 	bl	3481c398 <strlen>
#endif

int run_command_list(const char *cmd, int len, int flag)
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
3480e65c:	e1a05006 	mov	r5, r6
3480e660:	ea000008 	b	3480e688 <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
3480e664:	e2810001 	add	r0, r1, #1
3480e668:	ebffeedd 	bl	3480a1e4 <malloc>
		if (!buff)
3480e66c:	e2505000 	subs	r5, r0, #0
3480e670:	0a000008 	beq	3480e698 <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
3480e674:	e1a01006 	mov	r1, r6
3480e678:	e1a02004 	mov	r2, r4
3480e67c:	eb003809 	bl	3481c6a8 <memcpy>
		buff[len] = '\0';
3480e680:	e3a03000 	mov	r3, #0
3480e684:	e7c53004 	strb	r3, [r5, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e688:	e1a00005 	mov	r0, r5
3480e68c:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480e690:	e8bd4070 	pop	{r4, r5, r6, lr}
			return 1;
		memcpy(buff, cmd, len);
		buff[len] = '\0';
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e694:	eafff6ed 	b	3480c250 <parse_string_outer>
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480e698:	e3a00001 	mov	r0, #1
3480e69c:	e8bd8070 	pop	{r4, r5, r6, pc}

3480e6a0 <main_loop>:
#endif	/* CONFIG_BOOTDELAY >= 0  */

/****************************************************************************/

void main_loop (void)
{
3480e6a0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CONFIG_SYS_HUSH_PARSER
	u_boot_hush_start ();
3480e6a4:	ebfffacc 	bl	3480d1dc <u_boot_hush_start>
#if defined(CONFIG_UPDATE_TFTP)
	update_tftp (0UL);
#endif /* CONFIG_UPDATE_TFTP */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
3480e6a8:	e59f00fc 	ldr	r0, [pc, #252]	; 3480e7ac <main_loop+0x10c>
3480e6ac:	ebffe617 	bl	34807f10 <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
3480e6b0:	e3500000 	cmp	r0, #0
3480e6b4:	03a04005 	moveq	r4, #5
3480e6b8:	0a000003 	beq	3480e6cc <main_loop+0x2c>
3480e6bc:	e3a01000 	mov	r1, #0
3480e6c0:	e3a0200a 	mov	r2, #10
3480e6c4:	eb003b0f 	bl	3481d308 <simple_strtol>
3480e6c8:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
3480e6cc:	e59f00dc 	ldr	r0, [pc, #220]	; 3480e7b0 <main_loop+0x110>
3480e6d0:	ebffe60e 	bl	34807f10 <getenv>

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e6d4:	e3500000 	cmp	r0, #0
3480e6d8:	13740001 	cmnne	r4, #1
3480e6dc:	e1a06000 	mov	r6, r0
3480e6e0:	0a00002f 	beq	3480e7a4 <main_loop+0x104>
	int abort = 0;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480e6e4:	e3540000 	cmp	r4, #0
#ifndef CONFIG_MENU
static inline
#endif
int abortboot(int bootdelay)
{
	int abort = 0;
3480e6e8:	b3a05000 	movlt	r5, #0

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480e6ec:	ba00001d 	blt	3480e768 <main_loop+0xc8>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
3480e6f0:	e1a01004 	mov	r1, r4
3480e6f4:	e59f00b8 	ldr	r0, [pc, #184]	; 3480e7b4 <main_loop+0x114>
3480e6f8:	ebffecf2 	bl	34809ac8 <printf>
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
3480e6fc:	ebffecd4 	bl	34809a54 <tstc>
3480e700:	e2505000 	subs	r5, r0, #0
3480e704:	0a000017 	beq	3480e768 <main_loop+0xc8>
			(void) getc();  /* consume input	*/
3480e708:	ebffecc8 	bl	34809a30 <getc>
			puts ("\b\b\b 0");
3480e70c:	e59f00a4 	ldr	r0, [pc, #164]	; 3480e7b8 <main_loop+0x118>
3480e710:	ebffece2 	bl	34809aa0 <puts>
			abort = 1;	/* don't auto boot	*/
3480e714:	e3a05001 	mov	r5, #1
3480e718:	ea000012 	b	3480e768 <main_loop+0xc8>
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
3480e71c:	ebffeccc 	bl	34809a54 <tstc>
3480e720:	e3500000 	cmp	r0, #0
3480e724:	0a000003 	beq	3480e738 <main_loop+0x98>
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
3480e728:	ebffecc0 	bl	34809a30 <getc>

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
3480e72c:	e3a05001 	mov	r5, #1
				bootdelay = 0;	/* no more delay	*/
3480e730:	e3a04000 	mov	r4, #0
3480e734:	ea000008 	b	3480e75c <main_loop+0xbc>
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
3480e738:	e3020710 	movw	r0, #10000	; 0x2710
3480e73c:	eb003864 	bl	3481c8d4 <udelay>
	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
3480e740:	e2877001 	add	r7, r7, #1
3480e744:	e3570063 	cmp	r7, #99	; 0x63
3480e748:	c3a05000 	movgt	r5, #0
3480e74c:	d3a05001 	movle	r5, #1
3480e750:	e3550000 	cmp	r5, #0
3480e754:	1afffff0 	bne	3480e71c <main_loop+0x7c>
#endif

	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
3480e758:	e2444001 	sub	r4, r4, #1
				break;
			}
			udelay(10000);
		}

		printf("\b\b\b%2d ", bootdelay);
3480e75c:	e59f0058 	ldr	r0, [pc, #88]	; 3480e7bc <main_loop+0x11c>
3480e760:	e1a01004 	mov	r1, r4
3480e764:	ebffecd7 	bl	34809ac8 <printf>
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
3480e768:	e2753001 	rsbs	r3, r5, #1
3480e76c:	33a03000 	movcc	r3, #0
3480e770:	e3540000 	cmp	r4, #0
3480e774:	d3a03000 	movle	r3, #0
3480e778:	e3530000 	cmp	r3, #0
3480e77c:	13a07000 	movne	r7, #0
3480e780:	1affffef 	bne	3480e744 <main_loop+0xa4>
		}

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');
3480e784:	e3a0000a 	mov	r0, #10
3480e788:	ebffecba 	bl	34809a78 <putc>
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e78c:	e3550000 	cmp	r5, #0
3480e790:	1a000003 	bne	3480e7a4 <main_loop+0x104>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

		run_command_list(s, -1, 0);
3480e794:	e1a00006 	mov	r0, r6
3480e798:	e3e01000 	mvn	r1, #0
3480e79c:	e1a02005 	mov	r2, r5
3480e7a0:	ebffffa7 	bl	3480e644 <run_command_list>

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer();
3480e7a4:	ebfffa7b 	bl	3480d198 <parse_file_outer>
3480e7a8:	eafffffe 	b	3480e7a8 <main_loop+0x108>
3480e7ac:	34826897 	.word	0x34826897
3480e7b0:	34822d91 	.word	0x34822d91
3480e7b4:	348268a1 	.word	0x348268a1
3480e7b8:	348268c4 	.word	0x348268c4
3480e7bc:	348268ca 	.word	0x348268ca

3480e7c0 <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
3480e7c0:	e3520001 	cmp	r2, #1

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480e7c4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;
3480e7c8:	d3e00000 	mvnle	r0, #0

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480e7cc:	e1a04002 	mov	r4, r2
	int i;

	if (argc < 2)
3480e7d0:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
}

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
3480e7d4:	e2836004 	add	r6, r3, #4
3480e7d8:	e3a05001 	mov	r5, #1
{
	int i;

	if (argc < 2)
3480e7dc:	e1a07006 	mov	r7, r6
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
3480e7e0:	e4960004 	ldr	r0, [r6], #4
3480e7e4:	ebffe5c9 	bl	34807f10 <getenv>
3480e7e8:	e3500000 	cmp	r0, #0
3480e7ec:	1a000004 	bne	3480e804 <do_run+0x44>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
3480e7f0:	e59f0034 	ldr	r0, [pc, #52]	; 3480e82c <do_run+0x6c>
3480e7f4:	e5971000 	ldr	r1, [r7]
3480e7f8:	ebffecb2 	bl	34809ac8 <printf>
			return 1;
3480e7fc:	e3a00001 	mov	r0, #1
3480e800:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480e804:	e3a01003 	mov	r1, #3
3480e808:	ebfff690 	bl	3480c250 <parse_string_outer>
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
3480e80c:	e3500000 	cmp	r0, #0
3480e810:	1a000003 	bne	3480e824 <do_run+0x64>
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
3480e814:	e2855001 	add	r5, r5, #1
3480e818:	e1550004 	cmp	r5, r4
3480e81c:	baffffee 	blt	3480e7dc <do_run+0x1c>
3480e820:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
			return 1;
3480e824:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3480e828:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480e82c:	3482521d 	.word	0x3482521d

3480e830 <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
3480e830:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3480e834:	e24dd084 	sub	sp, sp, #132	; 0x84
3480e838:	e1a03000 	mov	r3, r0
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e83c:	e1a04121 	lsr	r4, r1, #2
3480e840:	e1a021a1 	lsr	r2, r1, #3
3480e844:	e24d0004 	sub	r0, sp, #4
	volatile long *addr;
	long           save[32];
	long           cnt;
	long           val;
	long           size;
	int            i = 0;
3480e848:	e3a0c000 	mov	ip, #0

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e84c:	ea000005 	b	3480e868 <get_ram_size+0x38>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
3480e850:	e7935102 	ldr	r5, [r3, r2, lsl #2]
3480e854:	e28cc001 	add	ip, ip, #1
3480e858:	e5a05004 	str	r5, [r0, #4]!
		sync ();
		*addr = ~cnt;
3480e85c:	e1e05002 	mvn	r5, r2
3480e860:	e7835102 	str	r5, [r3, r2, lsl #2]
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e864:	e1a020c2 	asr	r2, r2, #1
3480e868:	e3520000 	cmp	r2, #0
3480e86c:	1afffff7 	bne	3480e850 <get_ram_size+0x20>
		*addr = ~cnt;
	}

	addr = base;
	sync ();
	save[i] = *addr;
3480e870:	e5935000 	ldr	r5, [r3]
3480e874:	e1a0010c 	lsl	r0, ip, #2
3480e878:	e28d7080 	add	r7, sp, #128	; 0x80
3480e87c:	e0876000 	add	r6, r7, r0
3480e880:	e5065080 	str	r5, [r6, #-128]	; 0x80
	sync ();
	*addr = 0;
3480e884:	e5832000 	str	r2, [r3]

	sync ();
	if ((val = *addr) != 0) {
3480e888:	e5932000 	ldr	r2, [r3]
3480e88c:	e3520000 	cmp	r2, #0
3480e890:	e1a0200d 	mov	r2, sp
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480e894:	10820000 	addne	r0, r2, r0
3480e898:	008d5000 	addeq	r5, sp, r0
3480e89c:	03a02001 	moveq	r2, #1
	sync ();
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
3480e8a0:	15835000 	strne	r5, [r3]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e8a4:	13a02001 	movne	r2, #1
	save[i] = *addr;
	sync ();
	*addr = 0;

	sync ();
	if ((val = *addr) != 0) {
3480e8a8:	1a000003 	bne	3480e8bc <get_ram_size+0x8c>
3480e8ac:	ea000018 	b	3480e914 <get_ram_size+0xe4>
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
3480e8b0:	e5301004 	ldr	r1, [r0, #-4]!
3480e8b4:	e7831102 	str	r1, [r3, r2, lsl #2]
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e8b8:	e1a02082 	lsl	r2, r2, #1
3480e8bc:	e1520004 	cmp	r2, r4
3480e8c0:	3afffffa 	bcc	3480e8b0 <get_ram_size+0x80>
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
		}
		return (0);
3480e8c4:	e3a00000 	mov	r0, #0
3480e8c8:	ea000014 	b	3480e920 <get_ram_size+0xf0>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
3480e8cc:	e5356004 	ldr	r6, [r5, #-4]!
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
3480e8d0:	e7937102 	ldr	r7, [r3, r2, lsl #2]
		*addr = save[--i];
3480e8d4:	e7836102 	str	r6, [r3, r2, lsl #2]
		if (val != ~cnt) {
3480e8d8:	e1e06002 	mvn	r6, r2
3480e8dc:	e1570006 	cmp	r7, r6
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
3480e8e0:	e1a00102 	lsl	r0, r2, #2
		val = *addr;
		*addr = save[--i];
3480e8e4:	e24cc001 	sub	ip, ip, #1
3480e8e8:	e1a02082 	lsl	r2, r2, #1
		if (val != ~cnt) {
3480e8ec:	0a000008 	beq	3480e914 <get_ram_size+0xe4>
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480e8f0:	e1a0100d 	mov	r1, sp
3480e8f4:	e081c10c 	add	ip, r1, ip, lsl #2
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e8f8:	ea000002 	b	3480e908 <get_ram_size+0xd8>
				addr  = base + cnt;
				*addr = save[--i];
3480e8fc:	e53c1004 	ldr	r1, [ip, #-4]!
3480e900:	e7831102 	str	r1, [r3, r2, lsl #2]
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e904:	e1a02082 	lsl	r2, r2, #1
3480e908:	e1520004 	cmp	r2, r4
3480e90c:	3afffffa 	bcc	3480e8fc <get_ram_size+0xcc>
3480e910:	ea000002 	b	3480e920 <get_ram_size+0xf0>
			*addr = save[--i];
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e914:	e1520004 	cmp	r2, r4
3480e918:	3affffeb 	bcc	3480e8cc <get_ram_size+0x9c>
			}
			return (size);
		}
	}

	return (maxsize);
3480e91c:	e1a00001 	mov	r0, r1
}
3480e920:	e28dd084 	add	sp, sp, #132	; 0x84
3480e924:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3480e928 <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480e928:	e2403030 	sub	r3, r0, #48	; 0x30
3480e92c:	e6ef2073 	uxtb	r2, r3
3480e930:	e3520009 	cmp	r2, #9
		return (c - '0');
3480e934:	91a00003 	movls	r0, r3
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480e938:	912fff1e 	bxls	lr
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480e93c:	e2403061 	sub	r3, r0, #97	; 0x61
3480e940:	e6ef3073 	uxtb	r3, r3
3480e944:	e3530005 	cmp	r3, #5
		return (c + 10 - 'a');
3480e948:	92400057 	subls	r0, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480e94c:	912fff1e 	bxls	lr
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
3480e950:	e2403041 	sub	r3, r0, #65	; 0x41
3480e954:	e6ef3073 	uxtb	r3, r3
3480e958:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
3480e95c:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
3480e960:	83e00000 	mvnhi	r0, #0
}
3480e964:	e12fff1e 	bx	lr

3480e968 <hex2_bin>:

static int hex2_bin (char *s)
{
3480e968:	e92d4038 	push	{r3, r4, r5, lr}
3480e96c:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480e970:	e5d00000 	ldrb	r0, [r0]
3480e974:	ebffffeb 	bl	3480e928 <hex1_bin>
3480e978:	e2505000 	subs	r5, r0, #0
		return (-1);
3480e97c:	b3e00000 	mvnlt	r0, #0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480e980:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
3480e984:	e5d40001 	ldrb	r0, [r4, #1]
3480e988:	ebffffe6 	bl	3480e928 <hex1_bin>
3480e98c:	e3500000 	cmp	r0, #0
		return (-1);
	}

	return ((i<<4) + j);
3480e990:	a0800205 	addge	r0, r0, r5, lsl #4

	if ((i = hex1_bin(*s++)) < 0) {
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
		return (-1);
3480e994:	b3e00000 	mvnlt	r0, #0
	}

	return ((i<<4) + j);
}
3480e998:	e8bd8038 	pop	{r3, r4, r5, pc}

3480e99c <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
3480e99c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480e9a0:	e1a04001 	mov	r4, r1
3480e9a4:	e1a05002 	mov	r5, r2
3480e9a8:	e1a09003 	mov	r9, r3

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e9ac:	ea000002 	b	3480e9bc <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
3480e9b0:	e3530053 	cmp	r3, #83	; 0x53
			++input;
3480e9b4:	01a07000 	moveq	r7, r0
			break;
3480e9b8:	0a000004 	beq	3480e9d0 <srec_decode+0x34>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e9bc:	e5d03000 	ldrb	r3, [r0]
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
3480e9c0:	e1a07000 	mov	r7, r0

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e9c4:	e3530000 	cmp	r3, #0
3480e9c8:	e2800001 	add	r0, r0, #1
3480e9cc:	1afffff7 	bne	3480e9b0 <srec_decode+0x14>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480e9d0:	e5d7b000 	ldrb	fp, [r7]
3480e9d4:	e35b0000 	cmp	fp, #0
		return (SREC_EMPTY);
3480e9d8:	03a0600a 	moveq	r6, #10
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480e9dc:	0a000088 	beq	3480ec04 <srec_decode+0x268>
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
3480e9e0:	e2877001 	add	r7, r7, #1

	if ((*count = hex2_bin(input)) < 0) {
3480e9e4:	e1a00007 	mov	r0, r7
3480e9e8:	ebffffde 	bl	3480e968 <hex2_bin>
3480e9ec:	e3500000 	cmp	r0, #0
3480e9f0:	e5840000 	str	r0, [r4]
3480e9f4:	ba000081 	blt	3480ec00 <srec_decode+0x264>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
3480e9f8:	e24b3030 	sub	r3, fp, #48	; 0x30
3480e9fc:	e3530009 	cmp	r3, #9
3480ea00:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480ea04:	ea00007b 	b	3480ebf8 <srec_decode+0x25c>
3480ea08:	3480ea30 	.word	0x3480ea30
3480ea0c:	3480ea40 	.word	0x3480ea40
3480ea10:	3480ea50 	.word	0x3480ea50
3480ea14:	3480ea60 	.word	0x3480ea60
3480ea18:	3480ebf8 	.word	0x3480ebf8
3480ea1c:	3480ea70 	.word	0x3480ea70
3480ea20:	3480ebf8 	.word	0x3480ebf8
3480ea24:	3480ea80 	.word	0x3480ea80
3480ea28:	3480ea90 	.word	0x3480ea90
3480ea2c:	3480eaa0 	.word	0x3480eaa0

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480ea30:	e2403003 	sub	r3, r0, #3
3480ea34:	e5843000 	str	r3, [r4]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
3480ea38:	e3a06000 	mov	r6, #0
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480ea3c:	ea00001a 	b	3480eaac <srec_decode+0x110>
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480ea40:	e2403003 	sub	r3, r0, #3
3480ea44:	e5843000 	str	r3, [r4]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
3480ea48:	e3a06001 	mov	r6, #1
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480ea4c:	ea000016 	b	3480eaac <srec_decode+0x110>
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480ea50:	e2403004 	sub	r3, r0, #4
3480ea54:	e5843000 	str	r3, [r4]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
3480ea58:	e3a06002 	mov	r6, #2
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480ea5c:	ea000012 	b	3480eaac <srec_decode+0x110>
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480ea60:	e2403005 	sub	r3, r0, #5
3480ea64:	e5843000 	str	r3, [r4]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
3480ea68:	e3a06003 	mov	r6, #3
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480ea6c:	ea00000e 	b	3480eaac <srec_decode+0x110>
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
3480ea70:	e3a03000 	mov	r3, #0
3480ea74:	e5843000 	str	r3, [r4]
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
3480ea78:	e3a06005 	mov	r6, #5
		*count    = 0;			/* no data		*/
		break;
3480ea7c:	ea00000a 	b	3480eaac <srec_decode+0x110>
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480ea80:	e2403005 	sub	r3, r0, #5
3480ea84:	e5843000 	str	r3, [r4]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
3480ea88:	e3a06007 	mov	r6, #7
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480ea8c:	ea000006 	b	3480eaac <srec_decode+0x110>
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480ea90:	e2403004 	sub	r3, r0, #4
3480ea94:	e5843000 	str	r3, [r4]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
3480ea98:	e3a06008 	mov	r6, #8
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480ea9c:	ea000002 	b	3480eaac <srec_decode+0x110>
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480eaa0:	e2403003 	sub	r3, r0, #3
3480eaa4:	e5843000 	str	r3, [r4]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
3480eaa8:	e3a06009 	mov	r6, #9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480eaac:	e3a03000 	mov	r3, #0

	switch (v) {
3480eab0:	e24bb030 	sub	fp, fp, #48	; 0x30
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480eab4:	e5853000 	str	r3, [r5]

	switch (v) {
3480eab8:	e6ef307b 	uxtb	r3, fp
3480eabc:	e3530009 	cmp	r3, #9

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
3480eac0:	e6efa070 	uxtb	sl, r0
	input  += 2;
3480eac4:	e2877002 	add	r7, r7, #2
	}

	/* read address field */
	*addr = 0;

	switch (v) {
3480eac8:	8a00004a 	bhi	3480ebf8 <srec_decode+0x25c>
3480eacc:	e3a03001 	mov	r3, #1
3480ead0:	e6afb07b 	sxtb	fp, fp
3480ead4:	e1a0bb13 	lsl	fp, r3, fp
3480ead8:	e3003223 	movw	r3, #547	; 0x223
3480eadc:	e00b3003 	and	r3, fp, r3
3480eae0:	e3530000 	cmp	r3, #0
3480eae4:	1a000016 	bne	3480eb44 <srec_decode+0x1a8>
3480eae8:	e31b0088 	tst	fp, #136	; 0x88
3480eaec:	1a000002 	bne	3480eafc <srec_decode+0x160>
3480eaf0:	e31b0f41 	tst	fp, #260	; 0x104
3480eaf4:	1a000008 	bne	3480eb1c <srec_decode+0x180>
3480eaf8:	ea00003e 	b	3480ebf8 <srec_decode+0x25c>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
3480eafc:	e1a00007 	mov	r0, r7
3480eb00:	ebffff98 	bl	3480e968 <hex2_bin>
3480eb04:	e3500000 	cmp	r0, #0
3480eb08:	ba00003c 	blt	3480ec00 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
3480eb0c:	e08aa000 	add	sl, sl, r0
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
3480eb10:	e5850000 	str	r0, [r5]
		chksum += v;
3480eb14:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480eb18:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
3480eb1c:	e1a00007 	mov	r0, r7
3480eb20:	ebffff90 	bl	3480e968 <hex2_bin>
3480eb24:	e3500000 	cmp	r0, #0
3480eb28:	ba000034 	blt	3480ec00 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480eb2c:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
3480eb30:	e08aa000 	add	sl, sl, r0
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480eb34:	e0803403 	add	r3, r0, r3, lsl #8
3480eb38:	e5853000 	str	r3, [r5]
		chksum += v;
3480eb3c:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480eb40:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
3480eb44:	e1a00007 	mov	r0, r7
3480eb48:	ebffff86 	bl	3480e968 <hex2_bin>
3480eb4c:	e250b000 	subs	fp, r0, #0
3480eb50:	ba00002a 	blt	3480ec00 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480eb54:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
		input  += 2;
3480eb58:	e2877002 	add	r7, r7, #2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480eb5c:	e08b3403 	add	r3, fp, r3, lsl #8
3480eb60:	e5853000 	str	r3, [r5]
		chksum += v;
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
3480eb64:	e1a00007 	mov	r0, r7
3480eb68:	e58d3004 	str	r3, [sp, #4]
3480eb6c:	ebffff7d 	bl	3480e968 <hex2_bin>
3480eb70:	e3500000 	cmp	r0, #0
3480eb74:	e59d3004 	ldr	r3, [sp, #4]
3480eb78:	ba000020 	blt	3480ec00 <srec_decode+0x264>
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
3480eb7c:	e08aa00b 	add	sl, sl, fp

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480eb80:	e0803403 	add	r3, r0, r3, lsl #8
		chksum += v;
3480eb84:	e6e0a07a 	uxtab	sl, r0, sl

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480eb88:	e5853000 	str	r3, [r5]
		chksum += v;
3480eb8c:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480eb90:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480eb94:	e3a05000 	mov	r5, #0
3480eb98:	ea000009 	b	3480ebc4 <srec_decode+0x228>
		if ((v = hex2_bin(input)) < 0) {
3480eb9c:	e1a00007 	mov	r0, r7
3480eba0:	ebffff70 	bl	3480e968 <hex2_bin>
3480eba4:	e3500000 	cmp	r0, #0
3480eba8:	ba000014 	blt	3480ec00 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480ebac:	e6ef0070 	uxtb	r0, r0
		chksum += v;
3480ebb0:	e080a00a 	add	sl, r0, sl
	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480ebb4:	e7c90005 	strb	r0, [r9, r5]
		chksum += v;
3480ebb8:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480ebbc:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480ebc0:	e2855001 	add	r5, r5, #1
3480ebc4:	e5943000 	ldr	r3, [r4]
3480ebc8:	e1550003 	cmp	r5, r3
3480ebcc:	bafffff2 	blt	3480eb9c <srec_decode+0x200>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
3480ebd0:	e1a00007 	mov	r0, r7
3480ebd4:	ebffff63 	bl	3480e968 <hex2_bin>
3480ebd8:	e3500000 	cmp	r0, #0
3480ebdc:	ba000007 	blt	3480ec00 <srec_decode+0x264>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
3480ebe0:	e1e0a00a 	mvn	sl, sl
3480ebe4:	e6ef0070 	uxtb	r0, r0
3480ebe8:	e6efa07a 	uxtb	sl, sl
		return (SREC_E_BADCHKS);
3480ebec:	e150000a 	cmp	r0, sl
3480ebf0:	13e06002 	mvnne	r6, #2
3480ebf4:	ea000002 	b	3480ec04 <srec_decode+0x268>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
3480ebf8:	e3e06000 	mvn	r6, #0
3480ebfc:	ea000000 	b	3480ec04 <srec_decode+0x268>
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
3480ec00:	e3e06001 	mvn	r6, #1
	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
}
3480ec04:	e1a00006 	mov	r0, r6
3480ec08:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480ec0c <get_current>:
	for (s = serial_devices; s; s = s->next)
		s->init();
}

static struct serial_device *get_current(void)
{
3480ec0c:	e92d4008 	push	{r3, lr}
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480ec10:	e5983004 	ldr	r3, [r8, #4]
3480ec14:	e3130001 	tst	r3, #1
3480ec18:	0a000003 	beq	3480ec2c <get_current+0x20>
3480ec1c:	e59f301c 	ldr	r3, [pc, #28]	; 3480ec40 <get_current+0x34>
3480ec20:	e5930000 	ldr	r0, [r3]
3480ec24:	e3500000 	cmp	r0, #0
3480ec28:	18bd8008 	popne	{r3, pc}
		dev = default_serial_console();
3480ec2c:	eb0026cd 	bl	34818768 <default_serial_console>

		/* We must have a console device */
		if (!dev)
3480ec30:	e3500000 	cmp	r0, #0
3480ec34:	18bd8008 	popne	{r3, pc}
			panic("Cannot find console");
3480ec38:	e59f0004 	ldr	r0, [pc, #4]	; 3480ec44 <get_current+0x38>
3480ec3c:	eb003a17 	bl	3481d4a0 <panic>
3480ec40:	3482b4e0 	.word	0x3482b4e0
3480ec44:	348268d2 	.word	0x348268d2

3480ec48 <serial_register>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ec48:	e59f300c 	ldr	r3, [pc, #12]	; 3480ec5c <serial_register+0x14>
3480ec4c:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
3480ec50:	e5830004 	str	r0, [r3, #4]
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ec54:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
}
3480ec58:	e12fff1e 	bx	lr
3480ec5c:	3482b4e0 	.word	0x3482b4e0

3480ec60 <serial_stdio_init>:
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480ec60:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480ec64:	e59f3080 	ldr	r3, [pc, #128]	; 3480ecec <serial_stdio_init+0x8c>
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480ec68:	e24dd044 	sub	sp, sp, #68	; 0x44
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
		memset(&dev, 0, sizeof(dev));
3480ec6c:	e28d5004 	add	r5, sp, #4
}

void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480ec70:	e5934004 	ldr	r4, [r3, #4]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
3480ec74:	e2857008 	add	r7, r5, #8
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480ec78:	e3a06003 	mov	r6, #3
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480ec7c:	ea000016 	b	3480ecdc <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
3480ec80:	e3a0203c 	mov	r2, #60	; 0x3c
3480ec84:	e3a01000 	mov	r1, #0
3480ec88:	e1a00005 	mov	r0, r5
3480ec8c:	eb003661 	bl	3481c618 <memset>

		strcpy(dev.name, s->name);
3480ec90:	e1a01004 	mov	r1, r4
3480ec94:	e1a00007 	mov	r0, r7
3480ec98:	eb003559 	bl	3481c204 <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480ec9c:	e5943010 	ldr	r3, [r4, #16]
		dev.putc = s->putc;
		dev.puts = s->puts;
		dev.getc = s->getc;
		dev.tstc = s->tstc;

		stdio_register(&dev);
3480eca0:	e1a00005 	mov	r0, r5
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480eca4:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->uninit;
3480eca8:	e5943014 	ldr	r3, [r4, #20]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480ecac:	e58d6004 	str	r6, [sp, #4]

		dev.start = s->init;
		dev.stop = s->uninit;
3480ecb0:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
3480ecb4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3480ecb8:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
3480ecbc:	e5943028 	ldr	r3, [r4, #40]	; 0x28
3480ecc0:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
3480ecc4:	e594301c 	ldr	r3, [r4, #28]
3480ecc8:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
3480eccc:	e5943020 	ldr	r3, [r4, #32]
3480ecd0:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		stdio_register(&dev);
3480ecd4:	eb000083 	bl	3480eee8 <stdio_register>

		s = s->next;
3480ecd8:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480ecdc:	e3540000 	cmp	r4, #0
3480ece0:	1affffe6 	bne	3480ec80 <serial_stdio_init+0x20>

		stdio_register(&dev);

		s = s->next;
	}
}
3480ece4:	e28dd044 	add	sp, sp, #68	; 0x44
3480ece8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480ecec:	3482b4e0 	.word	0x3482b4e0

3480ecf0 <serial_assign>:

int serial_assign(const char *name)
{
3480ecf0:	e92d4038 	push	{r3, r4, r5, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480ecf4:	e59f303c 	ldr	r3, [pc, #60]	; 3480ed38 <serial_assign+0x48>
		s = s->next;
	}
}

int serial_assign(const char *name)
{
3480ecf8:	e1a05000 	mov	r5, r0
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480ecfc:	e5934004 	ldr	r4, [r3, #4]
3480ed00:	ea000008 	b	3480ed28 <serial_assign+0x38>
		if (strcmp(s->name, name) == 0) {
3480ed04:	e1a00004 	mov	r0, r4
3480ed08:	e1a01005 	mov	r1, r5
3480ed0c:	eb00356d 	bl	3481c2c8 <strcmp>
3480ed10:	e3500000 	cmp	r0, #0
3480ed14:	1a000002 	bne	3480ed24 <serial_assign+0x34>
			serial_current = s;
3480ed18:	e59f3018 	ldr	r3, [pc, #24]	; 3480ed38 <serial_assign+0x48>
3480ed1c:	e5834000 	str	r4, [r3]
			return 0;
3480ed20:	e8bd8038 	pop	{r3, r4, r5, pc}

int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480ed24:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480ed28:	e3540000 	cmp	r4, #0
3480ed2c:	1afffff4 	bne	3480ed04 <serial_assign+0x14>
			serial_current = s;
			return 0;
		}
	}

	return 1;
3480ed30:	e3a00001 	mov	r0, #1
}
3480ed34:	e8bd8038 	pop	{r3, r4, r5, pc}
3480ed38:	3482b4e0 	.word	0x3482b4e0

3480ed3c <serial_initialize>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ed3c:	e59f3034 	ldr	r3, [pc, #52]	; 3480ed78 <serial_initialize+0x3c>
3480ed40:	e59f1034 	ldr	r1, [pc, #52]	; 3480ed7c <serial_initialize+0x40>
3480ed44:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
}

void serial_initialize(void)
{
3480ed48:	e92d4010 	push	{r4, lr}
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ed4c:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480ed50:	e59f2028 	ldr	r2, [pc, #40]	; 3480ed80 <serial_initialize+0x44>
3480ed54:	e582102c 	str	r1, [r2, #44]	; 0x2c
3480ed58:	e59f1024 	ldr	r1, [pc, #36]	; 3480ed84 <serial_initialize+0x48>
3480ed5c:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480ed60:	e59f2020 	ldr	r2, [pc, #32]	; 3480ed88 <serial_initialize+0x4c>
3480ed64:	e582102c 	str	r1, [r2, #44]	; 0x2c
	serial_devices = dev;
3480ed68:	e5832004 	str	r2, [r3, #4]
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480ed6c:	eb00267d 	bl	34818768 <default_serial_console>
}
3480ed70:	e8bd4010 	pop	{r4, lr}
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480ed74:	eaffffdd 	b	3480ecf0 <serial_assign>
3480ed78:	3482b4e0 	.word	0x3482b4e0
3480ed7c:	348291a8 	.word	0x348291a8
3480ed80:	348291d8 	.word	0x348291d8
3480ed84:	34829208 	.word	0x34829208
3480ed88:	34829238 	.word	0x34829238

3480ed8c <serial_reinit_all>:

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480ed8c:	e59f3020 	ldr	r3, [pc, #32]	; 3480edb4 <serial_reinit_all+0x28>

	return 1;
}

void serial_reinit_all(void)
{
3480ed90:	e92d4010 	push	{r4, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480ed94:	e5934004 	ldr	r4, [r3, #4]
3480ed98:	ea000002 	b	3480eda8 <serial_reinit_all+0x1c>
		s->init();
3480ed9c:	e5943010 	ldr	r3, [r4, #16]
3480eda0:	e12fff33 	blx	r3

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480eda4:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480eda8:	e3540000 	cmp	r4, #0
3480edac:	1afffffa 	bne	3480ed9c <serial_reinit_all+0x10>
		s->init();
}
3480edb0:	e8bd8010 	pop	{r4, pc}
3480edb4:	3482b4e0 	.word	0x3482b4e0

3480edb8 <serial_init>:
		dev = serial_current;
	return dev;
}

int serial_init(void)
{
3480edb8:	e92d4008 	push	{r3, lr}
	return get_current()->init();
3480edbc:	ebffff92 	bl	3480ec0c <get_current>
3480edc0:	e5903010 	ldr	r3, [r0, #16]
3480edc4:	e12fff33 	blx	r3
}
3480edc8:	e8bd8008 	pop	{r3, pc}

3480edcc <serial_setbrg>:

void serial_setbrg(void)
{
3480edcc:	e92d4008 	push	{r3, lr}
	get_current()->setbrg();
3480edd0:	ebffff8d 	bl	3480ec0c <get_current>
3480edd4:	e5903018 	ldr	r3, [r0, #24]
3480edd8:	e12fff33 	blx	r3
}
3480eddc:	e8bd8008 	pop	{r3, pc}

3480ede0 <serial_getc>:

int serial_getc(void)
{
3480ede0:	e92d4008 	push	{r3, lr}
	return get_current()->getc();
3480ede4:	ebffff88 	bl	3480ec0c <get_current>
3480ede8:	e590301c 	ldr	r3, [r0, #28]
3480edec:	e12fff33 	blx	r3
}
3480edf0:	e8bd8008 	pop	{r3, pc}

3480edf4 <serial_tstc>:

int serial_tstc(void)
{
3480edf4:	e92d4008 	push	{r3, lr}
	return get_current()->tstc();
3480edf8:	ebffff83 	bl	3480ec0c <get_current>
3480edfc:	e5903020 	ldr	r3, [r0, #32]
3480ee00:	e12fff33 	blx	r3
}
3480ee04:	e8bd8008 	pop	{r3, pc}

3480ee08 <serial_putc>:

void serial_putc(const char c)
{
3480ee08:	e92d4010 	push	{r4, lr}
3480ee0c:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
3480ee10:	ebffff7d 	bl	3480ec0c <get_current>
3480ee14:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3480ee18:	e1a00004 	mov	r0, r4
3480ee1c:	e12fff33 	blx	r3
}
3480ee20:	e8bd8010 	pop	{r4, pc}

3480ee24 <serial_puts>:

void serial_puts(const char *s)
{
3480ee24:	e92d4010 	push	{r4, lr}
3480ee28:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
3480ee2c:	ebffff76 	bl	3480ec0c <get_current>
3480ee30:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3480ee34:	e1a00004 	mov	r0, r4
3480ee38:	e12fff33 	blx	r3
}
3480ee3c:	e8bd8010 	pop	{r4, pc}

3480ee40 <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
3480ee40:	e59f0000 	ldr	r0, [pc, #0]	; 3480ee48 <stdio_get_list+0x8>
3480ee44:	e12fff1e 	bx	lr
3480ee48:	3482b51c 	.word	0x3482b51c

3480ee4c <stdio_get_by_name>:

struct stdio_dev* stdio_get_by_name(const char *name)
{
3480ee4c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480ee50:	e2507000 	subs	r7, r0, #0
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480ee54:	159f6040 	ldrne	r6, [pc, #64]	; 3480ee9c <stdio_get_by_name+0x50>
3480ee58:	15b65034 	ldrne	r5, [r6, #52]!	; 0x34
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480ee5c:	0a00000b 	beq	3480ee90 <stdio_get_by_name+0x44>
3480ee60:	ea000006 	b	3480ee80 <stdio_get_by_name+0x34>
		return NULL;

	list_for_each(pos, &(devs.list)) {
		dev = list_entry(pos, struct stdio_dev, list);
3480ee64:	e2454034 	sub	r4, r5, #52	; 0x34
		if(strcmp(dev->name, name) == 0)
3480ee68:	e2840008 	add	r0, r4, #8
3480ee6c:	e1a01007 	mov	r1, r7
3480ee70:	eb003514 	bl	3481c2c8 <strcmp>
3480ee74:	e3500000 	cmp	r0, #0
3480ee78:	0a000005 	beq	3480ee94 <stdio_get_by_name+0x48>
	struct stdio_dev *dev;

	if(!name)
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480ee7c:	e5955000 	ldr	r5, [r5]
3480ee80:	e1550006 	cmp	r5, r6
3480ee84:	1afffff6 	bne	3480ee64 <stdio_get_by_name+0x18>
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
3480ee88:	e3a04000 	mov	r4, #0
3480ee8c:	ea000000 	b	3480ee94 <stdio_get_by_name+0x48>
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
		return NULL;
3480ee90:	e1a04007 	mov	r4, r7
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
}
3480ee94:	e1a00004 	mov	r0, r4
3480ee98:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480ee9c:	3482b4e8 	.word	0x3482b4e8

3480eea0 <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
3480eea0:	e92d4038 	push	{r3, r4, r5, lr}
	struct stdio_dev *_dev;

	if(!dev)
3480eea4:	e2505000 	subs	r5, r0, #0
		return NULL;
3480eea8:	01a04005 	moveq	r4, r5

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
3480eeac:	0a00000b 	beq	3480eee0 <stdio_clone+0x40>
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
3480eeb0:	e3a00001 	mov	r0, #1
3480eeb4:	e3a0103c 	mov	r1, #60	; 0x3c
3480eeb8:	ebffee36 	bl	3480a798 <calloc>

	if(!_dev)
3480eebc:	e2504000 	subs	r4, r0, #0
3480eec0:	0a000006 	beq	3480eee0 <stdio_clone+0x40>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
3480eec4:	e1a01005 	mov	r1, r5
3480eec8:	e3a0203c 	mov	r2, #60	; 0x3c
3480eecc:	eb0035f5 	bl	3481c6a8 <memcpy>
	strncpy(_dev->name, dev->name, 16);
3480eed0:	e2840008 	add	r0, r4, #8
3480eed4:	e2851008 	add	r1, r5, #8
3480eed8:	e3a02010 	mov	r2, #16
3480eedc:	eb0034cf 	bl	3481c220 <strncpy>

	return _dev;
}
3480eee0:	e1a00004 	mov	r0, r4
3480eee4:	e8bd8038 	pop	{r3, r4, r5, pc}

3480eee8 <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
3480eee8:	e92d4008 	push	{r3, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
3480eeec:	ebffffeb 	bl	3480eea0 <stdio_clone>
	if(!_dev)
3480eef0:	e3500000 	cmp	r0, #0
3480eef4:	0a000009 	beq	3480ef20 <stdio_register+0x38>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480eef8:	e59f3028 	ldr	r3, [pc, #40]	; 3480ef28 <stdio_register+0x40>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
3480eefc:	e2801034 	add	r1, r0, #52	; 0x34
3480ef00:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480ef04:	e5831038 	str	r1, [r3, #56]	; 0x38
	new->next = next;
3480ef08:	e2833034 	add	r3, r3, #52	; 0x34
3480ef0c:	e5803034 	str	r3, [r0, #52]	; 0x34
	new->prev = prev;
3480ef10:	e5802038 	str	r2, [r0, #56]	; 0x38
	prev->next = new;
3480ef14:	e5821000 	str	r1, [r2]
	return 0;
3480ef18:	e3a00000 	mov	r0, #0
3480ef1c:	e8bd8008 	pop	{r3, pc}
{
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
	if(!_dev)
		return -1;
3480ef20:	e3e00000 	mvn	r0, #0
	list_add_tail(&(_dev->list), &(devs.list));
	return 0;
}
3480ef24:	e8bd8008 	pop	{r3, pc}
3480ef28:	3482b4e8 	.word	0x3482b4e8

3480ef2c <stdio_init>:
	return 0;
}
#endif	/* CONFIG_SYS_STDIO_DEREGISTER */

int stdio_init (void)
{
3480ef2c:	e92d4010 	push	{r4, lr}
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480ef30:	e59f3078 	ldr	r3, [pc, #120]	; 3480efb0 <stdio_init+0x84>
3480ef34:	e24dd040 	sub	sp, sp, #64	; 0x40
3480ef38:	e2832034 	add	r2, r3, #52	; 0x34
3480ef3c:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
3480ef40:	e5832038 	str	r2, [r3, #56]	; 0x38

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480ef44:	e28d4004 	add	r4, sp, #4

#ifdef CONFIG_ARM_DCC_MULTI
	drv_arm_dcc_init ();
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480ef48:	e30c0350 	movw	r0, #50000	; 0xc350
3480ef4c:	e3a010fe 	mov	r1, #254	; 0xfe
3480ef50:	eb000654 	bl	348108a8 <i2c_init>

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480ef54:	e3a0203c 	mov	r2, #60	; 0x3c
3480ef58:	e1a00004 	mov	r0, r4
3480ef5c:	e3a01000 	mov	r1, #0
3480ef60:	eb0035ac 	bl	3481c618 <memset>

	strcpy (dev.name, "serial");
3480ef64:	e59f1048 	ldr	r1, [pc, #72]	; 3480efb4 <stdio_init+0x88>
3480ef68:	e2840008 	add	r0, r4, #8
3480ef6c:	eb0034a4 	bl	3481c204 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480ef70:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
3480ef74:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
3480ef78:	e59f3038 	ldr	r3, [pc, #56]	; 3480efb8 <stdio_init+0x8c>
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
	stdio_register (&dev);
3480ef7c:	e1a00004 	mov	r0, r4

	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "serial");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = serial_putc;
3480ef80:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
3480ef84:	e59f3030 	ldr	r3, [pc, #48]	; 3480efbc <stdio_init+0x90>
3480ef88:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
3480ef8c:	e59f302c 	ldr	r3, [pc, #44]	; 3480efc0 <stdio_init+0x94>
3480ef90:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
3480ef94:	e59f3028 	ldr	r3, [pc, #40]	; 3480efc4 <stdio_init+0x98>
3480ef98:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
3480ef9c:	ebffffd1 	bl	3480eee8 <stdio_register>
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
#ifdef CONFIG_SERIAL_MULTI
	serial_stdio_init ();
3480efa0:	ebffff2e 	bl	3480ec60 <serial_stdio_init>
#ifdef CONFIG_JTAG_CONSOLE
	drv_jtag_console_init ();
#endif

	return (0);
}
3480efa4:	e3a00000 	mov	r0, #0
3480efa8:	e28dd040 	add	sp, sp, #64	; 0x40
3480efac:	e8bd8010 	pop	{r4, pc}
3480efb0:	3482b4e8 	.word	0x3482b4e8
3480efb4:	34826037 	.word	0x34826037
3480efb8:	3480ee08 	.word	0x3480ee08
3480efbc:	3480ee24 	.word	0x3480ee24
3480efc0:	3480ede0 	.word	0x3480ede0
3480efc4:	3480edf4 	.word	0x3480edf4

3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
3480efc8:	e92d4070 	push	{r4, r5, r6, lr}
3480efcc:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
3480efd0:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480efd4:	e59f603c 	ldr	r6, [pc, #60]	; 3480f018 <CYGACC_COMM_IF_GETC_TIMEOUT+0x50>
3480efd8:	ea000002 	b	3480efe8 <CYGACC_COMM_IF_GETC_TIMEOUT+0x20>
    {
      udelay (DELAY);
3480efdc:	e3a00014 	mov	r0, #20
3480efe0:	eb00363b 	bl	3481c8d4 <udelay>
      counter++;
3480efe4:	e2844001 	add	r4, r4, #1
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480efe8:	ebffea99 	bl	34809a54 <tstc>
3480efec:	e3500000 	cmp	r0, #0
3480eff0:	1a000001 	bne	3480effc <CYGACC_COMM_IF_GETC_TIMEOUT+0x34>
3480eff4:	e1540006 	cmp	r4, r6
3480eff8:	1afffff7 	bne	3480efdc <CYGACC_COMM_IF_GETC_TIMEOUT+0x14>
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
3480effc:	ebffea94 	bl	34809a54 <tstc>
3480f000:	e3500000 	cmp	r0, #0
3480f004:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
3480f008:	ebffea88 	bl	34809a30 <getc>
3480f00c:	e5c50000 	strb	r0, [r5]
      return 1;
3480f010:	e3a00001 	mov	r0, #1
    }
  return 0;
}
3480f014:	e8bd8070 	pop	{r4, r5, r6, pc}
3480f018:	000186a0 	.word	0x000186a0

3480f01c <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
3480f01c:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f020:	e59f501c 	ldr	r5, [pc, #28]	; 3480f044 <xyzModem_flush+0x28>
3480f024:	e28d4007 	add	r4, sp, #7
3480f028:	e5953000 	ldr	r3, [r5]
3480f02c:	e1a01004 	mov	r1, r4
3480f030:	e5d30000 	ldrb	r0, [r3]
3480f034:	ebffffe3 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480f038:	e3500000 	cmp	r0, #0
3480f03c:	1afffff9 	bne	3480f028 <xyzModem_flush+0xc>
	return;
    }
}
3480f040:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
3480f044:	3482b530 	.word	0x3482b530

3480f048 <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
3480f048:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
3480f04c:	e59f4250 	ldr	r4, [pc, #592]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
3480f050:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
3480f054:	e3530000 	cmp	r3, #0
3480f058:	0a000003 	beq	3480f06c <xyzModem_get_hdr+0x24>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f05c:	e3a00006 	mov	r0, #6
3480f060:	ebffea84 	bl	34809a78 <putc>
  hdr_chars = 0;

  if (xyz.tx_ack)
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
3480f064:	e3a03000 	mov	r3, #0
3480f068:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
}

static int
xyzModem_get_hdr (void)
{
3480f06c:	e3a05000 	mov	r5, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f070:	e59f622c 	ldr	r6, [pc, #556]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
    }
}

static int
xyzModem_get_hdr (void)
{
3480f074:	e1a07005 	mov	r7, r5
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f078:	e28da007 	add	sl, sp, #7
3480f07c:	e5963000 	ldr	r3, [r6]
3480f080:	e1a0100a 	mov	r1, sl
3480f084:	e5d30000 	ldrb	r0, [r3]
3480f088:	ebffffce 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f08c:	e3500000 	cmp	r0, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f090:	e59f420c 	ldr	r4, [pc, #524]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f094:	0a000021 	beq	3480f120 <xyzModem_get_hdr+0xd8>
	{
	  hdr_chars++;
	  switch (c)
3480f098:	e5dd3007 	ldrb	r3, [sp, #7]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
3480f09c:	e2855001 	add	r5, r5, #1
	  switch (c)
3480f0a0:	e3530002 	cmp	r3, #2
3480f0a4:	0a00000c 	beq	3480f0dc <xyzModem_get_hdr+0x94>
3480f0a8:	8a000002 	bhi	3480f0b8 <xyzModem_get_hdr+0x70>
3480f0ac:	e3530001 	cmp	r3, #1
3480f0b0:	1afffff1 	bne	3480f07c <xyzModem_get_hdr+0x34>
3480f0b4:	ea000004 	b	3480f0cc <xyzModem_get_hdr+0x84>
3480f0b8:	e3530004 	cmp	r3, #4
3480f0bc:	0a000011 	beq	3480f108 <xyzModem_get_hdr+0xc0>
3480f0c0:	e3530018 	cmp	r3, #24
3480f0c4:	1affffec 	bne	3480f07c <xyzModem_get_hdr+0x34>
3480f0c8:	ea000007 	b	3480f0ec <xyzModem_get_hdr+0xa4>
	    {
	    case SOH:
	      xyz.total_SOH++;
3480f0cc:	e594341c 	ldr	r3, [r4, #1052]	; 0x41c
3480f0d0:	e2833001 	add	r3, r3, #1
3480f0d4:	e584341c 	str	r3, [r4, #1052]	; 0x41c
3480f0d8:	ea000069 	b	3480f284 <xyzModem_get_hdr+0x23c>
	    case STX:
	      if (c == STX)
		xyz.total_STX++;
3480f0dc:	e5943420 	ldr	r3, [r4, #1056]	; 0x420
3480f0e0:	e2833001 	add	r3, r3, #1
3480f0e4:	e5843420 	str	r3, [r4, #1056]	; 0x420
3480f0e8:	ea000065 	b	3480f284 <xyzModem_get_hdr+0x23c>
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f0ec:	e5963424 	ldr	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f0f0:	e2877001 	add	r7, r7, #1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f0f4:	e2833001 	add	r3, r3, #1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f0f8:	e3570003 	cmp	r7, #3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f0fc:	e5863424 	str	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f100:	1affffdd 	bne	3480f07c <xyzModem_get_hdr+0x34>
3480f104:	ea00005a 	b	3480f274 <xyzModem_get_hdr+0x22c>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
3480f108:	e3550001 	cmp	r5, #1
3480f10c:	1affffda 	bne	3480f07c <xyzModem_get_hdr+0x34>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f110:	e3a00006 	mov	r0, #6
3480f114:	ebffea57 	bl	34809a78 <putc>
	      if (hdr_chars == 1)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
3480f118:	e3e00003 	mvn	r0, #3
3480f11c:	ea000057 	b	3480f280 <xyzModem_get_hdr+0x238>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
3480f120:	ebffffbd 	bl	3480f01c <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f124:	e59f017c 	ldr	r0, [pc, #380]	; 3480f2a8 <xyzModem_get_hdr+0x260>
3480f128:	eb0035e9 	bl	3481c8d4 <udelay>
3480f12c:	ea000052 	b	3480f27c <xyzModem_get_hdr+0x234>
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
3480f130:	e5943000 	ldr	r3, [r4]
3480f134:	e59f1170 	ldr	r1, [pc, #368]	; 3480f2ac <xyzModem_get_hdr+0x264>
3480f138:	e5d30000 	ldrb	r0, [r3]
3480f13c:	ebffffa1 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
3480f140:	e3500000 	cmp	r0, #0
3480f144:	0a00004c 	beq	3480f27c <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480f148:	e28d7008 	add	r7, sp, #8
3480f14c:	e5773001 	ldrb	r3, [r7, #-1]!
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480f150:	e3a05000 	mov	r5, #0
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480f154:	e3530001 	cmp	r3, #1
3480f158:	13a03b01 	movne	r3, #1024	; 0x400
3480f15c:	03a03080 	moveq	r3, #128	; 0x80
3480f160:	e5843410 	str	r3, [r4, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
3480f164:	e2843004 	add	r3, r4, #4
3480f168:	e5843404 	str	r3, [r4, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
3480f16c:	ea000009 	b	3480f198 <xyzModem_get_hdr+0x150>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f170:	e5943000 	ldr	r3, [r4]
3480f174:	e1a01007 	mov	r1, r7
3480f178:	e5d30000 	ldrb	r0, [r3]
3480f17c:	ebffff91 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f180:	e3500000 	cmp	r0, #0
3480f184:	0a00003c 	beq	3480f27c <xyzModem_get_hdr+0x234>
	{
	  xyz.pkt[i] = c;
3480f188:	e5dd2007 	ldrb	r2, [sp, #7]
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480f18c:	e0843005 	add	r3, r4, r5
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
3480f190:	e5c32004 	strb	r2, [r3, #4]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480f194:	e2855001 	add	r5, r5, #1
3480f198:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f19c:	e59f6100 	ldr	r6, [pc, #256]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
3480f1a0:	e1550003 	cmp	r5, r3
3480f1a4:	bafffff1 	blt	3480f170 <xyzModem_get_hdr+0x128>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
3480f1a8:	e5963000 	ldr	r3, [r6]
3480f1ac:	e59f10fc 	ldr	r1, [pc, #252]	; 3480f2b0 <xyzModem_get_hdr+0x268>
3480f1b0:	e5d30000 	ldrb	r0, [r3]
3480f1b4:	ebffff83 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
3480f1b8:	e3500000 	cmp	r0, #0
3480f1bc:	0a00002e 	beq	3480f27c <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
3480f1c0:	e5963428 	ldr	r3, [r6, #1064]	; 0x428
3480f1c4:	e3530000 	cmp	r3, #0
3480f1c8:	0a000005 	beq	3480f1e4 <xyzModem_get_hdr+0x19c>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
3480f1cc:	e5963000 	ldr	r3, [r6]
3480f1d0:	e59f10dc 	ldr	r1, [pc, #220]	; 3480f2b4 <xyzModem_get_hdr+0x26c>
3480f1d4:	e5d30000 	ldrb	r0, [r3]
3480f1d8:	ebffff7a 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
3480f1dc:	e3500000 	cmp	r0, #0
3480f1e0:	0a000025 	beq	3480f27c <xyzModem_get_hdr+0x234>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
3480f1e4:	e59f40b8 	ldr	r4, [pc, #184]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
3480f1e8:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
3480f1ec:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480f1f0:	e0223003 	eor	r3, r2, r3
3480f1f4:	e35300ff 	cmp	r3, #255	; 0xff
3480f1f8:	0a000002 	beq	3480f208 <xyzModem_get_hdr+0x1c0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
3480f1fc:	ebffff86 	bl	3480f01c <xyzModem_flush>
      return xyzModem_frame;
3480f200:	e3e00005 	mvn	r0, #5
3480f204:	ea00001d 	b	3480f280 <xyzModem_get_hdr+0x238>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480f208:	e5943428 	ldr	r3, [r4, #1064]	; 0x428
3480f20c:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f210:	05941410 	ldreq	r1, [r4, #1040]	; 0x410
3480f214:	01a02003 	moveq	r2, r3
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480f218:	0a00000c 	beq	3480f250 <xyzModem_get_hdr+0x208>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480f21c:	e2840004 	add	r0, r4, #4
3480f220:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480f224:	eb002d52 	bl	3481a774 <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
3480f228:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
3480f22c:	e5d4340b 	ldrb	r3, [r4, #1035]	; 0x40b
3480f230:	e1833402 	orr	r3, r3, r2, lsl #8
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480f234:	e1500003 	cmp	r0, r3
3480f238:	ea00000a 	b	3480f268 <xyzModem_get_hdr+0x220>
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480f23c:	e0840002 	add	r0, r4, r2
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
	{
	  cksum += xyz.pkt[i];
3480f240:	e5d00004 	ldrb	r0, [r0, #4]
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f244:	e2822001 	add	r2, r2, #1
	{
	  cksum += xyz.pkt[i];
3480f248:	e0833000 	add	r3, r3, r0
3480f24c:	e6ff3073 	uxth	r3, r3
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f250:	e1520001 	cmp	r2, r1
3480f254:	bafffff8 	blt	3480f23c <xyzModem_get_hdr+0x1f4>
	{
	  cksum += xyz.pkt[i];
	}
      if (xyz.crc1 != (cksum & 0xFF))
3480f258:	e59f2044 	ldr	r2, [pc, #68]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
3480f25c:	e20330ff 	and	r3, r3, #255	; 0xff
3480f260:	e5d2240a 	ldrb	r2, [r2, #1034]	; 0x40a
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480f264:	e1520003 	cmp	r2, r3
3480f268:	13e00006 	mvnne	r0, #6
3480f26c:	03a00000 	moveq	r0, #0
3480f270:	ea000002 	b	3480f280 <xyzModem_get_hdr+0x238>
	    case CAN:
	      xyz.total_CAN++;
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
		{
		  return xyzModem_cancel;
3480f274:	e3e00004 	mvn	r0, #4
3480f278:	ea000000 	b	3480f280 <xyzModem_get_hdr+0x238>
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
3480f27c:	e3e00002 	mvn	r0, #2
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
}
3480f280:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
3480f284:	e59f4018 	ldr	r4, [pc, #24]	; 3480f2a4 <xyzModem_get_hdr+0x25c>
3480f288:	e59f1028 	ldr	r1, [pc, #40]	; 3480f2b8 <xyzModem_get_hdr+0x270>
3480f28c:	e5943000 	ldr	r3, [r4]
3480f290:	e5d30000 	ldrb	r0, [r3]
3480f294:	ebffff4b 	bl	3480efc8 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
3480f298:	e3500000 	cmp	r0, #0
3480f29c:	0afffff6 	beq	3480f27c <xyzModem_get_hdr+0x234>
3480f2a0:	eaffffa2 	b	3480f130 <xyzModem_get_hdr+0xe8>
3480f2a4:	3482b530 	.word	0x3482b530
3480f2a8:	0003d090 	.word	0x0003d090
3480f2ac:	3482b939 	.word	0x3482b939
3480f2b0:	3482b93a 	.word	0x3482b93a
3480f2b4:	3482b93b 	.word	0x3482b93b
3480f2b8:	3482b938 	.word	0x3482b938

3480f2bc <CYGACC_COMM_IF_PUTC>:
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f2bc:	e1a00001 	mov	r0, r1
3480f2c0:	eaffe9ec 	b	34809a78 <putc>

3480f2c4 <parse_num>:
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
3480f2c4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
3480f2c8:	e5d04000 	ldrb	r4, [r0]
3480f2cc:	e1a0c000 	mov	ip, r0
3480f2d0:	e3540020 	cmp	r4, #32
3480f2d4:	e2800001 	add	r0, r0, #1
3480f2d8:	0afffffa 	beq	3480f2c8 <parse_num+0x4>
3480f2dc:	e3a05000 	mov	r5, #0
3480f2e0:	e3a0600a 	mov	r6, #10
3480f2e4:	e3a00001 	mov	r0, #1
3480f2e8:	ea000037 	b	3480f3cc <parse_num+0x108>
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480f2ec:	e3500000 	cmp	r0, #0
3480f2f0:	0a00000a 	beq	3480f320 <parse_num+0x5c>
3480f2f4:	e3540030 	cmp	r4, #48	; 0x30
3480f2f8:	1a000008 	bne	3480f320 <parse_num+0x5c>
3480f2fc:	e5dc0001 	ldrb	r0, [ip, #1]

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
3480f300:	e2404041 	sub	r4, r0, #65	; 0x41
3480f304:	e6ef4074 	uxtb	r4, r4
3480f308:	e3540019 	cmp	r4, #25
    {
      c = (c - 'A') + 'a';
3480f30c:	92800020 	addls	r0, r0, #32
3480f310:	96ef0070 	uxtbls	r0, r0

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480f314:	e3500078 	cmp	r0, #120	; 0x78
	{
	  radix = 16;
	  s += 2;
3480f318:	028cc002 	addeq	ip, ip, #2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
3480f31c:	03a06010 	moveq	r6, #16
	  s += 2;
	}
      first = false;
      c = *s++;
3480f320:	e4dc4001 	ldrb	r4, [ip], #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f324:	e2447030 	sub	r7, r4, #48	; 0x30
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f328:	e2440041 	sub	r0, r4, #65	; 0x41

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f32c:	e6efa077 	uxtb	sl, r7
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f330:	e6ef0070 	uxtb	r0, r0

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f334:	e35a0009 	cmp	sl, #9
3480f338:	83a0a000 	movhi	sl, #0
3480f33c:	93a0a001 	movls	sl, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f340:	e3500005 	cmp	r0, #5
3480f344:	83a00000 	movhi	r0, #0
3480f348:	93a00001 	movls	r0, #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f34c:	e190900a 	orrs	r9, r0, sl
3480f350:	1a000004 	bne	3480f368 <parse_num+0xa4>
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f354:	e2447061 	sub	r7, r4, #97	; 0x61
3480f358:	e6ef7077 	uxtb	r7, r7
3480f35c:	e3570005 	cmp	r7, #5
3480f360:	9a000003 	bls	3480f374 <parse_num+0xb0>
3480f364:	ea00000f 	b	3480f3a8 <parse_num+0xe4>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480f368:	e35a0000 	cmp	sl, #0
    {
      ret = (c - '0');
3480f36c:	11a00007 	movne	r0, r7
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480f370:	1a000009 	bne	3480f39c <parse_num+0xd8>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480f374:	e2447061 	sub	r7, r4, #97	; 0x61
3480f378:	e6ef7077 	uxtb	r7, r7
3480f37c:	e3570005 	cmp	r7, #5
    {
      ret = (c - 'a' + 0x0a);
3480f380:	92440057 	subls	r0, r4, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480f384:	9a000002 	bls	3480f394 <parse_num+0xd0>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
3480f388:	e3500000 	cmp	r0, #0
3480f38c:	0a000002 	beq	3480f39c <parse_num+0xd8>
    {
      ret = (c - 'A' + 0x0A);
3480f390:	e2440037 	sub	r0, r4, #55	; 0x37
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
3480f394:	e1500006 	cmp	r0, r6
3480f398:	aa000002 	bge	3480f3a8 <parse_num+0xe4>
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480f39c:	e0250695 	mla	r5, r5, r6, r0
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
3480f3a0:	e3a00000 	mov	r0, #0
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480f3a4:	ea000008 	b	3480f3cc <parse_num+0x108>
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480f3a8:	e3530000 	cmp	r3, #0
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
3480f3ac:	01a00003 	moveq	r0, r3
	  result = (result * radix) + digit;
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480f3b0:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
3480f3b4:	e4d30001 	ldrb	r0, [r3], #1
3480f3b8:	e3500000 	cmp	r0, #0
3480f3bc:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
3480f3c0:	e1540000 	cmp	r4, r0
3480f3c4:	1afffffa 	bne	3480f3b4 <parse_num+0xf0>
3480f3c8:	ea000002 	b	3480f3d8 <parse_num+0x114>
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
  while (*s)
3480f3cc:	e5dc4000 	ldrb	r4, [ip]
3480f3d0:	e3540000 	cmp	r4, #0
3480f3d4:	1affffc4 	bne	3480f2ec <parse_num+0x28>
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
  if (es != (char **) 0)
3480f3d8:	e3520000 	cmp	r2, #0
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
3480f3dc:	e5815000 	str	r5, [r1]
  if (es != (char **) 0)
    {
      *es = s;
    }
  return true;
3480f3e0:	13a00001 	movne	r0, #1
	}
    }
  *val = result;
  if (es != (char **) 0)
    {
      *es = s;
3480f3e4:	1582c000 	strne	ip, [r2]
    }
  return true;
3480f3e8:	03a00001 	moveq	r0, #1
}
3480f3ec:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3480f3f0 <xyzModem_stream_open>:
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480f3f0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
3480f3f4:	e59f412c 	ldr	r4, [pc, #300]	; 3480f528 <xyzModem_stream_open+0x138>
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
3480f3f8:	e3a05000 	mov	r5, #0
3480f3fc:	e28d3008 	add	r3, sp, #8
3480f400:	e5235004 	str	r5, [r3, #-4]!
  xyz.__chan = &dummy;
3480f404:	e5843000 	str	r3, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
3480f408:	e3a03001 	mov	r3, #1
3480f40c:	e5843428 	str	r3, [r4, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480f410:	e5903004 	ldr	r3, [r0, #4]
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f414:	e3a00043 	mov	r0, #67	; 0x43
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480f418:	e5843414 	str	r3, [r4, #1044]	; 0x414
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480f41c:	e1a0a001 	mov	sl, r1
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
3480f420:	e5845410 	str	r5, [r4, #1040]	; 0x410
  xyz.crc_mode = true;
  xyz.at_eof = false;
3480f424:	e584542c 	str	r5, [r4, #1068]	; 0x42c
  xyz.tx_ack = false;
3480f428:	e5845430 	str	r5, [r4, #1072]	; 0x430
  xyz.mode = info->mode;
  xyz.total_retries = 0;
3480f42c:	e5845418 	str	r5, [r4, #1048]	; 0x418
  xyz.total_SOH = 0;
3480f430:	e584541c 	str	r5, [r4, #1052]	; 0x41c
  xyz.total_STX = 0;
3480f434:	e5845420 	str	r5, [r4, #1056]	; 0x420
  xyz.total_CAN = 0;
3480f438:	e5845424 	str	r5, [r4, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
3480f43c:	e5845438 	str	r5, [r4, #1080]	; 0x438
  xyz.file_length = 0;
3480f440:	e5845434 	str	r5, [r4, #1076]	; 0x434
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f444:	ebffe98b 	bl	34809a78 <putc>
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480f448:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f44c:	e3530001 	cmp	r3, #1
3480f450:	13a0700a 	movne	r7, #10
3480f454:	13a06014 	movne	r6, #20
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480f458:	11a09005 	movne	r9, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
3480f45c:	05c4340c 	strbeq	r3, [r4, #1036]	; 0x40c
      return 0;
3480f460:	01a00005 	moveq	r0, r5
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480f464:	1a00002a 	bne	3480f514 <xyzModem_stream_open+0x124>
3480f468:	ea00002d 	b	3480f524 <xyzModem_stream_open+0x134>
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
3480f46c:	ebfffef5 	bl	3480f048 <xyzModem_get_hdr>
      if (stat == 0)
3480f470:	e2505000 	subs	r5, r0, #0
3480f474:	1a000014 	bne	3480f4cc <xyzModem_stream_open+0xdc>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
3480f478:	e59f30a8 	ldr	r3, [pc, #168]	; 3480f528 <xyzModem_stream_open+0x138>
3480f47c:	e5d32408 	ldrb	r2, [r3, #1032]	; 0x408
3480f480:	e3520000 	cmp	r2, #0
3480f484:	1a00000a 	bne	3480f4b4 <xyzModem_stream_open+0xc4>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
3480f488:	e5930404 	ldr	r0, [r3, #1028]	; 0x404
3480f48c:	e4d02001 	ldrb	r2, [r0], #1
3480f490:	e3520000 	cmp	r2, #0
3480f494:	e5830404 	str	r0, [r3, #1028]	; 0x404
3480f498:	1afffffa 	bne	3480f488 <xyzModem_stream_open+0x98>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
3480f49c:	e59f3088 	ldr	r3, [pc, #136]	; 3480f52c <xyzModem_stream_open+0x13c>
3480f4a0:	e59f1088 	ldr	r1, [pc, #136]	; 3480f530 <xyzModem_stream_open+0x140>
3480f4a4:	ebffff86 	bl	3480f2c4 <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
3480f4a8:	e59f3078 	ldr	r3, [pc, #120]	; 3480f528 <xyzModem_stream_open+0x138>
3480f4ac:	e3a02001 	mov	r2, #1
3480f4b0:	e5832430 	str	r2, [r3, #1072]	; 0x430
	    }
	  xyz.next_blk = 1;
3480f4b4:	e59f306c 	ldr	r3, [pc, #108]	; 3480f528 <xyzModem_stream_open+0x138>
3480f4b8:	e3a02001 	mov	r2, #1
	  xyz.len = 0;
3480f4bc:	e3a00000 	mov	r0, #0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
3480f4c0:	e5c3240c 	strb	r2, [r3, #1036]	; 0x40c
	  xyz.len = 0;
3480f4c4:	e5830410 	str	r0, [r3, #1040]	; 0x410
	  return 0;
3480f4c8:	ea000015 	b	3480f524 <xyzModem_stream_open+0x134>
	}
      else if (stat == xyzModem_timeout)
3480f4cc:	e3750003 	cmn	r5, #3
3480f4d0:	1a00000d 	bne	3480f50c <xyzModem_stream_open+0x11c>
	{
	  if (--crc_retries <= 0)
3480f4d4:	e2477001 	sub	r7, r7, #1
3480f4d8:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f4dc:	e59f0050 	ldr	r0, [pc, #80]	; 3480f534 <xyzModem_stream_open+0x144>
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480f4e0:	d5849428 	strle	r9, [r4, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f4e4:	eb0034fa 	bl	3481c8d4 <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f4e8:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f4ec:	e3500000 	cmp	r0, #0
3480f4f0:	03a00015 	moveq	r0, #21
3480f4f4:	13a00043 	movne	r0, #67	; 0x43
3480f4f8:	ebffe95e 	bl	34809a78 <putc>
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	  xyz.total_retries++;
3480f4fc:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f500:	e2833001 	add	r3, r3, #1
3480f504:	e5843418 	str	r3, [r4, #1048]	; 0x418
3480f508:	ea000001 	b	3480f514 <xyzModem_stream_open+0x124>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
3480f50c:	e3750005 	cmn	r5, #5
3480f510:	0a000001 	beq	3480f51c <xyzModem_stream_open+0x12c>
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
    }

  while (retries-- > 0)
3480f514:	e2566001 	subs	r6, r6, #1
3480f518:	2affffd3 	bcs	3480f46c <xyzModem_stream_open+0x7c>
      if (stat == xyzModem_cancel)
	{
	  break;
	}
    }
  *err = stat;
3480f51c:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
3480f520:	e3e00000 	mvn	r0, #0
}
3480f524:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480f528:	3482b530 	.word	0x3482b530
3480f52c:	348263ac 	.word	0x348263ac
3480f530:	3482b964 	.word	0x3482b964
3480f534:	0007a120 	.word	0x0007a120

3480f538 <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480f538:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f53c:	e59f4240 	ldr	r4, [pc, #576]	; 3480f784 <xyzModem_stream_read+0x24c>
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480f540:	e1a09000 	mov	r9, r0
3480f544:	e1a0a001 	mov	sl, r1
3480f548:	e58d2004 	str	r2, [sp, #4]
  int stat, total, len;
  int retries;

  total = 0;
3480f54c:	e3a0b000 	mov	fp, #0
  stat = xyzModem_cancel;
3480f550:	e3e05004 	mvn	r5, #4
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f554:	e1a07004 	mov	r7, r4
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f558:	ea00007f 	b	3480f75c <xyzModem_stream_read+0x224>
    {
      if (xyz.len == 0)
3480f55c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f560:	e3530000 	cmp	r3, #0
3480f564:	03a06014 	moveq	r6, #20
3480f568:	0a00005d 	beq	3480f6e4 <xyzModem_stream_read+0x1ac>
3480f56c:	ea000066 	b	3480f70c <xyzModem_stream_read+0x1d4>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
3480f570:	ebfffeb4 	bl	3480f048 <xyzModem_get_hdr>
	      if (stat == 0)
3480f574:	e2505000 	subs	r5, r0, #0
3480f578:	1a000039 	bne	3480f664 <xyzModem_stream_read+0x12c>
		{
		  if (xyz.blk == xyz.next_blk)
3480f57c:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480f580:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
3480f584:	e1530002 	cmp	r3, r2
3480f588:	1a00002d 	bne	3480f644 <xyzModem_stream_read+0x10c>
		    {
		      xyz.tx_ack = true;
3480f58c:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f590:	e0833002 	add	r3, r3, r2
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
3480f594:	e5872430 	str	r2, [r7, #1072]	; 0x430
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480f598:	e5972414 	ldr	r2, [r7, #1044]	; 0x414
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f59c:	e5c7340c 	strb	r3, [r7, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480f5a0:	e3520001 	cmp	r2, #1
3480f5a4:	0a000002 	beq	3480f5b4 <xyzModem_stream_read+0x7c>
3480f5a8:	e5973434 	ldr	r3, [r7, #1076]	; 0x434
3480f5ac:	e3530000 	cmp	r3, #0
3480f5b0:	1a000017 	bne	3480f614 <xyzModem_stream_read+0xdc>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480f5b4:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480f5b8:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f5bc:	e0813003 	add	r3, r1, r3
3480f5c0:	e5530001 	ldrb	r0, [r3, #-1]
3480f5c4:	e350001a 	cmp	r0, #26
3480f5c8:	1a00000f 	bne	3480f60c <xyzModem_stream_read+0xd4>
3480f5cc:	e5530002 	ldrb	r0, [r3, #-2]
3480f5d0:	e350001a 	cmp	r0, #26
3480f5d4:	1a00000c 	bne	3480f60c <xyzModem_stream_read+0xd4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
3480f5d8:	e5533003 	ldrb	r3, [r3, #-3]
3480f5dc:	e353001a 	cmp	r3, #26
3480f5e0:	1a000009 	bne	3480f60c <xyzModem_stream_read+0xd4>
3480f5e4:	ea000001 	b	3480f5f0 <xyzModem_stream_read+0xb8>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
3480f5e8:	e2433001 	sub	r3, r3, #1
3480f5ec:	e5843410 	str	r3, [r4, #1040]	; 0x410
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
3480f5f0:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f5f4:	e3530000 	cmp	r3, #0
3480f5f8:	0a000003 	beq	3480f60c <xyzModem_stream_read+0xd4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
3480f5fc:	e0810003 	add	r0, r1, r3
3480f600:	e5500001 	ldrb	r0, [r0, #-1]
3480f604:	e350001a 	cmp	r0, #26
3480f608:	0afffff6 	beq	3480f5e8 <xyzModem_stream_read+0xb0>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480f60c:	e3520001 	cmp	r2, #1
3480f610:	0a00003d 	beq	3480f70c <xyzModem_stream_read+0x1d4>
3480f614:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480f618:	e3520000 	cmp	r2, #0
3480f61c:	0a00003a 	beq	3480f70c <xyzModem_stream_read+0x1d4>
			{
			  xyz.read_length += xyz.len;
3480f620:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480f624:	e5943438 	ldr	r3, [r4, #1080]	; 0x438
3480f628:	e0813003 	add	r3, r1, r3
			  if (xyz.read_length > xyz.file_length)
3480f62c:	e1530002 	cmp	r3, r2
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480f630:	80812002 	addhi	r2, r1, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
3480f634:	e5843438 	str	r3, [r4, #1080]	; 0x438
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480f638:	80633002 	rsbhi	r3, r3, r2
3480f63c:	85843410 	strhi	r3, [r4, #1040]	; 0x410
3480f640:	ea000031 	b	3480f70c <xyzModem_stream_read+0x1d4>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f644:	e2422001 	sub	r2, r2, #1
3480f648:	e20220ff 	and	r2, r2, #255	; 0xff
3480f64c:	e1530002 	cmp	r3, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
3480f650:	13e05007 	mvnne	r5, #7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f654:	1a00001a 	bne	3480f6c4 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f658:	e3a00006 	mov	r0, #6
3480f65c:	ebffe905 	bl	34809a78 <putc>
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
3480f660:	ea00001f 	b	3480f6e4 <xyzModem_stream_read+0x1ac>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
3480f664:	e3750005 	cmn	r5, #5
3480f668:	0a000021 	beq	3480f6f4 <xyzModem_stream_read+0x1bc>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
3480f66c:	e3750004 	cmn	r5, #4
3480f670:	1a000013 	bne	3480f6c4 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f674:	e3a00006 	mov	r0, #6
3480f678:	ebffe8fe 	bl	34809a78 <putc>
		}
	      if (stat == xyzModem_eof)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
3480f67c:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f680:	e3530002 	cmp	r3, #2
3480f684:	1a00000b 	bne	3480f6b8 <xyzModem_stream_read+0x180>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
3480f688:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f68c:	e3500000 	cmp	r0, #0
3480f690:	03a00015 	moveq	r0, #21
3480f694:	13a00043 	movne	r0, #67	; 0x43
3480f698:	ebffe8f6 	bl	34809a78 <putc>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
3480f69c:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f6a0:	e2833001 	add	r3, r3, #1
3480f6a4:	e5843418 	str	r3, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
3480f6a8:	ebfffe66 	bl	3480f048 <xyzModem_get_hdr>
3480f6ac:	e1a05000 	mov	r5, r0
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f6b0:	e3a00006 	mov	r0, #6
3480f6b4:	ebffe8ef 	bl	34809a78 <putc>
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
3480f6b8:	e3a03001 	mov	r3, #1
3480f6bc:	e584342c 	str	r3, [r4, #1068]	; 0x42c
		  break;
3480f6c0:	ea000009 	b	3480f6ec <xyzModem_stream_read+0x1b4>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f6c4:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f6c8:	e3500000 	cmp	r0, #0
3480f6cc:	03a00015 	moveq	r0, #21
3480f6d0:	13a00043 	movne	r0, #67	; 0x43
3480f6d4:	ebffe8e7 	bl	34809a78 <putc>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
3480f6d8:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f6dc:	e2833001 	add	r3, r3, #1
3480f6e0:	e5843418 	str	r3, [r4, #1048]	; 0x418
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
3480f6e4:	e2566001 	subs	r6, r6, #1
3480f6e8:	2affffa0 	bcs	3480f570 <xyzModem_stream_read+0x38>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
3480f6ec:	e3550000 	cmp	r5, #0
3480f6f0:	aa000005 	bge	3480f70c <xyzModem_stream_read+0x1d4>
	    {
	      *err = stat;
3480f6f4:	e59d2004 	ldr	r2, [sp, #4]
	      xyz.len = -1;
3480f6f8:	e59f3084 	ldr	r3, [pc, #132]	; 3480f784 <xyzModem_stream_read+0x24c>
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
3480f6fc:	e5825000 	str	r5, [r2]
	      xyz.len = -1;
3480f700:	e3e02000 	mvn	r2, #0
3480f704:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
3480f708:	ea00001b 	b	3480f77c <xyzModem_stream_read+0x244>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
3480f70c:	e594342c 	ldr	r3, [r4, #1068]	; 0x42c
3480f710:	e3530000 	cmp	r3, #0
3480f714:	1a000010 	bne	3480f75c <xyzModem_stream_read+0x224>
	{
	  len = xyz.len;
3480f718:	e5946410 	ldr	r6, [r4, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480f71c:	e1a00009 	mov	r0, r9
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
	{
	  len = xyz.len;
3480f720:	e15a0006 	cmp	sl, r6
3480f724:	b1a0600a 	movlt	r6, sl
3480f728:	a1a06006 	movge	r6, r6
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480f72c:	e1a02006 	mov	r2, r6
3480f730:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480f734:	eb0033db 	bl	3481c6a8 <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480f738:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
3480f73c:	e066a00a 	rsb	sl, r6, sl
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480f740:	e0663003 	rsb	r3, r6, r3
3480f744:	e5843410 	str	r3, [r4, #1040]	; 0x410
	  xyz.bufp += len;
3480f748:	e5943404 	ldr	r3, [r4, #1028]	; 0x404
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
3480f74c:	e0899006 	add	r9, r9, r6
	  total += len;
3480f750:	e08bb006 	add	fp, fp, r6
	  xyz.len -= len;
	  xyz.bufp += len;
3480f754:	e0836006 	add	r6, r3, r6
3480f758:	e5846404 	str	r6, [r4, #1028]	; 0x404
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f75c:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
3480f760:	e35a0000 	cmp	sl, #0
3480f764:	d3a03000 	movle	r3, #0
3480f768:	c3a03001 	movgt	r3, #1
3480f76c:	e3520000 	cmp	r2, #0
3480f770:	13a03000 	movne	r3, #0
3480f774:	e3530000 	cmp	r3, #0
3480f778:	1affff77 	bne	3480f55c <xyzModem_stream_read+0x24>
	  xyz.len -= len;
	  xyz.bufp += len;
	}
    }
  return total;
}
3480f77c:	e1a0000b 	mov	r0, fp
3480f780:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480f784:	3482b530 	.word	0x3482b530

3480f788 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
3480f788:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
3480f78c:	e59f3034 	ldr	r3, [pc, #52]	; 3480f7c8 <xyzModem_stream_close+0x40>

void
xyzModem_stream_close (int *err)
{
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
3480f790:	e59f1034 	ldr	r1, [pc, #52]	; 3480f7cc <xyzModem_stream_close+0x44>
3480f794:	e5932424 	ldr	r2, [r3, #1060]	; 0x424
3480f798:	e593c428 	ldr	ip, [r3, #1064]	; 0x428
3480f79c:	e58d2000 	str	r2, [sp]
3480f7a0:	e5932418 	ldr	r2, [r3, #1048]	; 0x418
3480f7a4:	e35c0000 	cmp	ip, #0
3480f7a8:	e58d2004 	str	r2, [sp, #4]
3480f7ac:	e59f201c 	ldr	r2, [pc, #28]	; 3480f7d0 <xyzModem_stream_close+0x48>
3480f7b0:	e59f001c 	ldr	r0, [pc, #28]	; 3480f7d4 <xyzModem_stream_close+0x4c>
3480f7b4:	11a01002 	movne	r1, r2
3480f7b8:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
3480f7bc:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
3480f7c0:	ebffe8c0 	bl	34809ac8 <printf>
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
3480f7c4:	e8bd800e 	pop	{r1, r2, r3, pc}
3480f7c8:	3482b530 	.word	0x3482b530
3480f7cc:	348268e6 	.word	0x348268e6
3480f7d0:	3482609a 	.word	0x3482609a
3480f7d4:	348268ec 	.word	0x348268ec

3480f7d8 <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
3480f7d8:	e3500000 	cmp	r0, #0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
3480f7dc:	e92d4010 	push	{r4, lr}
3480f7e0:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
3480f7e4:	0a000018 	beq	3480f84c <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
3480f7e8:	e59f4074 	ldr	r4, [pc, #116]	; 3480f864 <xyzModem_stream_terminate+0x8c>
3480f7ec:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f7f0:	e2433001 	sub	r3, r3, #1
3480f7f4:	e3530001 	cmp	r3, #1
3480f7f8:	88bd8010 	pophi	{r4, pc}
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f7fc:	e3a00018 	mov	r0, #24
3480f800:	ebffe89c 	bl	34809a78 <putc>
3480f804:	e3a00018 	mov	r0, #24
3480f808:	ebffe89a 	bl	34809a78 <putc>
3480f80c:	e3a00018 	mov	r0, #24
3480f810:	ebffe898 	bl	34809a78 <putc>
3480f814:	e3a00018 	mov	r0, #24
3480f818:	ebffe896 	bl	34809a78 <putc>
3480f81c:	e3a00008 	mov	r0, #8
3480f820:	ebffe894 	bl	34809a78 <putc>
3480f824:	e3a00008 	mov	r0, #8
3480f828:	ebffe892 	bl	34809a78 <putc>
3480f82c:	e3a00008 	mov	r0, #8
3480f830:	ebffe890 	bl	34809a78 <putc>
3480f834:	e3a00008 	mov	r0, #8
3480f838:	ebffe88e 	bl	34809a78 <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
3480f83c:	ebfffdf6 	bl	3480f01c <xyzModem_flush>
	  xyz.at_eof = true;
3480f840:	e3a03001 	mov	r3, #1
3480f844:	e584342c 	str	r3, [r4, #1068]	; 0x42c
3480f848:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
3480f84c:	e12fff34 	blx	r4
3480f850:	e3500000 	cmp	r0, #0
3480f854:	aafffffc 	bge	3480f84c <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f858:	e59f0008 	ldr	r0, [pc, #8]	; 3480f868 <xyzModem_stream_terminate+0x90>
    }
}
3480f85c:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f860:	ea00341b 	b	3481c8d4 <udelay>
3480f864:	3482b530 	.word	0x3482b530
3480f868:	0003d090 	.word	0x0003d090

3480f86c <xyzModem_error>:
    }
}

char *
xyzModem_error (int err)
{
3480f86c:	e2800008 	add	r0, r0, #8
3480f870:	e3500007 	cmp	r0, #7
3480f874:	959f3008 	ldrls	r3, [pc, #8]	; 3480f884 <xyzModem_error+0x18>
3480f878:	859f0008 	ldrhi	r0, [pc, #8]	; 3480f888 <xyzModem_error+0x1c>
3480f87c:	97930100 	ldrls	r0, [r3, r0, lsl #2]
      break;
    default:
      return "Unknown error";
      break;
    }
}
3480f880:	e12fff1e 	bx	lr
3480f884:	34821364 	.word	0x34821364
3480f888:	3482692d 	.word	0x3482692d

3480f88c <get_dev>:
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480f88c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480f890:	e2505000 	subs	r5, r0, #0
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480f894:	e1a07001 	mov	r7, r1
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480f898:	159f4054 	ldrne	r4, [pc, #84]	; 3480f8f4 <get_dev+0x68>
3480f89c:	0a000012 	beq	3480f8ec <get_dev+0x60>
3480f8a0:	ea00000c 	b	3480f8d8 <get_dev+0x4c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f8a4:	e1a0000a 	mov	r0, sl
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
		name = drvr->name;
		reloc_get_dev = drvr->get_dev;
3480f8a8:	e5146004 	ldr	r6, [r4, #-4]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f8ac:	eb0032b9 	bl	3481c398 <strlen>
3480f8b0:	e1a0100a 	mov	r1, sl
3480f8b4:	e1a02000 	mov	r2, r0
3480f8b8:	e1a00005 	mov	r0, r5
3480f8bc:	eb00328d 	bl	3481c2f8 <strncmp>
3480f8c0:	e3500000 	cmp	r0, #0
3480f8c4:	e2844008 	add	r4, r4, #8
3480f8c8:	1a000002 	bne	3480f8d8 <get_dev+0x4c>
			return reloc_get_dev(dev);
3480f8cc:	e1a00007 	mov	r0, r7
3480f8d0:	e12fff36 	blx	r6
3480f8d4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
3480f8d8:	e514a008 	ldr	sl, [r4, #-8]
3480f8dc:	e35a0000 	cmp	sl, #0
3480f8e0:	1affffef 	bne	3480f8a4 <get_dev+0x18>
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
3480f8e4:	e1a0000a 	mov	r0, sl
3480f8e8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
		return NULL;
3480f8ec:	e1a00005 	mov	r0, r5
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
}
3480f8f0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480f8f4:	3482138c 	.word	0x3482138c

3480f8f8 <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f8f8:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f8fc:	e5d0300b 	ldrb	r3, [r0, #11]
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f900:	e1a04000 	mov	r4, r0
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f904:	e35300ff 	cmp	r3, #255	; 0xff
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f908:	e24dd014 	sub	sp, sp, #20
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
		puts ("not available\n");
3480f90c:	059f01b0 	ldreq	r0, [pc, #432]	; 3480fac4 <dev_print+0x1cc>

void dev_print (block_dev_desc_t *dev_desc)
{
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f910:	0a000068 	beq	3480fab8 <dev_print+0x1c0>
		puts ("not available\n");
		return;
	}

	switch (dev_desc->if_type) {
3480f914:	e5941000 	ldr	r1, [r4]
3480f918:	e3510008 	cmp	r1, #8
3480f91c:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f920:	ea00001e 	b	3480f9a0 <dev_print+0xa8>
3480f924:	3480f998 	.word	0x3480f998
3480f928:	3480f970 	.word	0x3480f970
3480f92c:	3480f948 	.word	0x3480f948
3480f930:	3480f970 	.word	0x3480f970
3480f934:	3480f978 	.word	0x3480f978
3480f938:	3480f990 	.word	0x3480f990
3480f93c:	3480f978 	.word	0x3480f978
3480f940:	3480f978 	.word	0x3480f978
3480f944:	3480f970 	.word	0x3480f970
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480f948:	e2843041 	add	r3, r4, #65	; 0x41
3480f94c:	e5d41009 	ldrb	r1, [r4, #9]
3480f950:	e5d4200a 	ldrb	r2, [r4, #10]
3480f954:	e58d3000 	str	r3, [sp]
3480f958:	e2843056 	add	r3, r4, #86	; 0x56
3480f95c:	e58d3004 	str	r3, [sp, #4]
3480f960:	e59f0160 	ldr	r0, [pc, #352]	; 3480fac8 <dev_print+0x1d0>
3480f964:	e2843018 	add	r3, r4, #24
3480f968:	ebffe856 	bl	34809ac8 <printf>
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
		break;
3480f96c:	ea00000f 	b	3480f9b0 <dev_print+0xb8>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
3480f970:	e59f0154 	ldr	r0, [pc, #340]	; 3480facc <dev_print+0x1d4>
3480f974:	ea000000 	b	3480f97c <dev_print+0x84>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
3480f978:	e59f0150 	ldr	r0, [pc, #336]	; 3480fad0 <dev_print+0x1d8>
3480f97c:	e2841018 	add	r1, r4, #24
3480f980:	e2842056 	add	r2, r4, #86	; 0x56
3480f984:	e2843041 	add	r3, r4, #65	; 0x41
3480f988:	ebffe84e 	bl	34809ac8 <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
3480f98c:	ea000007 	b	3480f9b0 <dev_print+0xb8>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
3480f990:	e59f013c 	ldr	r0, [pc, #316]	; 3480fad4 <dev_print+0x1dc>
3480f994:	ea000047 	b	3480fab8 <dev_print+0x1c0>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
3480f998:	e59f0138 	ldr	r0, [pc, #312]	; 3480fad8 <dev_print+0x1e0>
3480f99c:	ea000045 	b	3480fab8 <dev_print+0x1c0>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f9a0:	e59f0134 	ldr	r0, [pc, #308]	; 3480fadc <dev_print+0x1e4>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480f9a4:	e28dd014 	add	sp, sp, #20
3480f9a8:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f9ac:	eaffe845 	b	34809ac8 <printf>
		return;
	}
	puts ("            Type: ");
3480f9b0:	e59f0128 	ldr	r0, [pc, #296]	; 3480fae0 <dev_print+0x1e8>
3480f9b4:	ebffe839 	bl	34809aa0 <puts>
	if (dev_desc->removable)
3480f9b8:	e5d4300c 	ldrb	r3, [r4, #12]
3480f9bc:	e3530000 	cmp	r3, #0
3480f9c0:	0a000001 	beq	3480f9cc <dev_print+0xd4>
		puts ("Removable ");
3480f9c4:	e59f0118 	ldr	r0, [pc, #280]	; 3480fae4 <dev_print+0x1ec>
3480f9c8:	ebffe834 	bl	34809aa0 <puts>
	switch (dev_desc->type & 0x1F) {
3480f9cc:	e5d4100b 	ldrb	r1, [r4, #11]
3480f9d0:	e201101f 	and	r1, r1, #31
3480f9d4:	e3510007 	cmp	r1, #7
3480f9d8:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f9dc:	ea000010 	b	3480fa24 <dev_print+0x12c>
3480f9e0:	3480fa00 	.word	0x3480fa00
3480f9e4:	3480fa1c 	.word	0x3480fa1c
3480f9e8:	3480fa24 	.word	0x3480fa24
3480f9ec:	3480fa24 	.word	0x3480fa24
3480f9f0:	3480fa24 	.word	0x3480fa24
3480f9f4:	3480fa08 	.word	0x3480fa08
3480f9f8:	3480fa24 	.word	0x3480fa24
3480f9fc:	3480fa14 	.word	0x3480fa14
	case DEV_TYPE_HARDDISK:
		puts ("Hard Disk");
3480fa00:	e59f00e0 	ldr	r0, [pc, #224]	; 3480fae8 <dev_print+0x1f0>
3480fa04:	ea000000 	b	3480fa0c <dev_print+0x114>
		break;
	case DEV_TYPE_CDROM:
		puts ("CD ROM");
3480fa08:	e59f00dc 	ldr	r0, [pc, #220]	; 3480faec <dev_print+0x1f4>
3480fa0c:	ebffe823 	bl	34809aa0 <puts>
		break;
3480fa10:	ea000005 	b	3480fa2c <dev_print+0x134>
	case DEV_TYPE_OPDISK:
		puts ("Optical Device");
3480fa14:	e59f00d4 	ldr	r0, [pc, #212]	; 3480faf0 <dev_print+0x1f8>
3480fa18:	eafffffb 	b	3480fa0c <dev_print+0x114>
		break;
	case DEV_TYPE_TAPE:
		puts ("Tape");
3480fa1c:	e59f00d0 	ldr	r0, [pc, #208]	; 3480faf4 <dev_print+0x1fc>
3480fa20:	eafffff9 	b	3480fa0c <dev_print+0x114>
		break;
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
3480fa24:	e59f00cc 	ldr	r0, [pc, #204]	; 3480faf8 <dev_print+0x200>
3480fa28:	ebffe826 	bl	34809ac8 <printf>
		break;
	}
	puts ("\n");
3480fa2c:	e59f00c8 	ldr	r0, [pc, #200]	; 3480fafc <dev_print+0x204>
3480fa30:	ebffe81a 	bl	34809aa0 <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480fa34:	e5947010 	ldr	r7, [r4, #16]
3480fa38:	e5946014 	ldr	r6, [r4, #20]
3480fa3c:	e0130697 	muls	r3, r7, r6
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480fa40:	059f00b8 	ldreq	r0, [pc, #184]	; 3480fb00 <dev_print+0x208>
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
		break;
	}
	puts ("\n");
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480fa44:	0a00001b 	beq	3480fab8 <dev_print+0x1c0>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
3480fa48:	e1a024a6 	lsr	r2, r6, #9
3480fa4c:	e0020297 	mul	r2, r7, r2
static lba512_t lba512_muldiv (lba512_t block_count, lba512_t mul_by, lba512_t div_by)
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
3480fa50:	e1a035a2 	lsr	r3, r2, #11
	bc_rem  = block_count - div_by * bc_quot;
3480fa54:	e1a05583 	lsl	r5, r3, #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480fa58:	e3a0400a 	mov	r4, #10
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
	bc_rem  = block_count - div_by * bc_quot;
3480fa5c:	e0655002 	rsb	r5, r5, r2
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480fa60:	e0030394 	mul	r3, r4, r3
3480fa64:	e0050594 	mul	r5, r4, r5
3480fa68:	e08355a5 	add	r5, r3, r5, lsr #11

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480fa6c:	e1a01004 	mov	r1, r4
3480fa70:	e1a00005 	mov	r0, r5
3480fa74:	eb004053 	bl	3481fbc8 <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
3480fa78:	e1a0a435 	lsr	sl, r5, r4

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480fa7c:	e1a09000 	mov	r9, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480fa80:	e1a01004 	mov	r1, r4
3480fa84:	e1a0000a 	mov	r0, sl
3480fa88:	eb00404e 	bl	3481fbc8 <__udivsi3>
		gb_rem	= gb - (10 * gb_quot);
3480fa8c:	e06aa094 	mls	sl, r4, r0, sl

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480fa90:	e1a03000 	mov	r3, r0
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480fa94:	e1a01009 	mov	r1, r9
3480fa98:	e0625994 	mls	r2, r4, r9, r5
3480fa9c:	e59f0060 	ldr	r0, [pc, #96]	; 3480fb04 <dev_print+0x20c>
3480faa0:	e58da000 	str	sl, [sp]
3480faa4:	e58d7004 	str	r7, [sp, #4]
3480faa8:	e58d6008 	str	r6, [sp, #8]
3480faac:	ebffe805 	bl	34809ac8 <printf>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480fab0:	e28dd014 	add	sp, sp, #20
3480fab4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480fab8:	e28dd014 	add	sp, sp, #20
3480fabc:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480fac0:	eaffe7f6 	b	34809aa0 <puts>
3480fac4:	34826b03 	.word	0x34826b03
3480fac8:	348269c5 	.word	0x348269c5
3480facc:	348269eb 	.word	0x348269eb
3480fad0:	34826a08 	.word	0x34826a08
3480fad4:	34826a25 	.word	0x34826a25
3480fad8:	34826a36 	.word	0x34826a36
3480fadc:	34826a4b 	.word	0x34826a4b
3480fae0:	34826a66 	.word	0x34826a66
3480fae4:	34826a79 	.word	0x34826a79
3480fae8:	34826a84 	.word	0x34826a84
3480faec:	34826a8e 	.word	0x34826a8e
3480faf0:	34826a95 	.word	0x34826a95
3480faf4:	34826aa4 	.word	0x34826aa4
3480faf8:	34826aa9 	.word	0x34826aa9
3480fafc:	34826197 	.word	0x34826197
3480fb00:	34826aed 	.word	0x34826aed
3480fb04:	34826ab2 	.word	0x34826ab2

3480fb08 <init_part>:
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION) || \
    defined(CONFIG_EFI_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
3480fb08:	e92d4010 	push	{r4, lr}
3480fb0c:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
3480fb10:	eb000259 	bl	3481047c <test_part_dos>
3480fb14:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
3480fb18:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
3480fb1c:	13a03000 	movne	r3, #0
3480fb20:	e5c43008 	strb	r3, [r4, #8]
3480fb24:	e8bd8010 	pop	{r4, pc}

3480fb28 <print_part>:
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480fb28:	e92d4010 	push	{r4, lr}

		switch (dev_desc->part_type) {
3480fb2c:	e5d03008 	ldrb	r3, [r0, #8]
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480fb30:	e1a04000 	mov	r4, r0

		switch (dev_desc->part_type) {
3480fb34:	e3530002 	cmp	r3, #2
3480fb38:	1a000025 	bne	3480fbd4 <print_part+0xac>
}


static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
	puts ("\nPartition Map for ");
3480fb3c:	e59f009c 	ldr	r0, [pc, #156]	; 3480fbe0 <print_part+0xb8>
3480fb40:	ebffe7d6 	bl	34809aa0 <puts>
	switch (dev_desc->if_type) {
3480fb44:	e5943000 	ldr	r3, [r4]
3480fb48:	e2433001 	sub	r3, r3, #1
3480fb4c:	e3530007 	cmp	r3, #7
3480fb50:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480fb54:	ea000015 	b	3480fbb0 <print_part+0x88>
3480fb58:	3480fb78 	.word	0x3480fb78
3480fb5c:	3480fb88 	.word	0x3480fb88
3480fb60:	3480fb90 	.word	0x3480fb90
3480fb64:	3480fb98 	.word	0x3480fb98
3480fb68:	3480fba0 	.word	0x3480fba0
3480fb6c:	3480fba8 	.word	0x3480fba8
3480fb70:	3480fbb0 	.word	0x3480fbb0
3480fb74:	3480fb80 	.word	0x3480fb80
	case IF_TYPE_IDE:
		puts ("IDE");
3480fb78:	e59f0064 	ldr	r0, [pc, #100]	; 3480fbe4 <print_part+0xbc>
3480fb7c:	ea00000c 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_SATA:
		puts ("SATA");
3480fb80:	e59f0060 	ldr	r0, [pc, #96]	; 3480fbe8 <print_part+0xc0>
3480fb84:	ea00000a 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_SCSI:
		puts ("SCSI");
3480fb88:	e59f005c 	ldr	r0, [pc, #92]	; 3480fbec <print_part+0xc4>
3480fb8c:	ea000008 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_ATAPI:
		puts ("ATAPI");
3480fb90:	e59f0058 	ldr	r0, [pc, #88]	; 3480fbf0 <print_part+0xc8>
3480fb94:	ea000006 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_USB:
		puts ("USB");
3480fb98:	e59f0054 	ldr	r0, [pc, #84]	; 3480fbf4 <print_part+0xcc>
3480fb9c:	ea000004 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_DOC:
		puts ("DOC");
3480fba0:	e59f0050 	ldr	r0, [pc, #80]	; 3480fbf8 <print_part+0xd0>
3480fba4:	ea000002 	b	3480fbb4 <print_part+0x8c>
		break;
	case IF_TYPE_MMC:
		puts ("MMC");
3480fba8:	e59f004c 	ldr	r0, [pc, #76]	; 3480fbfc <print_part+0xd4>
3480fbac:	ea000000 	b	3480fbb4 <print_part+0x8c>
		break;
	default:
		puts ("UNKNOWN");
3480fbb0:	e59f0048 	ldr	r0, [pc, #72]	; 3480fc00 <print_part+0xd8>
3480fbb4:	ebffe7b9 	bl	34809aa0 <puts>
		break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
3480fbb8:	e5941004 	ldr	r1, [r4, #4]
3480fbbc:	e59f2040 	ldr	r2, [pc, #64]	; 3480fc04 <print_part+0xdc>
3480fbc0:	e59f0040 	ldr	r0, [pc, #64]	; 3480fc08 <print_part+0xe0>
3480fbc4:	ebffe7bf 	bl	34809ac8 <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480fbc8:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
3480fbcc:	e8bd4010 	pop	{r4, lr}
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480fbd0:	ea000241 	b	348104dc <print_part_dos>
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480fbd4:	e59f0030 	ldr	r0, [pc, #48]	; 3480fc0c <print_part+0xe4>
}
3480fbd8:	e8bd4010 	pop	{r4, lr}
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480fbdc:	eaffe7af 	b	34809aa0 <puts>
3480fbe0:	34826b12 	.word	0x34826b12
3480fbe4:	34826b26 	.word	0x34826b26
3480fbe8:	34826b2a 	.word	0x34826b2a
3480fbec:	34826b2f 	.word	0x34826b2f
3480fbf0:	34826b34 	.word	0x34826b34
3480fbf4:	34826b3a 	.word	0x34826b3a
3480fbf8:	34826b3e 	.word	0x34826b3e
3480fbfc:	348241e2 	.word	0x348241e2
3480fc00:	34826b42 	.word	0x34826b42
3480fc04:	34826b70 	.word	0x34826b70
3480fc08:	34826b4a 	.word	0x34826b4a
3480fc0c:	34826b74 	.word	0x34826b74

3480fc10 <get_partition_info>:

#endif

int get_partition_info(block_dev_desc_t *dev_desc, int part
					, disk_partition_t *info)
{
3480fc10:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
3480fc14:	e5d03008 	ldrb	r3, [r0, #8]
3480fc18:	e3530002 	cmp	r3, #2
3480fc1c:	1a000003 	bne	3480fc30 <get_partition_info+0x20>
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
3480fc20:	eb000238 	bl	34810508 <get_partition_info_dos>
3480fc24:	e3500000 	cmp	r0, #0
	default:
		break;
	}
#endif

	return -1;
3480fc28:	13e00000 	mvnne	r0, #0
3480fc2c:	e8bd8008 	pop	{r3, pc}
3480fc30:	e3e00000 	mvn	r0, #0
}
3480fc34:	e8bd8008 	pop	{r3, pc}

3480fc38 <get_device>:

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480fc38:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480fc3c:	e1a05000 	mov	r5, r0
3480fc40:	e1a04001 	mov	r4, r1
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480fc44:	e1a00001 	mov	r0, r1
	return -1;
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480fc48:	e1a06002 	mov	r6, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480fc4c:	e28d1004 	add	r1, sp, #4
3480fc50:	e3a02010 	mov	r2, #16
3480fc54:	eb003562 	bl	3481d1e4 <simple_strtoul>
	if (*ep) {
3480fc58:	e59d3004 	ldr	r3, [sp, #4]
3480fc5c:	e5d33000 	ldrb	r3, [r3]
3480fc60:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
3480fc64:	159f0044 	ldrne	r0, [pc, #68]	; 3480fcb0 <get_device+0x78>
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
	if (*ep) {
3480fc68:	1a00000a 	bne	3480fc98 <get_device+0x60>
	       block_dev_desc_t **dev_desc)
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480fc6c:	e1a07000 	mov	r7, r0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480fc70:	e1a01007 	mov	r1, r7
3480fc74:	e1a00005 	mov	r0, r5
3480fc78:	ebffff03 	bl	3480f88c <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480fc7c:	e3500000 	cmp	r0, #0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480fc80:	e5860000 	str	r0, [r6]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480fc84:	0a000002 	beq	3480fc94 <get_device+0x5c>
3480fc88:	e5d0300b 	ldrb	r3, [r0, #11]
3480fc8c:	e35300ff 	cmp	r3, #255	; 0xff
3480fc90:	1a000004 	bne	3480fca8 <get_device+0x70>
		printf("** Bad device %s %s **\n", ifname, dev_str);
3480fc94:	e59f0018 	ldr	r0, [pc, #24]	; 3480fcb4 <get_device+0x7c>
3480fc98:	e1a01005 	mov	r1, r5
3480fc9c:	e1a02004 	mov	r2, r4
3480fca0:	ebffe788 	bl	34809ac8 <printf>
		return -1;
3480fca4:	e3e07000 	mvn	r7, #0
	}

	return dev;
}
3480fca8:	e1a00007 	mov	r0, r7
3480fcac:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
3480fcb0:	34826b90 	.word	0x34826b90
3480fcb4:	34826bb6 	.word	0x34826bb6

3480fcb8 <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480fcb8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480fcbc:	e2516000 	subs	r6, r1, #0
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480fcc0:	e24dd058 	sub	sp, sp, #88	; 0x58
3480fcc4:	e1a09000 	mov	r9, r0
3480fcc8:	e1a0b002 	mov	fp, r2
3480fccc:	e1a05003 	mov	r5, r3
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480fcd0:	0a000008 	beq	3480fcf8 <get_device_and_partition+0x40>
3480fcd4:	e1a00006 	mov	r0, r6
3480fcd8:	eb0031ae 	bl	3481c398 <strlen>
3480fcdc:	e3500000 	cmp	r0, #0
3480fce0:	0a000004 	beq	3480fcf8 <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
3480fce4:	e1a00006 	mov	r0, r6
3480fce8:	e59f1280 	ldr	r1, [pc, #640]	; 3480ff70 <get_device_and_partition+0x2b8>
3480fcec:	eb003175 	bl	3481c2c8 <strcmp>
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480fcf0:	e3500000 	cmp	r0, #0
3480fcf4:	1a000007 	bne	3480fd18 <get_device_and_partition+0x60>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
3480fcf8:	e59f0274 	ldr	r0, [pc, #628]	; 3480ff74 <get_device_and_partition+0x2bc>
3480fcfc:	ebffe083 	bl	34807f10 <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
3480fd00:	e2506000 	subs	r6, r0, #0
3480fd04:	1a000003 	bne	3480fd18 <get_device_and_partition+0x60>
		printf("** No device specified **\n");
3480fd08:	e59f0268 	ldr	r0, [pc, #616]	; 3480ff78 <get_device_and_partition+0x2c0>
3480fd0c:	ebffe76d 	bl	34809ac8 <printf>
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480fd10:	e1a07006 	mov	r7, r6
3480fd14:	ea00008f 	b	3480ff58 <get_device_and_partition+0x2a0>
		printf("** No device specified **\n");
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
3480fd18:	e1a00006 	mov	r0, r6
3480fd1c:	e3a0103a 	mov	r1, #58	; 0x3a
3480fd20:	eb003186 	bl	3481c340 <strchr>
	if (part_str) {
3480fd24:	e2504000 	subs	r4, r0, #0
3480fd28:	01a0a006 	moveq	sl, r6
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480fd2c:	01a07004 	moveq	r7, r4
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
3480fd30:	0a000007 	beq	3480fd54 <get_device_and_partition+0x9c>
		dup_str = strdup(dev_part_str);
3480fd34:	e1a00006 	mov	r0, r6
3480fd38:	eb0031cb 	bl	3481c46c <strdup>
		dup_str[part_str - dev_part_str] = 0;
3480fd3c:	e0663004 	rsb	r3, r6, r4
3480fd40:	e3a02000 	mov	r2, #0
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
3480fd44:	e1a07000 	mov	r7, r0
		dup_str[part_str - dev_part_str] = 0;
3480fd48:	e7c02003 	strb	r2, [r0, r3]
		dev_str = dup_str;
		part_str++;
3480fd4c:	e2844001 	add	r4, r4, #1
	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
		dup_str[part_str - dev_part_str] = 0;
		dev_str = dup_str;
3480fd50:	e1a0a000 	mov	sl, r0
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
3480fd54:	e1a00009 	mov	r0, r9
3480fd58:	e1a0100a 	mov	r1, sl
3480fd5c:	e1a0200b 	mov	r2, fp
3480fd60:	ebffffb4 	bl	3480fc38 <get_device>
	if (dev < 0)
3480fd64:	e3500000 	cmp	r0, #0
3480fd68:	ba00007a 	blt	3480ff58 <get_device_and_partition+0x2a0>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
3480fd6c:	e3540000 	cmp	r4, #0
3480fd70:	0a000018 	beq	3480fdd8 <get_device_and_partition+0x120>
3480fd74:	e5d43000 	ldrb	r3, [r4]
3480fd78:	e3530000 	cmp	r3, #0
3480fd7c:	0a000015 	beq	3480fdd8 <get_device_and_partition+0x120>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480fd80:	e1a00004 	mov	r0, r4
3480fd84:	e59f11f0 	ldr	r1, [pc, #496]	; 3480ff7c <get_device_and_partition+0x2c4>
3480fd88:	eb00314e 	bl	3481c2c8 <strcmp>
3480fd8c:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
3480fd90:	03e04000 	mvneq	r4, #0
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480fd94:	0a000010 	beq	3480fddc <get_device_and_partition+0x124>
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480fd98:	e1a00004 	mov	r0, r4
3480fd9c:	e28d1054 	add	r1, sp, #84	; 0x54
3480fda0:	e3a02010 	mov	r2, #16
3480fda4:	eb00350e 	bl	3481d1e4 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480fda8:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3480fdac:	e5d33000 	ldrb	r3, [r3]
3480fdb0:	e3530000 	cmp	r3, #0
3480fdb4:	1a000003 	bne	3480fdc8 <get_device_and_partition+0x110>
3480fdb8:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480fdbc:	e1a04000 	mov	r4, r0
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480fdc0:	e1902002 	orrs	r2, r0, r2
3480fdc4:	1a000004 	bne	3480fddc <get_device_and_partition+0x124>
			printf("** Bad partition specification %s %s **\n",
3480fdc8:	e59f01b0 	ldr	r0, [pc, #432]	; 3480ff80 <get_device_and_partition+0x2c8>
3480fdcc:	e1a01009 	mov	r1, r9
3480fdd0:	e1a02006 	mov	r2, r6
3480fdd4:	ea00000d 	b	3480fe10 <get_device_and_partition+0x158>
	if (dev < 0)
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
3480fdd8:	e3e04001 	mvn	r4, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
3480fddc:	e59b0000 	ldr	r0, [fp]
3480fde0:	e5d03008 	ldrb	r3, [r0, #8]
3480fde4:	e3530000 	cmp	r3, #0
3480fde8:	13540000 	cmpne	r4, #0
3480fdec:	13a03000 	movne	r3, #0
3480fdf0:	03a03001 	moveq	r3, #1
3480fdf4:	1a000015 	bne	3480fe50 <get_device_and_partition+0x198>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
3480fdf8:	e5903010 	ldr	r3, [r0, #16]
3480fdfc:	e3530000 	cmp	r3, #0
3480fe00:	1a000004 	bne	3480fe18 <get_device_and_partition+0x160>
			printf("** Bad device size - %s %s **\n", ifname,
3480fe04:	e59f0178 	ldr	r0, [pc, #376]	; 3480ff84 <get_device_and_partition+0x2cc>
3480fe08:	e1a01009 	mov	r1, r9
3480fe0c:	e1a0200a 	mov	r2, sl
3480fe10:	ebffe72c 	bl	34809ac8 <printf>
3480fe14:	ea00004f 	b	3480ff58 <get_device_and_partition+0x2a0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480fe18:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
3480fe1c:	e2726001 	rsbs	r6, r2, #1
3480fe20:	33a06000 	movcc	r6, #0
3480fe24:	e3540000 	cmp	r4, #0
3480fe28:	c3866001 	orrgt	r6, r6, #1
3480fe2c:	e3560000 	cmp	r6, #0
			printf("** No partition table - %s %s **\n", ifname,
3480fe30:	159f0150 	ldrne	r0, [pc, #336]	; 3480ff88 <get_device_and_partition+0x2d0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480fe34:	1afffff3 	bne	3480fe08 <get_device_and_partition+0x150>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
3480fe38:	e5853004 	str	r3, [r5, #4]
		info->blksz = (*dev_desc)->blksz;
3480fe3c:	e5903014 	ldr	r3, [r0, #20]
			printf("** No partition table - %s %s **\n", ifname,
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
3480fe40:	e5856000 	str	r6, [r5]
		info->size = (*dev_desc)->lba;
		info->blksz = (*dev_desc)->blksz;
3480fe44:	e5853008 	str	r3, [r5, #8]
		info->bootable = 0;
3480fe48:	e585604c 	str	r6, [r5, #76]	; 0x4c
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
		goto cleanup;
3480fe4c:	ea000042 	b	3480ff5c <get_device_and_partition+0x2a4>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
3480fe50:	e3740002 	cmn	r4, #2
3480fe54:	0a000005 	beq	3480fe70 <get_device_and_partition+0x1b8>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480fe58:	e3740001 	cmn	r4, #1
3480fe5c:	01a04003 	moveq	r4, r3
3480fe60:	03a0a001 	moveq	sl, #1
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
				tmpinfo = *info;
3480fe64:	028d9004 	addeq	r9, sp, #4

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480fe68:	0a00000a 	beq	3480fe98 <get_device_and_partition+0x1e0>
3480fe6c:	ea000000 	b	3480fe74 <get_device_and_partition+0x1bc>
	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
		part = 1;
3480fe70:	e3a04001 	mov	r4, #1
	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
		ret = get_partition_info(*dev_desc, part, info);
3480fe74:	e1a01004 	mov	r1, r4
3480fe78:	e1a02005 	mov	r2, r5
3480fe7c:	ebffff63 	bl	3480fc10 <get_partition_info>
		if (ret) {
3480fe80:	e2506000 	subs	r6, r0, #0
3480fe84:	0a000028 	beq	3480ff2c <get_device_and_partition+0x274>
			printf("** Invalid partition %d **\n", part);
3480fe88:	e1a01004 	mov	r1, r4
3480fe8c:	e59f00f8 	ldr	r0, [pc, #248]	; 3480ff8c <get_device_and_partition+0x2d4>
3480fe90:	ebffe70c 	bl	34809ac8 <printf>
			goto cleanup;
3480fe94:	ea000030 	b	3480ff5c <get_device_and_partition+0x2a4>
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
			ret = get_partition_info(*dev_desc, p, info);
3480fe98:	e59b0000 	ldr	r0, [fp]
3480fe9c:	e1a0100a 	mov	r1, sl
3480fea0:	e1a02005 	mov	r2, r5
3480fea4:	ebffff59 	bl	3480fc10 <get_partition_info>
			if (ret)
3480fea8:	e2506000 	subs	r6, r0, #0
3480feac:	1a000011 	bne	3480fef8 <get_device_and_partition+0x240>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
3480feb0:	e3540000 	cmp	r4, #0
3480feb4:	01a0400a 	moveq	r4, sl
3480feb8:	0a000002 	beq	3480fec8 <get_device_and_partition+0x210>
3480febc:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480fec0:	e3530000 	cmp	r3, #0
3480fec4:	11a0400a 	movne	r4, sl
				part = p;

			/* Best possible partition? Stop searching. */
			if (info->bootable)
3480fec8:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480fecc:	e3530000 	cmp	r3, #0
3480fed0:	0a000002 	beq	3480fee0 <get_device_and_partition+0x228>
		if (part) {
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
3480fed4:	e35a0011 	cmp	sl, #17
3480fed8:	1a000013 	bne	3480ff2c <get_device_and_partition+0x274>
3480fedc:	ea00000a 	b	3480ff0c <get_device_and_partition+0x254>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
3480fee0:	e154000a 	cmp	r4, sl
3480fee4:	1a000003 	bne	3480fef8 <get_device_and_partition+0x240>
				tmpinfo = *info;
3480fee8:	e1a00009 	mov	r0, r9
3480feec:	e1a01005 	mov	r1, r5
3480fef0:	e3a02050 	mov	r2, #80	; 0x50
3480fef4:	eb0031eb 	bl	3481c6a8 <memcpy>
		/*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
3480fef8:	e28aa001 	add	sl, sl, #1
3480fefc:	e35a0011 	cmp	sl, #17
3480ff00:	1affffe4 	bne	3480fe98 <get_device_and_partition+0x1e0>
			 */
			if (part == p)
				tmpinfo = *info;
		}
		/* If we found any acceptable partition */
		if (part) {
3480ff04:	e3540000 	cmp	r4, #0
3480ff08:	0a000004 	beq	3480ff20 <get_device_and_partition+0x268>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
3480ff0c:	e1a00005 	mov	r0, r5
3480ff10:	e28d1004 	add	r1, sp, #4
3480ff14:	e3a02050 	mov	r2, #80	; 0x50
3480ff18:	eb0031e2 	bl	3481c6a8 <memcpy>
3480ff1c:	ea000002 	b	3480ff2c <get_device_and_partition+0x274>
			ret = 0;
		} else {
			printf("** No valid partitions found **\n");
3480ff20:	e59f0068 	ldr	r0, [pc, #104]	; 3480ff90 <get_device_and_partition+0x2d8>
3480ff24:	ebffe6e7 	bl	34809ac8 <printf>
			goto cleanup;
3480ff28:	ea00000b 	b	3480ff5c <get_device_and_partition+0x2a4>
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480ff2c:	e285502c 	add	r5, r5, #44	; 0x2c
3480ff30:	e1a00005 	mov	r0, r5
3480ff34:	e59f1058 	ldr	r1, [pc, #88]	; 3480ff94 <get_device_and_partition+0x2dc>
3480ff38:	e3a02020 	mov	r2, #32
3480ff3c:	eb0030ed 	bl	3481c2f8 <strncmp>
3480ff40:	e3500000 	cmp	r0, #0
			info->type);
		ret  = -1;
		goto cleanup;
	}

	ret = part;
3480ff44:	01a06004 	moveq	r6, r4
		} else {
			printf("** No valid partitions found **\n");
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480ff48:	0a000003 	beq	3480ff5c <get_device_and_partition+0x2a4>
		printf("** Invalid partition type \"%.32s\""
3480ff4c:	e59f0044 	ldr	r0, [pc, #68]	; 3480ff98 <get_device_and_partition+0x2e0>
3480ff50:	e1a01005 	mov	r1, r5
3480ff54:	ebffe6db 	bl	34809ac8 <printf>
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
3480ff58:	e3e06000 	mvn	r6, #0

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
3480ff5c:	e1a00007 	mov	r0, r7
3480ff60:	ebffe816 	bl	34809fc0 <free>
	return ret;
}
3480ff64:	e1a00006 	mov	r0, r6
3480ff68:	e28dd058 	add	sp, sp, #88	; 0x58
3480ff6c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480ff70:	34827404 	.word	0x34827404
3480ff74:	34826bce 	.word	0x34826bce
3480ff78:	34826bd9 	.word	0x34826bd9
3480ff7c:	34826bf4 	.word	0x34826bf4
3480ff80:	34826bf9 	.word	0x34826bf9
3480ff84:	34826c22 	.word	0x34826c22
3480ff88:	34826c41 	.word	0x34826c41
3480ff8c:	34826c63 	.word	0x34826c63
3480ff90:	34826c7f 	.word	0x34826c7f
3480ff94:	34826865 	.word	0x34826865
3480ff98:	34826ca0 	.word	0x34826ca0

3480ff9c <le32_to_int>:
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480ff9c:	e5d03002 	ldrb	r3, [r0, #2]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480ffa0:	e5d02003 	ldrb	r2, [r0, #3]
	    (le32[2] << 16) +
3480ffa4:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480ffa8:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
3480ffac:	e5d02000 	ldrb	r2, [r0]
3480ffb0:	e5d00001 	ldrb	r0, [r0, #1]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480ffb4:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
	     le32[0]
	   );
}
3480ffb8:	e0830400 	add	r0, r3, r0, lsl #8
3480ffbc:	e12fff1e 	bx	lr

3480ffc0 <is_extended>:

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
3480ffc0:	e3500005 	cmp	r0, #5
3480ffc4:	1350000f 	cmpne	r0, #15
3480ffc8:	0a000003 	beq	3480ffdc <is_extended+0x1c>
3480ffcc:	e3500085 	cmp	r0, #133	; 0x85
3480ffd0:	13a00000 	movne	r0, #0
3480ffd4:	03a00001 	moveq	r0, #1
3480ffd8:	e12fff1e 	bx	lr
3480ffdc:	e3a00001 	mov	r0, #1
	    part_type == 0xf ||
	    part_type == 0x85);
}
3480ffe0:	e12fff1e 	bx	lr

3480ffe4 <test_block_type>:
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480ffe4:	e92d4010 	push	{r4, lr}
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480ffe8:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480ffec:	e1a04000 	mov	r4, r0
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480fff0:	e3530055 	cmp	r3, #85	; 0x55
3480fff4:	1a00000f 	bne	34810038 <test_block_type+0x54>
3480fff8:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
3480fffc:	e35300aa 	cmp	r3, #170	; 0xaa
34810000:	1a00000c 	bne	34810038 <test_block_type+0x54>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
34810004:	e2800036 	add	r0, r0, #54	; 0x36
34810008:	e59f1038 	ldr	r1, [pc, #56]	; 34810048 <test_block_type+0x64>
3481000c:	e3a02003 	mov	r2, #3
34810010:	eb0030b8 	bl	3481c2f8 <strncmp>
34810014:	e3500000 	cmp	r0, #0
34810018:	0a000008 	beq	34810040 <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
3481001c:	e2840052 	add	r0, r4, #82	; 0x52
34810020:	e59f1024 	ldr	r1, [pc, #36]	; 3481004c <test_block_type+0x68>
34810024:	e3a02005 	mov	r2, #5
34810028:	eb0030b2 	bl	3481c2f8 <strncmp>

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
3481002c:	e2700001 	rsbs	r0, r0, #1
34810030:	33a00000 	movcc	r0, #0
34810034:	e8bd8010 	pop	{r4, pc}
34810038:	e3e00000 	mvn	r0, #0
3481003c:	e8bd8010 	pop	{r4, pc}
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
		return DOS_PBR; /* is PBR */
34810040:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
34810044:	e8bd8010 	pop	{r4, pc}
34810048:	34826cd5 	.word	0x34826cd5
3481004c:	34826cd9 	.word	0x34826cd9

34810050 <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810050:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810054:	e28db01c 	add	fp, sp, #28
34810058:	e24dd020 	sub	sp, sp, #32
3481005c:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810060:	e5903014 	ldr	r3, [r0, #20]

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810064:	e50b2024 	str	r2, [fp, #-36]	; 0x24
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810068:	e283303f 	add	r3, r3, #63	; 0x3f
3481006c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
34810070:	e2833048 	add	r3, r3, #72	; 0x48
34810074:	e04dd003 	sub	sp, sp, r3
34810078:	e28d504f 	add	r5, sp, #79	; 0x4f
3481007c:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810080:	e590c060 	ldr	ip, [r0, #96]	; 0x60

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810084:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810088:	e3a02001 	mov	r2, #1
3481008c:	e5900004 	ldr	r0, [r0, #4]
34810090:	e1a03005 	mov	r3, r5

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810094:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810098:	e12fff3c 	blx	ip
3481009c:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
348100a0:	159f0158 	ldrne	r0, [pc, #344]	; 34810200 <print_partition_extended+0x1b0>
348100a4:	15941004 	ldrne	r1, [r4, #4]
348100a8:	11a02007 	movne	r2, r7
348100ac:	1a000006 	bne	348100cc <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
348100b0:	e1a00005 	mov	r0, r5
348100b4:	ebffffca 	bl	3480ffe4 <test_block_type>
	if (i != DOS_MBR) {
348100b8:	e3500000 	cmp	r0, #0
348100bc:	0a000004 	beq	348100d4 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
348100c0:	e59f013c 	ldr	r0, [pc, #316]	; 34810204 <print_partition_extended+0x1b4>
348100c4:	e5d511fe 	ldrb	r1, [r5, #510]	; 0x1fe
348100c8:	e5d521ff 	ldrb	r2, [r5, #511]	; 0x1ff
348100cc:	ebffe67d 	bl	34809ac8 <printf>
348100d0:	ea000048 	b	348101f8 <print_partition_extended+0x1a8>
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348100d4:	e2856f6f 	add	r6, r5, #444	; 0x1bc
348100d8:	e2866002 	add	r6, r6, #2
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
348100dc:	e2855f7b 	add	r5, r5, #492	; 0x1ec
348100e0:	e2859002 	add	r9, r5, #2
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348100e4:	e1a05006 	mov	r5, r6
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
348100e8:	e5d51004 	ldrb	r1, [r5, #4]
348100ec:	e3510000 	cmp	r1, #0
348100f0:	e50b1020 	str	r1, [fp, #-32]
348100f4:	0a000022 	beq	34810184 <print_partition_extended+0x134>
348100f8:	e3570000 	cmp	r7, #0
348100fc:	0a000003 	beq	34810110 <print_partition_extended+0xc0>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
34810100:	e1a00001 	mov	r0, r1
34810104:	ebffffad 	bl	3480ffc0 <is_extended>
34810108:	e3500000 	cmp	r0, #0
3481010c:	1a00001e 	bne	3481018c <print_partition_extended+0x13c>
	return p->boot_ind == 0x80;
}

static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
34810110:	e2850008 	add	r0, r5, #8
34810114:	ebffffa0 	bl	3480ff9c <le32_to_int>
34810118:	e0802007 	add	r2, r0, r7
	int lba_size  = le32_to_int (p->size4);
3481011c:	e285000c 	add	r0, r5, #12
34810120:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
34810124:	ebffff9c 	bl	3480ff9c <le32_to_int>
34810128:	e1a03000 	mov	r3, r0

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
		part_num, lba_start, lba_size, p->sys_ind,
		(is_extended(p->sys_ind) ? " Extd" : ""),
3481012c:	e51b0020 	ldr	r0, [fp, #-32]
34810130:	e50b3028 	str	r3, [fp, #-40]	; 0x28
34810134:	ebffffa1 	bl	3480ffc0 <is_extended>
static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
34810138:	e59fe0c8 	ldr	lr, [pc, #200]	; 34810208 <print_partition_extended+0x1b8>
3481013c:	e5d51000 	ldrb	r1, [r5]
34810140:	e59fc0c4 	ldr	ip, [pc, #196]	; 3481020c <print_partition_extended+0x1bc>
34810144:	e3500000 	cmp	r0, #0
34810148:	11a0c00e 	movne	ip, lr
3481014c:	e59fe0bc 	ldr	lr, [pc, #188]	; 34810210 <print_partition_extended+0x1c0>
34810150:	e1a0000c 	mov	r0, ip
34810154:	e3510080 	cmp	r1, #128	; 0x80
34810158:	e59fc0ac 	ldr	ip, [pc, #172]	; 3481020c <print_partition_extended+0x1bc>
3481015c:	01a0c00e 	moveq	ip, lr
34810160:	e1a0100c 	mov	r1, ip
34810164:	e51bc020 	ldr	ip, [fp, #-32]
34810168:	e98d0003 	stmib	sp, {r0, r1}
3481016c:	e59f00a0 	ldr	r0, [pc, #160]	; 34810214 <print_partition_extended+0x1c4>
34810170:	e1a0100a 	mov	r1, sl
34810174:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
34810178:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
3481017c:	e58dc000 	str	ip, [sp]
34810180:	ebffe650 	bl	34809ac8 <printf>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
34810184:	e3570000 	cmp	r7, #0
34810188:	0a000005 	beq	348101a4 <print_partition_extended+0x154>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3481018c:	e5d50004 	ldrb	r0, [r5, #4]
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
34810190:	e3500000 	cmp	r0, #0
34810194:	0a000003 	beq	348101a8 <print_partition_extended+0x158>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
34810198:	ebffff88 	bl	3480ffc0 <is_extended>
3481019c:	e3500000 	cmp	r0, #0
348101a0:	1a000000 	bne	348101a8 <print_partition_extended+0x158>
			part_num++;
348101a4:	e28aa001 	add	sl, sl, #1
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
348101a8:	e1550009 	cmp	r5, r9
348101ac:	12855010 	addne	r5, r5, #16
348101b0:	1affffcc 	bne	348100e8 <print_partition_extended+0x98>
348101b4:	e51b5024 	ldr	r5, [fp, #-36]	; 0x24
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
348101b8:	e5d60004 	ldrb	r0, [r6, #4]
348101bc:	ebffff7f 	bl	3480ffc0 <is_extended>
348101c0:	e3500000 	cmp	r0, #0
348101c4:	0a000008 	beq	348101ec <print_partition_extended+0x19c>
			int lba_start = le32_to_int (pt->start4) + relative;
348101c8:	e2860008 	add	r0, r6, #8
348101cc:	ebffff72 	bl	3480ff9c <le32_to_int>

			print_partition_extended (dev_desc, lba_start,
348101d0:	e3570000 	cmp	r7, #0

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
348101d4:	e0801005 	add	r1, r0, r5

			print_partition_extended (dev_desc, lba_start,
348101d8:	11a02005 	movne	r2, r5
348101dc:	e1a00004 	mov	r0, r4
348101e0:	01a02001 	moveq	r2, r1
348101e4:	e1a0300a 	mov	r3, sl
348101e8:	ebffff98 	bl	34810050 <print_partition_extended>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
348101ec:	e1560009 	cmp	r6, r9
348101f0:	12866010 	addne	r6, r6, #16
348101f4:	1affffef 	bne	348101b8 <print_partition_extended+0x168>
						  part_num);
		}
	}

	return;
}
348101f8:	e24bd01c 	sub	sp, fp, #28
348101fc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810200:	34826ceb 	.word	0x34826ceb
34810204:	34826d16 	.word	0x34826d16
34810208:	34826cdf 	.word	0x34826cdf
3481020c:	34823d17 	.word	0x34823d17
34810210:	34826ce5 	.word	0x34826ce5
34810214:	34826d3b 	.word	0x34826d3b

34810218 <get_partition_info_extended.clone.1>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
34810218:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481021c:	e28db01c 	add	fp, sp, #28
34810220:	e24dd010 	sub	sp, sp, #16
34810224:	e1a06003 	mov	r6, r3
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810228:	e5903014 	ldr	r3, [r0, #20]
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3481022c:	e590c060 	ldr	ip, [r0, #96]	; 0x60
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810230:	e283303f 	add	r3, r3, #63	; 0x3f
34810234:	e3c3303f 	bic	r3, r3, #63	; 0x3f
34810238:	e2833048 	add	r3, r3, #72	; 0x48
3481023c:	e04dd003 	sub	sp, sp, r3
34810240:	e28d4047 	add	r4, sp, #71	; 0x47
34810244:	e3c4403f 	bic	r4, r4, #63	; 0x3f
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
34810248:	e1a05000 	mov	r5, r0
3481024c:	e1a09002 	mov	r9, r2
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810250:	e5900004 	ldr	r0, [r0, #4]
34810254:	e3a02001 	mov	r2, #1
34810258:	e1a03004 	mov	r3, r4
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3481025c:	e1a0a001 	mov	sl, r1
34810260:	e59b7008 	ldr	r7, [fp, #8]
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810264:	e12fff3c 	blx	ip
34810268:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3481026c:	159f01e8 	ldrne	r0, [pc, #488]	; 3481045c <get_partition_info_extended.clone.1+0x244>
34810270:	15951004 	ldrne	r1, [r5, #4]
34810274:	11a0200a 	movne	r2, sl
34810278:	1a000007 	bne	3481029c <get_partition_info_extended.clone.1+0x84>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
3481027c:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
34810280:	e3510055 	cmp	r1, #85	; 0x55
34810284:	1a000002 	bne	34810294 <get_partition_info_extended.clone.1+0x7c>
34810288:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
3481028c:	e35300aa 	cmp	r3, #170	; 0xaa
34810290:	0a000003 	beq	348102a4 <get_partition_info_extended.clone.1+0x8c>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
34810294:	e59f01c4 	ldr	r0, [pc, #452]	; 34810460 <get_partition_info_extended.clone.1+0x248>
34810298:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
3481029c:	ebffe609 	bl	34809ac8 <printf>
348102a0:	ea00006a 	b	34810450 <get_partition_info_extended.clone.1+0x238>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348102a4:	e2843f6f 	add	r3, r4, #444	; 0x1bc
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
348102a8:	e2844f7b 	add	r4, r4, #492	; 0x1ec
348102ac:	e2844002 	add	r4, r4, #2
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348102b0:	e2833002 	add	r3, r3, #2
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
348102b4:	e50b4020 	str	r4, [fp, #-32]
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348102b8:	e1a04003 	mov	r4, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
348102bc:	e5d42000 	ldrb	r2, [r4]
348102c0:	e312007f 	tst	r2, #127	; 0x7f
348102c4:	1a00003b 	bne	348103b8 <get_partition_info_extended.clone.1+0x1a0>
		    (pt->sys_ind != 0) &&
348102c8:	e5d40004 	ldrb	r0, [r4, #4]
348102cc:	e59b1004 	ldr	r1, [fp, #4]
348102d0:	e1560001 	cmp	r6, r1
348102d4:	13a02000 	movne	r2, #0
348102d8:	03a02001 	moveq	r2, #1
348102dc:	e3500000 	cmp	r0, #0
348102e0:	03a02000 	moveq	r2, #0
348102e4:	e3520000 	cmp	r2, #0
348102e8:	0a000032 	beq	348103b8 <get_partition_info_extended.clone.1+0x1a0>
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
348102ec:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348102f0:	ebffff32 	bl	3480ffc0 <is_extended>
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
348102f4:	e3500000 	cmp	r0, #0
348102f8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
348102fc:	1a00002d 	bne	348103b8 <get_partition_info_extended.clone.1+0x1a0>
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
34810300:	e3a03c02 	mov	r3, #512	; 0x200
34810304:	e5873008 	str	r3, [r7, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
34810308:	e2840008 	add	r0, r4, #8
3481030c:	ebffff22 	bl	3480ff9c <le32_to_int>
34810310:	e080000a 	add	r0, r0, sl
34810314:	e5870000 	str	r0, [r7]
			info->size  = le32_to_int (pt->size4);
34810318:	e284000c 	add	r0, r4, #12
3481031c:	ebffff1e 	bl	3480ff9c <le32_to_int>
			switch(dev_desc->if_type) {
34810320:	e5953000 	ldr	r3, [r5]
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
			info->size  = le32_to_int (pt->size4);
34810324:	e5870004 	str	r0, [r7, #4]
			switch(dev_desc->if_type) {
34810328:	e2433001 	sub	r3, r3, #1
3481032c:	e287000c 	add	r0, r7, #12
34810330:	e5952004 	ldr	r2, [r5, #4]
34810334:	e3530007 	cmp	r3, #7
34810338:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481033c:	ea00000f 	b	34810380 <get_partition_info_extended.clone.1+0x168>
34810340:	34810360 	.word	0x34810360
34810344:	34810368 	.word	0x34810368
34810348:	34810360 	.word	0x34810360
3481034c:	34810370 	.word	0x34810370
34810350:	34810378 	.word	0x34810378
34810354:	34810380 	.word	0x34810380
34810358:	34810380 	.word	0x34810380
3481035c:	34810360 	.word	0x34810360
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
34810360:	e59f10fc 	ldr	r1, [pc, #252]	; 34810464 <get_partition_info_extended.clone.1+0x24c>
34810364:	ea000006 	b	34810384 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
34810368:	e59f10f8 	ldr	r1, [pc, #248]	; 34810468 <get_partition_info_extended.clone.1+0x250>
3481036c:	ea000004 	b	34810384 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
34810370:	e59f10f4 	ldr	r1, [pc, #244]	; 3481046c <get_partition_info_extended.clone.1+0x254>
34810374:	ea000002 	b	34810384 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
34810378:	e59f10f0 	ldr	r1, [pc, #240]	; 34810470 <get_partition_info_extended.clone.1+0x258>
3481037c:	ea000000 	b	34810384 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
34810380:	e59f10ec 	ldr	r1, [pc, #236]	; 34810474 <get_partition_info_extended.clone.1+0x25c>
34810384:	e1a03006 	mov	r3, r6
34810388:	e2822061 	add	r2, r2, #97	; 0x61
3481038c:	eb00343a 	bl	3481d47c <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
34810390:	e287002c 	add	r0, r7, #44	; 0x2c
34810394:	e59f10dc 	ldr	r1, [pc, #220]	; 34810478 <get_partition_info_extended.clone.1+0x260>
34810398:	eb003437 	bl	3481d47c <sprintf>
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
3481039c:	e5d43000 	ldrb	r3, [r4]
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
#ifdef CONFIG_PARTITION_UUIDS
			sprintf(info->uuid, "%08x-%02x", disksig, part_num);
#endif
			return 0;
348103a0:	e3a00000 	mov	r0, #0
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
348103a4:	e3530080 	cmp	r3, #128	; 0x80
348103a8:	13a03000 	movne	r3, #0
348103ac:	03a03001 	moveq	r3, #1
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
348103b0:	e587304c 	str	r3, [r7, #76]	; 0x4c
348103b4:	ea000026 	b	34810454 <get_partition_info_extended.clone.1+0x23c>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
348103b8:	e35a0000 	cmp	sl, #0
348103bc:	0a000007 	beq	348103e0 <get_partition_info_extended.clone.1+0x1c8>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
348103c0:	e5d40004 	ldrb	r0, [r4, #4]
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
348103c4:	e3500000 	cmp	r0, #0
348103c8:	0a000005 	beq	348103e4 <get_partition_info_extended.clone.1+0x1cc>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
348103cc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348103d0:	ebfffefa 	bl	3480ffc0 <is_extended>
348103d4:	e3500000 	cmp	r0, #0
348103d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
348103dc:	1a000000 	bne	348103e4 <get_partition_info_extended.clone.1+0x1cc>
			part_num++;
348103e0:	e2866001 	add	r6, r6, #1
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
348103e4:	e51b2020 	ldr	r2, [fp, #-32]
348103e8:	e1540002 	cmp	r4, r2
348103ec:	12844010 	addne	r4, r4, #16
348103f0:	1affffb1 	bne	348102bc <get_partition_info_extended.clone.1+0xa4>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
348103f4:	e5d30004 	ldrb	r0, [r3, #4]
348103f8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348103fc:	ebfffeef 	bl	3480ffc0 <is_extended>
34810400:	e3500000 	cmp	r0, #0
34810404:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
34810408:	0a00000c 	beq	34810440 <get_partition_info_extended.clone.1+0x228>
			int lba_start = le32_to_int (pt->start4) + relative;
3481040c:	e2830008 	add	r0, r3, #8
34810410:	ebfffee1 	bl	3480ff9c <le32_to_int>

			return get_partition_info_extended (dev_desc, lba_start,
34810414:	e59b3004 	ldr	r3, [fp, #4]

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
34810418:	e0801009 	add	r1, r0, r9

			return get_partition_info_extended (dev_desc, lba_start,
3481041c:	e35a0000 	cmp	sl, #0
34810420:	e58d3000 	str	r3, [sp]
34810424:	e1a00005 	mov	r0, r5
34810428:	11a02009 	movne	r2, r9
3481042c:	01a02001 	moveq	r2, r1
34810430:	e1a03006 	mov	r3, r6
34810434:	e58d7004 	str	r7, [sp, #4]
34810438:	ebffff76 	bl	34810218 <get_partition_info_extended.clone.1>
3481043c:	ea000004 	b	34810454 <get_partition_info_extended.clone.1+0x23c>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
34810440:	e51b1020 	ldr	r1, [fp, #-32]
34810444:	e1530001 	cmp	r3, r1
34810448:	12833010 	addne	r3, r3, #16
3481044c:	1affffe8 	bne	348103f4 <get_partition_info_extended.clone.1+0x1dc>
			return get_partition_info_extended (dev_desc, lba_start,
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
34810450:	e3e00000 	mvn	r0, #0
}
34810454:	e24bd01c 	sub	sp, fp, #28
34810458:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481045c:	34826ceb 	.word	0x34826ceb
34810460:	34826d16 	.word	0x34826d16
34810464:	34826d53 	.word	0x34826d53
34810468:	34826d5a 	.word	0x34826d5a
3481046c:	34826d61 	.word	0x34826d61
34810470:	34826d6a 	.word	0x34826d6a
34810474:	34826d73 	.word	0x34826d73
34810478:	34826865 	.word	0x34826865

3481047c <test_part_dos>:
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
3481047c:	e92d4818 	push	{r3, r4, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810480:	e5903014 	ldr	r3, [r0, #20]
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
34810484:	e28db00c 	add	fp, sp, #12
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810488:	e283303f 	add	r3, r3, #63	; 0x3f
3481048c:	e3c3303f 	bic	r3, r3, #63	; 0x3f
34810490:	e2833048 	add	r3, r3, #72	; 0x48
34810494:	e04dd003 	sub	sp, sp, r3
34810498:	e28d403f 	add	r4, sp, #63	; 0x3f
3481049c:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348104a0:	e590c060 	ldr	ip, [r0, #96]	; 0x60
348104a4:	e3a01000 	mov	r1, #0
348104a8:	e5900004 	ldr	r0, [r0, #4]
348104ac:	e3a02001 	mov	r2, #1
348104b0:	e1a03004 	mov	r3, r4
348104b4:	e12fff3c 	blx	ip
348104b8:	e3500001 	cmp	r0, #1
		return -1;
348104bc:	13e00000 	mvnne	r0, #0

int test_part_dos (block_dev_desc_t *dev_desc)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348104c0:	1a000003 	bne	348104d4 <test_part_dos+0x58>
		return -1;

	if (test_block_type(buffer) != DOS_MBR)
348104c4:	e1a00004 	mov	r0, r4
348104c8:	ebfffec5 	bl	3480ffe4 <test_block_type>
348104cc:	e3500000 	cmp	r0, #0
		return -1;
348104d0:	13e00000 	mvnne	r0, #0

	return 0;
}
348104d4:	e24bd00c 	sub	sp, fp, #12
348104d8:	e8bd8818 	pop	{r3, r4, fp, pc}

348104dc <print_part_dos>:
	}
	return -1;
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
348104dc:	e92d4010 	push	{r4, lr}
348104e0:	e1a04000 	mov	r4, r0
	printf ("Partition     Start Sector     Num Sectors     Type\n");
348104e4:	e59f0018 	ldr	r0, [pc, #24]	; 34810504 <print_part_dos+0x28>
348104e8:	ebffe576 	bl	34809ac8 <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
348104ec:	e3a01000 	mov	r1, #0
348104f0:	e1a00004 	mov	r0, r4
348104f4:	e1a02001 	mov	r2, r1
348104f8:	e3a03001 	mov	r3, #1
}
348104fc:	e8bd4010 	pop	{r4, lr}
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
	printf ("Partition     Start Sector     Num Sectors     Type\n");
	print_partition_extended (dev_desc, 0, 0, 1);
34810500:	eafffed2 	b	34810050 <print_partition_extended>
34810504:	34826d7a 	.word	0x34826d7a

34810508 <get_partition_info_dos>:
}

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
34810508:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
3481050c:	e58d1000 	str	r1, [sp]
34810510:	e3a01000 	mov	r1, #0
34810514:	e58d2004 	str	r2, [sp, #4]
34810518:	e3a03001 	mov	r3, #1
3481051c:	e1a02001 	mov	r2, r1
34810520:	ebffff3c 	bl	34810218 <get_partition_info_extended.clone.1>
}
34810524:	e8bd800e 	pop	{r1, r2, r3, pc}

34810528 <s5p_gpio_cfg_pin>:

void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
{
	unsigned int value;

	value = readl(&bank->con);
34810528:	e5903000 	ldr	r3, [r0]
	value &= ~CON_MASK(gpio);
3481052c:	e3a0c00f 	mov	ip, #15
34810530:	e1a01101 	lsl	r1, r1, #2
34810534:	e1c3311c 	bic	r3, r3, ip, lsl r1
	value |= CON_SFR(gpio, cfg);
34810538:	e1831112 	orr	r1, r3, r2, lsl r1
	writel(value, &bank->con);
3481053c:	e5801000 	str	r1, [r0]
}
34810540:	e12fff1e 	bx	lr

34810544 <s5p_gpio_direction_output>:

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
34810544:	e92d4070 	push	{r4, r5, r6, lr}
34810548:	e1a04000 	mov	r4, r0
3481054c:	e1a05002 	mov	r5, r2
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
34810550:	e3a02001 	mov	r2, #1
	value |= CON_SFR(gpio, cfg);
	writel(value, &bank->con);
}

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
34810554:	e1a06001 	mov	r6, r1
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
34810558:	ebfffff2 	bl	34810528 <s5p_gpio_cfg_pin>

	value = readl(&bank->dat);
3481055c:	e5943004 	ldr	r3, [r4, #4]
	value &= ~DAT_MASK(gpio);
34810560:	e3a02001 	mov	r2, #1
34810564:	e1a06612 	lsl	r6, r2, r6
	if (en)
34810568:	e3550000 	cmp	r5, #0
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
3481056c:	e1c33006 	bic	r3, r3, r6
	if (en)
		value |= DAT_SET(gpio);
34810570:	11833006 	orrne	r3, r3, r6
	writel(value, &bank->dat);
34810574:	e5843004 	str	r3, [r4, #4]
}
34810578:	e8bd8070 	pop	{r4, r5, r6, pc}

3481057c <s5p_gpio_direction_input>:

void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
{
	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
3481057c:	e3a02000 	mov	r2, #0
34810580:	eaffffe8 	b	34810528 <s5p_gpio_cfg_pin>

34810584 <s5p_gpio_set_value>:

void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
34810584:	e5903004 	ldr	r3, [r0, #4]
	value &= ~DAT_MASK(gpio);
34810588:	e3a0c001 	mov	ip, #1
3481058c:	e1a0111c 	lsl	r1, ip, r1
	if (en)
34810590:	e3520000 	cmp	r2, #0
void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
34810594:	e1c33001 	bic	r3, r3, r1
	if (en)
		value |= DAT_SET(gpio);
34810598:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
3481059c:	e5803004 	str	r3, [r0, #4]
}
348105a0:	e12fff1e 	bx	lr

348105a4 <s5p_gpio_get_value>:

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
348105a4:	e5903004 	ldr	r3, [r0, #4]
	return !!(value & DAT_MASK(gpio));
348105a8:	e3a02001 	mov	r2, #1
348105ac:	e0132112 	ands	r2, r3, r2, lsl r1
}
348105b0:	03a00000 	moveq	r0, #0
348105b4:	13a00001 	movne	r0, #1
348105b8:	e12fff1e 	bx	lr

348105bc <s5p_gpio_set_pull>:

void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->pull);
348105bc:	e5903008 	ldr	r3, [r0, #8]
	value &= ~PULL_MASK(gpio);
348105c0:	e3a0c003 	mov	ip, #3
348105c4:	e1a01081 	lsl	r1, r1, #1
348105c8:	e1c3311c 	bic	r3, r3, ip, lsl r1

	switch (mode) {
348105cc:	e242c001 	sub	ip, r2, #1
348105d0:	e35c0001 	cmp	ip, #1
	case GPIO_PULL_DOWN:
	case GPIO_PULL_UP:
		value |= PULL_MODE(gpio, mode);
348105d4:	91833112 	orrls	r3, r3, r2, lsl r1
		break;
	default:
		break;
	}

	writel(value, &bank->pull);
348105d8:	e5803008 	str	r3, [r0, #8]
}
348105dc:	e12fff1e 	bx	lr

348105e0 <s5p_gpio_set_drv>:

void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
348105e0:	e590300c 	ldr	r3, [r0, #12]
	value &= ~DRV_MASK(gpio);

	switch (mode) {
348105e4:	e3520003 	cmp	r2, #3
348105e8:	812fff1e 	bxhi	lr
void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~DRV_MASK(gpio);
348105ec:	e1a01081 	lsl	r1, r1, #1
348105f0:	e3a0c003 	mov	ip, #3
348105f4:	e1c3311c 	bic	r3, r3, ip, lsl r1
	switch (mode) {
	case GPIO_DRV_1X:
	case GPIO_DRV_2X:
	case GPIO_DRV_3X:
	case GPIO_DRV_4X:
		value |= DRV_SET(gpio, mode);
348105f8:	e1831112 	orr	r1, r3, r2, lsl r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
348105fc:	e580100c 	str	r1, [r0, #12]
34810600:	e12fff1e 	bx	lr

34810604 <s5p_gpio_set_rate>:

void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
34810604:	e590300c 	ldr	r3, [r0, #12]
	value &= ~RATE_MASK(gpio);

	switch (mode) {
34810608:	e3520001 	cmp	r2, #1
3481060c:	812fff1e 	bxhi	lr
void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~RATE_MASK(gpio);
34810610:	e3a02001 	mov	r2, #1
34810614:	e2811010 	add	r1, r1, #16
34810618:	e1a01112 	lsl	r1, r2, r1
3481061c:	e1c33001 	bic	r3, r3, r1

	switch (mode) {
	case GPIO_DRV_FAST:
	case GPIO_DRV_SLOW:
		value |= RATE_SET(gpio);
34810620:	e1831001 	orr	r1, r3, r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
34810624:	e580100c 	str	r1, [r0, #12]
34810628:	e12fff1e 	bx	lr

3481062c <s5p_gpio_get_bank>:
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3481062c:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810630:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810634:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
}
34810638:	e2800602 	add	r0, r0, #2097152	; 0x200000
3481063c:	e12fff1e 	bx	lr

34810640 <s5p_gpio_get_pin>:

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
}
34810640:	e2000007 	and	r0, r0, #7
34810644:	e12fff1e 	bx	lr

34810648 <gpio_request>:
/* Common GPIO API */

int gpio_request(unsigned gpio, const char *label)
{
	return 0;
}
34810648:	e3a00000 	mov	r0, #0
3481064c:	e12fff1e 	bx	lr

34810650 <gpio_free>:

int gpio_free(unsigned gpio)
{
	return 0;
}
34810650:	e3a00000 	mov	r0, #0
34810654:	e12fff1e 	bx	lr

34810658 <gpio_direction_input>:

int gpio_direction_input(unsigned gpio)
{
34810658:	e1a01000 	mov	r1, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3481065c:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810660:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810664:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
{
	return 0;
}

int gpio_direction_input(unsigned gpio)
{
34810668:	e92d4008 	push	{r3, lr}
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
3481066c:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810670:	e2011007 	and	r1, r1, #7
34810674:	ebffffc0 	bl	3481057c <s5p_gpio_direction_input>
				s5p_gpio_get_pin(gpio));
	return 0;
}
34810678:	e3a00000 	mov	r0, #0
3481067c:	e8bd8008 	pop	{r3, pc}

34810680 <gpio_direction_output>:

int gpio_direction_output(unsigned gpio, int value)
{
34810680:	e92d4008 	push	{r3, lr}
34810684:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
34810688:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3481068c:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810690:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
				s5p_gpio_get_pin(gpio));
	return 0;
}

int gpio_direction_output(unsigned gpio, int value)
{
34810694:	e1a02001 	mov	r2, r1
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
34810698:	e2800602 	add	r0, r0, #2097152	; 0x200000
3481069c:	e2031007 	and	r1, r3, #7
348106a0:	ebffffa7 	bl	34810544 <s5p_gpio_direction_output>
				 s5p_gpio_get_pin(gpio), value);
	return 0;
}
348106a4:	e3a00000 	mov	r0, #0
348106a8:	e8bd8008 	pop	{r3, pc}

348106ac <gpio_get_value>:
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
348106ac:	e1a031a0 	lsr	r3, r0, #3

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
348106b0:	e1a03283 	lsl	r3, r3, #5
348106b4:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
348106b8:	e2833602 	add	r3, r3, #2097152	; 0x200000
348106bc:	e5933004 	ldr	r3, [r3, #4]
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
348106c0:	e3a02001 	mov	r2, #1
	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
}

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
348106c4:	e2000007 	and	r0, r0, #7
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
348106c8:	e0132012 	ands	r2, r3, r2, lsl r0
				       s5p_gpio_get_pin(gpio));
}
348106cc:	03a00000 	moveq	r0, #0
348106d0:	13a00001 	movne	r0, #1
348106d4:	e12fff1e 	bx	lr

348106d8 <gpio_set_value>:

int gpio_set_value(unsigned gpio, int value)
{
348106d8:	e92d4008 	push	{r3, lr}
348106dc:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
348106e0:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
348106e4:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
348106e8:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
				       s5p_gpio_get_pin(gpio));
}

int gpio_set_value(unsigned gpio, int value)
{
348106ec:	e1a02001 	mov	r2, r1
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
348106f0:	e2800602 	add	r0, r0, #2097152	; 0x200000
348106f4:	e2031007 	and	r1, r3, #7
348106f8:	ebffffa1 	bl	34810584 <s5p_gpio_set_value>
			  s5p_gpio_get_pin(gpio), value);

	return 0;
}
348106fc:	e3a00000 	mov	r0, #0
34810700:	e8bd8008 	pop	{r3, pc}

34810704 <send_start>:

/*-----------------------------------------------------------------------
 * START: High -> Low on SDA while SCL is High
 */
static void send_start(void)
{
34810704:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_DELAY;
34810708:	e3a00005 	mov	r0, #5
3481070c:	eb003070 	bl	3481c8d4 <udelay>
	I2C_SDA(1);
34810710:	e3a000b0 	mov	r0, #176	; 0xb0
34810714:	ebffffcf 	bl	34810658 <gpio_direction_input>
	I2C_ACTIVE;
	I2C_DELAY;
34810718:	e3a00005 	mov	r0, #5
3481071c:	eb00306c 	bl	3481c8d4 <udelay>
	I2C_SCL(1);
34810720:	e3a01001 	mov	r1, #1
34810724:	e3a000b3 	mov	r0, #179	; 0xb3
34810728:	ebffffd4 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
3481072c:	e3a00005 	mov	r0, #5
34810730:	eb003067 	bl	3481c8d4 <udelay>
	I2C_SDA(0);
34810734:	e3a01000 	mov	r1, #0
34810738:	e3a000b0 	mov	r0, #176	; 0xb0
3481073c:	ebffffcf 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810740:	e3a00005 	mov	r0, #5
}
34810744:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(0);
	I2C_DELAY;
34810748:	ea003061 	b	3481c8d4 <udelay>

3481074c <send_stop>:

/*-----------------------------------------------------------------------
 * STOP: Low -> High on SDA while SCL is High
 */
static void send_stop(void)
{
3481074c:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
34810750:	e3a01000 	mov	r1, #0
34810754:	e3a000b3 	mov	r0, #179	; 0xb3
34810758:	ebffffc8 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
3481075c:	e3a00005 	mov	r0, #5
34810760:	eb00305b 	bl	3481c8d4 <udelay>
	I2C_SDA(0);
34810764:	e3a01000 	mov	r1, #0
34810768:	e3a000b0 	mov	r0, #176	; 0xb0
3481076c:	ebffffc3 	bl	34810680 <gpio_direction_output>
	I2C_ACTIVE;
	I2C_DELAY;
34810770:	e3a00005 	mov	r0, #5
34810774:	eb003056 	bl	3481c8d4 <udelay>
	I2C_SCL(1);
34810778:	e3a01001 	mov	r1, #1
3481077c:	e3a000b3 	mov	r0, #179	; 0xb3
34810780:	ebffffbe 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810784:	e3a00005 	mov	r0, #5
34810788:	eb003051 	bl	3481c8d4 <udelay>
	I2C_SDA(1);
3481078c:	e3a000b0 	mov	r0, #176	; 0xb0
34810790:	ebffffb0 	bl	34810658 <gpio_direction_input>
	I2C_DELAY;
34810794:	e3a00005 	mov	r0, #5
	I2C_TRISTATE;
}
34810798:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(1);
	I2C_DELAY;
3481079c:	ea00304c 	b	3481c8d4 <udelay>

348107a0 <write_byte>:

/*-----------------------------------------------------------------------
 * Send 8 bits and look for an acknowledgement.
 */
static int write_byte(uchar data)
{
348107a0:	e92d4038 	push	{r3, r4, r5, lr}
348107a4:	e1a05000 	mov	r5, r0
348107a8:	e3a04008 	mov	r4, #8
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
348107ac:	e3a01000 	mov	r1, #0
348107b0:	e3a000b3 	mov	r0, #179	; 0xb3
348107b4:	ebffffb1 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
348107b8:	e3a00005 	mov	r0, #5
348107bc:	eb003044 	bl	3481c8d4 <udelay>
		I2C_SDA(data & 0x80);
348107c0:	e3150080 	tst	r5, #128	; 0x80
348107c4:	0a000002 	beq	348107d4 <write_byte+0x34>
348107c8:	e3a000b0 	mov	r0, #176	; 0xb0
348107cc:	ebffffa1 	bl	34810658 <gpio_direction_input>
348107d0:	ea000002 	b	348107e0 <write_byte+0x40>
348107d4:	e3a000b0 	mov	r0, #176	; 0xb0
348107d8:	e3a01000 	mov	r1, #0
348107dc:	ebffffa7 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
348107e0:	e3a00005 	mov	r0, #5
348107e4:	eb00303a 	bl	3481c8d4 <udelay>
		I2C_SCL(1);
348107e8:	e3a01001 	mov	r1, #1
348107ec:	e3a000b3 	mov	r0, #179	; 0xb3
348107f0:	ebffffa2 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
348107f4:	e3a00005 	mov	r0, #5
348107f8:	eb003035 	bl	3481c8d4 <udelay>
		I2C_DELAY;
348107fc:	e3a00005 	mov	r0, #5
34810800:	eb003033 	bl	3481c8d4 <udelay>
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
34810804:	e2544001 	subs	r4, r4, #1
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;

		data <<= 1;
34810808:	11a05085 	lslne	r5, r5, #1
3481080c:	16ef5075 	uxtbne	r5, r5
34810810:	1affffe5 	bne	348107ac <write_byte+0xc>
	}

	/*
	 * Look for an <ACK>(negative logic) and return it.
	 */
	I2C_SCL(0);
34810814:	e1a01004 	mov	r1, r4
34810818:	e3a000b3 	mov	r0, #179	; 0xb3
3481081c:	ebffff97 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810820:	e3a00005 	mov	r0, #5
34810824:	eb00302a 	bl	3481c8d4 <udelay>
	I2C_SDA(1);
34810828:	e3a000b0 	mov	r0, #176	; 0xb0
3481082c:	ebffff89 	bl	34810658 <gpio_direction_input>
	I2C_TRISTATE;
	I2C_DELAY;
34810830:	e3a00005 	mov	r0, #5
34810834:	eb003026 	bl	3481c8d4 <udelay>
	I2C_SCL(1);
34810838:	e3a01001 	mov	r1, #1
3481083c:	e3a000b3 	mov	r0, #179	; 0xb3
34810840:	ebffff8e 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810844:	e3a00005 	mov	r0, #5
34810848:	eb003021 	bl	3481c8d4 <udelay>
	I2C_DELAY;
3481084c:	e3a00005 	mov	r0, #5
34810850:	eb00301f 	bl	3481c8d4 <udelay>
	nack = I2C_READ;
34810854:	e3a000b0 	mov	r0, #176	; 0xb0
34810858:	ebffff93 	bl	348106ac <gpio_get_value>
	I2C_SCL(0);
3481085c:	e1a01004 	mov	r1, r4
	I2C_TRISTATE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_DELAY;
	nack = I2C_READ;
34810860:	e1a05000 	mov	r5, r0
	I2C_SCL(0);
34810864:	e3a000b3 	mov	r0, #179	; 0xb3
34810868:	ebffff84 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
3481086c:	e3a00005 	mov	r0, #5
34810870:	eb003017 	bl	3481c8d4 <udelay>
	I2C_ACTIVE;

	return(nack);	/* not a nack is an ack */
}
34810874:	e1a00005 	mov	r0, r5
34810878:	e8bd8038 	pop	{r3, r4, r5, pc}

3481087c <i2c_get_bus_num>:
 * Functions for multiple I2C bus handling
 */
unsigned int i2c_get_bus_num(void)
{
	return i2c_bus_num;
}
3481087c:	e59f3004 	ldr	r3, [pc, #4]	; 34810888 <i2c_get_bus_num+0xc>
34810880:	e5930000 	ldr	r0, [r3]
34810884:	e12fff1e 	bx	lr
34810888:	348289cc 	.word	0x348289cc

3481088c <i2c_set_bus_num>:
			i2c_bus_num = bus;
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
3481088c:	e3500006 	cmp	r0, #6
		return -1;
	i2c_bus_num = bus;
34810890:	959f300c 	ldrls	r3, [pc, #12]	; 348108a4 <i2c_set_bus_num+0x18>
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
		return -1;
34810894:	83e00000 	mvnhi	r0, #0
	i2c_bus_num = bus;
34810898:	95830000 	strls	r0, [r3]
#endif
	return 0;
3481089c:	93a00000 	movls	r0, #0
}
348108a0:	e12fff1e 	bx	lr
348108a4:	348289cc 	.word	0x348289cc

348108a8 <i2c_init>:

/*-----------------------------------------------------------------------
 * Initialization
 */
void i2c_init (int speed, int slaveaddr)
{
348108a8:	e92d4010 	push	{r4, lr}
static void send_reset(void)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;

	I2C_SCL(1);
348108ac:	e3a01001 	mov	r1, #1
348108b0:	e3a000b3 	mov	r0, #179	; 0xb3
348108b4:	ebffff71 	bl	34810680 <gpio_direction_output>
	I2C_SDA(1);
348108b8:	e3a000b0 	mov	r0, #176	; 0xb0
348108bc:	ebffff65 	bl	34810658 <gpio_direction_input>
#ifdef	I2C_INIT
	I2C_INIT;
348108c0:	e59f105c 	ldr	r1, [pc, #92]	; 34810924 <i2c_init+0x7c>
348108c4:	e3a000b3 	mov	r0, #179	; 0xb3
348108c8:	ebffff5e 	bl	34810648 <gpio_request>
348108cc:	e3a000b0 	mov	r0, #176	; 0xb0
348108d0:	e59f104c 	ldr	r1, [pc, #76]	; 34810924 <i2c_init+0x7c>
348108d4:	ebffff5b 	bl	34810648 <gpio_request>
348108d8:	e3a04009 	mov	r4, #9
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
		I2C_SCL(0);
348108dc:	e3a01000 	mov	r1, #0
348108e0:	e3a000b3 	mov	r0, #179	; 0xb3
348108e4:	ebffff65 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
348108e8:	e3a00005 	mov	r0, #5
348108ec:	eb002ff8 	bl	3481c8d4 <udelay>
		I2C_DELAY;
348108f0:	e3a00005 	mov	r0, #5
348108f4:	eb002ff6 	bl	3481c8d4 <udelay>
		I2C_SCL(1);
348108f8:	e3a01001 	mov	r1, #1
348108fc:	e3a000b3 	mov	r0, #179	; 0xb3
34810900:	ebffff5e 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
34810904:	e3a00005 	mov	r0, #5
34810908:	eb002ff1 	bl	3481c8d4 <udelay>
		I2C_DELAY;
3481090c:	e3a00005 	mov	r0, #5
34810910:	eb002fef 	bl	3481c8d4 <udelay>
	I2C_SDA(1);
#ifdef	I2C_INIT
	I2C_INIT;
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
34810914:	e2544001 	subs	r4, r4, #1
34810918:	1affffef 	bne	348108dc <i2c_init+0x34>
	 * the DIMM SPD, for instance), RAM won't be usable and your
	 * system will crash.
	 */
	send_reset ();
#endif
}
3481091c:	e8bd4010 	pop	{r4, lr}
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;
	}
	send_stop();
34810920:	eaffff89 	b	3481074c <send_stop>
34810924:	34826daf 	.word	0x34826daf

34810928 <i2c_probe>:
 * Probe to see if a chip is present.  Also good for checking for the
 * completion of EEPROM writes since the chip stops responding until
 * the write completes (typically 10mSec).
 */
int i2c_probe(uchar addr)
{
34810928:	e92d4010 	push	{r4, lr}
3481092c:	e1a04000 	mov	r4, r0

	/*
	 * perform 1 byte write transaction with just address byte
	 * (fake write)
	 */
	send_start();
34810930:	ebffff73 	bl	34810704 <send_start>
	rc = write_byte ((addr << 1) | 0);
34810934:	e1a00084 	lsl	r0, r4, #1
34810938:	e20000fe 	and	r0, r0, #254	; 0xfe
3481093c:	ebffff97 	bl	348107a0 <write_byte>
34810940:	e1a04000 	mov	r4, r0
	send_stop();
34810944:	ebffff80 	bl	3481074c <send_stop>

	return (rc ? 1 : 0);
}
34810948:	e2540000 	subs	r0, r4, #0
3481094c:	13a00001 	movne	r0, #1
34810950:	e8bd8010 	pop	{r4, pc}

34810954 <i2c_read>:

/*-----------------------------------------------------------------------
 * Read bytes
 */
int  i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810954:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
34810958:	e1a07002 	mov	r7, r2
3481095c:	e1a04000 	mov	r4, r0
34810960:	e1a05001 	mov	r5, r1
34810964:	e1a0a003 	mov	sl, r3
34810968:	e59d6020 	ldr	r6, [sp, #32]
	 * Do the addressing portion of a write cycle to set the
	 * chip's address pointer.  If the address length is zero,
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
3481096c:	ebffff64 	bl	34810704 <send_start>
	if(alen > 0) {
34810970:	e3570000 	cmp	r7, #0
34810974:	da000014 	ble	348109cc <i2c_read+0x78>
		if(write_byte(chip << 1)) {	/* write cycle */
34810978:	e1a00084 	lsl	r0, r4, #1
3481097c:	e20000fe 	and	r0, r0, #254	; 0xfe
34810980:	ebffff86 	bl	348107a0 <write_byte>
34810984:	e3500000 	cmp	r0, #0
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
34810988:	02479001 	subeq	r9, r7, #1
3481098c:	01a09189 	lsleq	r9, r9, #3
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
	if(alen > 0) {
		if(write_byte(chip << 1)) {	/* write cycle */
34810990:	0a000009 	beq	348109bc <i2c_read+0x68>
			send_stop();
34810994:	ebffff6c 	bl	3481074c <send_stop>
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
34810998:	e3a00001 	mov	r0, #1
3481099c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
348109a0:	e1a00935 	lsr	r0, r5, r9
348109a4:	e6ef0070 	uxtb	r0, r0
348109a8:	ebffff7c 	bl	348107a0 <write_byte>
348109ac:	e3500000 	cmp	r0, #0
348109b0:	e2477001 	sub	r7, r7, #1
348109b4:	1a000041 	bne	34810ac0 <i2c_read+0x16c>
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
			}
			shift -= 8;
348109b8:	e2499008 	sub	r9, r9, #8
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
348109bc:	e3570000 	cmp	r7, #0
348109c0:	cafffff6 	bgt	348109a0 <i2c_read+0x4c>
		 * stop/start sequence.
		 */
#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
		send_start();
#else
		send_stop();
348109c4:	ebffff60 	bl	3481074c <send_stop>
		send_start();
348109c8:	ebffff4d 	bl	34810704 <send_start>
	/*
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
348109cc:	e1a04084 	lsl	r4, r4, #1
348109d0:	e3840001 	orr	r0, r4, #1
348109d4:	e6ef0070 	uxtb	r0, r0
348109d8:	ebffff70 	bl	348107a0 <write_byte>
	while(len-- > 0) {
348109dc:	ea000032 	b	34810aac <i2c_read+0x158>

	/*
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
348109e0:	e3a000b0 	mov	r0, #176	; 0xb0
348109e4:	ebffff1b 	bl	34810658 <gpio_direction_input>
348109e8:	e3a04008 	mov	r4, #8
	data = 0;
348109ec:	e3a05000 	mov	r5, #0
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
348109f0:	e3a01000 	mov	r1, #0
348109f4:	e3a000b3 	mov	r0, #179	; 0xb3
348109f8:	ebffff20 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
348109fc:	e3a00005 	mov	r0, #5
34810a00:	eb002fb3 	bl	3481c8d4 <udelay>
		I2C_SCL(1);
34810a04:	e3a01001 	mov	r1, #1
34810a08:	e3a000b3 	mov	r0, #179	; 0xb3
34810a0c:	ebffff1b 	bl	34810680 <gpio_direction_output>
		I2C_DELAY;
34810a10:	e3a00005 	mov	r0, #5
34810a14:	eb002fae 	bl	3481c8d4 <udelay>
		data <<= 1;
		data |= I2C_READ;
34810a18:	e3a000b0 	mov	r0, #176	; 0xb0
34810a1c:	ebffff22 	bl	348106ac <gpio_get_value>
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		data <<= 1;
34810a20:	e1a05085 	lsl	r5, r5, #1
		data |= I2C_READ;
34810a24:	e1855000 	orr	r5, r5, r0
		I2C_DELAY;
34810a28:	e3a00005 	mov	r0, #5
34810a2c:	eb002fa8 	bl	3481c8d4 <udelay>
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
	data = 0;
	for(j = 0; j < 8; j++) {
34810a30:	e2544001 	subs	r4, r4, #1
34810a34:	1affffed 	bne	348109f0 <i2c_read+0x9c>
 */
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
34810a38:	e1a01004 	mov	r1, r4
34810a3c:	e3a000b3 	mov	r0, #179	; 0xb3
34810a40:	ebffff0e 	bl	34810680 <gpio_direction_output>
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
34810a44:	e2466001 	sub	r6, r6, #1
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
	I2C_DELAY;
34810a48:	e3a00005 	mov	r0, #5
34810a4c:	eb002fa0 	bl	3481c8d4 <udelay>
	I2C_ACTIVE;
	I2C_SDA(ack);
34810a50:	e3560000 	cmp	r6, #0
34810a54:	1a000002 	bne	34810a64 <i2c_read+0x110>
34810a58:	e3a000b0 	mov	r0, #176	; 0xb0
34810a5c:	ebfffefd 	bl	34810658 <gpio_direction_input>
34810a60:	ea000002 	b	34810a70 <i2c_read+0x11c>
34810a64:	e3a000b0 	mov	r0, #176	; 0xb0
34810a68:	e1a01004 	mov	r1, r4
34810a6c:	ebffff03 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810a70:	e3a00005 	mov	r0, #5
34810a74:	eb002f96 	bl	3481c8d4 <udelay>
	I2C_SCL(1);
34810a78:	e3a01001 	mov	r1, #1
34810a7c:	e3a000b3 	mov	r0, #179	; 0xb3
34810a80:	ebfffefe 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810a84:	e3a00005 	mov	r0, #5
34810a88:	eb002f91 	bl	3481c8d4 <udelay>
	I2C_DELAY;
34810a8c:	e3a00005 	mov	r0, #5
34810a90:	eb002f8f 	bl	3481c8d4 <udelay>
	I2C_SCL(0);
34810a94:	e3a01000 	mov	r1, #0
34810a98:	e3a000b3 	mov	r0, #179	; 0xb3
34810a9c:	ebfffef7 	bl	34810680 <gpio_direction_output>
	I2C_DELAY;
34810aa0:	e3a00005 	mov	r0, #5
34810aa4:	eb002f8a 	bl	3481c8d4 <udelay>
		data |= I2C_READ;
		I2C_DELAY;
	}
	send_ack(ack);

	return(data);
34810aa8:	e4ca5001 	strb	r5, [sl], #1
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
34810aac:	e3560000 	cmp	r6, #0
34810ab0:	caffffca 	bgt	348109e0 <i2c_read+0x8c>
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
34810ab4:	ebffff24 	bl	3481074c <send_stop>
	return(0);
34810ab8:	e3a00000 	mov	r0, #0
34810abc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
34810ac0:	e3a00001 	mov	r0, #1
	while(len-- > 0) {
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
	return(0);
}
34810ac4:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34810ac8 <i2c_write>:

/*-----------------------------------------------------------------------
 * Write bytes
 */
int  i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810ac8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810acc:	e1a05000 	mov	r5, r0
34810ad0:	e1a06002 	mov	r6, r2
34810ad4:	e1a04001 	mov	r4, r1
34810ad8:	e1a07003 	mov	r7, r3
	int shift, failures = 0;

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
34810adc:	ebffff08 	bl	34810704 <send_start>
	if(write_byte(chip << 1)) {	/* write cycle */
34810ae0:	e1a00085 	lsl	r0, r5, #1
34810ae4:	e20000fe 	and	r0, r0, #254	; 0xfe
34810ae8:	ebffff2c 	bl	348107a0 <write_byte>
34810aec:	e3500000 	cmp	r0, #0
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
34810af0:	02465001 	subeq	r5, r6, #1
34810af4:	01a05185 	lsleq	r5, r5, #3

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
	if(write_byte(chip << 1)) {	/* write cycle */
34810af8:	0a000008 	beq	34810b20 <i2c_write+0x58>
		send_stop();
34810afc:	ebffff12 	bl	3481074c <send_stop>
34810b00:	ea000014 	b	34810b58 <i2c_write+0x90>
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
34810b04:	e1a00534 	lsr	r0, r4, r5
34810b08:	e6ef0070 	uxtb	r0, r0
34810b0c:	ebffff23 	bl	348107a0 <write_byte>
34810b10:	e3500000 	cmp	r0, #0
34810b14:	e2466001 	sub	r6, r6, #1
34810b18:	1a00000e 	bne	34810b58 <i2c_write+0x90>
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
		}
		shift -= 8;
34810b1c:	e2455008 	sub	r5, r5, #8
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
34810b20:	e3560000 	cmp	r6, #0
34810b24:	cafffff6 	bgt	34810b04 <i2c_write+0x3c>
34810b28:	e59d5018 	ldr	r5, [sp, #24]
34810b2c:	e3a04000 	mov	r4, #0
34810b30:	ea000004 	b	34810b48 <i2c_write+0x80>
		}
		shift -= 8;
	}

	while(len-- > 0) {
		if(write_byte(*buffer++)) {
34810b34:	e4d70001 	ldrb	r0, [r7], #1
34810b38:	ebffff18 	bl	348107a0 <write_byte>
34810b3c:	e3500000 	cmp	r0, #0
			failures++;
34810b40:	12844001 	addne	r4, r4, #1
34810b44:	e2455001 	sub	r5, r5, #1
			return(1);
		}
		shift -= 8;
	}

	while(len-- > 0) {
34810b48:	e3550000 	cmp	r5, #0
34810b4c:	cafffff8 	bgt	34810b34 <i2c_write+0x6c>
		if(write_byte(*buffer++)) {
			failures++;
		}
	}
	send_stop();
34810b50:	ebfffefd 	bl	3481074c <send_stop>
	return(failures);
34810b54:	ea000000 	b	34810b5c <i2c_write+0x94>
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
34810b58:	e3a04001 	mov	r4, #1
			failures++;
		}
	}
	send_stop();
	return(failures);
}
34810b5c:	e1a00004 	mov	r0, r4
34810b60:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34810b64 <sort_array_by_ordering>:
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810b64:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810b68:	e28db01c 	add	fp, sp, #28
34810b6c:	e24dd008 	sub	sp, sp, #8
34810b70:	e50b2020 	str	r2, [fp, #-32]
	int temp[count];
34810b74:	e1a02101 	lsl	r2, r1, #2
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810b78:	e1a09003 	mov	r9, r3
	int temp[count];
34810b7c:	e282300e 	add	r3, r2, #14
34810b80:	e3c33007 	bic	r3, r3, #7
34810b84:	e04dd003 	sub	sp, sp, r3
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810b88:	e1a04000 	mov	r4, r0
34810b8c:	e1a05001 	mov	r5, r1
	int dest_count;
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
34810b90:	e1a0000d 	mov	r0, sp
34810b94:	e1a01004 	mov	r1, r4
34810b98:	eb002ec2 	bl	3481c6a8 <memcpy>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810b9c:	e3a02000 	mov	r2, #0
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
	int temp[count];
34810ba0:	e1a0600d 	mov	r6, sp
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810ba4:	e51b0020 	ldr	r0, [fp, #-32]
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;
34810ba8:	e1a03002 	mov	r3, r2

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810bac:	ea00000d 	b	34810be8 <sort_array_by_ordering+0x84>
		if (array_search(temp, count, order[i]) != -1)
34810bb0:	e490c004 	ldr	ip, [r0], #4
34810bb4:	e1a07006 	mov	r7, r6
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810bb8:	e3a01000 	mov	r1, #0
34810bbc:	ea000003 	b	34810bd0 <sort_array_by_ordering+0x6c>
		if (array[i] == key)
34810bc0:	e497a004 	ldr	sl, [r7], #4
34810bc4:	e15a000c 	cmp	sl, ip
34810bc8:	0a000003 	beq	34810bdc <sort_array_by_ordering+0x78>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810bcc:	e2811001 	add	r1, r1, #1
34810bd0:	e1510005 	cmp	r1, r5
34810bd4:	bafffff9 	blt	34810bc0 <sort_array_by_ordering+0x5c>
34810bd8:	ea000001 	b	34810be4 <sort_array_by_ordering+0x80>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
		if (array_search(temp, count, order[i]) != -1)
			dest[dest_count++] = order[i];
34810bdc:	e784c103 	str	ip, [r4, r3, lsl #2]
34810be0:	e2833001 	add	r3, r3, #1
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810be4:	e2822001 	add	r2, r2, #1
34810be8:	e1520009 	cmp	r2, r9
34810bec:	baffffef 	blt	34810bb0 <sort_array_by_ordering+0x4c>
34810bf0:	e1a00003 	mov	r0, r3
34810bf4:	e3a02000 	mov	r2, #0
34810bf8:	ea00000b 	b	34810c2c <sort_array_by_ordering+0xc8>
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
34810bfc:	e496c004 	ldr	ip, [r6], #4
34810c00:	e51b7020 	ldr	r7, [fp, #-32]
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810c04:	e3a01000 	mov	r1, #0
34810c08:	ea000003 	b	34810c1c <sort_array_by_ordering+0xb8>
		if (array[i] == key)
34810c0c:	e497a004 	ldr	sl, [r7], #4
34810c10:	e15a000c 	cmp	sl, ip
34810c14:	0a000003 	beq	34810c28 <sort_array_by_ordering+0xc4>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810c18:	e2811001 	add	r1, r1, #1
34810c1c:	e1510009 	cmp	r1, r9
34810c20:	bafffff9 	blt	34810c0c <sort_array_by_ordering+0xa8>
34810c24:	ea000004 	b	34810c3c <sort_array_by_ordering+0xd8>
			dest[dest_count++] = order[i];
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
34810c28:	e2822001 	add	r2, r2, #1
34810c2c:	e1520005 	cmp	r2, r5
34810c30:	bafffff1 	blt	34810bfc <sort_array_by_ordering+0x98>
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
	}
	assert(dest_count == count);
	return same;
}
34810c34:	e24bd01c 	sub	sp, fp, #28
34810c38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
34810c3c:	e784c103 	str	ip, [r4, r3, lsl #2]
34810c40:	e2833001 	add	r3, r3, #1
34810c44:	eafffff7 	b	34810c28 <sort_array_by_ordering+0xc4>

34810c48 <input_queue_ascii>:
};


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
34810c48:	e5903010 	ldr	r3, [r0, #16]
34810c4c:	e5902014 	ldr	r2, [r0, #20]
34810c50:	e353000f 	cmp	r3, #15
34810c54:	1a000003 	bne	34810c68 <input_queue_ascii+0x20>
		if (!config->fifo_out)
34810c58:	e3520000 	cmp	r2, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
34810c5c:	13a03000 	movne	r3, #0


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
34810c60:	1a000003 	bne	34810c74 <input_queue_ascii+0x2c>
34810c64:	ea000007 	b	34810c88 <input_queue_ascii+0x40>
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
34810c68:	e2833001 	add	r3, r3, #1
34810c6c:	e1530002 	cmp	r3, r2
34810c70:	0a000006 	beq	34810c90 <input_queue_ascii+0x48>
			return -1; /* buffer full */
		config->fifo_in++;
34810c74:	e5803010 	str	r3, [r0, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
34810c78:	e5903010 	ldr	r3, [r0, #16]
34810c7c:	e7c01003 	strb	r1, [r0, r3]

	return 0;
34810c80:	e3a00000 	mov	r0, #0
34810c84:	e12fff1e 	bx	lr

int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
			return -1; /* buffer full */
34810c88:	e3e00000 	mvn	r0, #0
34810c8c:	e12fff1e 	bx	lr
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
			return -1; /* buffer full */
34810c90:	e3e00000 	mvn	r0, #0
		config->fifo_in++;
	}
	config->fifo[config->fifo_in] = (uchar)ch;

	return 0;
}
34810c94:	e12fff1e 	bx	lr

34810c98 <input_tstc>:

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810c98:	e5902010 	ldr	r2, [r0, #16]
34810c9c:	e5903014 	ldr	r3, [r0, #20]

	return 0;
}

int input_tstc(struct input_config *config)
{
34810ca0:	e92d4010 	push	{r4, lr}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810ca4:	e1520003 	cmp	r2, r3

	return 0;
}

int input_tstc(struct input_config *config)
{
34810ca8:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810cac:	1a000005 	bne	34810cc8 <input_tstc+0x30>
34810cb0:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
34810cb4:	e3530000 	cmp	r3, #0
34810cb8:	0a000002 	beq	34810cc8 <input_tstc+0x30>
		if (!(*config->read_keys)(config))
34810cbc:	e12fff33 	blx	r3
34810cc0:	e3500000 	cmp	r0, #0
34810cc4:	08bd8010 	popeq	{r4, pc}
			return 0;
	}
	return config->fifo_in != config->fifo_out;
34810cc8:	e5940010 	ldr	r0, [r4, #16]
34810ccc:	e5943014 	ldr	r3, [r4, #20]
34810cd0:	e0500003 	subs	r0, r0, r3
34810cd4:	13a00001 	movne	r0, #1
}
34810cd8:	e8bd8010 	pop	{r4, pc}

34810cdc <input_getc>:

int input_getc(struct input_config *config)
{
34810cdc:	e92d4010 	push	{r4, lr}
34810ce0:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810ce4:	ea000006 	b	34810d04 <input_getc+0x28>
		if (config->read_keys)
34810ce8:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
34810cec:	e3530000 	cmp	r3, #0
34810cf0:	0a000003 	beq	34810d04 <input_getc+0x28>
			err = (*config->read_keys)(config);
34810cf4:	e1a00004 	mov	r0, r4
34810cf8:	e12fff33 	blx	r3
		if (err)
34810cfc:	e3500000 	cmp	r0, #0
34810d00:	1a00000b 	bne	34810d34 <input_getc+0x58>

int input_getc(struct input_config *config)
{
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810d04:	e5943014 	ldr	r3, [r4, #20]
34810d08:	e5942010 	ldr	r2, [r4, #16]
34810d0c:	e1520003 	cmp	r2, r3
34810d10:	0afffff4 	beq	34810ce8 <input_getc+0xc>
			err = (*config->read_keys)(config);
		if (err)
			return -1;
	}

	if (++config->fifo_out == INPUT_BUFFER_LEN)
34810d14:	e2833001 	add	r3, r3, #1
34810d18:	e3530010 	cmp	r3, #16
34810d1c:	e5843014 	str	r3, [r4, #20]
		config->fifo_out = 0;
34810d20:	03a03000 	moveq	r3, #0
34810d24:	05843014 	streq	r3, [r4, #20]

	return config->fifo[config->fifo_out];
34810d28:	e5943014 	ldr	r3, [r4, #20]
34810d2c:	e7d40003 	ldrb	r0, [r4, r3]
34810d30:	e8bd8010 	pop	{r4, pc}

	while (config->fifo_in == config->fifo_out) {
		if (config->read_keys)
			err = (*config->read_keys)(config);
		if (err)
			return -1;
34810d34:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
34810d38:	e8bd8010 	pop	{r4, pc}

34810d3c <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34810d3c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810d40:	e28db01c 	add	fp, sp, #28
34810d44:	e24dd010 	sub	sp, sp, #16
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34810d48:	e5d0701b 	ldrb	r7, [r0, #27]
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
34810d4c:	e282300e 	add	r3, r2, #14
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
34810d50:	e3a09000 	mov	r9, #0
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
34810d54:	e3c33007 	bic	r3, r3, #7
34810d58:	e04dd003 	sub	sp, sp, r3
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34810d5c:	e1570009 	cmp	r7, r9
	char ch[num_keycodes];
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
34810d60:	e5c09018 	strb	r9, [r0, #24]
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34810d64:	e1a04000 	mov	r4, r0
34810d68:	e1a06001 	mov	r6, r1
34810d6c:	e1a05002 	mov	r5, r2
	char ch[num_keycodes];
34810d70:	e50bd020 	str	sp, [fp, #-32]
	int count, i, same = 0;
	int is_repeat = 0;
34810d74:	01a09007 	moveq	r9, r7
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34810d78:	0a000012 	beq	34810dc8 <input_send_keycodes+0x8c>
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34810d7c:	e280a01c 	add	sl, r0, #28
34810d80:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34810d84:	e1a00001 	mov	r0, r1
34810d88:	e1a01002 	mov	r1, r2
34810d8c:	e1a0200a 	mov	r2, sl
34810d90:	ebffff73 	bl	34810b64 <sort_array_by_ordering>
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810d94:	e1a01006 	mov	r1, r6
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34810d98:	e1a07000 	mov	r7, r0
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810d9c:	e1a02105 	lsl	r2, r5, #2
34810da0:	e1a0000a 	mov	r0, sl
34810da4:	eb002e3f 	bl	3481c6a8 <memcpy>
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
34810da8:	e1570005 	cmp	r7, r5
	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
	config->num_prev_keycodes = num_keycodes;
34810dac:	e584505c 	str	r5, [r4, #92]	; 0x5c
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
34810db0:	1a000004 	bne	34810dc8 <input_send_keycodes+0x8c>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
34810db4:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
34810db8:	ebffc14f 	bl	348012fc <get_timer>
		if (!is_repeat)
34810dbc:	e1500009 	cmp	r0, r9
34810dc0:	a2899001 	addge	r9, r9, #1
34810dc4:	ba000061 	blt	34810f50 <input_send_keycodes+0x214>
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
34810dc8:	e2840060 	add	r0, r4, #96	; 0x60
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
34810dcc:	e3590000 	cmp	r9, #0
34810dd0:	13a07000 	movne	r7, #0
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
34810dd4:	e50b0024 	str	r0, [fp, #-36]	; 0x24
34810dd8:	e1a0e006 	mov	lr, r6
34810ddc:	e1a03000 	mov	r3, r0

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
34810de0:	e3a0c000 	mov	ip, #0
34810de4:	ea000032 	b	34810eb4 <input_send_keycodes+0x178>
		int key = keycode[i] & KEY_MASK;
34810de8:	e49e1004 	ldr	r1, [lr], #4

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810dec:	e593a00c 	ldr	sl, [r3, #12]

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;
34810df0:	e1a00a01 	lsl	r0, r1, #20
34810df4:	e1a02a20 	lsr	r2, r0, #20

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810df8:	e152000a 	cmp	r2, sl
34810dfc:	aa000003 	bge	34810e10 <input_send_keycodes+0xd4>
34810e00:	e593a008 	ldr	sl, [r3, #8]
34810e04:	e7da0a20 	ldrb	r0, [sl, r0, lsr #20]
34810e08:	e35000ff 	cmp	r0, #255	; 0xff
34810e0c:	1a000027 	bne	34810eb0 <input_send_keycodes+0x174>
			table = process_modifier(config, key,
34810e10:	e2011902 	and	r1, r1, #32768	; 0x8000
34810e14:	e50b1028 	str	r1, [fp, #-40]	; 0x28
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
34810e18:	e5d4101b 	ldrb	r1, [r4, #27]
34810e1c:	e1a00004 	mov	r0, r4
34810e20:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
	int flip = -1;
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
34810e24:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
	for (i = 1; i < config->num_tables; i++) {
34810e28:	e3a01001 	mov	r1, #1
34810e2c:	ea000009 	b	34810e58 <input_send_keycodes+0x11c>
		struct input_key_xlate *tab = &config->table[i];

		if (key == tab->left_keycode || key == tab->right_keycode)
34810e30:	e590a070 	ldr	sl, [r0, #112]	; 0x70
34810e34:	e152000a 	cmp	r2, sl
34810e38:	0a000002 	beq	34810e48 <input_send_keycodes+0x10c>
34810e3c:	e590a074 	ldr	sl, [r0, #116]	; 0x74
34810e40:	e152000a 	cmp	r2, sl
34810e44:	1a000001 	bne	34810e50 <input_send_keycodes+0x114>

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
		struct input_key_xlate *tab = &config->table[i];
34810e48:	e2813006 	add	r3, r1, #6
34810e4c:	e0843203 	add	r3, r4, r3, lsl #4
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
34810e50:	e2811001 	add	r1, r1, #1
34810e54:	e2800010 	add	r0, r0, #16
34810e58:	e51ba02c 	ldr	sl, [fp, #-44]	; 0x2c
34810e5c:	e151000a 	cmp	r1, sl
34810e60:	bafffff2 	blt	34810e30 <input_send_keycodes+0xf4>
		if (key == tab->left_keycode || key == tab->right_keycode)
			table = tab;
	}

	/* Handle the lighted keys */
	if (!release) {
34810e64:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
34810e68:	e3500000 	cmp	r0, #0
34810e6c:	1a00000f 	bne	34810eb0 <input_send_keycodes+0x174>
34810e70:	e242203a 	sub	r2, r2, #58	; 0x3a
34810e74:	e352000c 	cmp	r2, #12
34810e78:	8a00000c 	bhi	34810eb0 <input_send_keycodes+0x174>
			flip = FLAG_CAPS_LOCK;
			break;
		}
	}

	if (flip != -1) {
34810e7c:	e59f10d8 	ldr	r1, [pc, #216]	; 34810f5c <input_send_keycodes+0x220>
34810e80:	e7912102 	ldr	r2, [r1, r2, lsl #2]
34810e84:	e3720001 	cmn	r2, #1
34810e88:	0a000008 	beq	34810eb0 <input_send_keycodes+0x174>
		int leds = 0;

		config->leds ^= flip;
		if (config->flags & FLAG_NUM_LOCK)
34810e8c:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
34810e90:	e3110001 	tst	r1, #1
34810e94:	03a02000 	moveq	r2, #0
34810e98:	13a02004 	movne	r2, #4
		if (config->flags & FLAG_CAPS_LOCK)
34810e9c:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
34810ea0:	13822002 	orrne	r2, r2, #2
		if (config->flags & FLAG_SCROLL_LOCK)
34810ea4:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
34810ea8:	13822001 	orrne	r2, r2, #1
		config->leds = leds;
34810eac:	e5c4201a 	strb	r2, [r4, #26]
	int i;

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
34810eb0:	e28cc001 	add	ip, ip, #1
34810eb4:	e15c0005 	cmp	ip, r5
34810eb8:	baffffca 	blt	34810de8 <input_send_keycodes+0xac>
34810ebc:	e3a02000 	mov	r2, #0
34810ec0:	e1a0a002 	mov	sl, r2
34810ec4:	ea00000f 	b	34810f08 <input_send_keycodes+0x1cc>
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
		int key = keycode[i];
34810ec8:	e4961004 	ldr	r1, [r6], #4

		if (key < table->num_entries && i >= same) {
34810ecc:	e593c00c 	ldr	ip, [r3, #12]
34810ed0:	e1520007 	cmp	r2, r7
34810ed4:	b3a00000 	movlt	r0, #0
34810ed8:	a3a00001 	movge	r0, #1
34810edc:	e151000c 	cmp	r1, ip
34810ee0:	a3a00000 	movge	r0, #0
34810ee4:	e3500000 	cmp	r0, #0
34810ee8:	0a000005 	beq	34810f04 <input_send_keycodes+0x1c8>
			int ch = table->xlate[key];
34810eec:	e5930008 	ldr	r0, [r3, #8]
34810ef0:	e7d01001 	ldrb	r1, [r0, r1]

			/* If a normal key with an ASCII value, add it! */
			if (ch != 0xff)
34810ef4:	e35100ff 	cmp	r1, #255	; 0xff
				output_ch[ch_count++] = (uchar)ch;
34810ef8:	151b0020 	ldrne	r0, [fp, #-32]
34810efc:	17c0100a 	strbne	r1, [r0, sl]
34810f00:	128aa001 	addne	sl, sl, #1
					keycode[i] & KEY_RELEASE);
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
34810f04:	e2822001 	add	r2, r2, #1
34810f08:	e1520005 	cmp	r2, r5
34810f0c:	baffffed 	blt	34810ec8 <input_send_keycodes+0x18c>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
34810f10:	e3a05000 	mov	r5, #0
34810f14:	ea000004 	b	34810f2c <input_send_keycodes+0x1f0>
		input_queue_ascii(config, ch[i]);
34810f18:	e51b3020 	ldr	r3, [fp, #-32]
34810f1c:	e1a00004 	mov	r0, r4
34810f20:	e7d31005 	ldrb	r1, [r3, r5]
34810f24:	ebffff47 	bl	34810c48 <input_queue_ascii>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
34810f28:	e2855001 	add	r5, r5, #1
34810f2c:	e155000a 	cmp	r5, sl
34810f30:	bafffff8 	blt	34810f18 <input_send_keycodes+0x1dc>
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
34810f34:	e3590000 	cmp	r9, #0
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
34810f38:	e3a00000 	mov	r0, #0
	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
34810f3c:	159450ac 	ldrne	r5, [r4, #172]	; 0xac
34810f40:	059450a8 	ldreq	r5, [r4, #168]	; 0xa8
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
34810f44:	ebffc0ec 	bl	348012fc <get_timer>
34810f48:	e0800005 	add	r0, r0, r5
34810f4c:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	return 0;
}
34810f50:	e3a00000 	mov	r0, #0
34810f54:	e24bd01c 	sub	sp, fp, #28
34810f58:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810f5c:	34821394 	.word	0x34821394

34810f60 <input_add_table>:

int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
34810f60:	e92d4010 	push	{r4, lr}
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810f64:	e5d0c01b 	ldrb	ip, [r0, #27]
34810f68:	e35c0004 	cmp	ip, #4
34810f6c:	0a00000b 	beq	34810fa0 <input_add_table+0x40>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810f70:	e28c4001 	add	r4, ip, #1
34810f74:	e5c0401b 	strb	r4, [r0, #27]
	table->left_keycode = left_keycode;
34810f78:	e28c4006 	add	r4, ip, #6
34810f7c:	e7801204 	str	r1, [r0, r4, lsl #4]
	table->right_keycode = right_keycode;
34810f80:	e0804204 	add	r4, r0, r4, lsl #4
	table->xlate = xlate;
34810f84:	e080020c 	add	r0, r0, ip, lsl #4
34810f88:	e5803068 	str	r3, [r0, #104]	; 0x68
	table->num_entries = num_entries;
34810f8c:	e59d3008 	ldr	r3, [sp, #8]
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810f90:	e5842004 	str	r2, [r4, #4]
	table->xlate = xlate;
	table->num_entries = num_entries;
34810f94:	e580306c 	str	r3, [r0, #108]	; 0x6c

	return 0;
34810f98:	e3a00000 	mov	r0, #0
34810f9c:	e8bd8010 	pop	{r4, pc}
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
34810fa0:	e3e00000 	mvn	r0, #0
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
}
34810fa4:	e8bd8010 	pop	{r4, pc}

34810fa8 <input_init>:

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
34810fa8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810fac:	e1a04000 	mov	r4, r0
34810fb0:	e1a06001 	mov	r6, r1
34810fb4:	e1a05002 	mov	r5, r2
	memset(config, '\0', sizeof(*config));
34810fb8:	e3a01000 	mov	r1, #0
34810fbc:	e3a020b0 	mov	r2, #176	; 0xb0
	return 0;
}

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
34810fc0:	e1a07003 	mov	r7, r3
	memset(config, '\0', sizeof(*config));
34810fc4:	eb002d93 	bl	3481c618 <memset>
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810fc8:	e5d4301b 	ldrb	r3, [r4, #27]

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
34810fcc:	e5c4601a 	strb	r6, [r4, #26]
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810fd0:	e3530004 	cmp	r3, #4
int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
	config->repeat_delay_ms = repeat_delay_ms;
34810fd4:	e58450a8 	str	r5, [r4, #168]	; 0xa8
	config->repeat_rate_ms = repeat_rate_ms;
34810fd8:	e58470ac 	str	r7, [r4, #172]	; 0xac
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810fdc:	0a00002b 	beq	34811090 <input_init+0xe8>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
34810fe0:	e2831006 	add	r1, r3, #6
34810fe4:	e3e00000 	mvn	r0, #0
34810fe8:	e7840201 	str	r0, [r4, r1, lsl #4]
	table->right_keycode = right_keycode;
34810fec:	e0841201 	add	r1, r4, r1, lsl #4
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810ff0:	e2832001 	add	r2, r3, #1
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810ff4:	e5810004 	str	r0, [r1, #4]
	table->xlate = xlate;
34810ff8:	e59f1098 	ldr	r1, [pc, #152]	; 34811098 <input_init+0xf0>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810ffc:	e6ef2072 	uxtb	r2, r2
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
34811000:	e0843203 	add	r3, r4, r3, lsl #4
34811004:	e5831068 	str	r1, [r3, #104]	; 0x68
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811008:	e3520004 	cmp	r2, #4

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
3481100c:	e3a01063 	mov	r1, #99	; 0x63
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811010:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
34811014:	e583106c 	str	r1, [r3, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811018:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
3481101c:	e282c006 	add	ip, r2, #6
34811020:	e3a0502a 	mov	r5, #42	; 0x2a
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811024:	e2823001 	add	r3, r2, #1
	table->left_keycode = left_keycode;
34811028:	e784520c 	str	r5, [r4, ip, lsl #4]
	table->right_keycode = right_keycode;
3481102c:	e084c20c 	add	ip, r4, ip, lsl #4
34811030:	e285500c 	add	r5, r5, #12
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811034:	e6ef3073 	uxtb	r3, r3
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34811038:	e58c5004 	str	r5, [ip, #4]
	table->xlate = xlate;
3481103c:	e59fc058 	ldr	ip, [pc, #88]	; 3481109c <input_init+0xf4>
34811040:	e0842202 	add	r2, r4, r2, lsl #4
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811044:	e3530004 	cmp	r3, #4
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811048:	e5c4301b 	strb	r3, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
3481104c:	e582c068 	str	ip, [r2, #104]	; 0x68
	table->num_entries = num_entries;
34811050:	e582106c 	str	r1, [r2, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811054:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811058:	e2832001 	add	r2, r3, #1
3481105c:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
34811060:	e280001e 	add	r0, r0, #30
34811064:	e2832006 	add	r2, r3, #6
34811068:	e7840202 	str	r0, [r4, r2, lsl #4]
	table->right_keycode = right_keycode;
	table->xlate = xlate;
3481106c:	e28cc064 	add	ip, ip, #100	; 0x64
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34811070:	e0842202 	add	r2, r4, r2, lsl #4
34811074:	e2800044 	add	r0, r0, #68	; 0x44
	table->xlate = xlate;
34811078:	e0844203 	add	r4, r4, r3, lsl #4
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
3481107c:	e5820004 	str	r0, [r2, #4]
	table->xlate = xlate;
34811080:	e584c068 	str	ip, [r4, #104]	; 0x68
	table->num_entries = num_entries;
34811084:	e584106c 	str	r1, [r4, #108]	; 0x6c
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
	}

	return 0;
34811088:	e3a00000 	mov	r0, #0
3481108c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
34811090:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34811094:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34811098:	348213c8 	.word	0x348213c8
3481109c:	348289d0 	.word	0x348289d0

348110a0 <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
348110a0:	e92d4038 	push	{r3, r4, r5, lr}
348110a4:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
348110a8:	ebfff78e 	bl	3480eee8 <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
348110ac:	e2505000 	subs	r5, r0, #0
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
348110b0:	13a00000 	movne	r0, #0
	int error;

	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
348110b4:	18bd8038 	popne	{r3, r4, r5, pc}
348110b8:	e59f0030 	ldr	r0, [pc, #48]	; 348110f0 <input_stdio_register+0x50>
348110bc:	e2844008 	add	r4, r4, #8
348110c0:	ebffdb92 	bl	34807f10 <getenv>
348110c4:	e1a01004 	mov	r1, r4
348110c8:	eb002c7e 	bl	3481c2c8 <strcmp>
348110cc:	e3500000 	cmp	r0, #0
348110d0:	1a000004 	bne	348110e8 <input_stdio_register+0x48>
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
348110d4:	e1a01004 	mov	r1, r4
348110d8:	ebffe2ce 	bl	34809c18 <console_assign>
	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
348110dc:	e3500000 	cmp	r0, #0
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
348110e0:	13e00000 	mvnne	r0, #0
348110e4:	e8bd8038 	pop	{r3, r4, r5, pc}
348110e8:	e1a00005 	mov	r0, r5
}
348110ec:	e8bd8038 	pop	{r3, r4, r5, pc}
348110f0:	34825239 	.word	0x34825239

348110f4 <do_pmic>:
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
348110f4:	e3520001 	cmp	r2, #1
{
	return &pmic;
}

int do_pmic(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348110f8:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
348110fc:	e1a04000 	mov	r4, r0
34811100:	e1a07002 	mov	r7, r2
34811104:	e1a05003 	mov	r5, r3
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
34811108:	da000045 	ble	34811224 <do_pmic+0x130>
		return cmd_usage(cmdtp);

	cmd = argv[1];
3481110c:	e5936004 	ldr	r6, [r3, #4]
	if (strcmp(cmd, "dump") == 0) {
34811110:	e59f1154 	ldr	r1, [pc, #340]	; 3481126c <do_pmic+0x178>
34811114:	e1a00006 	mov	r0, r6
34811118:	eb002c6a 	bl	3481c2c8 <strcmp>
3481111c:	e250a000 	subs	sl, r0, #0
34811120:	1a00001d 	bne	3481119c <do_pmic+0xa8>

	/* No subcommand found */
	return 1;
}

U_BOOT_CMD(
34811124:	e59f6144 	ldr	r6, [pc, #324]	; 34811270 <do_pmic+0x17c>
	return 0;
}

static void pmic_show_info(struct pmic *p)
{
	printf("PMIC: %s\n", p->name);
34811128:	e59f0144 	ldr	r0, [pc, #324]	; 34811274 <do_pmic+0x180>
3481112c:	e5961000 	ldr	r1, [r6]
34811130:	ebffe264 	bl	34809ac8 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34811134:	e1a0400a 	mov	r4, sl
		ret = pmic_reg_read(p, i, &val);
34811138:	e1a0500d 	mov	r5, sp
3481113c:	ea000010 	b	34811184 <do_pmic+0x90>
34811140:	e59f0128 	ldr	r0, [pc, #296]	; 34811270 <do_pmic+0x17c>
34811144:	e1a01004 	mov	r1, r4
34811148:	e1a0200d 	mov	r2, sp
3481114c:	eb0000a2 	bl	348113dc <pmic_reg_read>
		if (ret)
34811150:	e3500000 	cmp	r0, #0
34811154:	0a000001 	beq	34811160 <do_pmic+0x6c>
			puts("PMIC: Registers dump failed\n");
34811158:	e59f0118 	ldr	r0, [pc, #280]	; 34811278 <do_pmic+0x184>
3481115c:	ebffe24f 	bl	34809aa0 <puts>

		if (!(i % 8))
34811160:	e3140007 	tst	r4, #7
34811164:	1a000002 	bne	34811174 <do_pmic+0x80>
			printf("\n0x%02x: ", i);
34811168:	e59f010c 	ldr	r0, [pc, #268]	; 3481127c <do_pmic+0x188>
3481116c:	e1a01004 	mov	r1, r4
34811170:	ebffe254 	bl	34809ac8 <printf>

		printf("%08x ", val);
34811174:	e59f0104 	ldr	r0, [pc, #260]	; 34811280 <do_pmic+0x18c>
34811178:	e59d1000 	ldr	r1, [sp]
3481117c:	ebffe251 	bl	34809ac8 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34811180:	e2844001 	add	r4, r4, #1
34811184:	e5d63006 	ldrb	r3, [r6, #6]
34811188:	e1540003 	cmp	r4, r3
3481118c:	baffffeb 	blt	34811140 <do_pmic+0x4c>
		if (!(i % 8))
			printf("\n0x%02x: ", i);

		printf("%08x ", val);
	}
	puts("\n");
34811190:	e59f00ec 	ldr	r0, [pc, #236]	; 34811284 <do_pmic+0x190>
34811194:	ebffe241 	bl	34809aa0 <puts>
34811198:	ea000016 	b	348111f8 <do_pmic+0x104>
	if (strcmp(cmd, "dump") == 0) {
		pmic_dump(p);
		return 0;
	}

	if (strcmp(cmd, "read") == 0) {
3481119c:	e59f10e4 	ldr	r1, [pc, #228]	; 34811288 <do_pmic+0x194>
348111a0:	e1a00006 	mov	r0, r6
348111a4:	eb002c47 	bl	3481c2c8 <strcmp>
348111a8:	e2501000 	subs	r1, r0, #0
348111ac:	1a000013 	bne	34811200 <do_pmic+0x10c>
		if (argc < 3)
348111b0:	e3570002 	cmp	r7, #2
348111b4:	0a000019 	beq	34811220 <do_pmic+0x12c>
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
348111b8:	e3a02010 	mov	r2, #16
348111bc:	e5950008 	ldr	r0, [r5, #8]
348111c0:	eb003007 	bl	3481d1e4 <simple_strtoul>
348111c4:	e1a04000 	mov	r4, r0

		ret = pmic_reg_read(p, reg, &val);
348111c8:	e1a01004 	mov	r1, r4
348111cc:	e59f009c 	ldr	r0, [pc, #156]	; 34811270 <do_pmic+0x17c>
348111d0:	e28d2004 	add	r2, sp, #4
348111d4:	eb000080 	bl	348113dc <pmic_reg_read>

		if (ret)
348111d8:	e3500000 	cmp	r0, #0
348111dc:	0a000001 	beq	348111e8 <do_pmic+0xf4>
			puts("PMIC: Register read failed\n");
348111e0:	e59f00a4 	ldr	r0, [pc, #164]	; 3481128c <do_pmic+0x198>
348111e4:	ebffe22d 	bl	34809aa0 <puts>

		printf("\n0x%02x: 0x%08x\n", reg, val);
348111e8:	e59f00a0 	ldr	r0, [pc, #160]	; 34811290 <do_pmic+0x19c>
348111ec:	e1a01004 	mov	r1, r4
348111f0:	e59d2004 	ldr	r2, [sp, #4]
348111f4:	ebffe233 	bl	34809ac8 <printf>

		return 0;
348111f8:	e3a00000 	mov	r0, #0
348111fc:	ea000019 	b	34811268 <do_pmic+0x174>
	}

	if (strcmp(cmd, "write") == 0) {
34811200:	e1a00006 	mov	r0, r6
34811204:	e59f1088 	ldr	r1, [pc, #136]	; 34811294 <do_pmic+0x1a0>
34811208:	eb002c2e 	bl	3481c2c8 <strcmp>
3481120c:	e2506000 	subs	r6, r0, #0

		return 0;
	}

	/* No subcommand found */
	return 1;
34811210:	13a00001 	movne	r0, #1
		printf("\n0x%02x: 0x%08x\n", reg, val);

		return 0;
	}

	if (strcmp(cmd, "write") == 0) {
34811214:	1a000013 	bne	34811268 <do_pmic+0x174>
		if (argc < 4)
34811218:	e3570003 	cmp	r7, #3
3481121c:	ca000002 	bgt	3481122c <do_pmic+0x138>
			return cmd_usage(cmdtp);
34811220:	e1a00004 	mov	r0, r4
34811224:	ebffe0d0 	bl	3480956c <cmd_usage>
34811228:	ea00000e 	b	34811268 <do_pmic+0x174>

		reg = simple_strtoul(argv[2], NULL, 16);
3481122c:	e1a01006 	mov	r1, r6
34811230:	e3a02010 	mov	r2, #16
34811234:	e5950008 	ldr	r0, [r5, #8]
34811238:	eb002fe9 	bl	3481d1e4 <simple_strtoul>
		val = simple_strtoul(argv[3], NULL, 16);
3481123c:	e1a01006 	mov	r1, r6

	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
34811240:	e1a04000 	mov	r4, r0
		val = simple_strtoul(argv[3], NULL, 16);
34811244:	e3a02010 	mov	r2, #16
34811248:	e595000c 	ldr	r0, [r5, #12]
3481124c:	eb002fe4 	bl	3481d1e4 <simple_strtoul>

		pmic_reg_write(p, reg, val);
34811250:	e1a01004 	mov	r1, r4
	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
		val = simple_strtoul(argv[3], NULL, 16);
34811254:	e1a02000 	mov	r2, r0
34811258:	e58d0004 	str	r0, [sp, #4]

		pmic_reg_write(p, reg, val);
3481125c:	e59f000c 	ldr	r0, [pc, #12]	; 34811270 <do_pmic+0x17c>
34811260:	eb000033 	bl	34811334 <pmic_reg_write>

		return 0;
34811264:	e1a00006 	mov	r0, r6
	}

	/* No subcommand found */
	return 1;
}
34811268:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
3481126c:	34825cd8 	.word	0x34825cd8
34811270:	3482b96c 	.word	0x3482b96c
34811274:	34826db8 	.word	0x34826db8
34811278:	34826dc2 	.word	0x34826dc2
3481127c:	34826ddf 	.word	0x34826ddf
34811280:	34826de9 	.word	0x34826de9
34811284:	34826197 	.word	0x34826197
34811288:	34824192 	.word	0x34824192
3481128c:	34826def 	.word	0x34826def
34811290:	34826e0b 	.word	0x34826e0b
34811294:	34824197 	.word	0x34824197

34811298 <check_reg>:
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
34811298:	e92d4008 	push	{r3, lr}
	if (reg >= pmic.number_of_regs) {
3481129c:	e59f3024 	ldr	r3, [pc, #36]	; 348112c8 <check_reg+0x30>
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
348112a0:	e1a01000 	mov	r1, r0
	if (reg >= pmic.number_of_regs) {
348112a4:	e5d32006 	ldrb	r2, [r3, #6]
348112a8:	e1500002 	cmp	r0, r2
348112ac:	3a000003 	bcc	348112c0 <check_reg+0x28>
		printf("<reg num> = %d is invalid. Should be less than %d\n",
348112b0:	e59f0014 	ldr	r0, [pc, #20]	; 348112cc <check_reg+0x34>
348112b4:	ebffe203 	bl	34809ac8 <printf>
		       reg, pmic.number_of_regs);
		return -1;
348112b8:	e3e00000 	mvn	r0, #0
348112bc:	e8bd8008 	pop	{r3, pc}
	}
	return 0;
348112c0:	e3a00000 	mov	r0, #0
}
348112c4:	e8bd8008 	pop	{r3, pc}
348112c8:	3482b96c 	.word	0x3482b96c
348112cc:	34826e1c 	.word	0x34826e1c

348112d0 <pmic_set_output>:

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
348112d0:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348112d4:	e1a04002 	mov	r4, r2
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348112d8:	e28d2004 	add	r2, sp, #4
	}
	return 0;
}

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
348112dc:	e1a06000 	mov	r6, r0
348112e0:	e1a05001 	mov	r5, r1
348112e4:	e1a07003 	mov	r7, r3
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348112e8:	eb00003b 	bl	348113dc <pmic_reg_read>
348112ec:	e3500000 	cmp	r0, #0
		return -1;
348112f0:	13e00000 	mvnne	r0, #0

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348112f4:	1a00000a 	bne	34811324 <pmic_set_output+0x54>
348112f8:	e59d3004 	ldr	r3, [sp, #4]
		return -1;

	if (on)
348112fc:	e3570000 	cmp	r7, #0
		val |= out;
34811300:	11834004 	orrne	r4, r3, r4
	else
		val &= ~out;
34811304:	01c34004 	biceq	r4, r3, r4
34811308:	e58d4004 	str	r4, [sp, #4]

	if (pmic_reg_write(p, reg, val))
3481130c:	e1a00006 	mov	r0, r6
34811310:	e1a01005 	mov	r1, r5
34811314:	e59d2004 	ldr	r2, [sp, #4]
34811318:	eb000005 	bl	34811334 <pmic_reg_write>
3481131c:	e3500000 	cmp	r0, #0
		return -1;
34811320:	13e00000 	mvnne	r0, #0

	return 0;
}
34811324:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34811328 <get_pmic>:
}

struct pmic *get_pmic(void)
{
	return &pmic;
}
34811328:	e59f0000 	ldr	r0, [pc, #0]	; 34811330 <get_pmic+0x8>
3481132c:	e12fff1e 	bx	lr
34811330:	3482b96c 	.word	0x3482b96c

34811334 <pmic_reg_write>:
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34811334:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34811338:	e3a03000 	mov	r3, #0
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
3481133c:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
34811340:	e1a00001 	mov	r0, r1
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34811344:	e1a05001 	mov	r5, r1
34811348:	e1a06002 	mov	r6, r2
	unsigned char buf[4] = { 0 };
3481134c:	e58d300c 	str	r3, [sp, #12]

	if (check_reg(reg))
34811350:	ebffffd0 	bl	34811298 <check_reg>
34811354:	e3500000 	cmp	r0, #0
34811358:	1a00001a 	bne	348113c8 <pmic_reg_write+0x94>
		return -1;

	switch (pmic_i2c_tx_num) {
3481135c:	e5d43010 	ldrb	r3, [r4, #16]
34811360:	e3530001 	cmp	r3, #1
34811364:	0a000007 	beq	34811388 <pmic_reg_write+0x54>
34811368:	e3530003 	cmp	r3, #3
3481136c:	1a000007 	bne	34811390 <pmic_reg_write+0x5c>
	case 3:
		buf[0] = (val >> 16) & 0xff;
34811370:	e1a02826 	lsr	r2, r6, #16
34811374:	e5cd200c 	strb	r2, [sp, #12]
		buf[1] = (val >> 8) & 0xff;
34811378:	e1a02426 	lsr	r2, r6, #8
3481137c:	e5cd200d 	strb	r2, [sp, #13]
		buf[2] = val & 0xff;
34811380:	e5cd600e 	strb	r6, [sp, #14]
		break;
34811384:	ea000006 	b	348113a4 <pmic_reg_write+0x70>
	case 1:
		buf[0] = val & 0xff;
34811388:	e5cd600c 	strb	r6, [sp, #12]
		break;
3481138c:	ea000004 	b	348113a4 <pmic_reg_write+0x70>
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34811390:	e59f103c 	ldr	r1, [pc, #60]	; 348113d4 <pmic_reg_write+0xa0>
34811394:	e1a02003 	mov	r2, r3
34811398:	e59f0038 	ldr	r0, [pc, #56]	; 348113d8 <pmic_reg_write+0xa4>
3481139c:	ebffe1c9 	bl	34809ac8 <printf>
348113a0:	ea000008 	b	348113c8 <pmic_reg_write+0x94>
		return -1;
	}

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
348113a4:	e58d3000 	str	r3, [sp]
348113a8:	e5d40008 	ldrb	r0, [r4, #8]
348113ac:	e1a01005 	mov	r1, r5
348113b0:	e3a02001 	mov	r2, #1
348113b4:	e28d300c 	add	r3, sp, #12
348113b8:	ebfffdc2 	bl	34810ac8 <i2c_write>
348113bc:	e3500000 	cmp	r0, #0
		return -1;
348113c0:	13e00000 	mvnne	r0, #0
348113c4:	ea000000 	b	348113cc <pmic_reg_write+0x98>
int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
		return -1;
348113c8:	e3e00000 	mvn	r0, #0

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;

	return 0;
}
348113cc:	e28dd010 	add	sp, sp, #16
348113d0:	e8bd8070 	pop	{r4, r5, r6, pc}
348113d4:	3482142c 	.word	0x3482142c
348113d8:	34826ebe 	.word	0x34826ebe

348113dc <pmic_reg_read>:

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348113dc:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
348113e0:	e3a03000 	mov	r3, #0

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348113e4:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };
	u32 ret_val = 0;

	if (check_reg(reg))
348113e8:	e1a00001 	mov	r0, r1

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348113ec:	e1a06001 	mov	r6, r1
348113f0:	e1a05002 	mov	r5, r2
	unsigned char buf[4] = { 0 };
348113f4:	e58d300c 	str	r3, [sp, #12]
	u32 ret_val = 0;
348113f8:	e58d3008 	str	r3, [sp, #8]

	if (check_reg(reg))
348113fc:	ebffffa5 	bl	34811298 <check_reg>
34811400:	e3500000 	cmp	r0, #0
34811404:	1a00001f 	bne	34811488 <pmic_reg_read+0xac>
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34811408:	e5d43010 	ldrb	r3, [r4, #16]
3481140c:	e5d40008 	ldrb	r0, [r4, #8]
34811410:	e58d3000 	str	r3, [sp]
34811414:	e1a01006 	mov	r1, r6
34811418:	e3a02001 	mov	r2, #1
3481141c:	e28d300c 	add	r3, sp, #12
34811420:	ebfffd4b 	bl	34810954 <i2c_read>
34811424:	e3500000 	cmp	r0, #0
34811428:	1a000016 	bne	34811488 <pmic_reg_read+0xac>
		return -1;

	switch (pmic_i2c_tx_num) {
3481142c:	e5d42010 	ldrb	r2, [r4, #16]
34811430:	e3520001 	cmp	r2, #1
34811434:	0a000008 	beq	3481145c <pmic_reg_read+0x80>
34811438:	e3520003 	cmp	r2, #3
3481143c:	1a00000e 	bne	3481147c <pmic_reg_read+0xa0>
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
34811440:	e5dd300d 	ldrb	r3, [sp, #13]
34811444:	e5dd200c 	ldrb	r2, [sp, #12]
34811448:	e1a03403 	lsl	r3, r3, #8
3481144c:	e1833802 	orr	r3, r3, r2, lsl #16
34811450:	e5dd200e 	ldrb	r2, [sp, #14]
34811454:	e1833002 	orr	r3, r3, r2
34811458:	ea000000 	b	34811460 <pmic_reg_read+0x84>
		break;
	case 1:
		ret_val = buf[0];
3481145c:	e5dd300c 	ldrb	r3, [sp, #12]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34811460:	e1a00005 	mov	r0, r5
34811464:	e28d1008 	add	r1, sp, #8
34811468:	e3a02004 	mov	r2, #4
	switch (pmic_i2c_tx_num) {
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
		break;
	case 1:
		ret_val = buf[0];
3481146c:	e58d3008 	str	r3, [sp, #8]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34811470:	eb002c8c 	bl	3481c6a8 <memcpy>

	return 0;
34811474:	e3a00000 	mov	r0, #0
34811478:	ea000003 	b	3481148c <pmic_reg_read+0xb0>
		break;
	case 1:
		ret_val = buf[0];
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
3481147c:	e59f0010 	ldr	r0, [pc, #16]	; 34811494 <pmic_reg_read+0xb8>
34811480:	e59f1010 	ldr	r1, [pc, #16]	; 34811498 <pmic_reg_read+0xbc>
34811484:	ebffe18f 	bl	34809ac8 <printf>

	if (check_reg(reg))
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;
34811488:	e3e00000 	mvn	r0, #0
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));

	return 0;
}
3481148c:	e28dd010 	add	sp, sp, #16
34811490:	e8bd8070 	pop	{r4, r5, r6, pc}
34811494:	34826ebe 	.word	0x34826ebe
34811498:	3482143c 	.word	0x3482143c

3481149c <pmic_probe>:

int pmic_probe(struct pmic *p)
{
3481149c:	e92d4010 	push	{r4, lr}
348114a0:	e1a04000 	mov	r4, r0

static inline void I2C_SET_BUS(unsigned int bus) __attribute__((always_inline));
static inline void I2C_SET_BUS(unsigned int bus)
{
	if (I2C_MULTI_BUS)
		i2c_set_bus_num(bus);
348114a4:	e5d00004 	ldrb	r0, [r0, #4]
348114a8:	ebfffcf7 	bl	3481088c <i2c_set_bus_num>
	I2C_SET_BUS(p->bus);
	debug("PMIC:%s probed!\n", p->name);
	if (i2c_probe(pmic_i2c_addr)) {
348114ac:	e5d40008 	ldrb	r0, [r4, #8]
348114b0:	ebfffd1c 	bl	34810928 <i2c_probe>
348114b4:	e3500000 	cmp	r0, #0
348114b8:	08bd8010 	popeq	{r4, pc}
		printf("Can't find PMIC:%s\n", p->name);
348114bc:	e5941000 	ldr	r1, [r4]
348114c0:	e59f0008 	ldr	r0, [pc, #8]	; 348114d0 <pmic_probe+0x34>
348114c4:	ebffe17f 	bl	34809ac8 <printf>
		return -1;
348114c8:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
348114cc:	e8bd8010 	pop	{r4, pc}
348114d0:	34826ed5 	.word	0x34826ed5

348114d4 <pmic_init>:
#include <common.h>
#include <pmic.h>
#include <max8998_pmic.h>

int pmic_init(void)
{
348114d4:	e92d4010 	push	{r4, lr}
	struct pmic *p = get_pmic();
348114d8:	ebffff92 	bl	34811328 <get_pmic>
348114dc:	e1a04000 	mov	r4, r0
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");
348114e0:	e59f0030 	ldr	r0, [pc, #48]	; 34811518 <pmic_init+0x44>
348114e4:	ebffe16d 	bl	34809aa0 <puts>

	p->name = name;
348114e8:	e59f302c 	ldr	r3, [pc, #44]	; 3481151c <pmic_init+0x48>
	p->interface = PMIC_I2C;
348114ec:	e3a00000 	mov	r0, #0
	struct pmic *p = get_pmic();
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
348114f0:	e5843000 	str	r3, [r4]
	p->interface = PMIC_I2C;
	p->number_of_regs = PMIC_NUM_OF_REGS;
348114f4:	e3a0302d 	mov	r3, #45	; 0x2d
348114f8:	e5c43006 	strb	r3, [r4, #6]
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
348114fc:	e2833039 	add	r3, r3, #57	; 0x39
34811500:	e5c43008 	strb	r3, [r4, #8]
	p->hw.i2c.tx_num = 1;
34811504:	e3a03001 	mov	r3, #1
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
	p->interface = PMIC_I2C;
34811508:	e5c40005 	strb	r0, [r4, #5]
	p->number_of_regs = PMIC_NUM_OF_REGS;
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
	p->hw.i2c.tx_num = 1;
3481150c:	e5c43010 	strb	r3, [r4, #16]
	p->bus = I2C_PMIC;
34811510:	e5c40004 	strb	r0, [r4, #4]

	return 0;
}
34811514:	e8bd8010 	pop	{r4, pc}
34811518:	34826ee9 	.word	0x34826ee9
3481151c:	3482144c 	.word	0x3482144c

34811520 <__fswab32>:
34811520:	e6bf0f30 	rev	r0, r0
34811524:	e12fff1e 	bx	lr

34811528 <__board_mmc_getcd>:
static struct list_head mmc_devices;
static int cur_dev_num = -1;

int __board_mmc_getcd(struct mmc *mmc) {
	return -1;
}
34811528:	e3e00000 	mvn	r0, #0
3481152c:	e12fff1e 	bx	lr

34811530 <mmc_send_cmd>:
static inline void mmc_bounce_buffer_stop(struct mmc_data *backup,
					struct mmc_data *orig) { }
#endif

int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
34811530:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34811534:	e1a04000 	mov	r4, r0
34811538:	e1a06001 	mov	r6, r1
3481153c:	e1a05002 	mov	r5, r2
	struct mmc_data backup;
	int ret;

	memset(&backup, 0, sizeof(backup));
34811540:	e1a0000d 	mov	r0, sp
34811544:	e3a01000 	mov	r1, #0
34811548:	e3a02010 	mov	r2, #16
3481154c:	eb002c31 	bl	3481c618 <memset>
		default:
			printf("\t\tERROR MMC rsp not supported\n");
			break;
	}
#else
	ret = mmc->send_cmd(mmc, cmd, data);
34811550:	e5943110 	ldr	r3, [r4, #272]	; 0x110
34811554:	e1a00004 	mov	r0, r4
34811558:	e1a01006 	mov	r1, r6
3481155c:	e1a02005 	mov	r2, r5
34811560:	e12fff33 	blx	r3
#endif
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}
34811564:	e28dd010 	add	sp, sp, #16
34811568:	e8bd8070 	pop	{r4, r5, r6, pc}

3481156c <mmc_send_status>:

int mmc_send_status(struct mmc *mmc, int timeout)
{
3481156c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34811570:	e3a0300d 	mov	r3, #13
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811574:	e24dd024 	sub	sp, sp, #36	; 0x24
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34811578:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
3481157c:	e3a03015 	mov	r3, #21
34811580:	e58d3008 	str	r3, [sp, #8]
	if (!mmc_host_is_spi(mmc))
34811584:	e5903050 	ldr	r3, [r0, #80]	; 0x50
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811588:	e1a06000 	mov	r6, r0
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
3481158c:	e3130b01 	tst	r3, #1024	; 0x400
		cmd.cmdarg = mmc->rca << 16;
34811590:	01d038b0 	ldrheq	r3, [r0, #128]	; 0x80
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811594:	e1a04001 	mov	r4, r1
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;
34811598:	01a03803 	lsleq	r3, r3, #16
3481159c:	058d300c 	streq	r3, [sp, #12]
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
348115a0:	e3a05005 	mov	r5, #5
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
348115a4:	e28d7004 	add	r7, sp, #4
348115a8:	e1a00006 	mov	r0, r6
348115ac:	e1a01007 	mov	r1, r7
348115b0:	e3a02000 	mov	r2, #0
348115b4:	ebffffdd 	bl	34811530 <mmc_send_cmd>
		if (!err) {
348115b8:	e3500000 	cmp	r0, #0
348115bc:	1a00000d 	bne	348115f8 <mmc_send_status+0x8c>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348115c0:	e59d1010 	ldr	r1, [sp, #16]
348115c4:	e3110c01 	tst	r1, #256	; 0x100
348115c8:	0a000002 	beq	348115d8 <mmc_send_status+0x6c>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
348115cc:	e2013c1e 	and	r3, r1, #7680	; 0x1e00
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348115d0:	e3530c0e 	cmp	r3, #3584	; 0xe00
348115d4:	1a00000d 	bne	34811610 <mmc_send_status+0xa4>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
			     MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
348115d8:	e59f3050 	ldr	r3, [pc, #80]	; 34811630 <mmc_send_status+0xc4>
348115dc:	e0013003 	and	r3, r1, r3
348115e0:	e3530000 	cmp	r3, #0
348115e4:	0a000005 	beq	34811600 <mmc_send_status+0x94>
				printf("Status Error: 0x%08X\n",
348115e8:	e59f0044 	ldr	r0, [pc, #68]	; 34811634 <mmc_send_status+0xc8>
348115ec:	ebffe135 	bl	34809ac8 <printf>
					cmd.response[0]);
				return COMM_ERR;
348115f0:	e3e00011 	mvn	r0, #17
348115f4:	ea00000b 	b	34811628 <mmc_send_status+0xbc>
			}
		} else if (--retries < 0)
348115f8:	e2555001 	subs	r5, r5, #1
348115fc:	4a000009 	bmi	34811628 <mmc_send_status+0xbc>
			return err;

		udelay(1000);
34811600:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811604:	eb002cb2 	bl	3481c8d4 <udelay>

	} while (timeout--);
34811608:	e2544001 	subs	r4, r4, #1
3481160c:	2affffe5 	bcs	348115a8 <mmc_send_status+0x3c>

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34811610:	e3540000 	cmp	r4, #0
		printf("Timeout waiting card ready\n");
		return TIMEOUT;
	}

	return 0;
34811614:	c3a00000 	movgt	r0, #0

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34811618:	ca000002 	bgt	34811628 <mmc_send_status+0xbc>
		printf("Timeout waiting card ready\n");
3481161c:	e59f0014 	ldr	r0, [pc, #20]	; 34811638 <mmc_send_status+0xcc>
34811620:	ebffe128 	bl	34809ac8 <printf>
		return TIMEOUT;
34811624:	e3e00012 	mvn	r0, #18
	}

	return 0;
}
34811628:	e28dd024 	add	sp, sp, #36	; 0x24
3481162c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34811630:	fdf94080 	.word	0xfdf94080
34811634:	34826efa 	.word	0x34826efa
34811638:	34826f10 	.word	0x34826f10

3481163c <mmc_set_blocklen>:

int mmc_set_blocklen(struct mmc *mmc, int len)
{
3481163c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34811640:	e3a03010 	mov	r3, #16

	return 0;
}

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34811644:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34811648:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = len;
3481164c:	e58d100c 	str	r1, [sp, #12]
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34811650:	e3a03015 	mov	r3, #21
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34811654:	e28d1004 	add	r1, sp, #4
34811658:	e3a02000 	mov	r2, #0
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
3481165c:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34811660:	ebffffb2 	bl	34811530 <mmc_send_cmd>
}
34811664:	e28dd024 	add	sp, sp, #36	; 0x24
34811668:	e8bd8000 	pop	{pc}

3481166c <find_mmc_device>:
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
3481166c:	e59f2038 	ldr	r2, [pc, #56]	; 348116ac <find_mmc_device+0x40>

	return mmc_send_cmd(mmc, &cmd, NULL);
}

struct mmc *find_mmc_device(int dev_num)
{
34811670:	e92d4008 	push	{r3, lr}
34811674:	e1a01000 	mov	r1, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811678:	e5923000 	ldr	r3, [r2]
3481167c:	ea000004 	b	34811694 <find_mmc_device+0x28>
		m = list_entry(entry, struct mmc, link);

		if (m->block_dev.dev == dev_num)
34811680:	e593c0a4 	ldr	ip, [r3, #164]	; 0xa4
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
		m = list_entry(entry, struct mmc, link);
34811684:	e1a00003 	mov	r0, r3

		if (m->block_dev.dev == dev_num)
34811688:	e15c0001 	cmp	ip, r1
3481168c:	08bd8008 	popeq	{r3, pc}
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811690:	e5933000 	ldr	r3, [r3]
34811694:	e1530002 	cmp	r3, r2
34811698:	1afffff8 	bne	34811680 <find_mmc_device+0x14>

		if (m->block_dev.dev == dev_num)
			return m;
	}

	printf("MMC Device %d not found\n", dev_num);
3481169c:	e59f000c 	ldr	r0, [pc, #12]	; 348116b0 <find_mmc_device+0x44>
348116a0:	ebffe108 	bl	34809ac8 <printf>

	return NULL;
348116a4:	e3a00000 	mov	r0, #0
}
348116a8:	e8bd8008 	pop	{r3, pc}
348116ac:	3482b98c 	.word	0x3482b98c
348116b0:	34826f2c 	.word	0x34826f2c

348116b4 <mmc_berase>:
	return err;
}

static unsigned long
mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
{
348116b4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348116b8:	e24dd028 	sub	sp, sp, #40	; 0x28
348116bc:	e1a05001 	mov	r5, r1
348116c0:	e1a06002 	mov	r6, r2
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
348116c4:	ebffffe8 	bl	3481166c <find_mmc_device>
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
348116c8:	e2504000 	subs	r4, r0, #0
		return -1;
348116cc:	03e07000 	mvneq	r7, #0
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
348116d0:	0a000056 	beq	34811830 <mmc_berase+0x17c>
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
348116d4:	e5947090 	ldr	r7, [r4, #144]	; 0x90
348116d8:	e1a00005 	mov	r0, r5
348116dc:	e1a01007 	mov	r1, r7
348116e0:	eb0039b3 	bl	3481fdb4 <__aeabi_uidivmod>
348116e4:	e3510000 	cmp	r1, #0
348116e8:	1a000004 	bne	34811700 <mmc_berase+0x4c>
348116ec:	e1a00006 	mov	r0, r6
348116f0:	e1a01007 	mov	r1, r7
348116f4:	eb0039ae 	bl	3481fdb4 <__aeabi_uidivmod>
348116f8:	e3510000 	cmp	r1, #0
348116fc:	0a000045 	beq	34811818 <mmc_berase+0x164>
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
34811700:	e0853007 	add	r3, r5, r7
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
34811704:	e2672000 	rsb	r2, r7, #0
		       ((start + blkcnt + mmc->erase_grp_size)
34811708:	e0833006 	add	r3, r3, r6
		       & ~(mmc->erase_grp_size - 1)) - 1);
3481170c:	e0033002 	and	r3, r3, r2

	if (!mmc)
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
34811710:	e1a01007 	mov	r1, r7
34811714:	e0052002 	and	r2, r5, r2
34811718:	e2433001 	sub	r3, r3, #1
3481171c:	e59f0118 	ldr	r0, [pc, #280]	; 3481183c <mmc_berase+0x188>
34811720:	ebffe0e8 	bl	34809ac8 <printf>
34811724:	ea00003b 	b	34811818 <mmc_berase+0x164>
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34811728:	e5943090 	ldr	r3, [r4, #144]	; 0x90
			mmc->erase_grp_size : (blkcnt - blk);
3481172c:	e067a006 	rsb	sl, r7, r6
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34811730:	e15a0003 	cmp	sl, r3
34811734:	21a0a003 	movcs	sl, r3
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34811738:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
3481173c:	e0872005 	add	r2, r7, r5
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34811740:	e3530000 	cmp	r3, #0
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811744:	0594308c 	ldreq	r3, [r4, #140]	; 0x8c
34811748:	e242b001 	sub	fp, r2, #1
3481174c:	008bb00a 	addeq	fp, fp, sl
		start *= mmc->write_bl_len;
34811750:	00020293 	muleq	r2, r3, r2
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811754:	000b0b93 	muleq	fp, r3, fp
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34811758:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
3481175c:	108bb00a 	addne	fp, fp, sl
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34811760:	e2033802 	and	r3, r3, #131072	; 0x20000
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811764:	e3530000 	cmp	r3, #0
34811768:	03a01023 	moveq	r1, #35	; 0x23
3481176c:	13a01020 	movne	r1, #32
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
34811770:	e58d2014 	str	r2, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
34811774:	e3a02015 	mov	r2, #21
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811778:	03a03024 	moveq	r3, #36	; 0x24
3481177c:	13a03021 	movne	r3, #33	; 0x21
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
34811780:	e1cd10bc 	strh	r1, [sp, #12]
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;
34811784:	e58d2010 	str	r2, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811788:	e1a00004 	mov	r0, r4
3481178c:	e3a02000 	mov	r2, #0
34811790:	e1a01009 	mov	r1, r9
34811794:	e58d3004 	str	r3, [sp, #4]
34811798:	ebffff64 	bl	34811530 <mmc_send_cmd>
	if (err)
3481179c:	e2502000 	subs	r2, r0, #0
348117a0:	e59d3004 	ldr	r3, [sp, #4]
348117a4:	1a000011 	bne	348117f0 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = end_cmd;
	cmd.cmdarg = end;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117a8:	e1a00004 	mov	r0, r4
348117ac:	e1a01009 	mov	r1, r9

	err = mmc_send_cmd(mmc, &cmd, NULL);
	if (err)
		goto err_out;

	cmd.cmdidx = end_cmd;
348117b0:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = end;
348117b4:	e58db014 	str	fp, [sp, #20]

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117b8:	ebffff5c 	bl	34811530 <mmc_send_cmd>
	if (err)
348117bc:	e2502000 	subs	r2, r0, #0
348117c0:	1a00000a 	bne	348117f0 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
348117c4:	e3a03026 	mov	r3, #38	; 0x26
348117c8:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = SECURE_ERASE;
348117cc:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
348117d0:	e58d3014 	str	r3, [sp, #20]
	cmd.resp_type = MMC_RSP_R1b;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117d4:	e1a00004 	mov	r0, r4
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
348117d8:	e2833176 	add	r3, r3, #-2147483619	; 0x8000001d

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117dc:	e1a01009 	mov	r1, r9
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
348117e0:	e58d3010 	str	r3, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117e4:	ebffff51 	bl	34811530 <mmc_send_cmd>
	if (err)
348117e8:	e250b000 	subs	fp, r0, #0
348117ec:	0a000002 	beq	348117fc <mmc_berase+0x148>
		goto err_out;

	return 0;

err_out:
	puts("mmc erase failed\n");
348117f0:	e59f0048 	ldr	r0, [pc, #72]	; 34811840 <mmc_berase+0x18c>
348117f4:	ebffe0a9 	bl	34809aa0 <puts>
348117f8:	ea00000c 	b	34811830 <mmc_berase+0x17c>
			break;

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
348117fc:	e1a00004 	mov	r0, r4
34811800:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811804:	ebffff58 	bl	3481156c <mmc_send_status>
34811808:	e3500000 	cmp	r0, #0
3481180c:	1a000006 	bne	3481182c <mmc_berase+0x178>
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
		if (err)
			break;

		blk += blk_r;
34811810:	e087700a 	add	r7, r7, sl
34811814:	ea000001 	b	34811820 <mmc_berase+0x16c>

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
34811818:	e3a07000 	mov	r7, #0

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481181c:	e28d900c 	add	r9, sp, #12
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
34811820:	e1570006 	cmp	r7, r6
34811824:	3affffbf 	bcc	34811728 <mmc_berase+0x74>
34811828:	ea000000 	b	34811830 <mmc_berase+0x17c>

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
			return 0;
3481182c:	e1a0700b 	mov	r7, fp
	}

	return blk;
}
34811830:	e1a00007 	mov	r0, r7
34811834:	e28dd028 	add	sp, sp, #40	; 0x28
34811838:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481183c:	34826f45 	.word	0x34826f45
34811840:	34826fa2 	.word	0x34826fa2

34811844 <mmc_bwrite>:
	return blkcnt;
}

static ulong
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
34811844:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811848:	e24dd030 	sub	sp, sp, #48	; 0x30
3481184c:	e1a04002 	mov	r4, r2
34811850:	e1a05001 	mov	r5, r1
34811854:	e1a09003 	mov	r9, r3
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
34811858:	ebffff83 	bl	3481166c <find_mmc_device>
	if (!mmc)
3481185c:	e2506000 	subs	r6, r0, #0
		return 0;
34811860:	01a04006 	moveq	r4, r6
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34811864:	0a000052 	beq	348119b4 <mmc_bwrite+0x170>
		return 0;

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
34811868:	e596108c 	ldr	r1, [r6, #140]	; 0x8c
3481186c:	ebffff72 	bl	3481163c <mmc_set_blocklen>
34811870:	e3500000 	cmp	r0, #0
34811874:	1a00004b 	bne	348119a8 <mmc_bwrite+0x164>
34811878:	e1a0b004 	mov	fp, r4
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
3481187c:	e1a0a004 	mov	sl, r4

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811880:	e5964120 	ldr	r4, [r6, #288]	; 0x120
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811884:	e59620b0 	ldr	r2, [r6, #176]	; 0xb0

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811888:	e15b0004 	cmp	fp, r4
3481188c:	31a0400b 	movcc	r4, fp
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811890:	e0847005 	add	r7, r4, r5
34811894:	e1570002 	cmp	r7, r2
34811898:	9a000003 	bls	348118ac <mmc_bwrite+0x68>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
3481189c:	e1a01007 	mov	r1, r7
348118a0:	e59f0118 	ldr	r0, [pc, #280]	; 348119c0 <mmc_bwrite+0x17c>
348118a4:	ebffe087 	bl	34809ac8 <printf>
348118a8:	ea000036 	b	34811988 <mmc_bwrite+0x144>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (blkcnt > 1)
348118ac:	e3540001 	cmp	r4, #1
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
348118b0:	83a03019 	movhi	r3, #25
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
348118b4:	93a03018 	movls	r3, #24
348118b8:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
348118bc:	e5963040 	ldr	r3, [r6, #64]	; 0x40
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
348118c0:	e1a00006 	mov	r0, r6
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
348118c4:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
348118c8:	0596308c 	ldreq	r3, [r6, #140]	; 0x8c
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
348118cc:	e28d1004 	add	r1, sp, #4
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
348118d0:	00050593 	muleq	r5, r3, r5

	cmd.resp_type = MMC_RSP_R1;
348118d4:	e3a03015 	mov	r3, #21
348118d8:	e58d3008 	str	r3, [sp, #8]

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
348118dc:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
348118e0:	e28d2020 	add	r2, sp, #32

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
348118e4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_WRITE;
348118e8:	e3a03002 	mov	r3, #2
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
348118ec:	e58d500c 	str	r5, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
348118f0:	e58d9020 	str	r9, [sp, #32]
	data.blocks = blkcnt;
348118f4:	e58d4028 	str	r4, [sp, #40]	; 0x28
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;
348118f8:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data)) {
348118fc:	ebffff0b 	bl	34811530 <mmc_send_cmd>
34811900:	e2505000 	subs	r5, r0, #0
34811904:	0a000002 	beq	34811914 <mmc_bwrite+0xd0>
		printf("mmc write failed\n");
34811908:	e59f00b4 	ldr	r0, [pc, #180]	; 348119c4 <mmc_bwrite+0x180>
3481190c:	ebffe06d 	bl	34809ac8 <printf>
34811910:	ea00001c 	b	34811988 <mmc_bwrite+0x144>
	}

	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
34811914:	e5963050 	ldr	r3, [r6, #80]	; 0x50
34811918:	e3130b01 	tst	r3, #1024	; 0x400
3481191c:	13a03000 	movne	r3, #0
34811920:	03a03001 	moveq	r3, #1
34811924:	e3540001 	cmp	r4, #1
34811928:	93a03000 	movls	r3, #0
3481192c:	82033001 	andhi	r3, r3, #1
34811930:	e3530000 	cmp	r3, #0
34811934:	0a00000e 	beq	34811974 <mmc_bwrite+0x130>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811938:	e3a0300c 	mov	r3, #12
3481193c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811940:	e1a00006 	mov	r0, r6
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811944:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811948:	e28d1004 	add	r1, sp, #4
3481194c:	e1a02005 	mov	r2, r5
	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34811950:	e58d500c 	str	r5, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34811954:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811958:	ebfffef4 	bl	34811530 <mmc_send_cmd>
3481195c:	e3500000 	cmp	r0, #0
34811960:	0a000003 	beq	34811974 <mmc_bwrite+0x130>
			printf("mmc fail to send stop cmd\n");
34811964:	e59f005c 	ldr	r0, [pc, #92]	; 348119c8 <mmc_bwrite+0x184>
34811968:	ebffe056 	bl	34809ac8 <printf>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
3481196c:	e1a04005 	mov	r4, r5
34811970:	ea00000f 	b	348119b4 <mmc_bwrite+0x170>
			return 0;
		}
	}

	/* Waiting for the ready status */
	if (mmc_send_status(mmc, timeout))
34811974:	e1a00006 	mov	r0, r6
34811978:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481197c:	ebfffefa 	bl	3481156c <mmc_send_status>
34811980:	e3500000 	cmp	r0, #0
34811984:	0a000001 	beq	34811990 <mmc_bwrite+0x14c>
	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
34811988:	e3540000 	cmp	r4, #0
3481198c:	1a000005 	bne	348119a8 <mmc_bwrite+0x164>
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);
34811990:	e05bb004 	subs	fp, fp, r4
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34811994:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	} while (blocks_todo > 0);
34811998:	0a000004 	beq	348119b0 <mmc_bwrite+0x16c>
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
3481199c:	e0299493 	mla	r9, r3, r4, r9
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
348119a0:	e1a05007 	mov	r5, r7
348119a4:	eaffffb5 	b	34811880 <mmc_bwrite+0x3c>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
348119a8:	e3a04000 	mov	r4, #0
348119ac:	ea000000 	b	348119b4 <mmc_bwrite+0x170>
348119b0:	e1a0400a 	mov	r4, sl
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
348119b4:	e1a00004 	mov	r0, r4
348119b8:	e28dd030 	add	sp, sp, #48	; 0x30
348119bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348119c0:	34826fb4 	.word	0x34826fb4
348119c4:	34826fe0 	.word	0x34826fe0
348119c8:	34826ff2 	.word	0x34826ff2

348119cc <mmc_read_blocks>:

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
348119cc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
348119d0:	e3530001 	cmp	r3, #1

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
348119d4:	e24dd034 	sub	sp, sp, #52	; 0x34
348119d8:	e1a05003 	mov	r5, r3
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
348119dc:	83a03012 	movhi	r3, #18
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
348119e0:	93a03011 	movls	r3, #17
348119e4:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
348119e8:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
348119ec:	e28d7004 	add	r7, sp, #4
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
348119f0:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
348119f4:	05903088 	ldreq	r3, [r0, #136]	; 0x88

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
348119f8:	e58d1020 	str	r1, [sp, #32]
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
348119fc:	00020293 	muleq	r2, r3, r2

	cmd.resp_type = MMC_RSP_R1;
34811a00:	e3a03015 	mov	r3, #21
34811a04:	e58d3008 	str	r3, [sp, #8]

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34811a08:	e5903088 	ldr	r3, [r0, #136]	; 0x88
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34811a0c:	e58d200c 	str	r2, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34811a10:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811a14:	e1a01007 	mov	r1, r7
	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34811a18:	e3a03001 	mov	r3, #1

	if (mmc_send_cmd(mmc, &cmd, &data))
34811a1c:	e28d2020 	add	r2, sp, #32

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811a20:	e1a04000 	mov	r4, r0
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
34811a24:	e58d5028 	str	r5, [sp, #40]	; 0x28
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34811a28:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data))
34811a2c:	ebfffebf 	bl	34811530 <mmc_send_cmd>
34811a30:	e2506000 	subs	r6, r0, #0
		return 0;
34811a34:	13a00000 	movne	r0, #0
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811a38:	1a000011 	bne	34811a84 <mmc_read_blocks+0xb8>
		return 0;

	if (blkcnt > 1) {
34811a3c:	e3550001 	cmp	r5, #1
34811a40:	9a00000e 	bls	34811a80 <mmc_read_blocks+0xb4>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811a44:	e3a0300c 	mov	r3, #12
34811a48:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811a4c:	e1a00004 	mov	r0, r4
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811a50:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811a54:	e1a01007 	mov	r1, r7
34811a58:	e1a02006 	mov	r2, r6
	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34811a5c:	e58d600c 	str	r6, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34811a60:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811a64:	ebfffeb1 	bl	34811530 <mmc_send_cmd>
34811a68:	e3500000 	cmp	r0, #0
34811a6c:	0a000003 	beq	34811a80 <mmc_read_blocks+0xb4>
			printf("mmc fail to send stop cmd\n");
34811a70:	e59f0014 	ldr	r0, [pc, #20]	; 34811a8c <mmc_read_blocks+0xc0>
34811a74:	ebffe013 	bl	34809ac8 <printf>
			return 0;
34811a78:	e1a00006 	mov	r0, r6
34811a7c:	ea000000 	b	34811a84 <mmc_read_blocks+0xb8>
		}
	}

	return blkcnt;
34811a80:	e1a00005 	mov	r0, r5
}
34811a84:	e28dd034 	add	sp, sp, #52	; 0x34
34811a88:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34811a8c:	34826ff2 	.word	0x34826ff2

34811a90 <mmc_bread>:

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811a90:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811a94:	e2524000 	subs	r4, r2, #0

	return blkcnt;
}

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811a98:	e1a06001 	mov	r6, r1
34811a9c:	e1a07003 	mov	r7, r3
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811aa0:	0a000020 	beq	34811b28 <mmc_bread+0x98>
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
34811aa4:	ebfffef0 	bl	3481166c <find_mmc_device>
	if (!mmc)
34811aa8:	e2505000 	subs	r5, r0, #0
		return 0;
34811aac:	01a04005 	moveq	r4, r5

	if (blkcnt == 0)
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34811ab0:	0a00001c 	beq	34811b28 <mmc_bread+0x98>
		return 0;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811ab4:	e59520b0 	ldr	r2, [r5, #176]	; 0xb0
34811ab8:	e0841006 	add	r1, r4, r6
34811abc:	e1510002 	cmp	r1, r2
34811ac0:	9a000002 	bls	34811ad0 <mmc_bread+0x40>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34811ac4:	e59f0064 	ldr	r0, [pc, #100]	; 34811b30 <mmc_bread+0xa0>
34811ac8:	ebffdffe 	bl	34809ac8 <printf>
34811acc:	ea000014 	b	34811b24 <mmc_bread+0x94>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
34811ad0:	e5951088 	ldr	r1, [r5, #136]	; 0x88
34811ad4:	ebfffed8 	bl	3481163c <mmc_set_blocklen>
34811ad8:	e3500000 	cmp	r0, #0
34811adc:	1a000010 	bne	34811b24 <mmc_bread+0x94>
34811ae0:	e1a0a004 	mov	sl, r4
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811ae4:	e5959120 	ldr	r9, [r5, #288]	; 0x120
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34811ae8:	e1a00005 	mov	r0, r5

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811aec:	e15a0009 	cmp	sl, r9
34811af0:	31a0900a 	movcc	r9, sl
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34811af4:	e1a01007 	mov	r1, r7
34811af8:	e1a02006 	mov	r2, r6
34811afc:	e1a03009 	mov	r3, r9
34811b00:	ebffffb1 	bl	348119cc <mmc_read_blocks>
34811b04:	e1500009 	cmp	r0, r9
34811b08:	1a000005 	bne	34811b24 <mmc_bread+0x94>
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);
34811b0c:	e05aa000 	subs	sl, sl, r0
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
34811b10:	e5953088 	ldr	r3, [r5, #136]	; 0x88
	} while (blocks_todo > 0);
34811b14:	0a000003 	beq	34811b28 <mmc_bread+0x98>
	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
34811b18:	e0866000 	add	r6, r6, r0
		dst += cur * mmc->read_bl_len;
34811b1c:	e0277093 	mla	r7, r3, r0, r7
34811b20:	eaffffef 	b	34811ae4 <mmc_bread+0x54>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
34811b24:	e3a04000 	mov	r4, #0
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34811b28:	e1a00004 	mov	r0, r4
34811b2c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34811b30:	34826fb4 	.word	0x34826fb4

34811b34 <mmc_go_idle>:

int mmc_go_idle(struct mmc* mmc)
{
34811b34:	e92d4010 	push	{r4, lr}
34811b38:	e1a04000 	mov	r4, r0
34811b3c:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	udelay(1000);
34811b40:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811b44:	eb002b62 	bl	3481c8d4 <udelay>

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811b48:	e3a02000 	mov	r2, #0
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b4c:	e1a00004 	mov	r0, r4
34811b50:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811b54:	e1cd20b4 	strh	r2, [sp, #4]
	cmd.cmdarg = 0;
34811b58:	e58d200c 	str	r2, [sp, #12]
	cmd.resp_type = MMC_RSP_NONE;
34811b5c:	e58d2008 	str	r2, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b60:	ebfffe72 	bl	34811530 <mmc_send_cmd>

	if (err)
34811b64:	e2504000 	subs	r4, r0, #0
34811b68:	1a000001 	bne	34811b74 <mmc_go_idle+0x40>
		return err;

	udelay(2000);
34811b6c:	e2800e7d 	add	r0, r0, #2000	; 0x7d0
34811b70:	eb002b57 	bl	3481c8d4 <udelay>

	return 0;
}
34811b74:	e1a00004 	mov	r0, r4
34811b78:	e28dd020 	add	sp, sp, #32
34811b7c:	e8bd8010 	pop	{r4, pc}

34811b80 <sd_send_op_cond>:

int
sd_send_op_cond(struct mmc *mmc)
{
34811b80:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811b84:	e24dd020 	sub	sp, sp, #32
34811b88:	e1a04000 	mov	r4, r0
	int timeout = 1000;
34811b8c:	e3a06ffa 	mov	r6, #1000	; 0x3e8
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811b90:	e3a09015 	mov	r9, #21
		cmd.cmdarg = 0;
34811b94:	e3a07000 	mov	r7, #0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811b98:	e28da004 	add	sl, sp, #4

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811b9c:	e3a0b001 	mov	fp, #1
	int timeout = 1000;
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
34811ba0:	e3a01037 	mov	r1, #55	; 0x37
34811ba4:	e1cd10b4 	strh	r1, [sp, #4]
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811ba8:	e1a00004 	mov	r0, r4
34811bac:	e1a0100a 	mov	r1, sl
34811bb0:	e1a02007 	mov	r2, r7
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811bb4:	e58d9008 	str	r9, [sp, #8]
		cmd.cmdarg = 0;
34811bb8:	e58d700c 	str	r7, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811bbc:	ebfffe5b 	bl	34811530 <mmc_send_cmd>

		if (err)
34811bc0:	e2505000 	subs	r5, r0, #0
34811bc4:	1a00003a 	bne	34811cb4 <sd_send_op_cond+0x134>
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
34811bc8:	e3a03029 	mov	r3, #41	; 0x29
34811bcc:	e1cd30b4 	strh	r3, [sp, #4]
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811bd0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811bd4:	e59f10e4 	ldr	r1, [pc, #228]	; 34811cc0 <sd_send_op_cond+0x140>
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811bd8:	e3130b01 	tst	r3, #1024	; 0x400
34811bdc:	059f30e0 	ldreq	r3, [pc, #224]	; 34811cc4 <sd_send_op_cond+0x144>
34811be0:	0594202c 	ldreq	r2, [r4, #44]	; 0x2c
34811be4:	11a03007 	movne	r3, r7
34811be8:	00023003 	andeq	r3, r2, r3
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811bec:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811bf0:	e58d300c 	str	r3, [sp, #12]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811bf4:	e1520001 	cmp	r2, r1
			cmd.cmdarg |= OCR_HCS;
34811bf8:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811bfc:	e1a00004 	mov	r0, r4
34811c00:	e1a0100a 	mov	r1, sl
34811c04:	e3a02000 	mov	r2, #0
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;
34811c08:	058d300c 	streq	r3, [sp, #12]

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811c0c:	e58db008 	str	fp, [sp, #8]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811c10:	ebfffe46 	bl	34811530 <mmc_send_cmd>

		if (err)
34811c14:	e2505000 	subs	r5, r0, #0
34811c18:	1a000025 	bne	34811cb4 <sd_send_op_cond+0x134>
			return err;

		udelay(1000);
34811c1c:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34811c20:	eb002b2b 	bl	3481c8d4 <udelay>
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
34811c24:	e59d3010 	ldr	r3, [sp, #16]
34811c28:	e3530000 	cmp	r3, #0
34811c2c:	ba000002 	blt	34811c3c <sd_send_op_cond+0xbc>
34811c30:	e2566001 	subs	r6, r6, #1
34811c34:	2affffd9 	bcs	34811ba0 <sd_send_op_cond+0x20>
34811c38:	ea00001c 	b	34811cb0 <sd_send_op_cond+0x130>

	if (timeout <= 0)
34811c3c:	e3560000 	cmp	r6, #0
34811c40:	da00001a 	ble	34811cb0 <sd_send_op_cond+0x130>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
34811c44:	e59f3074 	ldr	r3, [pc, #116]	; 34811cc0 <sd_send_op_cond+0x140>
34811c48:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34811c4c:	e1520003 	cmp	r2, r3
		mmc->version = SD_VERSION_1_0;
34811c50:	12433010 	subne	r3, r3, #16
34811c54:	15843030 	strne	r3, [r4, #48]	; 0x30

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811c58:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811c5c:	e3130b01 	tst	r3, #1024	; 0x400
34811c60:	0a00000b 	beq	34811c94 <sd_send_op_cond+0x114>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811c64:	e3a0303a 	mov	r3, #58	; 0x3a
34811c68:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811c6c:	e3a02000 	mov	r2, #0
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811c70:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811c74:	e1a00004 	mov	r0, r4
34811c78:	e28d1004 	add	r1, sp, #4
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811c7c:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
34811c80:	e58d200c 	str	r2, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811c84:	ebfffe29 	bl	34811530 <mmc_send_cmd>

		if (err)
34811c88:	e3500000 	cmp	r0, #0
34811c8c:	11a05000 	movne	r5, r0
34811c90:	1a000007 	bne	34811cb4 <sd_send_op_cond+0x134>
			return err;
	}

	mmc->ocr = cmd.response[0];
34811c94:	e59d3010 	ldr	r3, [sp, #16]

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
34811c98:	e3a01000 	mov	r1, #0

		if (err)
			return err;
	}

	mmc->ocr = cmd.response[0];
34811c9c:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811ca0:	e7e03f53 	ubfx	r3, r3, #30, #1
34811ca4:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811ca8:	e1c418b0 	strh	r1, [r4, #128]	; 0x80

	return 0;
34811cac:	ea000000 	b	34811cb4 <sd_send_op_cond+0x134>

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
34811cb0:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811cb4:	e1a00005 	mov	r0, r5
34811cb8:	e28dd020 	add	sp, sp, #32
34811cbc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811cc0:	00020020 	.word	0x00020020
34811cc4:	00ff8000 	.word	0x00ff8000

34811cc8 <mmc_send_op_cond>:

int mmc_send_op_cond(struct mmc *mmc)
{
34811cc8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34811ccc:	e24dd020 	sub	sp, sp, #32
34811cd0:	e1a04000 	mov	r4, r0
 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811cd4:	e28da004 	add	sl, sp, #4
	int timeout = 10000;
	struct mmc_cmd cmd;
	int err;

	/* Some cards seem to need this */
	mmc_go_idle(mmc);
34811cd8:	ebffff95 	bl	34811b34 <mmc_go_idle>

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811cdc:	e3a07001 	mov	r7, #1
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;
34811ce0:	e3a02000 	mov	r2, #0

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ce4:	e1a00004 	mov	r0, r4
34811ce8:	e1a0100a 	mov	r1, sl

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811cec:	e1cd70b4 	strh	r7, [sp, #4]
 	cmd.resp_type = MMC_RSP_R3;
34811cf0:	e58d7008 	str	r7, [sp, #8]
 	cmd.cmdarg = 0;
34811cf4:	e58d200c 	str	r2, [sp, #12]

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811cf8:	ebfffe0c 	bl	34811530 <mmc_send_cmd>

 	if (err)
34811cfc:	e2505000 	subs	r5, r0, #0
34811d00:	1a00003d 	bne	34811dfc <mmc_send_op_cond+0x134>
 		return err;

 	udelay(1000);
34811d04:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34811d08:	eb002af1 	bl	3481c8d4 <udelay>
	return 0;
}

int mmc_send_op_cond(struct mmc *mmc)
{
	int timeout = 10000;
34811d0c:	e3026710 	movw	r6, #10000	; 0x2710
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811d10:	e5941050 	ldr	r1, [r4, #80]	; 0x50
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811d14:	e3a03001 	mov	r3, #1
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811d18:	e3110b01 	tst	r1, #1024	; 0x400
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811d1c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
34811d20:	0594002c 	ldreq	r0, [r4, #44]	; 0x2c
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
34811d24:	059d3010 	ldreq	r3, [sp, #16]

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
34811d28:	059f20d8 	ldreq	r2, [pc, #216]	; 34811e08 <mmc_send_op_cond+0x140>
34811d2c:	00030000 	andeq	r0, r3, r0
34811d30:	00002002 	andeq	r2, r0, r2
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));
34811d34:	02033206 	andeq	r3, r3, #1610612736	; 0x60000000
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811d38:	01823003 	orreq	r3, r2, r3
34811d3c:	13a03000 	movne	r3, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
34811d40:	e3110b02 	tst	r1, #2048	; 0x800
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811d44:	e58d300c 	str	r3, [sp, #12]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d48:	e1a00004 	mov	r0, r4
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
34811d4c:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d50:	e1a0100a 	mov	r1, sl
34811d54:	e3a02000 	mov	r2, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
34811d58:	158d300c 	strne	r3, [sp, #12]

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811d5c:	e58d7008 	str	r7, [sp, #8]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d60:	ebfffdf2 	bl	34811530 <mmc_send_cmd>

		if (err)
34811d64:	e2505000 	subs	r5, r0, #0
34811d68:	1a000023 	bne	34811dfc <mmc_send_op_cond+0x134>
			return err;

		udelay(1000);
34811d6c:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34811d70:	eb002ad7 	bl	3481c8d4 <udelay>
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811d74:	e59d3010 	ldr	r3, [sp, #16]
34811d78:	e3530000 	cmp	r3, #0
34811d7c:	aa000002 	bge	34811d8c <mmc_send_op_cond+0xc4>

	if (timeout <= 0)
34811d80:	e3560000 	cmp	r6, #0
34811d84:	ca000003 	bgt	34811d98 <mmc_send_op_cond+0xd0>
34811d88:	ea00001a 	b	34811df8 <mmc_send_op_cond+0x130>

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811d8c:	e2566001 	subs	r6, r6, #1
34811d90:	2affffde 	bcs	34811d10 <mmc_send_op_cond+0x48>
34811d94:	ea000017 	b	34811df8 <mmc_send_op_cond+0x130>

	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811d98:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811d9c:	e3130b01 	tst	r3, #1024	; 0x400
34811da0:	0a00000b 	beq	34811dd4 <mmc_send_op_cond+0x10c>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811da4:	e3a0303a 	mov	r3, #58	; 0x3a
34811da8:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811dac:	e1a02005 	mov	r2, r5
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811db0:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811db4:	e1a00004 	mov	r0, r4
34811db8:	e1a0100a 	mov	r1, sl
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811dbc:	e58d500c 	str	r5, [sp, #12]
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811dc0:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811dc4:	ebfffdd9 	bl	34811530 <mmc_send_cmd>

		if (err)
34811dc8:	e3500000 	cmp	r0, #0
34811dcc:	11a05000 	movne	r5, r0
34811dd0:	1a000009 	bne	34811dfc <mmc_send_op_cond+0x134>
			return err;
	}

	mmc->version = MMC_VERSION_UNKNOWN;
34811dd4:	e3a03801 	mov	r3, #65536	; 0x10000
34811dd8:	e5843030 	str	r3, [r4, #48]	; 0x30
	mmc->ocr = cmd.response[0];
34811ddc:	e59d3010 	ldr	r3, [sp, #16]
34811de0:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811de4:	e7e03f53 	ubfx	r3, r3, #30, #1
34811de8:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811dec:	e3a03000 	mov	r3, #0
34811df0:	e1c438b0 	strh	r3, [r4, #128]	; 0x80

	return 0;
34811df4:	ea000000 	b	34811dfc <mmc_send_op_cond+0x134>

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
34811df8:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811dfc:	e1a00005 	mov	r0, r5
34811e00:	e28dd020 	add	sp, sp, #32
34811e04:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34811e08:	007fff80 	.word	0x007fff80

34811e0c <mmc_send_ext_csd>:


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
34811e0c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
34811e10:	e3a03008 	mov	r3, #8
	return 0;
}


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
34811e14:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
34811e18:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811e1c:	e3a03015 	mov	r3, #21
34811e20:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
34811e24:	e3a02c02 	mov	r2, #512	; 0x200
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
34811e28:	e3a03000 	mov	r3, #0
34811e2c:	e58d300c 	str	r3, [sp, #12]

	data.dest = (char *)ext_csd;
34811e30:	e58d1020 	str	r1, [sp, #32]
	data.blocks = 1;
34811e34:	e2833001 	add	r3, r3, #1
	data.blocksize = 512;
34811e38:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811e3c:	e28d1004 	add	r1, sp, #4
34811e40:	e28d2020 	add	r2, sp, #32
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
34811e44:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
34811e48:	e58d3024 	str	r3, [sp, #36]	; 0x24

	err = mmc_send_cmd(mmc, &cmd, &data);
34811e4c:	ebfffdb7 	bl	34811530 <mmc_send_cmd>

	return err;
}
34811e50:	e28dd034 	add	sp, sp, #52	; 0x34
34811e54:	e8bd8000 	pop	{pc}

34811e58 <mmc_switch>:


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811e58:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
34811e5c:	e3a01006 	mov	r1, #6
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811e60:	e24dd020 	sub	sp, sp, #32
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34811e64:	e1a02802 	lsl	r2, r2, #16
{
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
34811e68:	e1cd10b4 	strh	r1, [sp, #4]
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34811e6c:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
34811e70:	e3a0101d 	mov	r1, #29
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34811e74:	e1823403 	orr	r3, r2, r3, lsl #8
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
34811e78:	e58d1008 	str	r1, [sp, #8]
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811e7c:	e3a02000 	mov	r2, #0
34811e80:	e28d1004 	add	r1, sp, #4
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811e84:	e1a04000 	mov	r4, r0
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34811e88:	e58d300c 	str	r3, [sp, #12]
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811e8c:	ebfffda7 	bl	34811530 <mmc_send_cmd>

	/* Waiting for the ready status */
	if (!ret)
34811e90:	e3500000 	cmp	r0, #0
34811e94:	1a000002 	bne	34811ea4 <mmc_switch+0x4c>
		ret = mmc_send_status(mmc, timeout);
34811e98:	e1a00004 	mov	r0, r4
34811e9c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811ea0:	ebfffdb1 	bl	3481156c <mmc_send_status>

	return ret;

}
34811ea4:	e28dd020 	add	sp, sp, #32
34811ea8:	e8bd8010 	pop	{r4, pc}

34811eac <mmc_change_freq>:

int mmc_change_freq(struct mmc *mmc)
{
34811eac:	e92d4070 	push	{r4, r5, r6, lr}
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811eb0:	e5902050 	ldr	r2, [r0, #80]	; 0x50
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811eb4:	e3a03000 	mov	r3, #0

	if (mmc_host_is_spi(mmc))
34811eb8:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811ebc:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811ec0:	e580304c 	str	r3, [r0, #76]	; 0x4c
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811ec4:	e24ddd09 	sub	sp, sp, #576	; 0x240
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
		return 0;
34811ec8:	11a00003 	movne	r0, r3
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811ecc:	1a00001f 	bne	34811f50 <mmc_change_freq+0xa4>
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
34811ed0:	e5941030 	ldr	r1, [r4, #48]	; 0x30
34811ed4:	e59f307c 	ldr	r3, [pc, #124]	; 34811f58 <mmc_change_freq+0xac>
34811ed8:	e1510003 	cmp	r1, r3
		return 0;
34811edc:	91a00002 	movls	r0, r2

	if (mmc_host_is_spi(mmc))
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
34811ee0:	9a00001a 	bls	34811f50 <mmc_change_freq+0xa4>

}

int mmc_change_freq(struct mmc *mmc)
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811ee4:	e28d503f 	add	r5, sp, #63	; 0x3f
34811ee8:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);
34811eec:	e1a01005 	mov	r1, r5
34811ef0:	ebffffc5 	bl	34811e0c <mmc_send_ext_csd>

	if (err)
34811ef4:	e3500000 	cmp	r0, #0
34811ef8:	1a000014 	bne	34811f50 <mmc_change_freq+0xa4>
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811efc:	e3a01001 	mov	r1, #1
34811f00:	e1a00004 	mov	r0, r4
34811f04:	e3a020b9 	mov	r2, #185	; 0xb9
34811f08:	e1a03001 	mov	r3, r1
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
34811f0c:	e5d560c4 	ldrb	r6, [r5, #196]	; 0xc4

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811f10:	ebffffd0 	bl	34811e58 <mmc_switch>

	if (err)
34811f14:	e3500000 	cmp	r0, #0
34811f18:	1a00000c 	bne	34811f50 <mmc_change_freq+0xa4>
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);
34811f1c:	e1a00004 	mov	r0, r4
34811f20:	e1a01005 	mov	r1, r5
34811f24:	ebffffb8 	bl	34811e0c <mmc_send_ext_csd>

	if (err)
34811f28:	e3500000 	cmp	r0, #0
34811f2c:	1a000007 	bne	34811f50 <mmc_change_freq+0xa4>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
34811f30:	e5d530b9 	ldrb	r3, [r5, #185]	; 0xb9
34811f34:	e3530000 	cmp	r3, #0
34811f38:	0a000004 	beq	34811f50 <mmc_change_freq+0xa4>
34811f3c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
34811f40:	e3160002 	tst	r6, #2
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
34811f44:	13833011 	orrne	r3, r3, #17
	else
		mmc->card_caps |= MMC_MODE_HS;
34811f48:	03833001 	orreq	r3, r3, #1
34811f4c:	e584304c 	str	r3, [r4, #76]	; 0x4c

	return 0;
}
34811f50:	e28ddd09 	add	sp, sp, #576	; 0x240
34811f54:	e8bd8070 	pop	{r4, r5, r6, pc}
34811f58:	0001003f 	.word	0x0001003f

34811f5c <mmc_switch_part>:

int mmc_switch_part(int dev_num, unsigned int part_num)
{
34811f5c:	e92d4010 	push	{r4, lr}
34811f60:	e1a04001 	mov	r4, r1
	struct mmc *mmc = find_mmc_device(dev_num);
34811f64:	ebfffdc0 	bl	3481166c <find_mmc_device>

	if (!mmc)
34811f68:	e2503000 	subs	r3, r0, #0
34811f6c:	0a000007 	beq	34811f90 <mmc_switch_part+0x34>
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811f70:	e5d33082 	ldrb	r3, [r3, #130]	; 0x82
34811f74:	e204c007 	and	ip, r4, #7
34811f78:	e3c33007 	bic	r3, r3, #7
34811f7c:	e3a01001 	mov	r1, #1
34811f80:	e3a020b3 	mov	r2, #179	; 0xb3
34811f84:	e18c3003 	orr	r3, ip, r3
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34811f88:	e8bd4010 	pop	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev_num);

	if (!mmc)
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811f8c:	eaffffb1 	b	34811e58 <mmc_switch>
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34811f90:	e3e00000 	mvn	r0, #0
34811f94:	e8bd8010 	pop	{r4, pc}

34811f98 <mmc_getcd>:

int mmc_getcd(struct mmc *mmc)
{
34811f98:	e92d4010 	push	{r4, lr}
34811f9c:	e1a04000 	mov	r4, r0
	int cd;

	cd = board_mmc_getcd(mmc);
34811fa0:	ebfffd60 	bl	34811528 <__board_mmc_getcd>

	if ((cd < 0) && mmc->getcd)
34811fa4:	e3500000 	cmp	r0, #0
34811fa8:	a8bd8010 	popge	{r4, pc}
34811fac:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
34811fb0:	e3530000 	cmp	r3, #0
34811fb4:	08bd8010 	popeq	{r4, pc}
		cd = mmc->getcd(mmc);
34811fb8:	e1a00004 	mov	r0, r4
34811fbc:	e12fff33 	blx	r3

	return cd;
}
34811fc0:	e8bd8010 	pop	{r4, pc}

34811fc4 <sd_switch>:

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811fc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811fc8:	e3a0c006 	mov	ip, #6

	return cd;
}

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811fcc:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811fd0:	e1cdc0b4 	strh	ip, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811fd4:	e3a0c015 	mov	ip, #21
34811fd8:	e58dc008 	str	ip, [sp, #8]
	cmd.cmdarg = (mode << 31) | 0xffffff;
34811fdc:	e3e0c4ff 	mvn	ip, #-16777216	; 0xff000000
34811fe0:	e18c1f81 	orr	r1, ip, r1, lsl #31
	cmd.cmdarg &= ~(0xf << (group * 4));
34811fe4:	e1a02102 	lsl	r2, r2, #2
34811fe8:	e3a0c00f 	mov	ip, #15
34811fec:	e1c1c21c 	bic	ip, r1, ip, lsl r2
	cmd.cmdarg |= value << (group * 4);
34811ff0:	e18c2213 	orr	r2, ip, r3, lsl r2

	data.dest = (char *)resp;
34811ff4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
34811ff8:	e58d200c 	str	r2, [sp, #12]

	data.dest = (char *)resp;
34811ffc:	e58d3020 	str	r3, [sp, #32]
	data.blocksize = 64;
34812000:	e3a03040 	mov	r3, #64	; 0x40
34812004:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
34812008:	e28d1004 	add	r1, sp, #4
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
3481200c:	e3a03001 	mov	r3, #1
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
34812010:	e28d2020 	add	r2, sp, #32
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
34812014:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.flags = MMC_DATA_READ;
34812018:	e58d3024 	str	r3, [sp, #36]	; 0x24

	return mmc_send_cmd(mmc, &cmd, &data);
3481201c:	ebfffd43 	bl	34811530 <mmc_send_cmd>
}
34812020:	e28dd034 	add	sp, sp, #52	; 0x34
34812024:	e8bd8000 	pop	{pc}

34812028 <sd_change_freq>:


int sd_change_freq(struct mmc *mmc)
{
34812028:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
3481202c:	e5902050 	ldr	r2, [r0, #80]	; 0x50
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
34812030:	e24ddd05 	sub	sp, sp, #320	; 0x140
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
34812034:	e28d70d3 	add	r7, sp, #211	; 0xd3
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
34812038:	e28d6053 	add	r6, sp, #83	; 0x53
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
3481203c:	e3a05000 	mov	r5, #0

	if (mmc_host_is_spi(mmc))
34812040:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
34812044:	e1a04000 	mov	r4, r0
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
34812048:	e3c7703f 	bic	r7, r7, #63	; 0x3f
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
3481204c:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
34812050:	e580504c 	str	r5, [r0, #76]	; 0x4c

	if (mmc_host_is_spi(mmc))
34812054:	1a000069 	bne	34812200 <sd_change_freq+0x1d8>
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
34812058:	e3a01037 	mov	r1, #55	; 0x37
3481205c:	e28d3c01 	add	r3, sp, #256	; 0x100
34812060:	e1c311b4 	strh	r1, [r3, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
34812064:	e1d038b0 	ldrh	r3, [r0, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812068:	e28dbf45 	add	fp, sp, #276	; 0x114
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
3481206c:	e1a03803 	lsl	r3, r3, #16
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
34812070:	e3a0a015 	mov	sl, #21
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812074:	e1a0100b 	mov	r1, fp
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
34812078:	e58da118 	str	sl, [sp, #280]	; 0x118
	cmd.cmdarg = mmc->rca << 16;
3481207c:	e58d311c 	str	r3, [sp, #284]	; 0x11c

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812080:	ebfffd2a 	bl	34811530 <mmc_send_cmd>

	if (err)
34812084:	e2505000 	subs	r5, r0, #0
34812088:	1a00005c 	bne	34812200 <sd_change_freq+0x1d8>
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
3481208c:	e3a01033 	mov	r1, #51	; 0x33
34812090:	e28d2c01 	add	r2, sp, #256	; 0x100
	cmd.resp_type = MMC_RSP_R1;
34812094:	e58da118 	str	sl, [sp, #280]	; 0x118
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34812098:	e1c211b4 	strh	r1, [r2, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
3481209c:	e58d511c 	str	r5, [sp, #284]	; 0x11c

	timeout = 3;
348120a0:	e3a0a003 	mov	sl, #3

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
348120a4:	e3a0c008 	mov	ip, #8
	data.blocks = 1;
348120a8:	e3a09001 	mov	r9, #1
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
348120ac:	e28d3e13 	add	r3, sp, #304	; 0x130
348120b0:	e1a02003 	mov	r2, r3
348120b4:	e1a00004 	mov	r0, r4
348120b8:	e1a0100b 	mov	r1, fp

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
348120bc:	e58dc13c 	str	ip, [sp, #316]	; 0x13c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
348120c0:	e58d3008 	str	r3, [sp, #8]
348120c4:	e58dc00c 	str	ip, [sp, #12]
	cmd.cmdarg = 0;

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
348120c8:	e58d7130 	str	r7, [sp, #304]	; 0x130
	data.blocksize = 8;
	data.blocks = 1;
348120cc:	e58d9138 	str	r9, [sp, #312]	; 0x138
	data.flags = MMC_DATA_READ;
348120d0:	e58d9134 	str	r9, [sp, #308]	; 0x134

	err = mmc_send_cmd(mmc, &cmd, &data);
348120d4:	ebfffd15 	bl	34811530 <mmc_send_cmd>

	if (err) {
348120d8:	e2505000 	subs	r5, r0, #0
348120dc:	e59d3008 	ldr	r3, [sp, #8]
348120e0:	e59dc00c 	ldr	ip, [sp, #12]
348120e4:	0a000003 	beq	348120f8 <sd_change_freq+0xd0>
		if (timeout--)
348120e8:	e35a0000 	cmp	sl, #0
348120ec:	0a000043 	beq	34812200 <sd_change_freq+0x1d8>
348120f0:	e24aa001 	sub	sl, sl, #1
348120f4:	eaffffed 	b	348120b0 <sd_change_freq+0x88>
			goto retry_scr;

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
348120f8:	e5970000 	ldr	r0, [r7]
348120fc:	ebfffd07 	bl	34811520 <__fswab32>
34812100:	e5840058 	str	r0, [r4, #88]	; 0x58
34812104:	e1a0a000 	mov	sl, r0
	mmc->scr[1] = __be32_to_cpu(scr[1]);
34812108:	e5970004 	ldr	r0, [r7, #4]
3481210c:	ebfffd03 	bl	34811520 <__fswab32>

	switch ((mmc->scr[0] >> 24) & 0xf) {
34812110:	e7e33c5a 	ubfx	r3, sl, #24, #4
34812114:	e3530001 	cmp	r3, #1

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);
34812118:	e584005c 	str	r0, [r4, #92]	; 0x5c
	switch ((mmc->scr[0] >> 24) & 0xf) {
		case 0:
			mmc->version = SD_VERSION_1_0;
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
3481211c:	059f30e8 	ldreq	r3, [pc, #232]	; 3481220c <sd_change_freq+0x1e4>
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);

	switch ((mmc->scr[0] >> 24) & 0xf) {
34812120:	0a000004 	beq	34812138 <sd_change_freq+0x110>
34812124:	3a000002 	bcc	34812134 <sd_change_freq+0x10c>
34812128:	e3530002 	cmp	r3, #2
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
			break;
		case 2:
			mmc->version = SD_VERSION_2;
3481212c:	059f30dc 	ldreq	r3, [pc, #220]	; 34812210 <sd_change_freq+0x1e8>
34812130:	0a000000 	beq	34812138 <sd_change_freq+0x110>
			break;
		default:
			mmc->version = SD_VERSION_1_0;
34812134:	e59f30d8 	ldr	r3, [pc, #216]	; 34812214 <sd_change_freq+0x1ec>
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
34812138:	e31a0701 	tst	sl, #262144	; 0x40000
			break;
		case 2:
			mmc->version = SD_VERSION_2;
			break;
		default:
			mmc->version = SD_VERSION_1_0;
3481213c:	e5843030 	str	r3, [r4, #48]	; 0x30
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
34812140:	1594304c 	ldrne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
34812144:	e5942030 	ldr	r2, [r4, #48]	; 0x30
			mmc->version = SD_VERSION_1_0;
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
34812148:	13833c01 	orrne	r3, r3, #256	; 0x100
3481214c:	1584304c 	strne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
34812150:	e59f30bc 	ldr	r3, [pc, #188]	; 34812214 <sd_change_freq+0x1ec>
34812154:	e1520003 	cmp	r2, r3
34812158:	13a07004 	movne	r7, #4
3481215c:	1a00000c 	bne	34812194 <sd_change_freq+0x16c>
34812160:	ea000026 	b	34812200 <sd_change_freq+0x1d8>
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34812164:	e3a01000 	mov	r1, #0
34812168:	e1a00004 	mov	r0, r4
3481216c:	e1a02001 	mov	r2, r1
34812170:	e3a03001 	mov	r3, #1
34812174:	e58d6000 	str	r6, [sp]
34812178:	ebffff91 	bl	34811fc4 <sd_switch>
				(u8 *)switch_status);

		if (err)
3481217c:	e3500000 	cmp	r0, #0
34812180:	1a00001d 	bne	348121fc <sd_change_freq+0x1d4>
			return err;

		/* The high-speed function is busy.  Try again */
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
34812184:	e596001c 	ldr	r0, [r6, #28]
34812188:	ebfffce4 	bl	34811520 <__fswab32>
3481218c:	e3100802 	tst	r0, #131072	; 0x20000
34812190:	0a000001 	beq	3481219c <sd_change_freq+0x174>
	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
34812194:	e2577001 	subs	r7, r7, #1
34812198:	2afffff1 	bcs	34812164 <sd_change_freq+0x13c>
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
3481219c:	e596000c 	ldr	r0, [r6, #12]
348121a0:	ebfffcde 	bl	34811520 <__fswab32>
348121a4:	e3100802 	tst	r0, #131072	; 0x20000
348121a8:	0a000014 	beq	34812200 <sd_change_freq+0x1d8>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
348121ac:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348121b0:	e2033011 	and	r3, r3, #17
348121b4:	e3530011 	cmp	r3, #17
348121b8:	1a000010 	bne	34812200 <sd_change_freq+0x1d8>
		(mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
348121bc:	e3a01001 	mov	r1, #1
348121c0:	e1a00004 	mov	r0, r4
348121c4:	e3a02000 	mov	r2, #0
348121c8:	e1a03001 	mov	r3, r1
348121cc:	e58d6000 	str	r6, [sp]
348121d0:	ebffff7b 	bl	34811fc4 <sd_switch>

	if (err)
348121d4:	e2505000 	subs	r5, r0, #0
348121d8:	1a000008 	bne	34812200 <sd_change_freq+0x1d8>
		return err;

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
348121dc:	e5960010 	ldr	r0, [r6, #16]
348121e0:	ebfffcce 	bl	34811520 <__fswab32>
348121e4:	e200040f 	and	r0, r0, #251658240	; 0xf000000
348121e8:	e3500401 	cmp	r0, #16777216	; 0x1000000
		mmc->card_caps |= MMC_MODE_HS;
348121ec:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
348121f0:	03833001 	orreq	r3, r3, #1
348121f4:	0584304c 	streq	r3, [r4, #76]	; 0x4c
348121f8:	ea000000 	b	34812200 <sd_change_freq+0x1d8>
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
348121fc:	e1a05000 	mov	r5, r0

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}
34812200:	e1a00005 	mov	r0, r5
34812204:	e28ddd05 	add	sp, sp, #320	; 0x140
34812208:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481220c:	0002001a 	.word	0x0002001a
34812210:	00020020 	.word	0x00020020
34812214:	00020010 	.word	0x00020010

34812218 <mmc_set_ios>:
	70,
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
34812218:	e92d4008 	push	{r3, lr}
	mmc->set_ios(mmc);
3481221c:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34812220:	e12fff33 	blx	r3
}
34812224:	e8bd8008 	pop	{r3, pc}

34812228 <mmc_set_clock>:

void mmc_set_clock(struct mmc *mmc, uint clock)
{
34812228:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
3481222c:	e590c038 	ldr	ip, [r0, #56]	; 0x38
{
	mmc->set_ios(mmc);
}

void mmc_set_clock(struct mmc *mmc, uint clock)
{
34812230:	e1510002 	cmp	r1, r2
34812234:	31a02001 	movcc	r2, r1
34812238:	e92d4008 	push	{r3, lr}
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
3481223c:	e152000c 	cmp	r2, ip
34812240:	25802048 	strcs	r2, [r0, #72]	; 0x48
34812244:	3580c048 	strcc	ip, [r0, #72]	; 0x48
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812248:	e5903114 	ldr	r3, [r0, #276]	; 0x114
3481224c:	e12fff33 	blx	r3
		clock = mmc->f_min;

	mmc->clock = clock;

	mmc_set_ios(mmc);
}
34812250:	e8bd8008 	pop	{r3, pc}

34812254 <mmc_set_bus_width>:

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
34812254:	e92d4008 	push	{r3, lr}
	mmc->bus_width = width;
34812258:	e5801044 	str	r1, [r0, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
3481225c:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34812260:	e12fff33 	blx	r3
void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}
34812264:	e8bd8008 	pop	{r3, pc}

34812268 <mmc_startup>:

int mmc_startup(struct mmc *mmc)
{
34812268:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
3481226c:	e5903050 	ldr	r3, [r0, #80]	; 0x50

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34812270:	e24ddd13 	sub	sp, sp, #1216	; 0x4c0
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34812274:	e3130b01 	tst	r3, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812278:	e28d5e49 	add	r5, sp, #1168	; 0x490
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
3481227c:	03a03002 	moveq	r3, #2
34812280:	13a0300a 	movne	r3, #10
34812284:	e28d1b01 	add	r1, sp, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812288:	e285500c 	add	r5, r5, #12
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
3481228c:	e1c139bc 	strh	r3, [r1, #156]	; 0x9c
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;
34812290:	e3a02000 	mov	r2, #0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34812294:	e3a03007 	mov	r3, #7
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812298:	e1a01005 	mov	r1, r5

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
3481229c:	e1a04000 	mov	r4, r0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
348122a0:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = 0;
348122a4:	e58d24a4 	str	r2, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
348122a8:	ebfffca0 	bl	34811530 <mmc_send_cmd>
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
348122ac:	e28da020 	add	sl, sp, #32
348122b0:	e28aa03b 	add	sl, sl, #59	; 0x3b
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
348122b4:	e2506000 	subs	r6, r0, #0
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
348122b8:	e3caa03f 	bic	sl, sl, #63	; 0x3f
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
348122bc:	1a00017b 	bne	348128b0 <mmc_startup+0x648>
		return err;

	memcpy(mmc->cid, cmd.response, 16);
348122c0:	e3a02010 	mov	r2, #16
348122c4:	e2840070 	add	r0, r4, #112	; 0x70
348122c8:	e285100c 	add	r1, r5, #12
348122cc:	eb0028f5 	bl	3481c6a8 <memcpy>
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
348122d0:	e5942050 	ldr	r2, [r4, #80]	; 0x50
348122d4:	e2122b01 	ands	r2, r2, #1024	; 0x400
348122d8:	1a000011 	bne	34812324 <mmc_startup+0xbc>
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
348122dc:	e3a03003 	mov	r3, #3
348122e0:	e28d0b01 	add	r0, sp, #1024	; 0x400
348122e4:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
		cmd.cmdarg = mmc->rca << 16;
348122e8:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348122ec:	e1a00004 	mov	r0, r4
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
348122f0:	e1a03803 	lsl	r3, r3, #16
348122f4:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348122f8:	e1a01005 	mov	r1, r5
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
		cmd.resp_type = MMC_RSP_R6;
348122fc:	e3a03015 	mov	r3, #21
34812300:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34812304:	ebfffc89 	bl	34811530 <mmc_send_cmd>

		if (err)
34812308:	e2506000 	subs	r6, r0, #0
3481230c:	1a000167 	bne	348128b0 <mmc_startup+0x648>
			return err;

		if (IS_SD(mmc))
34812310:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34812314:	e3130802 	tst	r3, #131072	; 0x20000
			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
34812318:	128d1b01 	addne	r1, sp, #1024	; 0x400
3481231c:	11d11aba 	ldrhne	r1, [r1, #170]	; 0xaa
34812320:	11c418b0 	strhne	r1, [r4, #128]	; 0x80
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
34812324:	e3a02009 	mov	r2, #9
34812328:	e28d3b01 	add	r3, sp, #1024	; 0x400
3481232c:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
	cmd.resp_type = MMC_RSP_R2;
34812330:	e3a03007 	mov	r3, #7
34812334:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = mmc->rca << 16;
34812338:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481233c:	e28d1e49 	add	r1, sp, #1168	; 0x490
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34812340:	e1a03803 	lsl	r3, r3, #16

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812344:	e281100c 	add	r1, r1, #12
34812348:	e3a02000 	mov	r2, #0
3481234c:	e1a00004 	mov	r0, r4
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34812350:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812354:	ebfffc75 	bl	34811530 <mmc_send_cmd>

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34812358:	e3a01ffa 	mov	r1, #1000	; 0x3e8
	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481235c:	e1a06000 	mov	r6, r0

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34812360:	e1a00004 	mov	r0, r4
34812364:	ebfffc80 	bl	3481156c <mmc_send_status>

	if (err)
34812368:	e3560000 	cmp	r6, #0
3481236c:	1a00014f 	bne	348128b0 <mmc_startup+0x648>
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
34812370:	e59d24b4 	ldr	r2, [sp, #1204]	; 0x4b4
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34812374:	e59d34a8 	ldr	r3, [sp, #1192]	; 0x4a8
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
34812378:	e584206c 	str	r2, [r4, #108]	; 0x6c

	if (mmc->version == MMC_VERSION_UNKNOWN) {
3481237c:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
34812380:	e59d04ac 	ldr	r0, [sp, #1196]	; 0x4ac
	mmc->csd[2] = cmd.response[2];
34812384:	e59d64b0 	ldr	r6, [sp, #1200]	; 0x4b0
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34812388:	e3520801 	cmp	r2, #65536	; 0x10000
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
3481238c:	e5843060 	str	r3, [r4, #96]	; 0x60
	mmc->csd[1] = cmd.response[1];
34812390:	e5840064 	str	r0, [r4, #100]	; 0x64
	mmc->csd[2] = cmd.response[2];
34812394:	e5846068 	str	r6, [r4, #104]	; 0x68
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34812398:	1a000012 	bne	348123e8 <mmc_startup+0x180>
		int version = (cmd.response[0] >> 26) & 0xf;
3481239c:	e7e32d53 	ubfx	r2, r3, #26, #4

		switch (version) {
348123a0:	e3520004 	cmp	r2, #4
348123a4:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
348123a8:	ea00000c 	b	348123e0 <mmc_startup+0x178>
348123ac:	348123e0 	.word	0x348123e0
348123b0:	348123c0 	.word	0x348123c0
348123b4:	348123c8 	.word	0x348123c8
348123b8:	348123d0 	.word	0x348123d0
348123bc:	348123d8 	.word	0x348123d8
			case 0:
				mmc->version = MMC_VERSION_1_2;
				break;
			case 1:
				mmc->version = MMC_VERSION_1_4;
348123c0:	e59f24f4 	ldr	r2, [pc, #1268]	; 348128bc <mmc_startup+0x654>
348123c4:	ea000006 	b	348123e4 <mmc_startup+0x17c>
				break;
			case 2:
				mmc->version = MMC_VERSION_2_2;
348123c8:	e59f24f0 	ldr	r2, [pc, #1264]	; 348128c0 <mmc_startup+0x658>
348123cc:	ea000004 	b	348123e4 <mmc_startup+0x17c>
				break;
			case 3:
				mmc->version = MMC_VERSION_3;
348123d0:	e59f24ec 	ldr	r2, [pc, #1260]	; 348128c4 <mmc_startup+0x65c>
348123d4:	ea000002 	b	348123e4 <mmc_startup+0x17c>
				break;
			case 4:
				mmc->version = MMC_VERSION_4;
348123d8:	e59f24e8 	ldr	r2, [pc, #1256]	; 348128c8 <mmc_startup+0x660>
348123dc:	ea000000 	b	348123e4 <mmc_startup+0x17c>
				break;
			default:
				mmc->version = MMC_VERSION_1_2;
348123e0:	e59f24e4 	ldr	r2, [pc, #1252]	; 348128cc <mmc_startup+0x664>
348123e4:	e5842030 	str	r2, [r4, #48]	; 0x30
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
348123e8:	e59f24e0 	ldr	r2, [pc, #1248]	; 348128d0 <mmc_startup+0x668>
348123ec:	e7e311d3 	ubfx	r1, r3, #3, #4
				break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
348123f0:	e2033007 	and	r3, r3, #7
348123f4:	e0823103 	add	r3, r2, r3, lsl #2
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
348123f8:	e5933040 	ldr	r3, [r3, #64]	; 0x40
348123fc:	e7922101 	ldr	r2, [r2, r1, lsl #2]

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34812400:	e7e35850 	ubfx	r5, r0, #16, #4

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34812404:	e0030293 	mul	r3, r3, r2

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
34812408:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
3481240c:	e5843084 	str	r3, [r4, #132]	; 0x84

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
34812410:	e3120802 	tst	r2, #131072	; 0x20000
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34812414:	059d24b4 	ldreq	r2, [sp, #1204]	; 0x4b4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34812418:	e3a03001 	mov	r3, #1

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
3481241c:	07e32b52 	ubfxeq	r2, r2, #22, #4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34812420:	e1a05513 	lsl	r5, r3, r5

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34812424:	01a03213 	lsleq	r3, r3, r2
34812428:	0584308c 	streq	r3, [r4, #140]	; 0x8c

	if (mmc->high_capacity) {
3481242c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
34812430:	1584508c 	strne	r5, [r4, #140]	; 0x8c
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
34812434:	e3530000 	cmp	r3, #0
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34812438:	e5845088 	str	r5, [r4, #136]	; 0x88
	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
3481243c:	0a000006 	beq	3481245c <mmc_startup+0x1f4>
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
34812440:	e1a06826 	lsr	r6, r6, #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
34812444:	e200003f 	and	r0, r0, #63	; 0x3f
			| (mmc->csd[2] & 0xffff0000) >> 16;
34812448:	e1860800 	orr	r0, r6, r0, lsl #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
3481244c:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
34812450:	e3a06008 	mov	r6, #8
34812454:	e3a07000 	mov	r7, #0
34812458:	ea000005 	b	34812474 <mmc_startup+0x20c>
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
			| (mmc->csd[2] & 0xc0000000) >> 30;
3481245c:	e1a03f26 	lsr	r3, r6, #30
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
34812460:	e1a00b00 	lsl	r0, r0, #22
			| (mmc->csd[2] & 0xc0000000) >> 30;
34812464:	e1830a20 	orr	r0, r3, r0, lsr #20
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34812468:	e7e267d6 	ubfx	r6, r6, #15, #3
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
3481246c:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34812470:	e3a07000 	mov	r7, #0
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
34812474:	e3a02001 	mov	r2, #1
34812478:	e0900002 	adds	r0, r0, r2
3481247c:	e3a03000 	mov	r3, #0
34812480:	e0a11003 	adc	r1, r1, r3
34812484:	e2862002 	add	r2, r6, #2
34812488:	eb0036ef 	bl	3482004c <__ashldi3>
	mmc->capacity *= mmc->read_bl_len;
3481248c:	e0832590 	umull	r2, r3, r0, r5
34812490:	e0233195 	mla	r3, r5, r1, r3

	if (mmc->read_bl_len > 512)
34812494:	e3550c02 	cmp	r5, #512	; 0x200
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
	mmc->capacity *= mmc->read_bl_len;
34812498:	e1c429f8 	strd	r2, [r4, #152]	; 0x98

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;
3481249c:	83a03c02 	movhi	r3, #512	; 0x200
348124a0:	85843088 	strhi	r3, [r4, #136]	; 0x88

	if (mmc->write_bl_len > 512)
348124a4:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
348124a8:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc->capacity *= mmc->read_bl_len;

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;

	if (mmc->write_bl_len > 512)
348124ac:	e3530c02 	cmp	r3, #512	; 0x200
		mmc->write_bl_len = 512;
348124b0:	83a03c02 	movhi	r3, #512	; 0x200
348124b4:	8584308c 	strhi	r3, [r4, #140]	; 0x8c

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
348124b8:	e2122b01 	ands	r2, r2, #1024	; 0x400
348124bc:	1a00000d 	bne	348124f8 <mmc_startup+0x290>
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
348124c0:	e3a03015 	mov	r3, #21
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
348124c4:	e3a00007 	mov	r0, #7
348124c8:	e28d1b01 	add	r1, sp, #1024	; 0x400
		cmd.resp_type = MMC_RSP_R1;
348124cc:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
		cmd.cmdarg = mmc->rca << 16;
348124d0:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
348124d4:	e1c109bc 	strh	r0, [r1, #156]	; 0x9c
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
		err = mmc_send_cmd(mmc, &cmd, NULL);
348124d8:	e28d1e49 	add	r1, sp, #1168	; 0x490

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
348124dc:	e1a03803 	lsl	r3, r3, #16
		err = mmc_send_cmd(mmc, &cmd, NULL);
348124e0:	e1a00004 	mov	r0, r4
348124e4:	e281100c 	add	r1, r1, #12

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
348124e8:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		err = mmc_send_cmd(mmc, &cmd, NULL);
348124ec:	ebfffc0f 	bl	34811530 <mmc_send_cmd>

		if (err)
348124f0:	e2506000 	subs	r6, r0, #0
348124f4:	1a0000ed 	bne	348128b0 <mmc_startup+0x648>
	}

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
348124f8:	e3a03001 	mov	r3, #1
348124fc:	e5843090 	str	r3, [r4, #144]	; 0x90
	mmc->part_config = MMCPART_NOAVAILABLE;
34812500:	e3e03000 	mvn	r3, #0
34812504:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34812508:	e5943030 	ldr	r3, [r4, #48]	; 0x30
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
3481250c:	e28d5fa6 	add	r5, sp, #664	; 0x298
34812510:	e2855003 	add	r5, r5, #3
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34812514:	e3130802 	tst	r3, #131072	; 0x20000
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34812518:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
3481251c:	1a000034 	bne	348125f4 <mmc_startup+0x38c>
34812520:	e59f23ac 	ldr	r2, [pc, #940]	; 348128d4 <mmc_startup+0x66c>
34812524:	e1530002 	cmp	r3, r2
34812528:	9a000031 	bls	348125f4 <mmc_startup+0x38c>
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
3481252c:	e1a00004 	mov	r0, r4
34812530:	e1a01005 	mov	r1, r5
34812534:	ebfffe34 	bl	34811e0c <mmc_send_ext_csd>
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
34812538:	e5d530c0 	ldrb	r3, [r5, #192]	; 0xc0
3481253c:	e2700001 	rsbs	r0, r0, #1
34812540:	33a00000 	movcc	r0, #0
34812544:	e3530001 	cmp	r3, #1
34812548:	93a00000 	movls	r0, #0
3481254c:	e3500000 	cmp	r0, #0
34812550:	0a000014 	beq	348125a8 <mmc_startup+0x340>
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34812554:	e5d510d6 	ldrb	r1, [r5, #214]	; 0xd6
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
34812558:	e5d530d5 	ldrb	r3, [r5, #213]	; 0xd5
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
3481255c:	e1a01801 	lsl	r1, r1, #16
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
34812560:	e1811403 	orr	r1, r1, r3, lsl #8
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34812564:	e5d530d4 	ldrb	r3, [r5, #212]	; 0xd4
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34812568:	e1811003 	orr	r1, r1, r3
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
3481256c:	e5d530d7 	ldrb	r3, [r5, #215]	; 0xd7
34812570:	e1811c03 	orr	r1, r1, r3, lsl #24
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34812574:	e1a02001 	mov	r2, r1
34812578:	e1a03fc2 	asr	r3, r2, #31
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
			capacity *= 512;
3481257c:	e1a03483 	lsl	r3, r3, #9
34812580:	e1833ba1 	orr	r3, r3, r1, lsr #23
34812584:	e1a01481 	lsl	r1, r1, #9
			if ((capacity >> 20) > 2 * 1024)
34812588:	e1a02a21 	lsr	r2, r1, #20
3481258c:	e1b00a23 	lsrs	r0, r3, #20
34812590:	e1822603 	orr	r2, r2, r3, lsl #12
34812594:	1a000001 	bne	348125a0 <mmc_startup+0x338>
34812598:	e3520b02 	cmp	r2, #2048	; 0x800
3481259c:	9a000001 	bls	348125a8 <mmc_startup+0x340>
				mmc->capacity = capacity;
348125a0:	e5841098 	str	r1, [r4, #152]	; 0x98
348125a4:	e584309c 	str	r3, [r4, #156]	; 0x9c
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
348125a8:	e5d530af 	ldrb	r3, [r5, #175]	; 0xaf
348125ac:	e3530000 	cmp	r3, #0
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
348125b0:	05943068 	ldreq	r3, [r4, #104]	; 0x68
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
348125b4:	15d530e0 	ldrbne	r3, [r5, #224]	; 0xe0
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
348125b8:	07e422d3 	ubfxeq	r2, r3, #5, #5
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
348125bc:	07e43553 	ubfxeq	r3, r3, #10, #5
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
348125c0:	02833001 	addeq	r3, r3, #1
				* (erase_gmul + 1);
348125c4:	02822001 	addeq	r2, r2, #1
348125c8:	00030293 	muleq	r3, r3, r2
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
348125cc:	11a03983 	lslne	r3, r3, #19
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
348125d0:	e5843090 	str	r3, [r4, #144]	; 0x90
				* (erase_gmul + 1);
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
348125d4:	e5d530a0 	ldrb	r3, [r5, #160]	; 0xa0
348125d8:	e3130001 	tst	r3, #1
348125dc:	1a000002 	bne	348125ec <mmc_startup+0x384>
348125e0:	e5d530e2 	ldrb	r3, [r5, #226]	; 0xe2
348125e4:	e3530000 	cmp	r3, #0
348125e8:	0a000001 	beq	348125f4 <mmc_startup+0x38c>
		    ext_csd[EXT_CSD_BOOT_MULT])
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
348125ec:	e5d530b3 	ldrb	r3, [r5, #179]	; 0xb3
348125f0:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	}

	if (IS_SD(mmc))
348125f4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
348125f8:	e3130802 	tst	r3, #131072	; 0x20000
348125fc:	0a000002 	beq	3481260c <mmc_startup+0x3a4>
		err = sd_change_freq(mmc);
34812600:	e1a00004 	mov	r0, r4
34812604:	ebfffe87 	bl	34812028 <sd_change_freq>
34812608:	ea000001 	b	34812614 <mmc_startup+0x3ac>
	else
		err = mmc_change_freq(mmc);
3481260c:	e1a00004 	mov	r0, r4
34812610:	ebfffe25 	bl	34811eac <mmc_change_freq>

	if (err)
34812614:	e3500000 	cmp	r0, #0
	}

	if (IS_SD(mmc))
		err = sd_change_freq(mmc);
	else
		err = mmc_change_freq(mmc);
34812618:	e1a06000 	mov	r6, r0

	if (err)
3481261c:	1a0000a3 	bne	348128b0 <mmc_startup+0x648>
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34812620:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812624:	e5947050 	ldr	r7, [r4, #80]	; 0x50

	if (IS_SD(mmc)) {
34812628:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
3481262c:	e0073003 	and	r3, r7, r3

	if (IS_SD(mmc)) {
34812630:	e3120802 	tst	r2, #131072	; 0x20000

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34812634:	e584304c 	str	r3, [r4, #76]	; 0x4c

	if (IS_SD(mmc)) {
34812638:	0a000027 	beq	348126dc <mmc_startup+0x474>
		if (mmc->card_caps & MMC_MODE_4BIT) {
3481263c:	e3130c01 	tst	r3, #256	; 0x100
34812640:	0a000020 	beq	348126c8 <mmc_startup+0x460>
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34812644:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812648:	e28d5e49 	add	r5, sp, #1168	; 0x490
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
3481264c:	e3a01037 	mov	r1, #55	; 0x37
34812650:	e28d2b01 	add	r2, sp, #1024	; 0x400
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812654:	e285500c 	add	r5, r5, #12
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34812658:	e1c219bc 	strh	r1, [r2, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
3481265c:	e1a03803 	lsl	r3, r3, #16
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34812660:	e3a07015 	mov	r7, #21
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812664:	e1a00004 	mov	r0, r4
34812668:	e1a01005 	mov	r1, r5
3481266c:	e1a02006 	mov	r2, r6
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34812670:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = mmc->rca << 16;
34812674:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812678:	ebfffbac 	bl	34811530 <mmc_send_cmd>
			if (err)
3481267c:	e3500000 	cmp	r0, #0
34812680:	1a000089 	bne	348128ac <mmc_startup+0x644>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
34812684:	e3a03006 	mov	r3, #6
34812688:	e28d0b01 	add	r0, sp, #1024	; 0x400
3481268c:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
34812690:	e1a01005 	mov	r1, r5
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
34812694:	e3a03002 	mov	r3, #2
			err = mmc_send_cmd(mmc, &cmd, NULL);
34812698:	e1a00004 	mov	r0, r4
3481269c:	e1a02006 	mov	r2, r6
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
348126a0:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = 2;
348126a4:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
			err = mmc_send_cmd(mmc, &cmd, NULL);
348126a8:	ebfffba0 	bl	34811530 <mmc_send_cmd>
			if (err)
348126ac:	e3500000 	cmp	r0, #0
348126b0:	1a00007d 	bne	348128ac <mmc_startup+0x644>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
348126b4:	e3a03004 	mov	r3, #4
348126b8:	e5843044 	str	r3, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348126bc:	e1a00004 	mov	r0, r4
348126c0:	e5943114 	ldr	r3, [r4, #276]	; 0x114
348126c4:	e12fff33 	blx	r3
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
348126c8:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
348126cc:	e3130001 	tst	r3, #1
			mmc->tran_speed = 50000000;
348126d0:	159f3200 	ldrne	r3, [pc, #512]	; 348128d8 <mmc_startup+0x670>
		else
			mmc->tran_speed = 25000000;
348126d4:	059f3200 	ldreq	r3, [pc, #512]	; 348128dc <mmc_startup+0x674>
348126d8:	ea00003e 	b	348127d8 <mmc_startup+0x570>
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
348126dc:	e7e17457 	ubfx	r7, r7, #8, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
348126e0:	e28a10d4 	add	r1, sl, #212	; 0xd4
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
348126e4:	e1a09107 	lsl	r9, r7, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
348126e8:	e285b0d4 	add	fp, r5, #212	; 0xd4
348126ec:	e58d1014 	str	r1, [sp, #20]
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
348126f0:	e1a00004 	mov	r0, r4
348126f4:	e3a01001 	mov	r1, #1
348126f8:	e3a020b7 	mov	r2, #183	; 0xb7
348126fc:	e6ef3077 	uxtb	r3, r7
34812700:	ebfffdd4 	bl	34811e58 <mmc_switch>
					EXT_CSD_BUS_WIDTH, width);

			if (err)
34812704:	e3500000 	cmp	r0, #0
34812708:	1a000028 	bne	348127b0 <mmc_startup+0x548>
				continue;

			if (!width) {
3481270c:	e3570000 	cmp	r7, #0
34812710:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34812714:	1a000004 	bne	3481272c <mmc_startup+0x4c4>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812718:	e3a02001 	mov	r2, #1
3481271c:	e5842044 	str	r2, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812720:	e1a00004 	mov	r0, r4
34812724:	e12fff33 	blx	r3
			if (err)
				continue;

			if (!width) {
				mmc_set_bus_width(mmc, 1);
				break;
34812728:	ea000024 	b	348127c0 <mmc_startup+0x558>
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
3481272c:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812730:	e5849044 	str	r9, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812734:	e12fff33 	blx	r3
				mmc_set_bus_width(mmc, 1);
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
34812738:	e1a00004 	mov	r0, r4
3481273c:	e1a0100a 	mov	r1, sl
34812740:	ebfffdb1 	bl	34811e0c <mmc_send_ext_csd>
			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
34812744:	e3500000 	cmp	r0, #0
34812748:	1a000018 	bne	348127b0 <mmc_startup+0x548>
3481274c:	e5d520a0 	ldrb	r2, [r5, #160]	; 0xa0
34812750:	e5da30a0 	ldrb	r3, [sl, #160]	; 0xa0
34812754:	e1520003 	cmp	r2, r3
34812758:	1a000014 	bne	348127b0 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
3481275c:	e5d520af 	ldrb	r2, [r5, #175]	; 0xaf
34812760:	e5da30af 	ldrb	r3, [sl, #175]	; 0xaf
34812764:	e1520003 	cmp	r2, r3
34812768:	1a000010 	bne	348127b0 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
3481276c:	e5d520c0 	ldrb	r2, [r5, #192]	; 0xc0
34812770:	e5da30c0 	ldrb	r3, [sl, #192]	; 0xc0
34812774:	e1520003 	cmp	r2, r3
34812778:	1a00000c 	bne	348127b0 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
3481277c:	e5d520e0 	ldrb	r2, [r5, #224]	; 0xe0
34812780:	e5da30e0 	ldrb	r3, [sl, #224]	; 0xe0
34812784:	e1520003 	cmp	r2, r3
34812788:	1a000008 	bne	348127b0 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
3481278c:	e1a0000b 	mov	r0, fp
34812790:	e59d1014 	ldr	r1, [sp, #20]
34812794:	e3a02004 	mov	r2, #4
34812798:	eb0027f5 	bl	3481c774 <memcmp>
3481279c:	e3500000 	cmp	r0, #0
					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
348127a0:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
348127a4:	01837007 	orreq	r7, r3, r7
348127a8:	0584704c 	streq	r7, [r4, #76]	; 0x4c
				break;
348127ac:	0a000003 	beq	348127c0 <mmc_startup+0x558>
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
348127b0:	e2477001 	sub	r7, r7, #1
348127b4:	e3770001 	cmn	r7, #1
348127b8:	e2499004 	sub	r9, r9, #4
348127bc:	1affffcb 	bne	348126f0 <mmc_startup+0x488>
				mmc->card_caps |= width;
				break;
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
348127c0:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
348127c4:	e3130001 	tst	r3, #1
348127c8:	0a000003 	beq	348127dc <mmc_startup+0x574>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
348127cc:	e3130010 	tst	r3, #16
				mmc->tran_speed = 52000000;
348127d0:	159f3108 	ldrne	r3, [pc, #264]	; 348128e0 <mmc_startup+0x678>
			else
				mmc->tran_speed = 26000000;
348127d4:	059f3108 	ldreq	r3, [pc, #264]	; 348128e4 <mmc_startup+0x67c>
348127d8:	e5843084 	str	r3, [r4, #132]	; 0x84
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);
348127dc:	e1a00004 	mov	r0, r4
348127e0:	e5941084 	ldr	r1, [r4, #132]	; 0x84
348127e4:	ebfffe8f 	bl	34812228 <mmc_set_clock>

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348127e8:	e594509c 	ldr	r5, [r4, #156]	; 0x9c
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
348127ec:	e3a03000 	mov	r3, #0
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
348127f0:	e5941088 	ldr	r1, [r4, #136]	; 0x88
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348127f4:	e5940098 	ldr	r0, [r4, #152]	; 0x98
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
348127f8:	e1550003 	cmp	r5, r3
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
348127fc:	e5c430aa 	strb	r3, [r4, #170]	; 0xaa
	mmc->block_dev.type = 0;
34812800:	e5c430ab 	strb	r3, [r4, #171]	; 0xab
	mmc->block_dev.blksz = mmc->read_bl_len;
34812804:	e58410b4 	str	r1, [r4, #180]	; 0xb4
/* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
34812808:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
3481280c:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
	do_div(__res, divisor);
34812810:	1a000003 	bne	34812824 <mmc_startup+0x5bc>
34812814:	eb0034eb 	bl	3481fbc8 <__udivsi3>
34812818:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
3481281c:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
34812820:	ea000002 	b	34812830 <mmc_startup+0x5c8>
34812824:	e28d0e4b 	add	r0, sp, #1200	; 0x4b0
34812828:	e2800008 	add	r0, r0, #8
3481282c:	eb0020d8 	bl	3481ab94 <__div64_32>
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812830:	e59d34b8 	ldr	r3, [sp, #1208]	; 0x4b8
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34812834:	e594c078 	ldr	ip, [r4, #120]	; 0x78

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812838:	e58430b0 	str	r3, [r4, #176]	; 0xb0
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
3481283c:	e5942070 	ldr	r2, [r4, #112]	; 0x70
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34812840:	e5d4307f 	ldrb	r3, [r4, #127]	; 0x7f
	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34812844:	e28400b8 	add	r0, r4, #184	; 0xb8
34812848:	e183340c 	orr	r3, r3, ip, lsl #8
3481284c:	e59f1094 	ldr	r1, [pc, #148]	; 348128e8 <mmc_startup+0x680>
34812850:	e1a02422 	lsr	r2, r2, #8
34812854:	eb002b08 	bl	3481d47c <sprintf>
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34812858:	e5943074 	ldr	r3, [r4, #116]	; 0x74
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
3481285c:	e5d42070 	ldrb	r2, [r4, #112]	; 0x70
34812860:	e7e71853 	ubfx	r1, r3, #16, #8
34812864:	e58d1000 	str	r1, [sp]
34812868:	e7e71453 	ubfx	r1, r3, #8, #8
3481286c:	e58d1004 	str	r1, [sp, #4]
34812870:	e20310ff 	and	r1, r3, #255	; 0xff
34812874:	e58d1008 	str	r1, [sp, #8]
34812878:	e28400e1 	add	r0, r4, #225	; 0xe1
3481287c:	e59f1068 	ldr	r1, [pc, #104]	; 348128ec <mmc_startup+0x684>
34812880:	e1a03c23 	lsr	r3, r3, #24
34812884:	eb002afc 	bl	3481d47c <sprintf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
34812888:	e5943078 	ldr	r3, [r4, #120]	; 0x78
3481288c:	e28400f6 	add	r0, r4, #246	; 0xf6
34812890:	e1a02e23 	lsr	r2, r3, #28
34812894:	e59f1054 	ldr	r1, [pc, #84]	; 348128f0 <mmc_startup+0x688>
34812898:	e7e33c53 	ubfx	r3, r3, #24, #4
3481289c:	eb002af6 	bl	3481d47c <sprintf>
			(mmc->cid[2] >> 24) & 0xf);
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
348128a0:	e28400a0 	add	r0, r4, #160	; 0xa0
348128a4:	ebfff497 	bl	3480fb08 <init_part>
#endif

	return 0;
348128a8:	ea000000 	b	348128b0 <mmc_startup+0x648>

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
348128ac:	e1a06000 	mov	r6, r0
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
#endif

	return 0;
}
348128b0:	e1a00006 	mov	r0, r6
348128b4:	e28ddd13 	add	sp, sp, #1216	; 0x4c0
348128b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348128bc:	00010014 	.word	0x00010014
348128c0:	00010022 	.word	0x00010022
348128c4:	00010030 	.word	0x00010030
348128c8:	00010040 	.word	0x00010040
348128cc:	00010012 	.word	0x00010012
348128d0:	3482145c 	.word	0x3482145c
348128d4:	0001003f 	.word	0x0001003f
348128d8:	02faf080 	.word	0x02faf080
348128dc:	017d7840 	.word	0x017d7840
348128e0:	03197500 	.word	0x03197500
348128e4:	018cba80 	.word	0x018cba80
348128e8:	3482700d 	.word	0x3482700d
348128ec:	3482701f 	.word	0x3482701f
348128f0:	3482702a 	.word	0x3482702a

348128f4 <mmc_send_if_cond>:

int mmc_send_if_cond(struct mmc *mmc)
{
348128f4:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
348128f8:	e3a03008 	mov	r3, #8

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
348128fc:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812900:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
int mmc_send_if_cond(struct mmc *mmc)
{
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34812904:	e1cd30b4 	strh	r3, [sp, #4]
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812908:	e59f3050 	ldr	r3, [pc, #80]	; 34812960 <mmc_send_if_cond+0x6c>
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481290c:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812910:	e0023003 	and	r3, r2, r3
34812914:	e3530000 	cmp	r3, #0
34812918:	e30021aa 	movw	r2, #426	; 0x1aa
3481291c:	11a03002 	movne	r3, r2
34812920:	03a030aa 	moveq	r3, #170	; 0xaa
34812924:	e58d300c 	str	r3, [sp, #12]
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812928:	e3a02000 	mov	r2, #0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
3481292c:	e3a03015 	mov	r3, #21

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
34812930:	e1a04000 	mov	r4, r0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
34812934:	e58d3008 	str	r3, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812938:	ebfffafc 	bl	34811530 <mmc_send_cmd>

	if (err)
3481293c:	e3500000 	cmp	r0, #0
34812940:	1a000004 	bne	34812958 <mmc_send_if_cond+0x64>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
34812944:	e5dd3010 	ldrb	r3, [sp, #16]
34812948:	e35300aa 	cmp	r3, #170	; 0xaa
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
3481294c:	059f3010 	ldreq	r3, [pc, #16]	; 34812964 <mmc_send_if_cond+0x70>

	if (err)
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
		return UNUSABLE_ERR;
34812950:	13e00010 	mvnne	r0, #16
	else
		mmc->version = SD_VERSION_2;
34812954:	05843030 	streq	r3, [r4, #48]	; 0x30

	return 0;
}
34812958:	e28dd020 	add	sp, sp, #32
3481295c:	e8bd8010 	pop	{r4, pc}
34812960:	00ff8000 	.word	0x00ff8000
34812964:	00020020 	.word	0x00020020

34812968 <mmc_register>:

int mmc_register(struct mmc *mmc)
{
	/* Setup the universal parts of the block interface just once */
	mmc->block_dev.if_type = IF_TYPE_MMC;
34812968:	e3a03006 	mov	r3, #6
3481296c:	e58030a0 	str	r3, [r0, #160]	; 0xa0
	mmc->block_dev.dev = cur_dev_num++;
34812970:	e59f305c 	ldr	r3, [pc, #92]	; 348129d4 <mmc_register+0x6c>
34812974:	e5932000 	ldr	r2, [r3]
34812978:	e58020a4 	str	r2, [r0, #164]	; 0xa4
3481297c:	e2822001 	add	r2, r2, #1
34812980:	e5832000 	str	r2, [r3]
	mmc->block_dev.removable = 1;
34812984:	e3a03001 	mov	r3, #1
34812988:	e5c030ac 	strb	r3, [r0, #172]	; 0xac
	mmc->block_dev.block_read = mmc_bread;
3481298c:	e59f3044 	ldr	r3, [pc, #68]	; 348129d8 <mmc_register+0x70>
34812990:	e5803100 	str	r3, [r0, #256]	; 0x100
	mmc->block_dev.block_write = mmc_bwrite;
34812994:	e59f3040 	ldr	r3, [pc, #64]	; 348129dc <mmc_register+0x74>
34812998:	e5803104 	str	r3, [r0, #260]	; 0x104
	mmc->block_dev.block_erase = mmc_berase;
3481299c:	e59f303c 	ldr	r3, [pc, #60]	; 348129e0 <mmc_register+0x78>
348129a0:	e5803108 	str	r3, [r0, #264]	; 0x108
	if (!mmc->b_max)
348129a4:	e5903120 	ldr	r3, [r0, #288]	; 0x120
348129a8:	e3530000 	cmp	r3, #0
		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
348129ac:	030f3fff 	movweq	r3, #65535	; 0xffff
348129b0:	05803120 	streq	r3, [r0, #288]	; 0x120
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348129b4:	e59f3028 	ldr	r3, [pc, #40]	; 348129e4 <mmc_register+0x7c>
348129b8:	e5932004 	ldr	r2, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348129bc:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348129c0:	e5830004 	str	r0, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
348129c4:	e5820000 	str	r0, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
348129c8:	e5802004 	str	r2, [r0, #4]
	INIT_LIST_HEAD (&mmc->link);

	list_add_tail (&mmc->link, &mmc_devices);

	return 0;
}
348129cc:	e3a00000 	mov	r0, #0
348129d0:	e12fff1e 	bx	lr
348129d4:	34828a98 	.word	0x34828a98
348129d8:	34811a90 	.word	0x34811a90
348129dc:	34811844 	.word	0x34811844
348129e0:	348116b4 	.word	0x348116b4
348129e4:	3482b98c 	.word	0x3482b98c

348129e8 <mmc_init>:
	return &mmc->block_dev;
}
#endif

int mmc_init(struct mmc *mmc)
{
348129e8:	e92d4038 	push	{r3, r4, r5, lr}
348129ec:	e1a04000 	mov	r4, r0
	int err;

	if (mmc_getcd(mmc) == 0) {
348129f0:	ebfffd68 	bl	34811f98 <mmc_getcd>
348129f4:	e3500000 	cmp	r0, #0
348129f8:	1a000004 	bne	34812a10 <mmc_init+0x28>
		mmc->has_init = 0;
348129fc:	e5840034 	str	r0, [r4, #52]	; 0x34
		printf("MMC: no card present\n");
34812a00:	e59f00b8 	ldr	r0, [pc, #184]	; 34812ac0 <mmc_init+0xd8>
34812a04:	ebffdc2f 	bl	34809ac8 <printf>
		return NO_CARD_ERR;
34812a08:	e3e0000f 	mvn	r0, #15
34812a0c:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	if (mmc->has_init)
34812a10:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34812a14:	e3530000 	cmp	r3, #0
34812a18:	1a000026 	bne	34812ab8 <mmc_init+0xd0>
		return 0;

	err = mmc->init(mmc);
34812a1c:	e5943118 	ldr	r3, [r4, #280]	; 0x118
34812a20:	e1a00004 	mov	r0, r4
34812a24:	e12fff33 	blx	r3

	if (err)
34812a28:	e3500000 	cmp	r0, #0
34812a2c:	18bd8038 	popne	{r3, r4, r5, pc}
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812a30:	e3a05001 	mov	r5, #1
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812a34:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34812a38:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812a3c:	e5845044 	str	r5, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812a40:	e12fff33 	blx	r3

	if (err)
		return err;

	mmc_set_bus_width(mmc, 1);
	mmc_set_clock(mmc, 1);
34812a44:	e1a00004 	mov	r0, r4
34812a48:	e1a01005 	mov	r1, r5
34812a4c:	ebfffdf5 	bl	34812228 <mmc_set_clock>

	/* Reset the Card */
	err = mmc_go_idle(mmc);
34812a50:	e1a00004 	mov	r0, r4
34812a54:	ebfffc36 	bl	34811b34 <mmc_go_idle>

	if (err)
34812a58:	e3500000 	cmp	r0, #0
34812a5c:	18bd8038 	popne	{r3, r4, r5, pc}
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
34812a60:	e5c40083 	strb	r0, [r4, #131]	; 0x83

	/* Test for SD version 2 */
	err = mmc_send_if_cond(mmc);
34812a64:	e1a00004 	mov	r0, r4
34812a68:	ebffffa1 	bl	348128f4 <mmc_send_if_cond>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);
34812a6c:	e1a00004 	mov	r0, r4
34812a70:	ebfffc42 	bl	34811b80 <sd_send_op_cond>

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
34812a74:	e3700013 	cmn	r0, #19
34812a78:	1a000007 	bne	34812a9c <mmc_init+0xb4>
		err = mmc_send_op_cond(mmc);
34812a7c:	e1a00004 	mov	r0, r4
34812a80:	ebfffc90 	bl	34811cc8 <mmc_send_op_cond>

		if (err) {
34812a84:	e3500000 	cmp	r0, #0
34812a88:	0a000003 	beq	34812a9c <mmc_init+0xb4>
			printf("Card did not respond to voltage select!\n");
34812a8c:	e59f0030 	ldr	r0, [pc, #48]	; 34812ac4 <mmc_init+0xdc>
34812a90:	ebffdc0c 	bl	34809ac8 <printf>
			return UNUSABLE_ERR;
34812a94:	e3e00010 	mvn	r0, #16
34812a98:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	err = mmc_startup(mmc);
34812a9c:	e1a00004 	mov	r0, r4
34812aa0:	ebfffdf0 	bl	34812268 <mmc_startup>
	if (err)
34812aa4:	e3500000 	cmp	r0, #0
		mmc->has_init = 0;
34812aa8:	13a03000 	movne	r3, #0
	else
		mmc->has_init = 1;
34812aac:	03a03001 	moveq	r3, #1
34812ab0:	e5843034 	str	r3, [r4, #52]	; 0x34
34812ab4:	e8bd8038 	pop	{r3, r4, r5, pc}
		printf("MMC: no card present\n");
		return NO_CARD_ERR;
	}

	if (mmc->has_init)
		return 0;
34812ab8:	e3a00000 	mov	r0, #0
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
	return err;
}
34812abc:	e8bd8038 	pop	{r3, r4, r5, pc}
34812ac0:	34827030 	.word	0x34827030
34812ac4:	34827046 	.word	0x34827046

34812ac8 <mmc_get_dev>:
	return 0;
}

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
34812ac8:	e92d4010 	push	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev);
34812acc:	ebfffae6 	bl	3481166c <find_mmc_device>
	if (!mmc || mmc_init(mmc))
34812ad0:	e2504000 	subs	r4, r0, #0
		return NULL;
34812ad4:	01a00004 	moveq	r0, r4

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
34812ad8:	08bd8010 	popeq	{r4, pc}
34812adc:	ebffffc1 	bl	348129e8 <mmc_init>
34812ae0:	e3500000 	cmp	r0, #0
		return NULL;

	return &mmc->block_dev;
34812ae4:	028400a0 	addeq	r0, r4, #160	; 0xa0
#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
		return NULL;
34812ae8:	13a00000 	movne	r0, #0

	return &mmc->block_dev;
}
34812aec:	e8bd8010 	pop	{r4, pc}

34812af0 <cpu_mmc_init>:
 * signals caller to move on
 */
static int __def_mmc_init(bd_t *bis)
{
	return -1;
}
34812af0:	e3e00000 	mvn	r0, #0
34812af4:	e12fff1e 	bx	lr

34812af8 <print_mmc_devices>:

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34812af8:	e92d4070 	push	{r4, r5, r6, lr}
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812afc:	e59f5048 	ldr	r5, [pc, #72]	; 34812b4c <print_mmc_devices+0x54>

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34812b00:	e1a06000 	mov	r6, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812b04:	e5954000 	ldr	r4, [r5]
34812b08:	ea00000a 	b	34812b38 <print_mmc_devices+0x40>
		m = list_entry(entry, struct mmc, link);

		printf("%s: %d", m->name, m->block_dev.dev);
34812b0c:	e59f003c 	ldr	r0, [pc, #60]	; 34812b50 <print_mmc_devices+0x58>
34812b10:	e2841008 	add	r1, r4, #8
34812b14:	e59420a4 	ldr	r2, [r4, #164]	; 0xa4
34812b18:	ebffdbea 	bl	34809ac8 <printf>

		if (entry->next != &mmc_devices)
34812b1c:	e5943000 	ldr	r3, [r4]
34812b20:	e1530005 	cmp	r3, r5
34812b24:	0a000002 	beq	34812b34 <print_mmc_devices+0x3c>
			printf("%c ", separator);
34812b28:	e59f0024 	ldr	r0, [pc, #36]	; 34812b54 <print_mmc_devices+0x5c>
34812b2c:	e1a01006 	mov	r1, r6
34812b30:	ebffdbe4 	bl	34809ac8 <printf>
void print_mmc_devices(char separator)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812b34:	e5944000 	ldr	r4, [r4]
34812b38:	e1540005 	cmp	r4, r5
34812b3c:	1afffff2 	bne	34812b0c <print_mmc_devices+0x14>

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34812b40:	e59f0010 	ldr	r0, [pc, #16]	; 34812b58 <print_mmc_devices+0x60>
}
34812b44:	e8bd4070 	pop	{r4, r5, r6, lr}

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34812b48:	eaffdbde 	b	34809ac8 <printf>
34812b4c:	3482b98c 	.word	0x3482b98c
34812b50:	3482706f 	.word	0x3482706f
34812b54:	3482376e 	.word	0x3482376e
34812b58:	34826197 	.word	0x34826197

34812b5c <get_mmc_num>:
}

int get_mmc_num(void)
{
	return cur_dev_num;
}
34812b5c:	e59f3004 	ldr	r3, [pc, #4]	; 34812b68 <get_mmc_num+0xc>
34812b60:	e5930000 	ldr	r0, [r3]
34812b64:	e12fff1e 	bx	lr
34812b68:	34828a98 	.word	0x34828a98

34812b6c <mmc_initialize>:
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34812b6c:	e59f303c 	ldr	r3, [pc, #60]	; 34812bb0 <mmc_initialize+0x44>

int mmc_initialize(bd_t *bis)
{
34812b70:	e92d4010 	push	{r4, lr}
34812b74:	e5833000 	str	r3, [r3]
	list->prev = list;
34812b78:	e5833004 	str	r3, [r3, #4]
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;
34812b7c:	e59f3030 	ldr	r3, [pc, #48]	; 34812bb4 <mmc_initialize+0x48>
34812b80:	e3a02000 	mov	r2, #0
34812b84:	e5832000 	str	r2, [r3]
{
	return cur_dev_num;
}

int mmc_initialize(bd_t *bis)
{
34812b88:	e1a04000 	mov	r4, r0
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;

	if (board_mmc_init(bis) < 0)
34812b8c:	ebffb883 	bl	34800da0 <board_mmc_init>
34812b90:	e3500000 	cmp	r0, #0
34812b94:	aa000001 	bge	34812ba0 <mmc_initialize+0x34>
		cpu_mmc_init(bis);
34812b98:	e1a00004 	mov	r0, r4
34812b9c:	ebffffd3 	bl	34812af0 <cpu_mmc_init>

	print_mmc_devices(',');
34812ba0:	e3a0002c 	mov	r0, #44	; 0x2c
34812ba4:	ebffffd3 	bl	34812af8 <print_mmc_devices>

	return 0;
}
34812ba8:	e3a00000 	mov	r0, #0
34812bac:	e8bd8010 	pop	{r4, pc}
34812bb0:	3482b98c 	.word	0x3482b98c
34812bb4:	34828a98 	.word	0x34828a98

34812bb8 <sdhci_set_ios>:

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812bb8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812bbc:	e5905028 	ldr	r5, [r0, #40]	; 0x28

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812bc0:	e1a07000 	mov	r7, r0
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if (host->set_control_reg)
34812bc4:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34812bc8:	e3530000 	cmp	r3, #0
34812bcc:	0a000001 	beq	34812bd8 <sdhci_set_ios+0x20>
		host->set_control_reg(host);
34812bd0:	e1a00005 	mov	r0, r5
34812bd4:	e12fff33 	blx	r3

	if (mmc->clock != host->clock)
34812bd8:	e597a048 	ldr	sl, [r7, #72]	; 0x48
34812bdc:	e5953014 	ldr	r3, [r5, #20]
34812be0:	e15a0003 	cmp	sl, r3
34812be4:	0a000040 	beq	34812cec <sdhci_set_ios+0x134>
		return COMM_ERR;
}

static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812be8:	e5976028 	ldr	r6, [r7, #40]	; 0x28
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812bec:	e5963004 	ldr	r3, [r6, #4]
34812bf0:	e3a02000 	mov	r2, #0
	unsigned int div, clk, timeout;

	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);

	if (clock == 0)
34812bf4:	e35a0000 	cmp	sl, #0
34812bf8:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
34812bfc:	0a00003a 	beq	34812cec <sdhci_set_ios+0x134>
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
34812c00:	e5d63010 	ldrb	r3, [r6, #16]
34812c04:	e597b03c 	ldr	fp, [r7, #60]	; 0x3c
34812c08:	e3530001 	cmp	r3, #1
34812c0c:	9a00000d 	bls	34812c48 <sdhci_set_ios+0x90>
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
34812c10:	e15b000a 	cmp	fp, sl
			div = 1;
34812c14:	93a04001 	movls	r4, #1
	if (clock == 0)
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
34812c18:	9a000014 	bls	34812c70 <sdhci_set_ios+0xb8>
34812c1c:	e3a04002 	mov	r4, #2
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
34812c20:	e30097fe 	movw	r9, #2046	; 0x7fe
				if ((mmc->f_max / div) <= clock)
34812c24:	e1a0000b 	mov	r0, fp
34812c28:	e1a01004 	mov	r1, r4
34812c2c:	eb0033e5 	bl	3481fbc8 <__udivsi3>
34812c30:	e150000a 	cmp	r0, sl
34812c34:	9a00000d 	bls	34812c70 <sdhci_set_ios+0xb8>
	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
34812c38:	e2844002 	add	r4, r4, #2
34812c3c:	e1540009 	cmp	r4, r9
34812c40:	1afffff7 	bne	34812c24 <sdhci_set_ios+0x6c>
34812c44:	ea000009 	b	34812c70 <sdhci_set_ios+0xb8>
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
34812c48:	e3a09008 	mov	r9, #8
34812c4c:	e3a04001 	mov	r4, #1
34812c50:	e1a0000b 	mov	r0, fp
34812c54:	e1a01004 	mov	r1, r4
34812c58:	eb0033da 	bl	3481fbc8 <__udivsi3>
34812c5c:	e150000a 	cmp	r0, sl
34812c60:	9a000002 	bls	34812c70 <sdhci_set_ios+0xb8>
					break;
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
34812c64:	e2599001 	subs	r9, r9, #1
34812c68:	e1a04084 	lsl	r4, r4, #1
34812c6c:	1afffff7 	bne	34812c50 <sdhci_set_ios+0x98>
				break;
		}
	}
	div >>= 1;

	if (host->set_clock)
34812c70:	e5963028 	ldr	r3, [r6, #40]	; 0x28
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
				break;
		}
	}
	div >>= 1;
34812c74:	e1a040a4 	lsr	r4, r4, #1

	if (host->set_clock)
34812c78:	e3530000 	cmp	r3, #0
34812c7c:	0a000002 	beq	34812c8c <sdhci_set_ios+0xd4>
		host->set_clock(host->index, div);
34812c80:	e5960020 	ldr	r0, [r6, #32]
34812c84:	e1a01004 	mov	r1, r4
34812c88:	e12fff33 	blx	r3

	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
34812c8c:	e1a03c04 	lsl	r3, r4, #24
34812c90:	e1a03823 	lsr	r3, r3, #16
	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
34812c94:	e3833001 	orr	r3, r3, #1
34812c98:	e7e14454 	ubfx	r4, r4, #8, #2
		<< SDHCI_DIVIDER_HI_SHIFT;
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812c9c:	e1834304 	orr	r4, r3, r4, lsl #6
34812ca0:	e5963004 	ldr	r3, [r6, #4]
34812ca4:	e1c342bc 	strh	r4, [r3, #44]	; 0x2c

	/* Wait max 20 ms */
	timeout = 20;
34812ca8:	e3a04014 	mov	r4, #20
34812cac:	ea000007 	b	34812cd0 <sdhci_set_ios+0x118>
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
34812cb0:	e3540000 	cmp	r4, #0
34812cb4:	1a000002 	bne	34812cc4 <sdhci_set_ios+0x10c>
			printf("Internal clock never stabilised.\n");
34812cb8:	e59f00a4 	ldr	r0, [pc, #164]	; 34812d64 <sdhci_set_ios+0x1ac>
34812cbc:	ebffdb81 	bl	34809ac8 <printf>
34812cc0:	ea000009 	b	34812cec <sdhci_set_ios+0x134>
			return -1;
		}
		timeout--;
		udelay(1000);
34812cc4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
			printf("Internal clock never stabilised.\n");
			return -1;
		}
		timeout--;
34812cc8:	e2444001 	sub	r4, r4, #1
		udelay(1000);
34812ccc:	eb002700 	bl	3481c8d4 <udelay>
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34812cd0:	e5963004 	ldr	r3, [r6, #4]
34812cd4:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);

	/* Wait max 20 ms */
	timeout = 20;
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
34812cd8:	e3130002 	tst	r3, #2
34812cdc:	0afffff3 	beq	34812cb0 <sdhci_set_ios+0xf8>
		timeout--;
		udelay(1000);
	}

	clk |= SDHCI_CLOCK_CARD_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812ce0:	e3833004 	orr	r3, r3, #4
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812ce4:	e5962004 	ldr	r2, [r6, #4]
34812ce8:	e1c232bc 	strh	r3, [r2, #44]	; 0x2c
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812cec:	e5953004 	ldr	r3, [r5, #4]
34812cf0:	e5d30028 	ldrb	r0, [r3, #40]	; 0x28
	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
34812cf4:	e5972044 	ldr	r2, [r7, #68]	; 0x44

	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
34812cf8:	e1a03000 	mov	r3, r0
	if (mmc->bus_width == 8) {
34812cfc:	e3520008 	cmp	r2, #8
34812d00:	e5951010 	ldr	r1, [r5, #16]
34812d04:	1a000004 	bne	34812d1c <sdhci_set_ios+0x164>
		ctrl &= ~SDHCI_CTRL_4BITBUS;
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812d08:	e20110ff 	and	r1, r1, #255	; 0xff
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
		ctrl &= ~SDHCI_CTRL_4BITBUS;
34812d0c:	e3c03002 	bic	r3, r0, #2
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812d10:	e3510001 	cmp	r1, #1
			ctrl |= SDHCI_CTRL_8BITBUS;
34812d14:	83833020 	orrhi	r3, r3, #32
34812d18:	ea000005 	b	34812d34 <sdhci_set_ios+0x17c>
	} else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812d1c:	e20110ff 	and	r1, r1, #255	; 0xff
34812d20:	e3510001 	cmp	r1, #1
			ctrl &= ~SDHCI_CTRL_8BITBUS;
34812d24:	83c03020 	bichi	r3, r0, #32
		if (mmc->bus_width == 4)
34812d28:	e3520004 	cmp	r2, #4
			ctrl |= SDHCI_CTRL_4BITBUS;
34812d2c:	03833002 	orreq	r3, r3, #2
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
34812d30:	13c33002 	bicne	r3, r3, #2
	}

	if (mmc->clock > 26000000)
34812d34:	e5971048 	ldr	r1, [r7, #72]	; 0x48
34812d38:	e59f2028 	ldr	r2, [pc, #40]	; 34812d68 <sdhci_set_ios+0x1b0>
34812d3c:	e1510002 	cmp	r1, r2
		ctrl |= SDHCI_CTRL_HISPD;
	else
		ctrl &= ~SDHCI_CTRL_HISPD;

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
34812d40:	e5952008 	ldr	r2, [r5, #8]
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
	}

	if (mmc->clock > 26000000)
		ctrl |= SDHCI_CTRL_HISPD;
34812d44:	83833004 	orrhi	r3, r3, #4
	else
		ctrl &= ~SDHCI_CTRL_HISPD;
34812d48:	93c33004 	bicls	r3, r3, #4

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
34812d4c:	e3120008 	tst	r2, #8
		ctrl &= ~SDHCI_CTRL_HISPD;
34812d50:	13c33004 	bicne	r3, r3, #4

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
34812d54:	e6ef3073 	uxtb	r3, r3
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812d58:	e5952004 	ldr	r2, [r5, #4]
34812d5c:	e5c23028 	strb	r3, [r2, #40]	; 0x28
}
34812d60:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812d64:	34827076 	.word	0x34827076
34812d68:	018cba80 	.word	0x018cba80

34812d6c <sdhci_init>:

int sdhci_init(struct mmc *mmc)
{
34812d6c:	e92d4070 	push	{r4, r5, r6, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812d70:	e5904028 	ldr	r4, [r0, #40]	; 0x28

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
}

int sdhci_init(struct mmc *mmc)
{
34812d74:	e1a05000 	mov	r5, r0
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
34812d78:	e5943008 	ldr	r3, [r4, #8]
34812d7c:	e3130001 	tst	r3, #1
34812d80:	0a00000d 	beq	34812dbc <sdhci_init+0x50>
34812d84:	e59f614c 	ldr	r6, [pc, #332]	; 34812ed8 <sdhci_init+0x16c>
34812d88:	e5963000 	ldr	r3, [r6]
34812d8c:	e3530000 	cmp	r3, #0
34812d90:	1a000009 	bne	34812dbc <sdhci_init+0x50>
		aligned_buffer = memalign(8, 512*1024);
34812d94:	e3a00008 	mov	r0, #8
34812d98:	e3a01702 	mov	r1, #524288	; 0x80000
34812d9c:	ebffdeb5 	bl	3480a878 <memalign>
		if (!aligned_buffer) {
34812da0:	e3500000 	cmp	r0, #0
int sdhci_init(struct mmc *mmc)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
		aligned_buffer = memalign(8, 512*1024);
34812da4:	e5860000 	str	r0, [r6]
		if (!aligned_buffer) {
34812da8:	1a000003 	bne	34812dbc <sdhci_init+0x50>
			printf("Aligned buffer alloc failed!!!");
34812dac:	e59f0128 	ldr	r0, [pc, #296]	; 34812edc <sdhci_init+0x170>
34812db0:	ebffdb44 	bl	34809ac8 <printf>
			return -1;
34812db4:	e3e00000 	mvn	r0, #0
34812db8:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);
34812dbc:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
34812dc0:	e3530000 	cmp	r3, #0
		return 0;
34812dc4:	01a02003 	moveq	r2, r3
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
34812dc8:	0a000010 	beq	34812e10 <sdhci_init+0xa4>
		return 0;
	if (!(x & 0xffff0000u)) {
34812dcc:	e1a02823 	lsr	r2, r3, #16
34812dd0:	e1a02802 	lsl	r2, r2, #16
34812dd4:	e3520000 	cmp	r2, #0
		x <<= 16;
34812dd8:	01a03803 	lsleq	r3, r3, #16
		r -= 16;
34812ddc:	02822010 	addeq	r2, r2, #16
 * This is defined the same way as ffs.
 * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
 */
static inline int generic_fls(int x)
{
	int r = 32;
34812de0:	13a02020 	movne	r2, #32
		return 0;
	if (!(x & 0xffff0000u)) {
		x <<= 16;
		r -= 16;
	}
	if (!(x & 0xff000000u)) {
34812de4:	e31304ff 	tst	r3, #-16777216	; 0xff000000
		x <<= 8;
34812de8:	01a03403 	lsleq	r3, r3, #8
		r -= 8;
34812dec:	02422008 	subeq	r2, r2, #8
	}
	if (!(x & 0xf0000000u)) {
34812df0:	e313020f 	tst	r3, #-268435456	; 0xf0000000
		x <<= 4;
34812df4:	01a03203 	lsleq	r3, r3, #4
		r -= 4;
34812df8:	02422004 	subeq	r2, r2, #4
	}
	if (!(x & 0xc0000000u)) {
34812dfc:	e3130103 	tst	r3, #-1073741824	; 0xc0000000
		x <<= 2;
34812e00:	01a03103 	lsleq	r3, r3, #2
		r -= 2;
34812e04:	02422002 	subeq	r2, r2, #2
	}
	if (!(x & 0x80000000u)) {
34812e08:	e3530000 	cmp	r3, #0
		x <<= 1;
		r -= 1;
34812e0c:	a2422001 	subge	r2, r2, #1
34812e10:	e2422001 	sub	r2, r2, #1
34812e14:	e6ff2072 	uxth	r2, r2

static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
{
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
34812e18:	e30f3fff 	movw	r3, #65535	; 0xffff
34812e1c:	e1520003 	cmp	r2, r3
34812e20:	0a00000f 	beq	34812e64 <sdhci_init+0xf8>
		switch (1 << power) {
34812e24:	e3a03001 	mov	r3, #1
34812e28:	e1a02213 	lsl	r2, r3, r2
34812e2c:	e3520701 	cmp	r2, #262144	; 0x40000
34812e30:	0a000023 	beq	34812ec4 <sdhci_init+0x158>
34812e34:	ca000004 	bgt	34812e4c <sdhci_init+0xe0>
34812e38:	e3520080 	cmp	r2, #128	; 0x80
34812e3c:	0a00001e 	beq	34812ebc <sdhci_init+0x150>
34812e40:	e3520802 	cmp	r2, #131072	; 0x20000
34812e44:	1a000006 	bne	34812e64 <sdhci_init+0xf8>
34812e48:	ea00001d 	b	34812ec4 <sdhci_init+0x158>
34812e4c:	e3520601 	cmp	r2, #1048576	; 0x100000
34812e50:	0a000001 	beq	34812e5c <sdhci_init+0xf0>
34812e54:	e3520602 	cmp	r2, #2097152	; 0x200000
34812e58:	1a000001 	bne	34812e64 <sdhci_init+0xf8>
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
			break;
		case MMC_VDD_32_33:
		case MMC_VDD_33_34:
			pwr = SDHCI_POWER_330;
34812e5c:	e3a0300e 	mov	r3, #14
34812e60:	ea000018 	b	34812ec8 <sdhci_init+0x15c>
34812e64:	e5943004 	ldr	r3, [r4, #4]
34812e68:	e3a02000 	mov	r2, #0
34812e6c:	e5c32029 	strb	r2, [r3, #41]	; 0x29
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);

	if (host->quirks & SDHCI_QUIRK_NO_CD) {
34812e70:	e5943008 	ldr	r3, [r4, #8]
34812e74:	e3130020 	tst	r3, #32
34812e78:	0a000008 	beq	34812ea0 <sdhci_init+0x134>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812e7c:	e5943004 	ldr	r3, [r4, #4]
34812e80:	e3a020c0 	mov	r2, #192	; 0xc0
34812e84:	e5832028 	str	r2, [r3, #40]	; 0x28
34812e88:	ea000000 	b	34812e90 <sdhci_init+0x124>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812e8c:	e5943004 	ldr	r3, [r4, #4]
34812e90:	e5933024 	ldr	r3, [r3, #36]	; 0x24
		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
34812e94:	e2033807 	and	r3, r3, #458752	; 0x70000

		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
34812e98:	e3530807 	cmp	r3, #458752	; 0x70000
34812e9c:	1afffffa 	bne	34812e8c <sdhci_init+0x120>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812ea0:	e5942004 	ldr	r2, [r4, #4]
34812ea4:	e3e03000 	mvn	r3, #0
34812ea8:	e5823034 	str	r3, [r2, #52]	; 0x34
34812eac:	e5942004 	ldr	r2, [r4, #4]

	/* Eable all state */
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);

	return 0;
34812eb0:	e3a00000 	mov	r0, #0
34812eb4:	e5823038 	str	r3, [r2, #56]	; 0x38
}
34812eb8:	e8bd8070 	pop	{r4, r5, r6, pc}
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
		switch (1 << power) {
		case MMC_VDD_165_195:
			pwr = SDHCI_POWER_180;
34812ebc:	e3a0300a 	mov	r3, #10
34812ec0:	ea000000 	b	34812ec8 <sdhci_init+0x15c>
			break;
		case MMC_VDD_29_30:
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
34812ec4:	e3a0300c 	mov	r3, #12
	if (pwr == 0) {
		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
		return;
	}

	pwr |= SDHCI_POWER_ON;
34812ec8:	e3833001 	orr	r3, r3, #1
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812ecc:	e5942004 	ldr	r2, [r4, #4]
34812ed0:	e5c23029 	strb	r3, [r2, #41]	; 0x29
34812ed4:	eaffffe5 	b	34812e70 <sdhci_init+0x104>
34812ed8:	3482b994 	.word	0x3482b994
34812edc:	34827098 	.word	0x34827098

34812ee0 <sdhci_reset.clone.9>:
#include <mmc.h>
#include <sdhci.h>

void *aligned_buffer;

static void sdhci_reset(struct sdhci_host *host, u8 mask)
34812ee0:	e92d4070 	push	{r4, r5, r6, lr}
34812ee4:	e1a04000 	mov	r4, r0
34812ee8:	e1a05001 	mov	r5, r1
34812eec:	e5903000 	ldr	r3, [r0]
{
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
34812ef0:	e3a06064 	mov	r6, #100	; 0x64
34812ef4:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f
34812ef8:	ea000008 	b	34812f20 <sdhci_reset.clone.9+0x40>
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
34812efc:	e3560000 	cmp	r6, #0
34812f00:	1a000003 	bne	34812f14 <sdhci_reset.clone.9+0x34>
			printf("Reset 0x%x never completed.\n", (int)mask);
34812f04:	e59f0028 	ldr	r0, [pc, #40]	; 34812f34 <sdhci_reset.clone.9+0x54>
34812f08:	e1a01005 	mov	r1, r5
			return;
		}
		timeout--;
		udelay(1000);
	}
}
34812f0c:	e8bd4070 	pop	{r4, r5, r6, lr}
	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
34812f10:	eaffdaec 	b	34809ac8 <printf>
			return;
		}
		timeout--;
		udelay(1000);
34812f14:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
			return;
		}
		timeout--;
34812f18:	e2466001 	sub	r6, r6, #1
		udelay(1000);
34812f1c:	eb00266c 	bl	3481c8d4 <udelay>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812f20:	e5943000 	ldr	r3, [r4]
34812f24:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
34812f28:	e1130005 	tst	r3, r5
34812f2c:	1afffff2 	bne	34812efc <sdhci_reset.clone.9+0x1c>
			return;
		}
		timeout--;
		udelay(1000);
	}
}
34812f30:	e8bd8070 	pop	{r4, r5, r6, pc}
34812f34:	348270b7 	.word	0x348270b7

34812f38 <sdhci_send_command>:
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
34812f38:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812f3c:	e5904028 	ldr	r4, [r0, #40]	; 0x28
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
34812f40:	e1a05001 	mov	r5, r1
34812f44:	e1a06002 	mov	r6, r2
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;

	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
34812f48:	e1d1a0b0 	ldrh	sl, [r1]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812f4c:	e5943004 	ldr	r3, [r4, #4]

	/* Wait max 10 ms */
	timeout = 10;

	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
34812f50:	e35a000c 	cmp	sl, #12
34812f54:	e3e02000 	mvn	r2, #0
34812f58:	e5832030 	str	r2, [r3, #48]	; 0x30
34812f5c:	03a0a001 	moveq	sl, #1
34812f60:	13a0a003 	movne	sl, #3
34812f64:	e3a0700a 	mov	r7, #10
34812f68:	ea000008 	b	34812f90 <sdhci_send_command+0x58>
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
34812f6c:	e3570000 	cmp	r7, #0
34812f70:	1a000003 	bne	34812f84 <sdhci_send_command+0x4c>
			printf("Controller never released inhibit bit(s).\n");
34812f74:	e59f0300 	ldr	r0, [pc, #768]	; 3481327c <sdhci_send_command+0x344>
34812f78:	ebffdad2 	bl	34809ac8 <printf>
			return COMM_ERR;
34812f7c:	e3e00011 	mvn	r0, #17
34812f80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
		timeout--;
		udelay(1000);
34812f84:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
			printf("Controller never released inhibit bit(s).\n");
			return COMM_ERR;
		}
		timeout--;
34812f88:	e2477001 	sub	r7, r7, #1
		udelay(1000);
34812f8c:	eb002650 	bl	3481c8d4 <udelay>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812f90:	e5943004 	ldr	r3, [r4, #4]
34812f94:	e5933024 	ldr	r3, [r3, #36]	; 0x24
	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
34812f98:	e11a0003 	tst	sl, r3
34812f9c:	1afffff2 	bne	34812f6c <sdhci_send_command+0x34>
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
34812fa0:	e5951004 	ldr	r1, [r5, #4]
34812fa4:	e2113001 	ands	r3, r1, #1
34812fa8:	0a000008 	beq	34812fd0 <sdhci_send_command+0x98>
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812fac:	e3110002 	tst	r1, #2
		flags = SDHCI_CMD_RESP_LONG;
34812fb0:	13a03001 	movne	r3, #1
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812fb4:	1a000002 	bne	34812fc4 <sdhci_send_command+0x8c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812fb8:	e3110008 	tst	r1, #8
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
34812fbc:	13a03003 	movne	r3, #3
	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812fc0:	0a000001 	beq	34812fcc <sdhci_send_command+0x94>
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
34812fc4:	e1a02003 	mov	r2, r3
34812fc8:	ea000001 	b	34812fd4 <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;
34812fcc:	e3a03002 	mov	r3, #2
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
34812fd0:	e3a02001 	mov	r2, #1
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;

	if (cmd->resp_type & MMC_RSP_CRC)
34812fd4:	e3110004 	tst	r1, #4
		flags |= SDHCI_CMD_CRC;
34812fd8:	13833008 	orrne	r3, r3, #8
	if (cmd->resp_type & MMC_RSP_OPCODE)
34812fdc:	e3110010 	tst	r1, #16
		flags |= SDHCI_CMD_INDEX;
34812fe0:	13833010 	orrne	r3, r3, #16
	if (data)
34812fe4:	e3560000 	cmp	r6, #0
34812fe8:	0a000014 	beq	34813040 <sdhci_send_command+0x108>
		flags |= SDHCI_CMD_DATA;
34812fec:	e3833020 	orr	r3, r3, #32
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812ff0:	e5941004 	ldr	r1, [r4, #4]
34812ff4:	e3a0000e 	mov	r0, #14
34812ff8:	e5c1002e 	strb	r0, [r1, #46]	; 0x2e
	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
34812ffc:	e9961003 	ldmib	r6, {r0, r1, ip}
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
34813000:	e3510001 	cmp	r1, #1
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34813004:	e1a0ca0c 	lsl	ip, ip, #20
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
34813008:	83a01022 	movhi	r1, #34	; 0x22
3481300c:	93a01002 	movls	r1, #2
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34813010:	e1a0ca2c 	lsr	ip, ip, #20
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
			mode |= SDHCI_TRNS_MULTI;

		if (data->flags == MMC_DATA_READ)
34813014:	e3500001 	cmp	r0, #1
			mode |= SDHCI_TRNS_READ;
34813018:	03811010 	orreq	r1, r1, #16
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
3481301c:	e38cca07 	orr	ip, ip, #28672	; 0x7000
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34813020:	e5940004 	ldr	r0, [r4, #4]
34813024:	e1c0c0b4 	strh	ip, [r0, #4]
				data->blocksize),
				SDHCI_BLOCK_SIZE);
		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
34813028:	e1d6c0b8 	ldrh	ip, [r6, #8]
3481302c:	e5940004 	ldr	r0, [r4, #4]
		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
34813030:	e6ff1071 	uxth	r1, r1
34813034:	e1c0c0b6 	strh	ip, [r0, #6]
34813038:	e5940004 	ldr	r0, [r4, #4]
3481303c:	e1c010bc 	strh	r1, [r0, #12]
	}

	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
34813040:	e5950008 	ldr	r0, [r5, #8]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813044:	e5941004 	ldr	r1, [r4, #4]
#ifdef CONFIG_MMC_SDMA
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
34813048:	e20330ff 	and	r3, r3, #255	; 0xff
3481304c:	e5810008 	str	r0, [r1, #8]
34813050:	e1d510b0 	ldrh	r1, [r5]
34813054:	e1833401 	orr	r3, r3, r1, lsl #8
34813058:	e6ff3073 	uxth	r3, r3
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
3481305c:	e5941004 	ldr	r1, [r4, #4]
34813060:	e1c130be 	strh	r3, [r1, #14]
	unsigned int stat = 0;
	int ret = 0;
	int trans_bytes = 0, is_aligned = 1;
	u32 mask, flags, mode;
	unsigned int timeout, start_addr = 0;
	unsigned int retry = 10000;
34813064:	e3023710 	movw	r3, #10000	; 0x2710
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813068:	e5941004 	ldr	r1, [r4, #4]
3481306c:	e5911030 	ldr	r1, [r1, #48]	; 0x30
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR)
34813070:	e3110902 	tst	r1, #32768	; 0x8000
34813074:	1a000005 	bne	34813090 <sdhci_send_command+0x158>
			break;
		if (--retry == 0)
34813078:	e2533001 	subs	r3, r3, #1
3481307c:	0a000005 	beq	34813098 <sdhci_send_command+0x160>
			break;
	} while ((stat & mask) != mask);
34813080:	e0020001 	and	r0, r2, r1
34813084:	e1500002 	cmp	r0, r2
34813088:	1afffff6 	bne	34813068 <sdhci_send_command+0x130>
3481308c:	ea000008 	b	348130b4 <sdhci_send_command+0x17c>

	if (retry == 0) {
34813090:	e3530000 	cmp	r3, #0
34813094:	1a000006 	bne	348130b4 <sdhci_send_command+0x17c>
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
34813098:	e5943008 	ldr	r3, [r4, #8]
3481309c:	e3130004 	tst	r3, #4
348130a0:	1a000073 	bne	34813274 <sdhci_send_command+0x33c>
			return 0;
		else {
			printf("Timeout for status update!\n");
348130a4:	e59f01d4 	ldr	r0, [pc, #468]	; 34813280 <sdhci_send_command+0x348>
348130a8:	ebffda86 	bl	34809ac8 <printf>
			return TIMEOUT;
348130ac:	e3e00012 	mvn	r0, #18
348130b0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
348130b4:	e3823902 	orr	r3, r2, #32768	; 0x8000
348130b8:	e0011003 	and	r1, r1, r3
348130bc:	e1510002 	cmp	r1, r2
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;
348130c0:	13e00000 	mvnne	r0, #0
			printf("Timeout for status update!\n");
			return TIMEOUT;
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
348130c4:	1a00001b 	bne	34813138 <sdhci_send_command+0x200>
}

static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
348130c8:	e5953004 	ldr	r3, [r5, #4]
348130cc:	e3130002 	tst	r3, #2
348130d0:	0a000012 	beq	34813120 <sdhci_send_command+0x1e8>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
348130d4:	e285500c 	add	r5, r5, #12
348130d8:	e3a0201c 	mov	r2, #28
348130dc:	e3a03000 	mov	r3, #0
348130e0:	e5940004 	ldr	r0, [r4, #4]
348130e4:	e7900002 	ldr	r0, [r0, r2]
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
					SDHCI_RESPONSE + (3-i)*4) << 8;
348130e8:	e1a00400 	lsl	r0, r0, #8
			if (i != 3)
348130ec:	e3530003 	cmp	r3, #3
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
348130f0:	e4850004 	str	r0, [r5], #4
					SDHCI_RESPONSE + (3-i)*4) << 8;
			if (i != 3)
348130f4:	0a000004 	beq	3481310c <sdhci_send_command+0x1d4>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
348130f8:	e5947004 	ldr	r7, [r4, #4]
348130fc:	e242c001 	sub	ip, r2, #1
34813100:	e7d7c00c 	ldrb	ip, [r7, ip]
				cmd->response[i] |= sdhci_readb(host,
34813104:	e18c0000 	orr	r0, ip, r0
34813108:	e5050004 	str	r0, [r5, #-4]
static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
3481310c:	e2833001 	add	r3, r3, #1
34813110:	e3530004 	cmp	r3, #4
34813114:	e2422004 	sub	r2, r2, #4
34813118:	1afffff0 	bne	348130e0 <sdhci_send_command+0x1a8>
3481311c:	ea000002 	b	3481312c <sdhci_send_command+0x1f4>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813120:	e5943004 	ldr	r3, [r4, #4]
34813124:	e5933010 	ldr	r3, [r3, #16]
			if (i != 3)
				cmd->response[i] |= sdhci_readb(host,
						SDHCI_RESPONSE + (3-i)*4-1);
		}
	} else {
		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
34813128:	e585300c 	str	r3, [r5, #12]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481312c:	e5943004 	ldr	r3, [r4, #4]
int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
	unsigned int stat = 0;
	int ret = 0;
34813130:	e3a00000 	mov	r0, #0
34813134:	e5831030 	str	r1, [r3, #48]	; 0x30
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;

	if (!ret && data)
34813138:	e2803001 	add	r3, r0, #1
3481313c:	e3560000 	cmp	r6, #0
34813140:	03a03000 	moveq	r3, #0
34813144:	12033001 	andne	r3, r3, #1
34813148:	e3530000 	cmp	r3, #0
3481314c:	0a000036 	beq	3481322c <sdhci_send_command+0x2f4>

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
34813150:	e2847004 	add	r7, r4, #4
}

static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
				unsigned int start_addr)
{
	unsigned int stat, rdy, mask, timeout, block = 0;
34813154:	e3a09000 	mov	r9, #0

	timeout = 10000;
34813158:	e302a710 	movw	sl, #10000	; 0x2710
3481315c:	e3a0b030 	mov	fp, #48	; 0x30
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813160:	e5973000 	ldr	r3, [r7]
34813164:	e5935030 	ldr	r5, [r3, #48]	; 0x30
	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR) {
34813168:	e2153902 	ands	r3, r5, #32768	; 0x8000
3481316c:	0a000003 	beq	34813180 <sdhci_send_command+0x248>
			printf("Error detected in status(0x%X)!\n", stat);
34813170:	e1a01005 	mov	r1, r5
34813174:	e59f0108 	ldr	r0, [pc, #264]	; 34813284 <sdhci_send_command+0x34c>
34813178:	ebffda52 	bl	34809ac8 <printf>
3481317c:	ea000025 	b	34813218 <sdhci_send_command+0x2e0>
			return -1;
		}
		if (stat & rdy) {
34813180:	e3150030 	tst	r5, #48	; 0x30
34813184:	0a00001b 	beq	348131f8 <sdhci_send_command+0x2c0>
34813188:	e5972000 	ldr	r2, [r7]
3481318c:	e5922024 	ldr	r2, [r2, #36]	; 0x24
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
34813190:	e3120b03 	tst	r2, #3072	; 0xc00
34813194:	0a000021 	beq	34813220 <sdhci_send_command+0x2e8>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813198:	e5972000 	ldr	r2, [r7]
3481319c:	e582b030 	str	fp, [r2, #48]	; 0x30
348131a0:	ea00000a 	b	348131d0 <sdhci_send_command+0x298>
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
		offs = data->dest + i;
		if (data->flags == MMC_DATA_READ)
348131a4:	e5961004 	ldr	r1, [r6, #4]
348131a8:	e3510001 	cmp	r1, #1
348131ac:	1a000003 	bne	348131c0 <sdhci_send_command+0x288>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348131b0:	e5971000 	ldr	r1, [r7]
348131b4:	e5911020 	ldr	r1, [r1, #32]
			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
348131b8:	e7821003 	str	r1, [r2, r3]
348131bc:	ea000002 	b	348131cc <sdhci_send_command+0x294>
		else
			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
348131c0:	e7921003 	ldr	r1, [r2, r3]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348131c4:	e5972000 	ldr	r2, [r7]
348131c8:	e5821020 	str	r1, [r2, #32]

static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
348131cc:	e2833004 	add	r3, r3, #4
348131d0:	e596100c 	ldr	r1, [r6, #12]
348131d4:	e5962000 	ldr	r2, [r6]
348131d8:	e1530001 	cmp	r3, r1
348131dc:	3afffff0 	bcc	348131a4 <sdhci_send_command+0x26c>
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
			if (++block >= data->blocks)
348131e0:	e5963008 	ldr	r3, [r6, #8]
348131e4:	e2899001 	add	r9, r9, #1
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
348131e8:	e0822001 	add	r2, r2, r1
			if (++block >= data->blocks)
348131ec:	e1590003 	cmp	r9, r3
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
348131f0:	e5862000 	str	r2, [r6]
			if (++block >= data->blocks)
348131f4:	2a00000b 	bcs	34813228 <sdhci_send_command+0x2f0>
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
348131f8:	e35a0000 	cmp	sl, #0
348131fc:	0a000003 	beq	34813210 <sdhci_send_command+0x2d8>
			udelay(10);
34813200:	e3a0000a 	mov	r0, #10
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
34813204:	e24aa001 	sub	sl, sl, #1
			udelay(10);
34813208:	eb0025b1 	bl	3481c8d4 <udelay>
3481320c:	ea000003 	b	34813220 <sdhci_send_command+0x2e8>
		else {
			printf("Transfer data timeout\n");
34813210:	e59f0070 	ldr	r0, [pc, #112]	; 34813288 <sdhci_send_command+0x350>
34813214:	ebffda2b 	bl	34809ac8 <printf>
			return -1;
34813218:	e3e00000 	mvn	r0, #0
3481321c:	ea000002 	b	3481322c <sdhci_send_command+0x2f4>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
34813220:	e3150002 	tst	r5, #2
34813224:	0affffcd 	beq	34813160 <sdhci_send_command+0x228>
	return 0;
34813228:	e3a00000 	mov	r0, #0
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
3481322c:	e5943004 	ldr	r3, [r4, #4]
34813230:	e5935030 	ldr	r5, [r3, #48]	; 0x30

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813234:	e5943004 	ldr	r3, [r4, #4]
34813238:	e3e02000 	mvn	r2, #0
	if (!ret && data)
		ret = sdhci_transfer_data(host, data, start_addr);

	stat = sdhci_readl(host, SDHCI_INT_STATUS);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	if (!ret) {
3481323c:	e3500000 	cmp	r0, #0
34813240:	e5832030 	str	r2, [r3, #48]	; 0x30
34813244:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
34813248:	e2844004 	add	r4, r4, #4
				!is_aligned && (data->flags == MMC_DATA_READ))
			memcpy(data->dest, aligned_buffer, trans_bytes);
		return 0;
	}

	sdhci_reset(host, SDHCI_RESET_CMD);
3481324c:	e1a00004 	mov	r0, r4
34813250:	e3a01002 	mov	r1, #2
34813254:	ebffff21 	bl	34812ee0 <sdhci_reset.clone.9>
	sdhci_reset(host, SDHCI_RESET_DATA);
34813258:	e1a00004 	mov	r0, r4
3481325c:	e3a01004 	mov	r1, #4
34813260:	ebffff1e 	bl	34812ee0 <sdhci_reset.clone.9>
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
34813264:	e3150801 	tst	r5, #65536	; 0x10000
34813268:	03e00011 	mvneq	r0, #17
3481326c:	13e00012 	mvnne	r0, #18
34813270:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			break;
	} while ((stat & mask) != mask);

	if (retry == 0) {
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
			return 0;
34813274:	e3a00000 	mov	r0, #0
	sdhci_reset(host, SDHCI_RESET_DATA);
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
	else
		return COMM_ERR;
}
34813278:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481327c:	348270d4 	.word	0x348270d4
34813280:	348270ff 	.word	0x348270ff
34813284:	3482711b 	.word	0x3482711b
34813288:	3482713c 	.word	0x3482713c

3481328c <add_sdhci>:

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
3481328c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34813290:	e1a05000 	mov	r5, r0
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34813294:	e3a00f4a 	mov	r0, #296	; 0x128

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34813298:	e1a07001 	mov	r7, r1
3481329c:	e1a06002 	mov	r6, r2
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
348132a0:	ebffdbcf 	bl	3480a1e4 <malloc>
	if (!mmc) {
348132a4:	e2504000 	subs	r4, r0, #0
		printf("mmc malloc fail!\n");
348132a8:	059f0144 	ldreq	r0, [pc, #324]	; 348133f4 <add_sdhci+0x168>
{
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
	if (!mmc) {
348132ac:	0a00001f 	beq	34813330 <add_sdhci+0xa4>
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
348132b0:	e5845028 	str	r5, [r4, #40]	; 0x28
	host->mmc = mmc;

	sprintf(mmc->name, "%s", host->name);
348132b4:	e2840008 	add	r0, r4, #8
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
	host->mmc = mmc;
348132b8:	e5854018 	str	r4, [r5, #24]

	sprintf(mmc->name, "%s", host->name);
348132bc:	e59f1134 	ldr	r1, [pc, #308]	; 348133f8 <add_sdhci+0x16c>
348132c0:	e5952000 	ldr	r2, [r5]
348132c4:	eb00286c 	bl	3481d47c <sprintf>
	mmc->send_cmd = sdhci_send_command;
348132c8:	e59f312c 	ldr	r3, [pc, #300]	; 348133fc <add_sdhci+0x170>
348132cc:	e5843110 	str	r3, [r4, #272]	; 0x110
	mmc->set_ios = sdhci_set_ios;
348132d0:	e59f3128 	ldr	r3, [pc, #296]	; 34813400 <add_sdhci+0x174>
348132d4:	e5843114 	str	r3, [r4, #276]	; 0x114
	mmc->init = sdhci_init;
348132d8:	e59f3124 	ldr	r3, [pc, #292]	; 34813404 <add_sdhci+0x178>
348132dc:	e5843118 	str	r3, [r4, #280]	; 0x118
	mmc->getcd = NULL;
348132e0:	e3a03000 	mov	r3, #0
348132e4:	e584311c 	str	r3, [r4, #284]	; 0x11c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348132e8:	e5953004 	ldr	r3, [r5, #4]
348132ec:	e593a040 	ldr	sl, [r3, #64]	; 0x40
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
348132f0:	e3570000 	cmp	r7, #0
		mmc->f_max = max_clk;
348132f4:	1584703c 	strne	r7, [r4, #60]	; 0x3c
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
348132f8:	1a000008 	bne	34813320 <add_sdhci+0x94>
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348132fc:	e5d53010 	ldrb	r3, [r5, #16]
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34813300:	e59f2100 	ldr	r2, [pc, #256]	; 34813408 <add_sdhci+0x17c>
#endif

	if (max_clk)
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34813304:	e3530001 	cmp	r3, #1
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34813308:	87e7345a 	ubfxhi	r3, sl, #8, #8
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
3481330c:	97e5345a 	ubfxls	r3, sl, #8, #6
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
34813310:	e584303c 	str	r3, [r4, #60]	; 0x3c
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34813314:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
34813318:	e0030392 	mul	r3, r2, r3
3481331c:	e584303c 	str	r3, [r4, #60]	; 0x3c
	}
	if (mmc->f_max == 0) {
34813320:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
34813324:	e3500000 	cmp	r0, #0
34813328:	1a000003 	bne	3481333c <add_sdhci+0xb0>
		printf("Hardware doesn't specify base clock frequency\n");
3481332c:	e59f00d8 	ldr	r0, [pc, #216]	; 3481340c <add_sdhci+0x180>
34813330:	ebffd9e4 	bl	34809ac8 <printf>
		return -1;
34813334:	e3e00000 	mvn	r0, #0
34813338:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	if (min_clk)
3481333c:	e3560000 	cmp	r6, #0
		mmc->f_min = min_clk;
34813340:	15846038 	strne	r6, [r4, #56]	; 0x38
	}
	if (mmc->f_max == 0) {
		printf("Hardware doesn't specify base clock frequency\n");
		return -1;
	}
	if (min_clk)
34813344:	1a000006 	bne	34813364 <add_sdhci+0xd8>
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34813348:	e5d53010 	ldrb	r3, [r5, #16]
3481334c:	e3530001 	cmp	r3, #1
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34813350:	91a00420 	lsrls	r0, r0, #8
		return -1;
	}
	if (min_clk)
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34813354:	9a000001 	bls	34813360 <add_sdhci+0xd4>
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
34813358:	e30017fe 	movw	r1, #2046	; 0x7fe
3481335c:	eb003219 	bl	3481fbc8 <__udivsi3>
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34813360:	e5840038 	str	r0, [r4, #56]	; 0x38
	}

	mmc->voltages = 0;
34813364:	e3a03000 	mov	r3, #0
	if (caps & SDHCI_CAN_VDD_330)
34813368:	e31a0401 	tst	sl, #16777216	; 0x1000000
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
	}

	mmc->voltages = 0;
3481336c:	e584302c 	str	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
34813370:	12833603 	addne	r3, r3, #3145728	; 0x300000
34813374:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_300)
34813378:	e31a0402 	tst	sl, #33554432	; 0x2000000
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
3481337c:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34813380:	e2850004 	add	r0, r5, #4

	mmc->voltages = 0;
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34813384:	13833806 	orrne	r3, r3, #393216	; 0x60000
34813388:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_180)
3481338c:	e31a0301 	tst	sl, #67108864	; 0x4000000
		mmc->voltages |= MMC_VDD_165_195;
34813390:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34813394:	e3a01001 	mov	r1, #1
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
	if (caps & SDHCI_CAN_VDD_180)
		mmc->voltages |= MMC_VDD_165_195;
34813398:	13833080 	orrne	r3, r3, #128	; 0x80
3481339c:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
348133a0:	e5953008 	ldr	r3, [r5, #8]
348133a4:	e3130010 	tst	r3, #16
		mmc->voltages |= host->voltages;
348133a8:	1595302c 	ldrne	r3, [r5, #44]	; 0x2c
348133ac:	1594202c 	ldrne	r2, [r4, #44]	; 0x2c
348133b0:	11823003 	orrne	r3, r2, r3
348133b4:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
348133b8:	e3003111 	movw	r3, #273	; 0x111
	if (caps & SDHCI_CAN_DO_8BIT)
348133bc:	e31a0701 	tst	sl, #262144	; 0x40000
		mmc->voltages |= MMC_VDD_165_195;

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
		mmc->voltages |= host->voltages;

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
348133c0:	e5843050 	str	r3, [r4, #80]	; 0x50
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
348133c4:	12833c02 	addne	r3, r3, #512	; 0x200
348133c8:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (host->host_caps)
348133cc:	e595300c 	ldr	r3, [r5, #12]
348133d0:	e3530000 	cmp	r3, #0
		mmc->host_caps |= host->host_caps;
348133d4:	15942050 	ldrne	r2, [r4, #80]	; 0x50
348133d8:	11823003 	orrne	r3, r2, r3
348133dc:	15843050 	strne	r3, [r4, #80]	; 0x50

	sdhci_reset(host, SDHCI_RESET_ALL);
348133e0:	ebfffebe 	bl	34812ee0 <sdhci_reset.clone.9>
	mmc_register(mmc);
348133e4:	e1a00004 	mov	r0, r4
348133e8:	ebfffd5e 	bl	34812968 <mmc_register>

	return 0;
348133ec:	e3a00000 	mov	r0, #0
}
348133f0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348133f4:	34827153 	.word	0x34827153
348133f8:	34824a94 	.word	0x34824a94
348133fc:	34812f38 	.word	0x34812f38
34813400:	34812bb8 	.word	0x34812bb8
34813404:	34812d6c 	.word	0x34812d6c
34813408:	000f4240 	.word	0x000f4240
3481340c:	34827165 	.word	0x34827165

34813410 <s5p_sdhci_set_control_reg>:

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813410:	e5903004 	ldr	r3, [r0, #4]
34813414:	e3a02803 	mov	r2, #196608	; 0x30000
34813418:	e583208c 	str	r2, [r3, #140]	; 0x8c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
3481341c:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 11 = 9mA
	 */
	sdhci_writel(host, SDHCI_CTRL4_DRIVE_MASK(0x3), SDHCI_CONTROL4);

	val = sdhci_readl(host, SDHCI_CONTROL2);
	val &= SDHCI_CTRL2_SELBASECLK_SHIFT;
34813420:	e2022004 	and	r2, r2, #4

	val |=	SDHCI_CTRL2_ENSTAASYNCCLR |
34813424:	e3822103 	orr	r2, r2, #-1073741824	; 0xc0000000
34813428:	e3822c41 	orr	r2, r2, #16640	; 0x4100

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481342c:	e5903004 	ldr	r3, [r0, #4]
34813430:	e5832080 	str	r2, [r3, #128]	; 0x80
34813434:	e5903004 	ldr	r3, [r0, #4]
34813438:	e3082080 	movw	r2, #32896	; 0x8080
3481343c:	e5832084 	str	r2, [r3, #132]	; 0x84
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813440:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 00/01 = HCLK
	 * 10 = EPLL
	 * 11 = XTI or XEXTCLK
	 */
	ctrl = sdhci_readl(host, SDHCI_CONTROL2);
	ctrl &= ~SDHCI_CTRL2_SELBASECLK_MASK(0x3);
34813444:	e3c22030 	bic	r2, r2, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
34813448:	e3822020 	orr	r2, r2, #32

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481344c:	e5903004 	ldr	r3, [r0, #4]
34813450:	e5832080 	str	r2, [r3, #128]	; 0x80
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}
34813454:	e12fff1e 	bx	lr

34813458 <s5p_sdhci_init>:

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34813458:	e92d4038 	push	{r3, r4, r5, lr}
3481345c:	e1a04000 	mov	r4, r0
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34813460:	e3a00030 	mov	r0, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34813464:	e1a05001 	mov	r5, r1
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34813468:	ebffdb5d 	bl	3480a1e4 <malloc>
	if (!host) {
3481346c:	e2503000 	subs	r3, r0, #0
34813470:	1a000003 	bne	34813484 <s5p_sdhci_init+0x2c>
		printf("sdhci__host malloc fail!\n");
34813474:	e59f0058 	ldr	r0, [pc, #88]	; 348134d4 <s5p_sdhci_init+0x7c>
34813478:	ebffd992 	bl	34809ac8 <printf>
		return 1;
3481347c:	e3a00001 	mov	r0, #1
34813480:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	host->name = S5P_NAME;
34813484:	e59f204c 	ldr	r2, [pc, #76]	; 348134d8 <s5p_sdhci_init+0x80>
	host->ioaddr = (void *)regbase;
34813488:	e8830014 	stm	r3, {r2, r4}

	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
3481348c:	e3a0201d 	mov	r2, #29
34813490:	e5832008 	str	r2, [r3, #8]
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
34813494:	e59f2040 	ldr	r2, [pc, #64]	; 348134dc <s5p_sdhci_init+0x84>
34813498:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
3481349c:	e1d42fbe 	ldrh	r2, [r4, #254]	; 0xfe
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
348134a0:	e5832010 	str	r2, [r3, #16]

	host->set_control_reg = &s5p_sdhci_set_control_reg;
348134a4:	e59f2034 	ldr	r2, [pc, #52]	; 348134e0 <s5p_sdhci_init+0x88>
	host->set_clock = set_mmc_clk;
	host->index = index;
348134a8:	e5835020 	str	r5, [r3, #32]
	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
348134ac:	e5832024 	str	r2, [r3, #36]	; 0x24
	host->set_clock = set_mmc_clk;
348134b0:	e59f202c 	ldr	r2, [pc, #44]	; 348134e4 <s5p_sdhci_init+0x8c>
	host->index = index;

	host->host_caps = MMC_MODE_HC;

	add_sdhci(host, 52000000, 400000);
348134b4:	e59f102c 	ldr	r1, [pc, #44]	; 348134e8 <s5p_sdhci_init+0x90>
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
	host->set_clock = set_mmc_clk;
348134b8:	e5832028 	str	r2, [r3, #40]	; 0x28
	host->index = index;

	host->host_caps = MMC_MODE_HC;
348134bc:	e3a02b02 	mov	r2, #2048	; 0x800
348134c0:	e583200c 	str	r2, [r3, #12]

	add_sdhci(host, 52000000, 400000);
348134c4:	e59f2020 	ldr	r2, [pc, #32]	; 348134ec <s5p_sdhci_init+0x94>
348134c8:	ebffff6f 	bl	3481328c <add_sdhci>
	return 0;
348134cc:	e3a00000 	mov	r0, #0
}
348134d0:	e8bd8038 	pop	{r3, r4, r5, pc}
348134d4:	34827194 	.word	0x34827194
348134d8:	348271ae 	.word	0x348271ae
348134dc:	00300080 	.word	0x00300080
348134e0:	34813410 	.word	0x34813410
348134e4:	34801998 	.word	0x34801998
348134e8:	03197500 	.word	0x03197500
348134ec:	00061a80 	.word	0x00061a80

348134f0 <add_mtd_device>:

int add_mtd_device(struct mtd_info *mtd)
{
	int i;

	BUG_ON(mtd->writesize == 0);
348134f0:	e5903014 	ldr	r3, [r0, #20]
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
348134f4:	e92d4010 	push	{r4, lr}
	int i;

	BUG_ON(mtd->writesize == 0);
348134f8:	e3530000 	cmp	r3, #0
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
348134fc:	e1a04000 	mov	r4, r0
	int i;

	BUG_ON(mtd->writesize == 0);
34813500:	1a000003 	bne	34813514 <add_mtd_device+0x24>
34813504:	e59f0044 	ldr	r0, [pc, #68]	; 34813550 <add_mtd_device+0x60>
34813508:	e59f1044 	ldr	r1, [pc, #68]	; 34813554 <add_mtd_device+0x64>
3481350c:	e3a02014 	mov	r2, #20
34813510:	ebffd96c 	bl	34809ac8 <printf>
34813514:	e59f203c 	ldr	r2, [pc, #60]	; 34813558 <add_mtd_device+0x68>

	for (i = 0; i < MAX_MTD_DEVICES; i++)
34813518:	e3a03000 	mov	r3, #0
		if (!mtd_table[i]) {
3481351c:	e5b20004 	ldr	r0, [r2, #4]!
34813520:	e3500000 	cmp	r0, #0
34813524:	1a000004 	bne	3481353c <add_mtd_device+0x4c>
			mtd_table[i] = mtd;
34813528:	e59f202c 	ldr	r2, [pc, #44]	; 3481355c <add_mtd_device+0x6c>
3481352c:	e7824103 	str	r4, [r2, r3, lsl #2]
			mtd->index = i;
34813530:	e5843024 	str	r3, [r4, #36]	; 0x24
			mtd->usecount = 0;
34813534:	e584009c 	str	r0, [r4, #156]	; 0x9c

			/* We _know_ we aren't being removed, because
			   our caller is still holding us here. So none
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
34813538:	e8bd8010 	pop	{r4, pc}
{
	int i;

	BUG_ON(mtd->writesize == 0);

	for (i = 0; i < MAX_MTD_DEVICES; i++)
3481353c:	e2833001 	add	r3, r3, #1
34813540:	e3530020 	cmp	r3, #32
34813544:	1afffff4 	bne	3481351c <add_mtd_device+0x2c>
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
		}

	return 1;
34813548:	e3a00001 	mov	r0, #1
}
3481354c:	e8bd8010 	pop	{r4, pc}
34813550:	348271bc 	.word	0x348271bc
34813554:	348271d2 	.word	0x348271d2
34813558:	3482b994 	.word	0x3482b994
3481355c:	3482b998 	.word	0x3482b998

34813560 <del_mtd_device>:
 */
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
34813560:	e5901024 	ldr	r1, [r0, #36]	; 0x24
34813564:	e59fc03c 	ldr	ip, [pc, #60]	; 348135a8 <del_mtd_device+0x48>
 *      and notify each currently active MTD 'user' of its departure.
 *      Returns zero on success or 1 on failure, which currently will happen
 *      if the requested device does not appear to be present in the list.
 */
int del_mtd_device(struct mtd_info *mtd)
{
34813568:	e92d4008 	push	{r3, lr}
	int ret;

	if (mtd_table[mtd->index] != mtd) {
3481356c:	e79c2101 	ldr	r2, [ip, r1, lsl #2]
34813570:	e1520000 	cmp	r2, r0
34813574:	1a000009 	bne	348135a0 <del_mtd_device+0x40>
		ret = -ENODEV;
	} else if (mtd->usecount) {
34813578:	e592309c 	ldr	r3, [r2, #156]	; 0x9c
3481357c:	e3530000 	cmp	r3, #0
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
	} else {
		/* No need to get a refcount on the module containing
		 * the notifier, since we hold the mtd_table_mutex */
		mtd_table[mtd->index] = NULL;
34813580:	078c3101 	streq	r3, [ip, r1, lsl #2]

		ret = 0;
34813584:	01a00003 	moveq	r0, r3
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
	} else if (mtd->usecount) {
34813588:	08bd8008 	popeq	{r3, pc}
		printk(KERN_NOTICE "Removing MTD device #%d (%s)"
3481358c:	e59f0018 	ldr	r0, [pc, #24]	; 348135ac <del_mtd_device+0x4c>
34813590:	e5922020 	ldr	r2, [r2, #32]
34813594:	ebffd94b 	bl	34809ac8 <printf>
				" with use count %d\n",
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
34813598:	e3e0000f 	mvn	r0, #15
3481359c:	e8bd8008 	pop	{r3, pc}
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
348135a0:	e3e00012 	mvn	r0, #18

		ret = 0;
	}

	return ret;
}
348135a4:	e8bd8008 	pop	{r3, pc}
348135a8:	3482b998 	.word	0x3482b998
348135ac:	348271dc 	.word	0x348271dc

348135b0 <get_mtd_device>:
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
348135b0:	e3710001 	cmn	r1, #1
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
348135b4:	e1a03000 	mov	r3, r0
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
348135b8:	1a000008 	bne	348135e0 <get_mtd_device+0x30>
348135bc:	e59f2060 	ldr	r2, [pc, #96]	; 34813624 <get_mtd_device+0x74>
 *      table, if any.  Given an address and num == -1, search the device table
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
348135c0:	e3a00000 	mov	r0, #0
348135c4:	e2821080 	add	r1, r2, #128	; 0x80
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
			if (mtd_table[i] == mtd)
348135c8:	e5b2c004 	ldr	ip, [r2, #4]!
348135cc:	e15c0003 	cmp	ip, r3
348135d0:	01a00003 	moveq	r0, r3
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
348135d4:	e1520001 	cmp	r2, r1
348135d8:	1afffffa 	bne	348135c8 <get_mtd_device+0x18>
348135dc:	ea000006 	b	348135fc <get_mtd_device+0x4c>
			if (mtd_table[i] == mtd)
				ret = mtd_table[i];
	} else if (num < MAX_MTD_DEVICES) {
348135e0:	e351001f 	cmp	r1, #31
348135e4:	ca00000a 	bgt	34813614 <get_mtd_device+0x64>
		ret = mtd_table[num];
348135e8:	e59f2038 	ldr	r2, [pc, #56]	; 34813628 <get_mtd_device+0x78>
348135ec:	e7920101 	ldr	r0, [r2, r1, lsl #2]
		if (mtd && mtd != ret)
348135f0:	e1530000 	cmp	r3, r0
348135f4:	13530000 	cmpne	r3, #0
348135f8:	1a000005 	bne	34813614 <get_mtd_device+0x64>
			ret = NULL;
	}

	if (!ret)
348135fc:	e3500000 	cmp	r0, #0
		goto out_unlock;

	ret->usecount++;
34813600:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34813604:	12833001 	addne	r3, r3, #1
34813608:	1580309c 	strne	r3, [r0, #156]	; 0x9c
		ret = mtd_table[num];
		if (mtd && mtd != ret)
			ret = NULL;
	}

	if (!ret)
3481360c:	112fff1e 	bxne	lr
34813610:	ea000001 	b	3481361c <get_mtd_device+0x6c>

	ret->usecount++;
	return ret;

out_unlock:
	return ERR_PTR(err);
34813614:	e3e00012 	mvn	r0, #18
34813618:	e12fff1e 	bx	lr
3481361c:	e3e00012 	mvn	r0, #18
}
34813620:	e12fff1e 	bx	lr
34813624:	3482b994 	.word	0x3482b994
34813628:	3482b998 	.word	0x3482b998

3481362c <get_mtd_device_nm>:
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
3481362c:	e92d4070 	push	{r4, r5, r6, lr}

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34813630:	e59f5060 	ldr	r5, [pc, #96]	; 34813698 <get_mtd_device_nm+0x6c>
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34813634:	e1a06000 	mov	r6, r0
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34813638:	e3a04000 	mov	r4, #0
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
3481363c:	e5b53004 	ldr	r3, [r5, #4]!
34813640:	e3530000 	cmp	r3, #0
34813644:	0a00000c 	beq	3481367c <get_mtd_device_nm+0x50>
34813648:	e1a00006 	mov	r0, r6
3481364c:	e5931020 	ldr	r1, [r3, #32]
34813650:	eb00231c 	bl	3481c2c8 <strcmp>
34813654:	e3500000 	cmp	r0, #0
34813658:	1a000007 	bne	3481367c <get_mtd_device_nm+0x50>
			mtd = mtd_table[i];
3481365c:	e59f3038 	ldr	r3, [pc, #56]	; 3481369c <get_mtd_device_nm+0x70>
34813660:	e7930104 	ldr	r0, [r3, r4, lsl #2]
			break;
		}
	}

	if (!mtd)
34813664:	e3500000 	cmp	r0, #0
		goto out_unlock;

	mtd->usecount++;
34813668:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
3481366c:	12833001 	addne	r3, r3, #1
34813670:	1580309c 	strne	r3, [r0, #156]	; 0x9c
			mtd = mtd_table[i];
			break;
		}
	}

	if (!mtd)
34813674:	18bd8070 	popne	{r4, r5, r6, pc}
34813678:	ea000004 	b	34813690 <get_mtd_device_nm+0x64>
struct mtd_info *get_mtd_device_nm(const char *name)
{
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
3481367c:	e2844001 	add	r4, r4, #1
34813680:	e3540020 	cmp	r4, #32
34813684:	1affffec 	bne	3481363c <get_mtd_device_nm+0x10>

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34813688:	e3e00012 	mvn	r0, #18
3481368c:	e8bd8070 	pop	{r4, r5, r6, pc}
34813690:	e3e00012 	mvn	r0, #18
}
34813694:	e8bd8070 	pop	{r4, r5, r6, pc}
34813698:	3482b994 	.word	0x3482b994
3481369c:	3482b998 	.word	0x3482b998

348136a0 <put_mtd_device>:

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
348136a0:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
348136a4:	e2433001 	sub	r3, r3, #1
	BUG_ON(c < 0);
348136a8:	e3530000 	cmp	r3, #0

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
348136ac:	e580309c 	str	r3, [r0, #156]	; 0x9c
	BUG_ON(c < 0);
348136b0:	a12fff1e 	bxge	lr
348136b4:	e59f0008 	ldr	r0, [pc, #8]	; 348136c4 <put_mtd_device+0x24>
348136b8:	e59f1008 	ldr	r1, [pc, #8]	; 348136c8 <put_mtd_device+0x28>
348136bc:	e3a0208f 	mov	r2, #143	; 0x8f
348136c0:	eaffd900 	b	34809ac8 <printf>
348136c4:	348271bc 	.word	0x348271bc
348136c8:	348271d2 	.word	0x348271d2

348136cc <part_read_user_prot_reg>:
	return res;
}

static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
348136cc:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_user_prot_reg(part->master, from,
348136d0:	e59d1018 	ldr	r1, [sp, #24]
348136d4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348136d8:	e58d1000 	str	r1, [sp]
348136dc:	e59d101c 	ldr	r1, [sp, #28]
348136e0:	e58d1004 	str	r1, [sp, #4]
348136e4:	e59d1020 	ldr	r1, [sp, #32]
348136e8:	e58d1008 	str	r1, [sp, #8]
348136ec:	e5901060 	ldr	r1, [r0, #96]	; 0x60
348136f0:	e12fff31 	blx	r1
					len, retlen, buf);
}
348136f4:	e28dd014 	add	sp, sp, #20
348136f8:	e8bd8000 	pop	{pc}

348136fc <part_get_user_prot_info>:

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
348136fc:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
34813700:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
34813704:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
34813708:	e12fff33 	blx	r3
}
3481370c:	e8bd8008 	pop	{r3, pc}

34813710 <part_read_fact_prot_reg>:

static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34813710:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_fact_prot_reg(part->master, from,
34813714:	e59d1018 	ldr	r1, [sp, #24]
34813718:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
3481371c:	e58d1000 	str	r1, [sp]
34813720:	e59d101c 	ldr	r1, [sp, #28]
34813724:	e58d1004 	str	r1, [sp, #4]
34813728:	e59d1020 	ldr	r1, [sp, #32]
3481372c:	e58d1008 	str	r1, [sp, #8]
34813730:	e5901058 	ldr	r1, [r0, #88]	; 0x58
34813734:	e12fff31 	blx	r1
					len, retlen, buf);
}
34813738:	e28dd014 	add	sp, sp, #20
3481373c:	e8bd8000 	pop	{pc}

34813740 <part_get_fact_prot_info>:

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34813740:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
34813744:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34813748:	e5903054 	ldr	r3, [r0, #84]	; 0x54
3481374c:	e12fff33 	blx	r3
}
34813750:	e8bd8008 	pop	{r3, pc}

34813754 <part_write>:

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813754:	e92d4030 	push	{r4, r5, lr}
34813758:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
3481375c:	e5900004 	ldr	r0, [r0, #4]
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813760:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813764:	e3100b01 	tst	r0, #1024	; 0x400
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813768:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
3481376c:	03e0001d 	mvneq	r0, #29

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813770:	0a00001b 	beq	348137e4 <part_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34813774:	e591e00c 	ldr	lr, [r1, #12]
34813778:	e5910008 	ldr	r0, [r1, #8]
3481377c:	e15e0003 	cmp	lr, r3
34813780:	8a000002 	bhi	34813790 <part_write+0x3c>
34813784:	1a00000a 	bne	348137b4 <part_write+0x60>
34813788:	e1500002 	cmp	r0, r2
3481378c:	9a000008 	bls	348137b4 <part_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34813790:	e092400c 	adds	r4, r2, ip
34813794:	e2a35000 	adc	r5, r3, #0
34813798:	e155000e 	cmp	r5, lr
3481379c:	8a000002 	bhi	348137ac <part_write+0x58>
348137a0:	1a000004 	bne	348137b8 <part_write+0x64>
348137a4:	e1540000 	cmp	r4, r0
348137a8:	9a000002 	bls	348137b8 <part_write+0x64>
		len = mtd->size - to;
348137ac:	e062c000 	rsb	ip, r2, r0
348137b0:	ea000000 	b	348137b8 <part_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
348137b4:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->write(part->master, to + part->offset,
348137b8:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348137bc:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
348137c0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
348137c4:	e58dc000 	str	ip, [sp]
348137c8:	e58d1004 	str	r1, [sp, #4]
348137cc:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
348137d0:	e0922004 	adds	r2, r2, r4
348137d4:	e58d1008 	str	r1, [sp, #8]
348137d8:	e5901044 	ldr	r1, [r0, #68]	; 0x44
348137dc:	e0a33005 	adc	r3, r3, r5
348137e0:	e12fff31 	blx	r1
				    len, retlen, buf);
}
348137e4:	e28dd014 	add	sp, sp, #20
348137e8:	e8bd8030 	pop	{r4, r5, pc}

348137ec <part_panic_write>:

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
348137ec:	e92d4030 	push	{r4, r5, lr}
348137f0:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348137f4:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
348137f8:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348137fc:	e3100b01 	tst	r0, #1024	; 0x400
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813800:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813804:	03e0001d 	mvneq	r0, #29

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813808:	0a00001b 	beq	3481387c <part_panic_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
3481380c:	e591e00c 	ldr	lr, [r1, #12]
34813810:	e5910008 	ldr	r0, [r1, #8]
34813814:	e15e0003 	cmp	lr, r3
34813818:	8a000002 	bhi	34813828 <part_panic_write+0x3c>
3481381c:	1a00000a 	bne	3481384c <part_panic_write+0x60>
34813820:	e1500002 	cmp	r0, r2
34813824:	9a000008 	bls	3481384c <part_panic_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34813828:	e092400c 	adds	r4, r2, ip
3481382c:	e2a35000 	adc	r5, r3, #0
34813830:	e155000e 	cmp	r5, lr
34813834:	8a000002 	bhi	34813844 <part_panic_write+0x58>
34813838:	1a000004 	bne	34813850 <part_panic_write+0x64>
3481383c:	e1540000 	cmp	r4, r0
34813840:	9a000002 	bls	34813850 <part_panic_write+0x64>
		len = mtd->size - to;
34813844:	e062c000 	rsb	ip, r2, r0
34813848:	ea000000 	b	34813850 <part_panic_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
3481384c:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->panic_write(part->master, to + part->offset,
34813850:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813854:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813858:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3481385c:	e58dc000 	str	ip, [sp]
34813860:	e58d1004 	str	r1, [sp, #4]
34813864:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34813868:	e0922004 	adds	r2, r2, r4
3481386c:	e58d1008 	str	r1, [sp, #8]
34813870:	e5901048 	ldr	r1, [r0, #72]	; 0x48
34813874:	e0a33005 	adc	r3, r3, r5
34813878:	e12fff31 	blx	r1
				    len, retlen, buf);
}
3481387c:	e28dd014 	add	sp, sp, #20
34813880:	e8bd8030 	pop	{r4, r5, pc}

34813884 <part_write_oob>:

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813884:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813888:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
3481388c:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813890:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813894:	e3100b01 	tst	r0, #1024	; 0x400
		return -EROFS;
34813898:	03e0001d 	mvneq	r0, #29
static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
3481389c:	0a00001a 	beq	3481390c <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
348138a0:	e591600c 	ldr	r6, [r1, #12]
348138a4:	e5910008 	ldr	r0, [r1, #8]
348138a8:	e1560003 	cmp	r6, r3
348138ac:	8a000002 	bhi	348138bc <part_write_oob+0x38>
348138b0:	1a000014 	bne	34813908 <part_write_oob+0x84>
348138b4:	e1500002 	cmp	r0, r2
348138b8:	9a000012 	bls	34813908 <part_write_oob+0x84>
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
348138bc:	e59c4018 	ldr	r4, [ip, #24]
348138c0:	e3540000 	cmp	r4, #0
348138c4:	0a000007 	beq	348138e8 <part_write_oob+0x64>
348138c8:	e59c7004 	ldr	r7, [ip, #4]
348138cc:	e0924007 	adds	r4, r2, r7
348138d0:	e2a35000 	adc	r5, r3, #0
348138d4:	e1550006 	cmp	r5, r6
348138d8:	8a00000a 	bhi	34813908 <part_write_oob+0x84>
348138dc:	1a000001 	bne	348138e8 <part_write_oob+0x64>
348138e0:	e1540000 	cmp	r4, r0
348138e4:	8a000007 	bhi	34813908 <part_write_oob+0x84>
		return -EINVAL;
	return part->master->write_oob(part->master, to + part->offset, ops);
348138e8:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
348138ec:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348138f0:	e58dc000 	str	ip, [sp]
348138f4:	e0922004 	adds	r2, r2, r4
348138f8:	e5901050 	ldr	r1, [r0, #80]	; 0x50
348138fc:	e0a33005 	adc	r3, r3, r5
34813900:	e12fff31 	blx	r1
34813904:	ea000000 	b	3481390c <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
		return -EINVAL;
34813908:	e3e00015 	mvn	r0, #21
	return part->master->write_oob(part->master, to + part->offset, ops);
}
3481390c:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813910 <part_write_user_prot_reg>:

static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34813910:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->write_user_prot_reg(part->master, from,
34813914:	e59d1018 	ldr	r1, [sp, #24]
34813918:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
3481391c:	e58d1000 	str	r1, [sp]
34813920:	e59d101c 	ldr	r1, [sp, #28]
34813924:	e58d1004 	str	r1, [sp, #4]
34813928:	e59d1020 	ldr	r1, [sp, #32]
3481392c:	e58d1008 	str	r1, [sp, #8]
34813930:	e5901064 	ldr	r1, [r0, #100]	; 0x64
34813934:	e12fff31 	blx	r1
					len, retlen, buf);
}
34813938:	e28dd014 	add	sp, sp, #20
3481393c:	e8bd8000 	pop	{pc}

34813940 <part_lock_user_prot_reg>:

static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len)
{
34813940:	e92d4007 	push	{r0, r1, r2, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
34813944:	e59d1010 	ldr	r1, [sp, #16]
34813948:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
3481394c:	e58d1000 	str	r1, [sp]
34813950:	e5901068 	ldr	r1, [r0, #104]	; 0x68
34813954:	e12fff31 	blx	r1
}
34813958:	e8bd800e 	pop	{r1, r2, r3, pc}

3481395c <part_erase>:

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
3481395c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813960:	e5903004 	ldr	r3, [r0, #4]
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813964:	e1a07000 	mov	r7, r0
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813968:	e3130b01 	tst	r3, #1024	; 0x400
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
3481396c:	e1a06001 	mov	r6, r1
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813970:	03e0001d 	mvneq	r0, #29

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813974:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return -EROFS;
	if (instr->addr >= mtd->size)
34813978:	e1c120d8 	ldrd	r2, [r1, #8]
3481397c:	e597100c 	ldr	r1, [r7, #12]
34813980:	e1510003 	cmp	r1, r3
34813984:	8a000003 	bhi	34813998 <part_erase+0x3c>
34813988:	1a00001b 	bne	348139fc <part_erase+0xa0>
3481398c:	e5971008 	ldr	r1, [r7, #8]
34813990:	e1510002 	cmp	r1, r2
34813994:	9a000018 	bls	348139fc <part_erase+0xa0>
		return -EINVAL;
	instr->addr += part->offset;
34813998:	e1c70bd0 	ldrd	r0, [r7, #176]	; 0xb0
3481399c:	e0900002 	adds	r0, r0, r2
348139a0:	e0a11003 	adc	r1, r1, r3
348139a4:	e1c600f8 	strd	r0, [r6, #8]
	ret = part->master->erase(part->master, instr);
348139a8:	e59700a8 	ldr	r0, [r7, #168]	; 0xa8
348139ac:	e1a01006 	mov	r1, r6
348139b0:	e5903034 	ldr	r3, [r0, #52]	; 0x34
348139b4:	e12fff33 	blx	r3
	if (ret) {
348139b8:	e3500000 	cmp	r0, #0
348139bc:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
348139c0:	e1c621d8 	ldrd	r2, [r6, #24]
348139c4:	e3720001 	cmn	r2, #1
348139c8:	1a000001 	bne	348139d4 <part_erase+0x78>
348139cc:	e3730001 	cmn	r3, #1
348139d0:	0a000003 	beq	348139e4 <part_erase+0x88>
			instr->fail_addr -= part->offset;
348139d4:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
348139d8:	e0522004 	subs	r2, r2, r4
348139dc:	e0c33005 	sbc	r3, r3, r5
348139e0:	e1c621f8 	strd	r2, [r6, #24]
		instr->addr -= part->offset;
348139e4:	e1c620d8 	ldrd	r2, [r6, #8]
348139e8:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
348139ec:	e0522004 	subs	r2, r2, r4
348139f0:	e0c33005 	sbc	r3, r3, r5
348139f4:	e1c620f8 	strd	r2, [r6, #8]
348139f8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (instr->addr >= mtd->size)
		return -EINVAL;
348139fc:	e3e00015 	mvn	r0, #21
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
			instr->fail_addr -= part->offset;
		instr->addr -= part->offset;
	}
	return ret;
}
34813a00:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34813a04 <part_lock>:
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813a04:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813a08:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813a0c:	e1a04002 	mov	r4, r2
34813a10:	e0962004 	adds	r2, r6, r4
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813a14:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813a18:	e1a05003 	mov	r5, r3
34813a1c:	e590000c 	ldr	r0, [r0, #12]
34813a20:	e0a73005 	adc	r3, r7, r5
34813a24:	e1500003 	cmp	r0, r3
34813a28:	3a00000b 	bcc	34813a5c <part_lock+0x58>
34813a2c:	1a000002 	bne	34813a3c <part_lock+0x38>
34813a30:	e5910008 	ldr	r0, [r1, #8]
34813a34:	e1500002 	cmp	r0, r2
34813a38:	3a000007 	bcc	34813a5c <part_lock+0x58>
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
34813a3c:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34813a40:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813a44:	e1cd60f0 	strd	r6, [sp]
34813a48:	e0922004 	adds	r2, r2, r4
34813a4c:	e5901070 	ldr	r1, [r0, #112]	; 0x70
34813a50:	e0a33005 	adc	r3, r3, r5
34813a54:	e12fff31 	blx	r1
34813a58:	ea000000 	b	34813a60 <part_lock+0x5c>

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813a5c:	e3e00015 	mvn	r0, #21
	return part->master->lock(part->master, ofs + part->offset, len);
}
34813a60:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813a64 <part_unlock>:

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813a64:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813a68:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813a6c:	e1a04002 	mov	r4, r2
34813a70:	e0962004 	adds	r2, r6, r4
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
}

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813a74:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813a78:	e1a05003 	mov	r5, r3
34813a7c:	e590000c 	ldr	r0, [r0, #12]
34813a80:	e0a73005 	adc	r3, r7, r5
34813a84:	e1500003 	cmp	r0, r3
34813a88:	3a00000b 	bcc	34813abc <part_unlock+0x58>
34813a8c:	1a000002 	bne	34813a9c <part_unlock+0x38>
34813a90:	e5910008 	ldr	r0, [r1, #8]
34813a94:	e1500002 	cmp	r0, r2
34813a98:	3a000007 	bcc	34813abc <part_unlock+0x58>
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
34813a9c:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34813aa0:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813aa4:	e1cd60f0 	strd	r6, [sp]
34813aa8:	e0922004 	adds	r2, r2, r4
34813aac:	e5901074 	ldr	r1, [r0, #116]	; 0x74
34813ab0:	e0a33005 	adc	r3, r3, r5
34813ab4:	e12fff31 	blx	r1
34813ab8:	ea000000 	b	34813ac0 <part_unlock+0x5c>

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813abc:	e3e00015 	mvn	r0, #21
	return part->master->unlock(part->master, ofs + part->offset, len);
}
34813ac0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813ac4 <part_sync>:

static void part_sync(struct mtd_info *mtd)
{
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813ac4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
}

static void part_sync(struct mtd_info *mtd)
{
34813ac8:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813acc:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
34813ad0:	e12fff33 	blx	r3
}
34813ad4:	e8bd8008 	pop	{r3, pc}

34813ad8 <part_block_isbad>:

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813ad8:	e92d4038 	push	{r3, r4, r5, lr}
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813adc:	e1a05003 	mov	r5, r3
34813ae0:	e590300c 	ldr	r3, [r0, #12]
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813ae4:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813ae8:	e1530005 	cmp	r3, r5
34813aec:	e1a04002 	mov	r4, r2
34813af0:	8a000003 	bhi	34813b04 <part_block_isbad+0x2c>
34813af4:	1a000009 	bne	34813b20 <part_block_isbad+0x48>
34813af8:	e5903008 	ldr	r3, [r0, #8]
34813afc:	e1530002 	cmp	r3, r2
34813b00:	9a000006 	bls	34813b20 <part_block_isbad+0x48>
		return -EINVAL;
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
34813b04:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34813b08:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
	return part->master->block_isbad(part->master, ofs);
34813b0c:	e0922004 	adds	r2, r2, r4
34813b10:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34813b14:	e0a33005 	adc	r3, r3, r5
34813b18:	e12fff31 	blx	r1
34813b1c:	e8bd8038 	pop	{r3, r4, r5, pc}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
34813b20:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}
34813b24:	e8bd8038 	pop	{r3, r4, r5, pc}

34813b28 <part_block_markbad>:
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813b28:	e5901004 	ldr	r1, [r0, #4]
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34813b2c:	e92d4070 	push	{r4, r5, r6, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813b30:	e3110b01 	tst	r1, #1024	; 0x400
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34813b34:	e1a06000 	mov	r6, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813b38:	03e0001d 	mvneq	r0, #29
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813b3c:	08bd8070 	popeq	{r4, r5, r6, pc}
		return -EROFS;
	if (ofs >= mtd->size)
34813b40:	e1a05003 	mov	r5, r3
34813b44:	e596300c 	ldr	r3, [r6, #12]
34813b48:	e1a04002 	mov	r4, r2
34813b4c:	e1530005 	cmp	r3, r5
34813b50:	8a000003 	bhi	34813b64 <part_block_markbad+0x3c>
34813b54:	1a00000d 	bne	34813b90 <part_block_markbad+0x68>
34813b58:	e5963008 	ldr	r3, [r6, #8]
34813b5c:	e1530002 	cmp	r3, r2
34813b60:	9a00000a 	bls	34813b90 <part_block_markbad+0x68>
		return -EINVAL;
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
34813b64:	e59600a8 	ldr	r0, [r6, #168]	; 0xa8

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34813b68:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	res = part->master->block_markbad(part->master, ofs);
34813b6c:	e0922004 	adds	r2, r2, r4
34813b70:	e0a33005 	adc	r3, r3, r5
34813b74:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34813b78:	e12fff31 	blx	r1
	if (!res)
34813b7c:	e3500000 	cmp	r0, #0
		mtd->ecc_stats.badblocks++;
34813b80:	05963088 	ldreq	r3, [r6, #136]	; 0x88
34813b84:	02833001 	addeq	r3, r3, #1
34813b88:	05863088 	streq	r3, [r6, #136]	; 0x88
34813b8c:	e8bd8070 	pop	{r4, r5, r6, pc}
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
34813b90:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
	if (!res)
		mtd->ecc_stats.badblocks++;
	return res;
}
34813b94:	e8bd8070 	pop	{r4, r5, r6, pc}

34813b98 <part_read_oob>:
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813b98:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813b9c:	e590500c 	ldr	r5, [r0, #12]
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813ba0:	e1a04000 	mov	r4, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813ba4:	e1550003 	cmp	r5, r3
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813ba8:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813bac:	e5906008 	ldr	r6, [r0, #8]
34813bb0:	8a000002 	bhi	34813bc0 <part_read_oob+0x28>
34813bb4:	1a00001f 	bne	34813c38 <part_read_oob+0xa0>
34813bb8:	e1560002 	cmp	r6, r2
34813bbc:	9a00001d 	bls	34813c38 <part_read_oob+0xa0>
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
34813bc0:	e59c1018 	ldr	r1, [ip, #24]
34813bc4:	e3510000 	cmp	r1, #0
34813bc8:	0a000007 	beq	34813bec <part_read_oob+0x54>
34813bcc:	e59c7004 	ldr	r7, [ip, #4]
34813bd0:	e0920007 	adds	r0, r2, r7
34813bd4:	e2a31000 	adc	r1, r3, #0
34813bd8:	e1510005 	cmp	r1, r5
34813bdc:	8a000015 	bhi	34813c38 <part_read_oob+0xa0>
34813be0:	1a000001 	bne	34813bec <part_read_oob+0x54>
34813be4:	e1500006 	cmp	r0, r6
34813be8:	8a000012 	bhi	34813c38 <part_read_oob+0xa0>
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);
34813bec:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
34813bf0:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
34813bf4:	e58dc000 	str	ip, [sp]
34813bf8:	e0922006 	adds	r2, r2, r6
34813bfc:	e0a33007 	adc	r3, r3, r7
34813c00:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34813c04:	e12fff31 	blx	r1

	if (unlikely(res)) {
34813c08:	e3500000 	cmp	r0, #0
34813c0c:	0a00000a 	beq	34813c3c <part_read_oob+0xa4>
		if (res == -EUCLEAN)
34813c10:	e3700075 	cmn	r0, #117	; 0x75
			mtd->ecc_stats.corrected++;
34813c14:	05943080 	ldreq	r3, [r4, #128]	; 0x80
34813c18:	02833001 	addeq	r3, r3, #1
34813c1c:	05843080 	streq	r3, [r4, #128]	; 0x80
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);

	if (unlikely(res)) {
		if (res == -EUCLEAN)
34813c20:	0a000005 	beq	34813c3c <part_read_oob+0xa4>
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
34813c24:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed++;
34813c28:	05943084 	ldreq	r3, [r4, #132]	; 0x84
34813c2c:	02833001 	addeq	r3, r3, #1
34813c30:	05843084 	streq	r3, [r4, #132]	; 0x84
34813c34:	ea000000 	b	34813c3c <part_read_oob+0xa4>
	int res;

	if (from >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
34813c38:	e3e00015 	mvn	r0, #21
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
			mtd->ecc_stats.failed++;
	}
	return res;
}
34813c3c:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813c40 <part_read>:
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
34813c40:	e92d4c7f 	push	{r0, r1, r2, r3, r4, r5, r6, sl, fp, lr}
34813c44:	e1a04000 	mov	r4, r0
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
34813c48:	e594e00c 	ldr	lr, [r4, #12]
{
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
34813c4c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8

	if (from >= mtd->size)
34813c50:	e15e0003 	cmp	lr, r3
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
34813c54:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
34813c58:	e5905080 	ldr	r5, [r0, #128]	; 0x80
34813c5c:	e5906084 	ldr	r6, [r0, #132]	; 0x84

	if (from >= mtd->size)
34813c60:	e594c008 	ldr	ip, [r4, #8]
34813c64:	8a000002 	bhi	34813c74 <part_read+0x34>
34813c68:	1a00000a 	bne	34813c98 <part_read+0x58>
34813c6c:	e15c0002 	cmp	ip, r2
34813c70:	9a000008 	bls	34813c98 <part_read+0x58>
		len = 0;
	else if (from + len > mtd->size)
34813c74:	e092a001 	adds	sl, r2, r1
34813c78:	e2a3b000 	adc	fp, r3, #0
34813c7c:	e15b000e 	cmp	fp, lr
34813c80:	8a000002 	bhi	34813c90 <part_read+0x50>
34813c84:	1a000004 	bne	34813c9c <part_read+0x5c>
34813c88:	e15a000c 	cmp	sl, ip
34813c8c:	9a000002 	bls	34813c9c <part_read+0x5c>
		len = mtd->size - from;
34813c90:	e062100c 	rsb	r1, r2, ip
34813c94:	ea000000 	b	34813c9c <part_read+0x5c>
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
		len = 0;
34813c98:	e3a01000 	mov	r1, #0
	else if (from + len > mtd->size)
		len = mtd->size - from;
	res = part->master->read(part->master, from + part->offset,
34813c9c:	e58d1000 	str	r1, [sp]
34813ca0:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34813ca4:	e1c4abd0 	ldrd	sl, [r4, #176]	; 0xb0
34813ca8:	e58d1004 	str	r1, [sp, #4]
34813cac:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34813cb0:	e092200a 	adds	r2, r2, sl
34813cb4:	e58d1008 	str	r1, [sp, #8]
34813cb8:	e0a3300b 	adc	r3, r3, fp
34813cbc:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34813cc0:	e12fff31 	blx	r1
				   len, retlen, buf);
	if (unlikely(res)) {
34813cc4:	e3500000 	cmp	r0, #0
34813cc8:	0a000010 	beq	34813d10 <part_read+0xd0>
		if (res == -EUCLEAN)
34813ccc:	e3700075 	cmn	r0, #117	; 0x75
34813cd0:	1a000006 	bne	34813cf0 <part_read+0xb0>
			mtd->ecc_stats.corrected += part->master->ecc_stats.corrected - stats.corrected;
34813cd4:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813cd8:	e5932080 	ldr	r2, [r3, #128]	; 0x80
34813cdc:	e5943080 	ldr	r3, [r4, #128]	; 0x80
34813ce0:	e0823003 	add	r3, r2, r3
34813ce4:	e0655003 	rsb	r5, r5, r3
34813ce8:	e5845080 	str	r5, [r4, #128]	; 0x80
34813cec:	ea000007 	b	34813d10 <part_read+0xd0>
		if (res == -EBADMSG)
34813cf0:	e370004a 	cmn	r0, #74	; 0x4a
34813cf4:	1a000005 	bne	34813d10 <part_read+0xd0>
			mtd->ecc_stats.failed += part->master->ecc_stats.failed - stats.failed;
34813cf8:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813cfc:	e5932084 	ldr	r2, [r3, #132]	; 0x84
34813d00:	e5943084 	ldr	r3, [r4, #132]	; 0x84
34813d04:	e0823003 	add	r3, r2, r3
34813d08:	e0666003 	rsb	r6, r6, r3
34813d0c:	e5846084 	str	r6, [r4, #132]	; 0x84
	}
	return res;
}
34813d10:	e28dd010 	add	sp, sp, #16
34813d14:	e8bd8c70 	pop	{r4, r5, r6, sl, fp, pc}

34813d18 <mtd_erase_callback>:
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->mtd->erase == part_erase) {
34813d18:	e5901000 	ldr	r1, [r0]
	}
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
34813d1c:	e92d4038 	push	{r3, r4, r5, lr}
	if (instr->mtd->erase == part_erase) {
34813d20:	e5912034 	ldr	r2, [r1, #52]	; 0x34
34813d24:	e59f3050 	ldr	r3, [pc, #80]	; 34813d7c <mtd_erase_callback+0x64>
34813d28:	e1520003 	cmp	r2, r3
34813d2c:	1a00000d 	bne	34813d68 <mtd_erase_callback+0x50>
		struct mtd_part *part = PART(instr->mtd);

		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
34813d30:	e1c021d8 	ldrd	r2, [r0, #24]
34813d34:	e3720001 	cmn	r2, #1
34813d38:	1a000001 	bne	34813d44 <mtd_erase_callback+0x2c>
34813d3c:	e3730001 	cmn	r3, #1
34813d40:	0a000003 	beq	34813d54 <mtd_erase_callback+0x3c>
			instr->fail_addr -= part->offset;
34813d44:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813d48:	e0522004 	subs	r2, r2, r4
34813d4c:	e0c33005 	sbc	r3, r3, r5
34813d50:	e1c021f8 	strd	r2, [r0, #24]
		instr->addr -= part->offset;
34813d54:	e1c020d8 	ldrd	r2, [r0, #8]
34813d58:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813d5c:	e0522004 	subs	r2, r2, r4
34813d60:	e0c33005 	sbc	r3, r3, r5
34813d64:	e1c020f8 	strd	r2, [r0, #8]
	}
	if (instr->callback)
34813d68:	e5903030 	ldr	r3, [r0, #48]	; 0x30
34813d6c:	e3530000 	cmp	r3, #0
34813d70:	08bd8038 	popeq	{r3, r4, r5, pc}
		instr->callback(instr);
34813d74:	e12fff33 	blx	r3
34813d78:	e8bd8038 	pop	{r3, r4, r5, pc}
34813d7c:	3481395c 	.word	0x3481395c

34813d80 <del_mtd_partitions>:
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
34813d80:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813d84:	e59f7074 	ldr	r7, [pc, #116]	; 34813e00 <del_mtd_partitions+0x80>
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
34813d88:	e1a0a000 	mov	sl, r0
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813d8c:	e5974000 	ldr	r4, [r7]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34813d90:	e3a06000 	mov	r6, #0
34813d94:	e41450bc 	ldr	r5, [r4], #-188	; 0xbc
34813d98:	e24550bc 	sub	r5, r5, #188	; 0xbc
34813d9c:	ea000012 	b	34813dec <del_mtd_partitions+0x6c>
		if (slave->master == master) {
34813da0:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813da4:	e153000a 	cmp	r3, sl
34813da8:	1a00000c 	bne	34813de0 <del_mtd_partitions+0x60>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34813dac:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
34813db0:	e59420bc 	ldr	r2, [r4, #188]	; 0xbc
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34813db4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34813db8:	e5832000 	str	r2, [r3]
			list_del(&slave->list);
			if (slave->registered)
34813dbc:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34813dc0:	e58460bc 	str	r6, [r4, #188]	; 0xbc
34813dc4:	e3530000 	cmp	r3, #0
	entry->prev = LIST_POISON2;
34813dc8:	e58460c0 	str	r6, [r4, #192]	; 0xc0
34813dcc:	0a000001 	beq	34813dd8 <del_mtd_partitions+0x58>
				del_mtd_device(&slave->mtd);
34813dd0:	e1a00004 	mov	r0, r4
34813dd4:	ebfffde1 	bl	34813560 <del_mtd_device>
			kfree(slave);
34813dd8:	e1a00004 	mov	r0, r4
34813ddc:	ebffd877 	bl	34809fc0 <free>

int del_mtd_partitions(struct mtd_info *master)
{
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813de0:	e59530bc 	ldr	r3, [r5, #188]	; 0xbc
34813de4:	e1a04005 	mov	r4, r5
34813de8:	e24350bc 	sub	r5, r3, #188	; 0xbc
34813dec:	e28430bc 	add	r3, r4, #188	; 0xbc
34813df0:	e1570003 	cmp	r7, r3
34813df4:	1affffe9 	bne	34813da0 <del_mtd_partitions+0x20>
				del_mtd_device(&slave->mtd);
			kfree(slave);
		}

	return 0;
}
34813df8:	e3a00000 	mov	r0, #0
34813dfc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34813e00:	3482ba18 	.word	0x3482ba18

34813e04 <add_mtd_partitions>:
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813e04:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34813e08:	e59f35d4 	ldr	r3, [pc, #1492]	; 348143e4 <add_mtd_partitions+0x5e0>
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813e0c:	e24dd028 	sub	sp, sp, #40	; 0x28
34813e10:	e58d201c 	str	r2, [sp, #28]
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34813e14:	e5932000 	ldr	r2, [r3]
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813e18:	e1a04000 	mov	r4, r0
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34813e1c:	e3520000 	cmp	r2, #0
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813e20:	e1a05001 	mov	r5, r1
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34813e24:	05833000 	streq	r3, [r3]
	list->prev = list;
34813e28:	05833004 	streq	r3, [r3, #4]
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
34813e2c:	e59f05b4 	ldr	r0, [pc, #1460]	; 348143e8 <add_mtd_partitions+0x5e4>
34813e30:	e59d101c 	ldr	r1, [sp, #28]
34813e34:	e5942020 	ldr	r2, [r4, #32]
34813e38:	ebffd722 	bl	34809ac8 <printf>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34813e3c:	e2855020 	add	r5, r5, #32
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34813e40:	e3a07000 	mov	r7, #0
int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
	struct mtd_part *slave;
	uint64_t cur_offset = 0;
34813e44:	e3a0a000 	mov	sl, #0
34813e48:	e3a0b000 	mov	fp, #0
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34813e4c:	ea00015e 	b	348143cc <add_mtd_partitions+0x5c8>
		uint64_t cur_offset)
{
	struct mtd_part *slave;

	/* allocate the partition structure */
	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
34813e50:	e3a000c8 	mov	r0, #200	; 0xc8
34813e54:	e3a01001 	mov	r1, #1
34813e58:	ebffda4e 	bl	3480a798 <calloc>
	if (!slave) {
34813e5c:	e2506000 	subs	r6, r0, #0
34813e60:	1a000006 	bne	34813e80 <add_mtd_partitions+0x7c>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
34813e64:	e5941020 	ldr	r1, [r4, #32]
34813e68:	e59f057c 	ldr	r0, [pc, #1404]	; 348143ec <add_mtd_partitions+0x5e8>
34813e6c:	ebffd715 	bl	34809ac8 <printf>
			master->name);
		del_mtd_partitions(master);
34813e70:	e1a00004 	mov	r0, r4
34813e74:	ebffffc1 	bl	34813d80 <del_mtd_partitions>
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
34813e78:	e3e0000b 	mvn	r0, #11
34813e7c:	ea000156 	b	348143dc <add_mtd_partitions+0x5d8>
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
34813e80:	e59f055c 	ldr	r0, [pc, #1372]	; 348143e4 <add_mtd_partitions+0x5e0>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
			master->name);
		del_mtd_partitions(master);
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);
34813e84:	e28630bc 	add	r3, r6, #188	; 0xbc
34813e88:	e5902000 	ldr	r2, [r0]
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
34813e8c:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34813e90:	e5823004 	str	r3, [r2, #4]
	new->next = next;
34813e94:	e58620bc 	str	r2, [r6, #188]	; 0xbc
	new->prev = prev;
34813e98:	e58600c0 	str	r0, [r6, #192]	; 0xc0

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813e9c:	e5d43000 	ldrb	r3, [r4]
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
34813ea0:	e59f1548 	ldr	r1, [pc, #1352]	; 348143f0 <add_mtd_partitions+0x5ec>
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813ea4:	e5c63000 	strb	r3, [r6]
	slave->mtd.flags = master->flags & ~part->mask_flags;
34813ea8:	e5152008 	ldr	r2, [r5, #-8]
34813eac:	e5943004 	ldr	r3, [r4, #4]
34813eb0:	e1c33002 	bic	r3, r3, r2
34813eb4:	e5863004 	str	r3, [r6, #4]
	slave->mtd.size = part->size;
34813eb8:	e14521d8 	ldrd	r2, [r5, #-24]	; 0xffffffe8
34813ebc:	e1c620f8 	strd	r2, [r6, #8]
	slave->mtd.writesize = master->writesize;
34813ec0:	e5943014 	ldr	r3, [r4, #20]

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
34813ec4:	e59f2528 	ldr	r2, [pc, #1320]	; 348143f4 <add_mtd_partitions+0x5f0>

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
	slave->mtd.flags = master->flags & ~part->mask_flags;
	slave->mtd.size = part->size;
	slave->mtd.writesize = master->writesize;
34813ec8:	e5863014 	str	r3, [r6, #20]
	slave->mtd.oobsize = master->oobsize;
34813ecc:	e5943018 	ldr	r3, [r4, #24]
34813ed0:	e5863018 	str	r3, [r6, #24]
	slave->mtd.oobavail = master->oobavail;
34813ed4:	e594301c 	ldr	r3, [r4, #28]
34813ed8:	e586301c 	str	r3, [r6, #28]
	slave->mtd.subpage_sft = master->subpage_sft;
34813edc:	e5943090 	ldr	r3, [r4, #144]	; 0x90
34813ee0:	e5863090 	str	r3, [r6, #144]	; 0x90

	slave->mtd.name = part->name;
34813ee4:	e5153020 	ldr	r3, [r5, #-32]
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
34813ee8:	e5861040 	str	r1, [r6, #64]	; 0x40
	slave->mtd.writesize = master->writesize;
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
34813eec:	e5863020 	str	r3, [r6, #32]
	slave->mtd.owner = master->owner;
34813ef0:	e5943098 	ldr	r3, [r4, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
34813ef4:	e5862044 	str	r2, [r6, #68]	; 0x44
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;
34813ef8:	e5863098 	str	r3, [r6, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;

	if (master->panic_write)
34813efc:	e5943048 	ldr	r3, [r4, #72]	; 0x48
34813f00:	e3530000 	cmp	r3, #0
		slave->mtd.panic_write = part_panic_write;
34813f04:	159f34ec 	ldrne	r3, [pc, #1260]	; 348143f8 <add_mtd_partitions+0x5f4>
34813f08:	15863048 	strne	r3, [r6, #72]	; 0x48

	if (master->read_oob)
34813f0c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34813f10:	e3530000 	cmp	r3, #0
		slave->mtd.read_oob = part_read_oob;
34813f14:	159f04e0 	ldrne	r0, [pc, #1248]	; 348143fc <add_mtd_partitions+0x5f8>
	if (master->write_oob)
34813f18:	e5943050 	ldr	r3, [r4, #80]	; 0x50

	if (master->panic_write)
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
34813f1c:	1586004c 	strne	r0, [r6, #76]	; 0x4c
	if (master->write_oob)
34813f20:	e3530000 	cmp	r3, #0
		slave->mtd.write_oob = part_write_oob;
34813f24:	159f14d4 	ldrne	r1, [pc, #1236]	; 34814400 <add_mtd_partitions+0x5fc>
	if (master->read_user_prot_reg)
34813f28:	e5943060 	ldr	r3, [r4, #96]	; 0x60
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
34813f2c:	15861050 	strne	r1, [r6, #80]	; 0x50
	if (master->read_user_prot_reg)
34813f30:	e3530000 	cmp	r3, #0
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
34813f34:	159f24c8 	ldrne	r2, [pc, #1224]	; 34814404 <add_mtd_partitions+0x600>
34813f38:	15862060 	strne	r2, [r6, #96]	; 0x60
	if (master->read_fact_prot_reg)
34813f3c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
	slave->offset = part->offset;
34813f40:	e5152010 	ldr	r2, [r5, #-16]
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
	if (master->read_user_prot_reg)
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
	if (master->read_fact_prot_reg)
34813f44:	e3530000 	cmp	r3, #0
		slave->mtd.read_fact_prot_reg = part_read_fact_prot_reg;
34813f48:	159f34b8 	ldrne	r3, [pc, #1208]	; 34814408 <add_mtd_partitions+0x604>
34813f4c:	15863058 	strne	r3, [r6, #88]	; 0x58
	if (master->write_user_prot_reg)
34813f50:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34813f54:	e3530000 	cmp	r3, #0
		slave->mtd.write_user_prot_reg = part_write_user_prot_reg;
34813f58:	159f34ac 	ldrne	r3, [pc, #1196]	; 3481440c <add_mtd_partitions+0x608>
34813f5c:	15863064 	strne	r3, [r6, #100]	; 0x64
	if (master->lock_user_prot_reg)
34813f60:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34813f64:	e3530000 	cmp	r3, #0
		slave->mtd.lock_user_prot_reg = part_lock_user_prot_reg;
34813f68:	159f34a0 	ldrne	r3, [pc, #1184]	; 34814410 <add_mtd_partitions+0x60c>
34813f6c:	15863068 	strne	r3, [r6, #104]	; 0x68
	if (master->get_user_prot_info)
34813f70:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34813f74:	e3530000 	cmp	r3, #0
		slave->mtd.get_user_prot_info = part_get_user_prot_info;
34813f78:	159f3494 	ldrne	r3, [pc, #1172]	; 34814414 <add_mtd_partitions+0x610>
34813f7c:	1586305c 	strne	r3, [r6, #92]	; 0x5c
	if (master->get_fact_prot_info)
34813f80:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34813f84:	e3530000 	cmp	r3, #0
		slave->mtd.get_fact_prot_info = part_get_fact_prot_info;
34813f88:	159f3488 	ldrne	r3, [pc, #1160]	; 34814418 <add_mtd_partitions+0x614>
34813f8c:	15863054 	strne	r3, [r6, #84]	; 0x54
	if (master->sync)
34813f90:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34813f94:	e3530000 	cmp	r3, #0
		slave->mtd.sync = part_sync;
34813f98:	159f347c 	ldrne	r3, [pc, #1148]	; 3481441c <add_mtd_partitions+0x618>
34813f9c:	1586306c 	strne	r3, [r6, #108]	; 0x6c
	if (master->lock)
34813fa0:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34813fa4:	e3530000 	cmp	r3, #0
		slave->mtd.lock = part_lock;
34813fa8:	159f3470 	ldrne	r3, [pc, #1136]	; 34814420 <add_mtd_partitions+0x61c>
34813fac:	15863070 	strne	r3, [r6, #112]	; 0x70
	if (master->unlock)
34813fb0:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34813fb4:	e3530000 	cmp	r3, #0
		slave->mtd.unlock = part_unlock;
34813fb8:	159f3464 	ldrne	r3, [pc, #1124]	; 34814424 <add_mtd_partitions+0x620>
34813fbc:	15863074 	strne	r3, [r6, #116]	; 0x74
	if (master->block_isbad)
34813fc0:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34813fc4:	e3530000 	cmp	r3, #0
		slave->mtd.block_isbad = part_block_isbad;
34813fc8:	159f3458 	ldrne	r3, [pc, #1112]	; 34814428 <add_mtd_partitions+0x624>
34813fcc:	15863078 	strne	r3, [r6, #120]	; 0x78
	if (master->block_markbad)
34813fd0:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
34813fd4:	e58640a8 	str	r4, [r6, #168]	; 0xa8
		slave->mtd.lock = part_lock;
	if (master->unlock)
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
34813fd8:	e3530000 	cmp	r3, #0
		slave->mtd.block_markbad = part_block_markbad;
34813fdc:	159f3448 	ldrne	r3, [pc, #1096]	; 3481442c <add_mtd_partitions+0x628>
34813fe0:	1586307c 	strne	r3, [r6, #124]	; 0x7c
	slave->mtd.erase = part_erase;
34813fe4:	e59f3444 	ldr	r3, [pc, #1092]	; 34814430 <add_mtd_partitions+0x62c>
	slave->master = master;
	slave->offset = part->offset;
	slave->index = partno;

	if (slave->offset == MTDPART_OFS_APPEND)
34813fe8:	e3720001 	cmn	r2, #1
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
34813fec:	e5863034 	str	r3, [r6, #52]	; 0x34
	slave->master = master;
	slave->offset = part->offset;
34813ff0:	e515300c 	ldr	r3, [r5, #-12]
34813ff4:	e58620b0 	str	r2, [r6, #176]	; 0xb0
34813ff8:	e58630b4 	str	r3, [r6, #180]	; 0xb4
	slave->index = partno;
34813ffc:	e58670b8 	str	r7, [r6, #184]	; 0xb8

	if (slave->offset == MTDPART_OFS_APPEND)
34814000:	1a000001 	bne	3481400c <add_mtd_partitions+0x208>
34814004:	e3730001 	cmn	r3, #1
		slave->offset = cur_offset;
34814008:	01c6abf0 	strdeq	sl, [r6, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_NXTBLK) {
3481400c:	e59630b0 	ldr	r3, [r6, #176]	; 0xb0
34814010:	e3730002 	cmn	r3, #2
34814014:	1a000027 	bne	348140b8 <add_mtd_partitions+0x2b4>
34814018:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
3481401c:	e3730001 	cmn	r3, #1
34814020:	1a000024 	bne	348140b8 <add_mtd_partitions+0x2b4>
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34814024:	e25b9000 	subs	r9, fp, #0
		slave->offset = cur_offset;
34814028:	e1c6abf0 	strd	sl, [r6, #176]	; 0xb0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
3481402c:	e5941010 	ldr	r1, [r4, #16]
34814030:	e1cda2f0 	strd	sl, [sp, #32]
34814034:	1a000002 	bne	34814044 <add_mtd_partitions+0x240>
34814038:	e1a0000a 	mov	r0, sl
3481403c:	eb002f5c 	bl	3481fdb4 <__aeabi_uidivmod>
34814040:	ea000002 	b	34814050 <add_mtd_partitions+0x24c>
34814044:	e28d0020 	add	r0, sp, #32
34814048:	eb001ad1 	bl	3481ab94 <__div64_32>
3481404c:	e1a01000 	mov	r1, r0

	if (slave->offset == MTDPART_OFS_APPEND)
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
34814050:	e3510000 	cmp	r1, #0
34814054:	0a000017 	beq	348140b8 <add_mtd_partitions+0x2b4>
	void (*put_device) (struct mtd_info *mtd);
};

static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	do_div(sz, mtd->erasesize);
34814058:	e3590000 	cmp	r9, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
3481405c:	e5941010 	ldr	r1, [r4, #16]
34814060:	e1cda2f0 	strd	sl, [sp, #32]
34814064:	1a000004 	bne	3481407c <add_mtd_partitions+0x278>
34814068:	e1a0000a 	mov	r0, sl
3481406c:	eb002ed5 	bl	3481fbc8 <__udivsi3>
34814070:	e58d9024 	str	r9, [sp, #36]	; 0x24
34814074:	e58d0020 	str	r0, [sp, #32]
34814078:	ea000001 	b	34814084 <add_mtd_partitions+0x280>
3481407c:	e28d0020 	add	r0, sp, #32
34814080:	eb001ac3 	bl	3481ab94 <__div64_32>
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
			/* Round up to next erasesize */
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34814084:	e59d2020 	ldr	r2, [sp, #32]
34814088:	e5943010 	ldr	r3, [r4, #16]
3481408c:	e2822001 	add	r2, r2, #1
34814090:	e0020293 	mul	r2, r3, r2
34814094:	e3a03000 	mov	r3, #0
34814098:	e58620b0 	str	r2, [r6, #176]	; 0xb0
3481409c:	e58630b4 	str	r3, [r6, #180]	; 0xb4
			printk(KERN_NOTICE "Moving partition %d: "
348140a0:	e59f038c 	ldr	r0, [pc, #908]	; 34814434 <add_mtd_partitions+0x630>
348140a4:	e88d000c 	stm	sp, {r2, r3}
348140a8:	e1a01007 	mov	r1, r7
348140ac:	e1a0200a 	mov	r2, sl
348140b0:	e1a0300b 	mov	r3, fp
348140b4:	ebffd683 	bl	34809ac8 <printf>
			       "0x%012llx -> 0x%012llx\n", partno,
			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
348140b8:	e5962008 	ldr	r2, [r6, #8]
348140bc:	e596300c 	ldr	r3, [r6, #12]
348140c0:	e1923003 	orrs	r3, r2, r3
348140c4:	1a000004 	bne	348140dc <add_mtd_partitions+0x2d8>
		slave->mtd.size = master->size - slave->offset;
348140c8:	e1c400d8 	ldrd	r0, [r4, #8]
348140cc:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
348140d0:	e0500002 	subs	r0, r0, r2
348140d4:	e0c11003 	sbc	r1, r1, r3
348140d8:	e1c600f8 	strd	r0, [r6, #8]

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
348140dc:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
		slave->mtd.size = master->size - slave->offset;

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
348140e0:	e1c620d8 	ldrd	r2, [r6, #8]
348140e4:	e092200a 	adds	r2, r2, sl
348140e8:	e0a3300b 	adc	r3, r3, fp
348140ec:	e1cd20f0 	strd	r2, [sp]
348140f0:	e5963020 	ldr	r3, [r6, #32]
348140f4:	e1a0200a 	mov	r2, sl
348140f8:	e58d3008 	str	r3, [sp, #8]
348140fc:	e59f0334 	ldr	r0, [pc, #820]	; 34814438 <add_mtd_partitions+0x634>
34814100:	e1a0300b 	mov	r3, fp
34814104:	ebffd66f 	bl	34809ac8 <printf>
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);

	/* let's do some sanity checks */
	if (slave->offset >= master->size) {
34814108:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
3481410c:	e1c400d8 	ldrd	r0, [r4, #8]
34814110:	e151000b 	cmp	r1, fp
34814114:	8a00000a 	bhi	34814144 <add_mtd_partitions+0x340>
34814118:	1a000001 	bne	34814124 <add_mtd_partitions+0x320>
3481411c:	e150000a 	cmp	r0, sl
34814120:	8a000007 	bhi	34814144 <add_mtd_partitions+0x340>
		/* let's register it anyway to preserve ordering */
		slave->offset = 0;
34814124:	e3a02000 	mov	r2, #0
34814128:	e3a03000 	mov	r3, #0
3481412c:	e1c62bf0 	strd	r2, [r6, #176]	; 0xb0
		slave->mtd.size = 0;
34814130:	e1c620f8 	strd	r2, [r6, #8]
		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
34814134:	e5151020 	ldr	r1, [r5, #-32]
34814138:	e59f02fc 	ldr	r0, [pc, #764]	; 3481443c <add_mtd_partitions+0x638>
3481413c:	ebffd661 	bl	34809ac8 <printf>
34814140:	ea000092 	b	34814390 <add_mtd_partitions+0x58c>
			part->name);
		goto out_register;
	}
	if (slave->offset + slave->mtd.size > master->size) {
34814144:	e1c620d8 	ldrd	r2, [r6, #8]
34814148:	e092200a 	adds	r2, r2, sl
3481414c:	e0a3300b 	adc	r3, r3, fp
34814150:	e1530001 	cmp	r3, r1
34814154:	8a000002 	bhi	34814164 <add_mtd_partitions+0x360>
34814158:	1a000009 	bne	34814184 <add_mtd_partitions+0x380>
3481415c:	e1520000 	cmp	r2, r0
34814160:	9a000007 	bls	34814184 <add_mtd_partitions+0x380>
		slave->mtd.size = master->size - slave->offset;
34814164:	e050000a 	subs	r0, r0, sl
34814168:	e0c1100b 	sbc	r1, r1, fp
3481416c:	e1c600f8 	strd	r0, [r6, #8]
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
34814170:	e1cd00f0 	strd	r0, [sp]
34814174:	e5942020 	ldr	r2, [r4, #32]
34814178:	e59f02c0 	ldr	r0, [pc, #704]	; 34814440 <add_mtd_partitions+0x63c>
3481417c:	e5151020 	ldr	r1, [r5, #-32]
34814180:	ebffd650 	bl	34809ac8 <printf>
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
34814184:	e594a02c 	ldr	sl, [r4, #44]	; 0x2c
34814188:	e35a0001 	cmp	sl, #1
3481418c:	da000033 	ble	34814260 <add_mtd_partitions+0x45c>
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34814190:	e1c60bd0 	ldrd	r0, [r6, #176]	; 0xb0
34814194:	e1c620d8 	ldrd	r2, [r6, #8]
34814198:	e1cd01f0 	strd	r0, [sp, #16]
3481419c:	e0922000 	adds	r2, r2, r0
		struct mtd_erase_region_info *regions = master->eraseregions;
348141a0:	e3a00000 	mov	r0, #0
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
348141a4:	e0a33001 	adc	r3, r3, r1
		struct mtd_erase_region_info *regions = master->eraseregions;
348141a8:	e594c030 	ldr	ip, [r4, #48]	; 0x30

		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
348141ac:	e1a01000 	mov	r1, r0
348141b0:	ea000003 	b	348141c4 <add_mtd_partitions+0x3c0>
348141b4:	e2811001 	add	r1, r1, #1
348141b8:	e151000a 	cmp	r1, sl
348141bc:	e2800018 	add	r0, r0, #24
348141c0:	aa000009 	bge	348141ec <add_mtd_partitions+0x3e8>
348141c4:	e08c9000 	add	r9, ip, r0
348141c8:	e5999004 	ldr	r9, [r9, #4]
348141cc:	e59db014 	ldr	fp, [sp, #20]
348141d0:	e159000b 	cmp	r9, fp
348141d4:	8a000004 	bhi	348141ec <add_mtd_partitions+0x3e8>
348141d8:	1afffff5 	bne	348141b4 <add_mtd_partitions+0x3b0>
348141dc:	e79c9000 	ldr	r9, [ip, r0]
348141e0:	e59db010 	ldr	fp, [sp, #16]
348141e4:	e159000b 	cmp	r9, fp
348141e8:	9afffff1 	bls	348141b4 <add_mtd_partitions+0x3b0>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348141ec:	e3a09018 	mov	r9, #24
		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
			;
		/* The loop searched for the region _behind_ the first one */
		i--;
348141f0:	e2410001 	sub	r0, r1, #1
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348141f4:	e021c199 	mla	r1, r9, r1, ip
348141f8:	ea000005 	b	34814214 <add_mtd_partitions+0x410>
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
			if (slave->mtd.erasesize < regions[i].erasesize) {
348141fc:	e511c010 	ldr	ip, [r1, #-16]
34814200:	e5969010 	ldr	r9, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34814204:	e2800001 	add	r0, r0, #1
			if (slave->mtd.erasesize < regions[i].erasesize) {
34814208:	e159000c 	cmp	r9, ip
				slave->mtd.erasesize = regions[i].erasesize;
3481420c:	3586c010 	strcc	ip, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34814210:	e2811018 	add	r1, r1, #24
34814214:	e150000a 	cmp	r0, sl
34814218:	aa000006 	bge	34814238 <add_mtd_partitions+0x434>
3481421c:	e511c014 	ldr	ip, [r1, #-20]
34814220:	e15c0003 	cmp	ip, r3
34814224:	3afffff4 	bcc	348141fc <add_mtd_partitions+0x3f8>
34814228:	1a000002 	bne	34814238 <add_mtd_partitions+0x434>
3481422c:	e511c018 	ldr	ip, [r1, #-24]
34814230:	e15c0002 	cmp	ip, r2
34814234:	3afffff0 	bcc	348141fc <add_mtd_partitions+0x3f8>
			if (slave->mtd.erasesize < regions[i].erasesize) {
				slave->mtd.erasesize = regions[i].erasesize;
			}
		}
		BUG_ON(slave->mtd.erasesize == 0);
34814238:	e5963010 	ldr	r3, [r6, #16]
3481423c:	e3530000 	cmp	r3, #0
34814240:	1a000008 	bne	34814268 <add_mtd_partitions+0x464>
34814244:	e59f01f8 	ldr	r0, [pc, #504]	; 34814444 <add_mtd_partitions+0x640>
34814248:	e59f11f8 	ldr	r1, [pc, #504]	; 34814448 <add_mtd_partitions+0x644>
3481424c:	e300218a 	movw	r2, #394	; 0x18a
34814250:	e59f31f4 	ldr	r3, [pc, #500]	; 3481444c <add_mtd_partitions+0x648>
34814254:	ebffd61b 	bl	34809ac8 <printf>
34814258:	e59f01f0 	ldr	r0, [pc, #496]	; 34814450 <add_mtd_partitions+0x64c>
3481425c:	eb00248f 	bl	3481d4a0 <panic>
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
34814260:	e5943010 	ldr	r3, [r4, #16]
34814264:	e5863010 	str	r3, [r6, #16]
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34814268:	e5963004 	ldr	r3, [r6, #4]
3481426c:	e3130b01 	tst	r3, #1024	; 0x400
34814270:	0a000013 	beq	348142c4 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
34814274:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
34814278:	e59600b0 	ldr	r0, [r6, #176]	; 0xb0
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
3481427c:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34814280:	e5961010 	ldr	r1, [r6, #16]
34814284:	e58d0020 	str	r0, [sp, #32]
34814288:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481428c:	1a000001 	bne	34814298 <add_mtd_partitions+0x494>
34814290:	eb002ec7 	bl	3481fdb4 <__aeabi_uidivmod>
34814294:	ea000002 	b	348142a4 <add_mtd_partitions+0x4a0>
34814298:	e28d0020 	add	r0, sp, #32
3481429c:	eb001a3c 	bl	3481ab94 <__div64_32>
348142a0:	e1a01000 	mov	r1, r0
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
348142a4:	e3510000 	cmp	r1, #0
348142a8:	0a000005 	beq	348142c4 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
348142ac:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
348142b0:	e59f019c 	ldr	r0, [pc, #412]	; 34814454 <add_mtd_partitions+0x650>
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
348142b4:	e3c33b01 	bic	r3, r3, #1024	; 0x400
348142b8:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
348142bc:	e5151020 	ldr	r1, [r5, #-32]
348142c0:	ebffd600 	bl	34809ac8 <printf>
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
348142c4:	e5963004 	ldr	r3, [r6, #4]
348142c8:	e3130b01 	tst	r3, #1024	; 0x400
348142cc:	0a000013 	beq	34814320 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
348142d0:	e596300c 	ldr	r3, [r6, #12]
348142d4:	e5960008 	ldr	r0, [r6, #8]
348142d8:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
348142dc:	e5961010 	ldr	r1, [r6, #16]
348142e0:	e58d0020 	str	r0, [sp, #32]
348142e4:	e58d3024 	str	r3, [sp, #36]	; 0x24
348142e8:	1a000001 	bne	348142f4 <add_mtd_partitions+0x4f0>
348142ec:	eb002eb0 	bl	3481fdb4 <__aeabi_uidivmod>
348142f0:	ea000002 	b	34814300 <add_mtd_partitions+0x4fc>
348142f4:	e28d0020 	add	r0, sp, #32
348142f8:	eb001a25 	bl	3481ab94 <__div64_32>
348142fc:	e1a01000 	mov	r1, r0
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34814300:	e3510000 	cmp	r1, #0
34814304:	0a000005 	beq	34814320 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
34814308:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
3481430c:	e59f0144 	ldr	r0, [pc, #324]	; 34814458 <add_mtd_partitions+0x654>
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
34814310:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34814314:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34814318:	e5151020 	ldr	r1, [r5, #-32]
3481431c:	ebffd5e9 	bl	34809ac8 <printf>
			part->name);
	}

	slave->mtd.ecclayout = master->ecclayout;
34814320:	e5943028 	ldr	r3, [r4, #40]	; 0x28
34814324:	e5863028 	str	r3, [r6, #40]	; 0x28
	if (master->block_isbad) {
34814328:	e5943078 	ldr	r3, [r4, #120]	; 0x78
3481432c:	e3530000 	cmp	r3, #0
34814330:	13a0a000 	movne	sl, #0
34814334:	13a0b000 	movne	fp, #0
34814338:	1a00000d 	bne	34814374 <add_mtd_partitions+0x570>
3481433c:	ea000013 	b	34814390 <add_mtd_partitions+0x58c>
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
						offs + slave->offset))
34814340:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
34814344:	e092200a 	adds	r2, r2, sl
34814348:	e0a3300b 	adc	r3, r3, fp
3481434c:	e5941078 	ldr	r1, [r4, #120]	; 0x78
34814350:	e1a00004 	mov	r0, r4
34814354:	e12fff31 	blx	r1
34814358:	e3500000 	cmp	r0, #0
						offs + slave->offset))
				slave->mtd.ecc_stats.badblocks++;
3481435c:	15963088 	ldrne	r3, [r6, #136]	; 0x88
34814360:	12833001 	addne	r3, r3, #1
34814364:	15863088 	strne	r3, [r6, #136]	; 0x88
			offs += slave->mtd.erasesize;
34814368:	e5963010 	ldr	r3, [r6, #16]
3481436c:	e09aa003 	adds	sl, sl, r3
34814370:	e2abb000 	adc	fp, fp, #0

	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
34814374:	e596300c 	ldr	r3, [r6, #12]
34814378:	e153000b 	cmp	r3, fp
3481437c:	8affffef 	bhi	34814340 <add_mtd_partitions+0x53c>
34814380:	1a000002 	bne	34814390 <add_mtd_partitions+0x58c>
34814384:	e5963008 	ldr	r3, [r6, #8]
34814388:	e153000a 	cmp	r3, sl
3481438c:	8affffeb 	bhi	34814340 <add_mtd_partitions+0x53c>
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34814390:	e5953000 	ldr	r3, [r5]
34814394:	e3530000 	cmp	r3, #0
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
34814398:	15836000 	strne	r6, [r3]
		slave->registered = 0;
3481439c:	13a03000 	movne	r3, #0
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
348143a0:	1a000002 	bne	348143b0 <add_mtd_partitions+0x5ac>
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
348143a4:	e1a00006 	mov	r0, r6
348143a8:	ebfffc50 	bl	348134f0 <add_mtd_device>
		slave->registered = 1;
348143ac:	e3a03001 	mov	r3, #1

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
348143b0:	e1c6a0d8 	ldrd	sl, [r6, #8]
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
		slave->registered = 1;
348143b4:	e58630c4 	str	r3, [r6, #196]	; 0xc4

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
348143b8:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
348143bc:	e09aa002 	adds	sl, sl, r2
348143c0:	e0abb003 	adc	fp, fp, r3
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348143c4:	e2877001 	add	r7, r7, #1
348143c8:	e2855028 	add	r5, r5, #40	; 0x28
348143cc:	e59d001c 	ldr	r0, [sp, #28]
348143d0:	e1570000 	cmp	r7, r0
348143d4:	bafffe9d 	blt	34813e50 <add_mtd_partitions+0x4c>
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
348143d8:	e3a00000 	mov	r0, #0
}
348143dc:	e28dd028 	add	sp, sp, #40	; 0x28
348143e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348143e4:	3482ba18 	.word	0x3482ba18
348143e8:	3482720c 	.word	0x3482720c
348143ec:	34827231 	.word	0x34827231
348143f0:	34813c40 	.word	0x34813c40
348143f4:	34813754 	.word	0x34813754
348143f8:	348137ec 	.word	0x348137ec
348143fc:	34813b98 	.word	0x34813b98
34814400:	34813884 	.word	0x34813884
34814404:	348136cc 	.word	0x348136cc
34814408:	34813710 	.word	0x34813710
3481440c:	34813910 	.word	0x34813910
34814410:	34813940 	.word	0x34813940
34814414:	348136fc 	.word	0x348136fc
34814418:	34813740 	.word	0x34813740
3481441c:	34813ac4 	.word	0x34813ac4
34814420:	34813a04 	.word	0x34813a04
34814424:	34813a64 	.word	0x34813a64
34814428:	34813ad8 	.word	0x34813ad8
3481442c:	34813b28 	.word	0x34813b28
34814430:	3481395c 	.word	0x3481395c
34814434:	3482726d 	.word	0x3482726d
34814438:	3482729a 	.word	0x3482729a
3481443c:	348272b6 	.word	0x348272b6
34814440:	348272e7 	.word	0x348272e7
34814444:	3482733d 	.word	0x3482733d
34814448:	3482735a 	.word	0x3482735a
3481444c:	348214ac 	.word	0x348214ac
34814450:	34827364 	.word	0x34827364
34814454:	34827369 	.word	0x34827369
34814458:	348273ba 	.word	0x348273ba

3481445c <onenand_init>:
struct mtd_info onenand_mtd;
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
3481445c:	e92d4070 	push	{r4, r5, r6, lr}
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34814460:	e59f407c 	ldr	r4, [pc, #124]	; 348144e4 <onenand_init+0x88>
34814464:	e3a01000 	mov	r1, #0
34814468:	e3a020a8 	mov	r2, #168	; 0xa8
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
3481446c:	e28450a8 	add	r5, r4, #168	; 0xa8
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34814470:	e1a00004 	mov	r0, r4
34814474:	eb002067 	bl	3481c618 <memset>
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34814478:	e3a01000 	mov	r1, #0
3481447c:	e3a020a8 	mov	r2, #168	; 0xa8
34814480:	e1a00005 	mov	r0, r5
34814484:	eb002063 	bl	3481c618 <memset>

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34814488:	e1a00004 	mov	r0, r4
void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));

	onenand_mtd.priv = &onenand_chip;
3481448c:	e5845094 	str	r5, [r4, #148]	; 0x94

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34814490:	ebffb26e 	bl	34800e50 <onenand_board_init>
#else
	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
#endif

	onenand_scan(&onenand_mtd, 1);
34814494:	e1a00004 	mov	r0, r4
34814498:	e3a01001 	mov	r1, #1
3481449c:	eb000b47 	bl	348171c0 <onenand_scan>

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
348144a0:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
348144a4:	e3130c02 	tst	r3, #512	; 0x200
348144a8:	0a000001 	beq	348144b4 <onenand_init+0x58>
		puts("Flex-");
348144ac:	e59f0034 	ldr	r0, [pc, #52]	; 348144e8 <onenand_init+0x8c>
348144b0:	ebffd57a 	bl	34809aa0 <puts>
	puts("OneNAND: ");
	print_size(onenand_chip.chipsize, "\n");
348144b4:	e59f4028 	ldr	r4, [pc, #40]	; 348144e4 <onenand_init+0x88>

	onenand_scan(&onenand_mtd, 1);

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
		puts("Flex-");
	puts("OneNAND: ");
348144b8:	e59f002c 	ldr	r0, [pc, #44]	; 348144ec <onenand_init+0x90>
348144bc:	ebffd577 	bl	34809aa0 <puts>
	print_size(onenand_chip.chipsize, "\n");
348144c0:	e59400c0 	ldr	r0, [r4, #192]	; 0xc0
348144c4:	e3a01000 	mov	r1, #0
348144c8:	e59f2020 	ldr	r2, [pc, #32]	; 348144f0 <onenand_init+0x94>
348144cc:	eb00190b 	bl	3481a900 <print_size>
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
348144d0:	e59f301c 	ldr	r3, [pc, #28]	; 348144f4 <onenand_init+0x98>
	add_mtd_device(&onenand_mtd);
348144d4:	e1a00004 	mov	r0, r4
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
348144d8:	e5843020 	str	r3, [r4, #32]
	add_mtd_device(&onenand_mtd);
#endif
}
348144dc:	e8bd4070 	pop	{r4, r5, r6, lr}
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
	add_mtd_device(&onenand_mtd);
348144e0:	eafffc02 	b	348134f0 <add_mtd_device>
348144e4:	3482ba20 	.word	0x3482ba20
348144e8:	34827400 	.word	0x34827400
348144ec:	34827406 	.word	0x34827406
348144f0:	34826197 	.word	0x34826197
348144f4:	34828a9c 	.word	0x34828a9c

348144f8 <generic_ffs>:

static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
348144f8:	e2503000 	subs	r3, r0, #0
348144fc:	0a000010 	beq	34814544 <generic_ffs+0x4c>
		return 0;
	if (!(x & 0xffff)) {
34814500:	e6ff2073 	uxth	r2, r3
34814504:	e3520000 	cmp	r2, #0
		x >>= 16;
34814508:	01a03843 	asreq	r3, r3, #16
		r += 16;
3481450c:	03a00011 	moveq	r0, #17
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
34814510:	13a00001 	movne	r0, #1
		return 0;
	if (!(x & 0xffff)) {
		x >>= 16;
		r += 16;
	}
	if (!(x & 0xff)) {
34814514:	e31300ff 	tst	r3, #255	; 0xff
		x >>= 8;
34814518:	01a03443 	asreq	r3, r3, #8
		r += 8;
3481451c:	02800008 	addeq	r0, r0, #8
	}
	if (!(x & 0xf)) {
34814520:	e313000f 	tst	r3, #15
		x >>= 4;
34814524:	01a03243 	asreq	r3, r3, #4
		r += 4;
34814528:	02800004 	addeq	r0, r0, #4
	}
	if (!(x & 3)) {
3481452c:	e3130003 	tst	r3, #3
		x >>= 2;
34814530:	01a03143 	asreq	r3, r3, #2
		r += 2;
34814534:	02800002 	addeq	r0, r0, #2
	}
	if (!(x & 1)) {
34814538:	e3130001 	tst	r3, #1
		x >>= 1;
		r += 1;
3481453c:	02800001 	addeq	r0, r0, #1
34814540:	e12fff1e 	bx	lr
static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
		return 0;
34814544:	e1a00003 	mov	r0, r3
	if (!(x & 1)) {
		x >>= 1;
		r += 1;
	}
	return r;
}
34814548:	e12fff1e 	bx	lr

3481454c <memcpy_16>:
{
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
3481454c:	e1a020a2 	lsr	r2, r2, #1
	while (len-- > 0)
34814550:	e3a03000 	mov	r3, #0
34814554:	ea000003 	b	34814568 <memcpy_16+0x1c>
		*d++ = *s++;
34814558:	e191c0b3 	ldrh	ip, [r1, r3]
3481455c:	e2422001 	sub	r2, r2, #1
34814560:	e180c0b3 	strh	ip, [r0, r3]
34814564:	e2833002 	add	r3, r3, #2
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
	while (len-- > 0)
34814568:	e3520000 	cmp	r2, #0
3481456c:	1afffff9 	bne	34814558 <memcpy_16+0xc>
		*d++ = *s++;
	return ret;
}
34814570:	e12fff1e 	bx	lr

34814574 <onenand_readw>:
 *
 * Read OneNAND register
 */
static unsigned short onenand_readw(void __iomem * addr)
{
	return readw(addr);
34814574:	e1d000b0 	ldrh	r0, [r0]
}
34814578:	e12fff1e 	bx	lr

3481457c <onenand_writew>:
 *
 * Write OneNAND register with value
 */
static void onenand_writew(unsigned short value, void __iomem * addr)
{
	writew(value, addr);
3481457c:	e1c100b0 	strh	r0, [r1]
}
34814580:	e12fff1e 	bx	lr

34814584 <onenand_read_bufferram>:
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
34814584:	e5902094 	ldr	r2, [r0, #148]	; 0x94
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34814588:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
3481458c:	e5921044 	ldr	r1, [r2, #68]	; 0x44
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34814590:	e59d3008 	ldr	r3, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814594:	e592c000 	ldr	ip, [r2]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814598:	e3510000 	cmp	r1, #0
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
3481459c:	e08cc003 	add	ip, ip, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348145a0:	0a000006 	beq	348145c0 <onenand_read_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
348145a4:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
348145a8:	05901014 	ldreq	r1, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
348145ac:	0a000003 	beq	348145c0 <onenand_read_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
348145b0:	e59f2028 	ldr	r2, [pc, #40]	; 348145e0 <onenand_read_bufferram+0x5c>
348145b4:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
348145b8:	05901018 	ldreq	r1, [r0, #24]
	}

	return 0;
348145bc:	13a01000 	movne	r1, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(buffer, bufferram + offset, count);
348145c0:	e59d3010 	ldr	r3, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
348145c4:	e08c1001 	add	r1, ip, r1

	memcpy_16(buffer, bufferram + offset, count);
348145c8:	e59d000c 	ldr	r0, [sp, #12]
348145cc:	e0811003 	add	r1, r1, r3
348145d0:	e59d2014 	ldr	r2, [sp, #20]
348145d4:	ebffffdc 	bl	3481454c <memcpy_16>

	return 0;
}
348145d8:	e3a00000 	mov	r0, #0
348145dc:	e8bd8008 	pop	{r3, pc}
348145e0:	00010020 	.word	0x00010020

348145e4 <onenand_sync_read_bufferram>:
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348145e4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
348145e8:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348145ec:	e59d3018 	ldr	r3, [sp, #24]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348145f0:	e5956044 	ldr	r6, [r5, #68]	; 0x44
				       size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
348145f4:	e5957000 	ldr	r7, [r5]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348145f8:	e3560000 	cmp	r6, #0
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348145fc:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814600:	e0877003 	add	r7, r7, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814604:	0a000006 	beq	34814624 <onenand_sync_read_bufferram+0x40>
		if (area == ONENAND_DATARAM)
34814608:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
3481460c:	05906014 	ldreq	r6, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34814610:	0a000003 	beq	34814624 <onenand_sync_read_bufferram+0x40>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34814614:	e59f2048 	ldr	r2, [pc, #72]	; 34814664 <onenand_sync_read_bufferram+0x80>
34814618:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
3481461c:	05906018 	ldreq	r6, [r0, #24]
	}

	return 0;
34814620:	13a06000 	movne	r6, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
34814624:	e5953074 	ldr	r3, [r5, #116]	; 0x74
34814628:	e1a00004 	mov	r0, r4
3481462c:	e3a01902 	mov	r1, #32768	; 0x8000
34814630:	e12fff33 	blx	r3

	memcpy_16(buffer, bufferram + offset, count);
34814634:	e59d3020 	ldr	r3, [sp, #32]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
34814638:	e0876006 	add	r6, r7, r6

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);

	memcpy_16(buffer, bufferram + offset, count);
3481463c:	e0861003 	add	r1, r6, r3
34814640:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34814644:	e59d001c 	ldr	r0, [sp, #28]
34814648:	ebffffbf 	bl	3481454c <memcpy_16>

	this->mmcontrol(mtd, 0);
3481464c:	e1a00004 	mov	r0, r4
34814650:	e5953074 	ldr	r3, [r5, #116]	; 0x74
34814654:	e3a01000 	mov	r1, #0
34814658:	e12fff33 	blx	r3

	return 0;
}
3481465c:	e3a00000 	mov	r0, #0
34814660:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34814664:	00010020 	.word	0x00010020

34814668 <onenand_write_bufferram>:
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
34814668:	e5901094 	ldr	r1, [r0, #148]	; 0x94
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
3481466c:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814670:	e5913044 	ldr	r3, [r1, #68]	; 0x44
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34814674:	e59d2008 	ldr	r2, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814678:	e591c000 	ldr	ip, [r1]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
3481467c:	e3530000 	cmp	r3, #0
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814680:	e08cc002 	add	ip, ip, r2
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814684:	0a000006 	beq	348146a4 <onenand_write_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
34814688:	e3520b01 	cmp	r2, #1024	; 0x400
			return mtd->writesize;
3481468c:	05903014 	ldreq	r3, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34814690:	0a000003 	beq	348146a4 <onenand_write_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34814694:	e59f3028 	ldr	r3, [pc, #40]	; 348146c4 <onenand_write_bufferram+0x5c>
34814698:	e1520003 	cmp	r2, r3
			return mtd->oobsize;
3481469c:	05903018 	ldreq	r3, [r0, #24]
	}

	return 0;
348146a0:	13a03000 	movne	r3, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(bufferram + offset, buffer, count);
348146a4:	e59d2010 	ldr	r2, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
348146a8:	e08c3003 	add	r3, ip, r3

	memcpy_16(bufferram + offset, buffer, count);
348146ac:	e0830002 	add	r0, r3, r2
348146b0:	e59d100c 	ldr	r1, [sp, #12]
348146b4:	e59d2014 	ldr	r2, [sp, #20]
348146b8:	ebffffa3 	bl	3481454c <memcpy_16>

	return 0;
}
348146bc:	e3a00000 	mov	r0, #0
348146c0:	e8bd8008 	pop	{r3, pc}
348146c4:	00010020 	.word	0x00010020

348146c8 <onenand_sync>:
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_SYNCING);

	/* Release it and go back */
	onenand_release_device(mtd);
}
348146c8:	e12fff1e 	bx	lr

348146cc <onenand_block_isbad>:
 * @param ofs		offset relative to mtd start
 *
 * Check whether the block is bad
 */
int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
348146cc:	e92d4007 	push	{r0, r1, r2, lr}
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
348146d0:	e590100c 	ldr	r1, [r0, #12]
348146d4:	e1510003 	cmp	r1, r3
348146d8:	3a00000a 	bcc	34814708 <onenand_block_isbad+0x3c>
348146dc:	1a000002 	bne	348146ec <onenand_block_isbad+0x20>
348146e0:	e5901008 	ldr	r1, [r0, #8]
348146e4:	e1510002 	cmp	r1, r2
348146e8:	3a000006 	bcc	34814708 <onenand_block_isbad+0x3c>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348146ec:	e5901094 	ldr	r1, [r0, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
348146f0:	e3a0c000 	mov	ip, #0
348146f4:	e59110a0 	ldr	r1, [r1, #160]	; 0xa0
348146f8:	e58dc000 	str	ip, [sp]
348146fc:	e5911010 	ldr	r1, [r1, #16]
34814700:	e12fff31 	blx	r1
		return -EINVAL;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
34814704:	ea000000 	b	3481470c <onenand_block_isbad+0x40>
{
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
		return -EINVAL;
34814708:	e3e00015 	mvn	r0, #21

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
}
3481470c:	e8bd800e 	pop	{r1, r2, r3, pc}

34814710 <onenand_block_markbad>:
 * @param ofs		offset relative to mtd start
 *
 * Mark the block as bad
 */
int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34814710:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34814714:	e1a06000 	mov	r6, r0
34814718:	e1a04002 	mov	r4, r2
3481471c:	e1a05003 	mov	r5, r3
	struct onenand_chip *this = mtd->priv;
34814720:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int ret;

	ret = onenand_block_isbad(mtd, ofs);
34814724:	ebffffe8 	bl	348146cc <onenand_block_isbad>
	if (ret) {
34814728:	e3500000 	cmp	r0, #0
3481472c:	10000fc0 	andne	r0, r0, r0, asr #31
34814730:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		if (ret > 0)
			return 0;
		return ret;
	}

	ret = this->block_markbad(mtd, ofs);
34814734:	e5971078 	ldr	r1, [r7, #120]	; 0x78
34814738:	e1a00006 	mov	r0, r6
3481473c:	e1a02004 	mov	r2, r4
34814740:	e1a03005 	mov	r3, r5
34814744:	e12fff31 	blx	r1
	return ret;
}
34814748:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481474c <onenand_chip_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
3481474c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34814750:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34814754:	e1a0a000 	mov	sl, r0
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814758:	e5940000 	ldr	r0, [r4]
3481475c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814760:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814764:	e2800042 	add	r0, r0, #66	; 0x42
34814768:	e12fff33 	blx	r3

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
3481476c:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814770:	e1a07000 	mov	r7, r0

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814774:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814778:	e1a00880 	lsl	r0, r0, #17
3481477c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814780:	e1a008a0 	lsr	r0, r0, #17
34814784:	e2811042 	add	r1, r1, #66	; 0x42
34814788:	e12fff33 	blx	r3
			 this->base + ONENAND_REG_SYS_CFG1);

	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
3481478c:	e5941000 	ldr	r1, [r4]
34814790:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814794:	e3a00090 	mov	r0, #144	; 0x90
34814798:	e12fff33 	blx	r3

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
3481479c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348147a0:	e5940000 	ldr	r0, [r4]
348147a4:	e12fff33 	blx	r3
348147a8:	e1a05000 	mov	r5, r0
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
348147ac:	e5940000 	ldr	r0, [r4]
348147b0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348147b4:	e2800002 	add	r0, r0, #2
348147b8:	e12fff33 	blx	r3

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
348147bc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348147c0:	e5941000 	ldr	r1, [r4]
	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
348147c4:	e1a06000 	mov	r6, r0

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
348147c8:	e3a000f0 	mov	r0, #240	; 0xf0
348147cc:	e12fff33 	blx	r3

	/* Wait reset */
	this->wait(mtd, FL_RESETING);
348147d0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348147d4:	e3a01006 	mov	r1, #6
348147d8:	e1a0000a 	mov	r0, sl
348147dc:	e12fff33 	blx	r3

	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
348147e0:	e5941000 	ldr	r1, [r4]
348147e4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348147e8:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348147ec:	e1a00007 	mov	r0, r7
348147f0:	e2811042 	add	r1, r1, #66	; 0x42
348147f4:	e12fff33 	blx	r3
#ifdef ONENAND_DEBUG
	char *name;
#endif

	for (i = 0; i < size; i++)
		if (manuf == onenand_manuf_ids[i].id)
348147f8:	e3550020 	cmp	r5, #32
348147fc:	0a000001 	beq	34814808 <onenand_chip_probe+0xbc>
34814800:	e35500ec 	cmp	r5, #236	; 0xec
34814804:	1a00000f 	bne	34814848 <onenand_chip_probe+0xfc>
	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;

	/* Read manufacturer and device IDs from Register */
	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
34814808:	e5940000 	ldr	r0, [r4]
3481480c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814810:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34814814:	e12fff33 	blx	r3
34814818:	e1a07000 	mov	r7, r0
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
3481481c:	e5940000 	ldr	r0, [r4]
34814820:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814824:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34814828:	e2800002 	add	r0, r0, #2
3481482c:	e12fff33 	blx	r3

	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
34814830:	e1570005 	cmp	r7, r5
34814834:	01500006 	cmpeq	r0, r6
34814838:	03a00000 	moveq	r0, #0
3481483c:	13a00001 	movne	r0, #1
		return -ENXIO;
34814840:	13e00005 	mvnne	r0, #5
34814844:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);

	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;
34814848:	e3e00005 	mvn	r0, #5
	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
		return -ENXIO;

	return 0;
}
3481484c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34814850 <flexonenand_get_size>:
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814850:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34814854:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814858:	e3a01010 	mov	r1, #16
	struct onenand_chip *this = mtd->priv;
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
3481485c:	e594701c 	ldr	r7, [r4, #28]
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814860:	e5946030 	ldr	r6, [r4, #48]	; 0x30
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34814864:	e7e33257 	ubfx	r3, r7, #4, #4
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814868:	e1a01311 	lsl	r1, r1, r3
3481486c:	e1a02001 	mov	r2, r1
34814870:	e1a03fc2 	asr	r3, r2, #31
34814874:	e1a03a03 	lsl	r3, r3, #20
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814878:	e24dd018 	sub	sp, sp, #24
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
3481487c:	e1a02006 	mov	r2, r6
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814880:	e1a05000 	mov	r5, r0
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814884:	e1a00a01 	lsl	r0, r1, #20
34814888:	e1831621 	orr	r1, r3, r1, lsr #12
3481488c:	eb002de7 	bl	34820030 <__ashrdi3>
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814890:	e7e071d7 	ubfx	r7, r7, #3, #1
34814894:	e1a07750 	asr	r7, r0, r7
	maxbdry = blksperdie - 1;
34814898:	e2473001 	sub	r3, r7, #1
3481489c:	e58d300c 	str	r3, [sp, #12]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
348148a0:	e8940009 	ldm	r4, {r0, r3}
348148a4:	e2800b79 	add	r0, r0, #123904	; 0x1e400
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
348148a8:	e1a03083 	lsl	r3, r3, #1
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
348148ac:	e58d7010 	str	r7, [sp, #16]
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
348148b0:	e585302c 	str	r3, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
348148b4:	e2800042 	add	r0, r0, #66	; 0x42
348148b8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348148bc:	e12fff33 	blx	r3
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
348148c0:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
348148c4:	e58d0008 	str	r0, [sp, #8]
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
348148c8:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348148cc:	e3800c01 	orr	r0, r0, #256	; 0x100
348148d0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348148d4:	e6ff0070 	uxth	r0, r0
348148d8:	e2811042 	add	r1, r1, #66	; 0x42

	for (die = 0; die < this->dies; die++) {
348148dc:	e3a07000 	mov	r7, #0

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;
348148e0:	e2466001 	sub	r6, r6, #1
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
348148e4:	e12fff33 	blx	r3

	for (die = 0; die < this->dies; die++) {
		this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
348148e8:	e1a0a007 	mov	sl, r7
348148ec:	ea000034 	b	348149c4 <flexonenand_get_size+0x174>
348148f0:	e58da000 	str	sl, [sp]
348148f4:	e1a02007 	mov	r2, r7
348148f8:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348148fc:	e3a01066 	mov	r1, #102	; 0x66
34814900:	e1a0300a 	mov	r3, sl
34814904:	e1a00005 	mov	r0, r5
34814908:	e12fff3c 	blx	ip
		this->wait(mtd, FL_SYNCING);
3481490c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814910:	e3a01004 	mov	r1, #4
34814914:	e1a00005 	mov	r0, r5
34814918:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
3481491c:	e58da000 	str	sl, [sp]
34814920:	e1a02007 	mov	r2, r7
34814924:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814928:	e3011985 	movw	r1, #6533	; 0x1985
3481492c:	e1a0300a 	mov	r3, sl
34814930:	e1a00005 	mov	r0, r5
34814934:	e12fff3c 	blx	ip
		this->wait(mtd, FL_READING);
34814938:	e3a01001 	mov	r1, #1
3481493c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814940:	e1a00005 	mov	r0, r5
34814944:	e12fff33 	blx	r3

		bdry = this->read_word(this->base + ONENAND_DATARAM);
34814948:	e5940000 	ldr	r0, [r4]
3481494c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814950:	e2800b01 	add	r0, r0, #1024	; 0x400
34814954:	e12fff33 	blx	r3
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;
34814958:	e1a03b00 	lsl	r3, r0, #22
3481495c:	e287b002 	add	fp, r7, #2
34814960:	e1a03b23 	lsr	r3, r3, #22
34814964:	e784310b 	str	r3, [r4, fp, lsl #2]

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814968:	e58da000 	str	sl, [sp]
		this->wait(mtd, FL_SYNCING);

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
3481496c:	e1a09000 	mov	r9, r0
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814970:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814974:	e3a02000 	mov	r2, #0
34814978:	e3a010f0 	mov	r1, #240	; 0xf0
3481497c:	e3a03000 	mov	r3, #0
34814980:	e1a00005 	mov	r0, r5
34814984:	e12fff3c 	blx	ip
		this->wait(mtd, FL_RESETING);
34814988:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481498c:	e3a01006 	mov	r1, #6
34814990:	e1a00005 	mov	r0, r5
34814994:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
34814998:	e1a03729 	lsr	r3, r9, #14
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
		this->wait(mtd, FL_RESETING);

		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
3481499c:	e794210b 	ldr	r2, [r4, fp, lsl #2]
348149a0:	e59fb240 	ldr	fp, [pc, #576]	; 34814be8 <flexonenand_get_size+0x398>
348149a4:	e3530003 	cmp	r3, #3
348149a8:	e59f923c 	ldr	r9, [pc, #572]	; 34814bec <flexonenand_get_size+0x39c>
348149ac:	11a0900b 	movne	r9, fp
348149b0:	e1a01007 	mov	r1, r7
348149b4:	e59f0234 	ldr	r0, [pc, #564]	; 34814bf0 <flexonenand_get_size+0x3a0>
348149b8:	e1a03009 	mov	r3, r9
348149bc:	ebffd441 	bl	34809ac8 <printf>

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);

	for (die = 0; die < this->dies; die++) {
348149c0:	e2877001 	add	r7, r7, #1
348149c4:	e5943004 	ldr	r3, [r4, #4]
348149c8:	e1570003 	cmp	r7, r3
348149cc:	3affffc7 	bcc	348148f0 <flexonenand_get_size+0xa0>
		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
		       this->boundary[die], locked ? "(Locked)" : "(Unlocked)");
	}

	/* Enable ECC */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
348149d0:	e5941000 	ldr	r1, [r4]
348149d4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348149d8:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348149dc:	e59d0008 	ldr	r0, [sp, #8]
348149e0:	e2811042 	add	r1, r1, #66	; 0x42
348149e4:	e12fff33 	blx	r3
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
348149e8:	e594c004 	ldr	ip, [r4, #4]
348149ec:	e2847004 	add	r7, r4, #4
348149f0:	e58dc014 	str	ip, [sp, #20]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
348149f4:	e1a00007 	mov	r0, r7
	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
348149f8:	e3a02000 	mov	r2, #0
348149fc:	e3a03000 	mov	r3, #0
	i = -1;
34814a00:	e3e01000 	mvn	r1, #0

	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
34814a04:	e3a0c000 	mov	ip, #0
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
34814a08:	e3a0e018 	mov	lr, #24
34814a0c:	e58d4008 	str	r4, [sp, #8]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
34814a10:	ea00003c 	b	34814b08 <flexonenand_get_size+0x2b8>
		if (!die || this->boundary[die-1] != maxbdry) {
34814a14:	e35c0000 	cmp	ip, #0
34814a18:	0a000003 	beq	34814a2c <flexonenand_get_size+0x1dc>
34814a1c:	e590a000 	ldr	sl, [r0]
34814a20:	e59d400c 	ldr	r4, [sp, #12]
34814a24:	e15a0004 	cmp	sl, r4
34814a28:	0a00000f 	beq	34814a6c <flexonenand_get_size+0x21c>
			i++;
34814a2c:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
34814a30:	e009019e 	mul	r9, lr, r1
34814a34:	e595b030 	ldr	fp, [r5, #48]	; 0x30
34814a38:	e08ba009 	add	sl, fp, r9
34814a3c:	e18b20f9 	strd	r2, [fp, r9]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
34814a40:	e3a0b001 	mov	fp, #1
34814a44:	e1a0961b 	lsl	r9, fp, r6
34814a48:	e58a9008 	str	r9, [sl, #8]
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
34814a4c:	e5909004 	ldr	r9, [r0, #4]
34814a50:	e089900b 	add	r9, r9, fp
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
			mtd->eraseregions[i].numblocks =
34814a54:	e58a900c 	str	r9, [sl, #12]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814a58:	e1a09619 	lsl	r9, r9, r6
34814a5c:	e0922009 	adds	r2, r2, r9
34814a60:	e2a33000 	adc	r3, r3, #0
			eraseshift++;
34814a64:	e086600b 	add	r6, r6, fp
34814a68:	ea00000e 	b	34814aa8 <flexonenand_get_size+0x258>
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814a6c:	e5959030 	ldr	r9, [r5, #48]	; 0x30
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
34814a70:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
34814a74:	e029919e 	mla	r9, lr, r1, r9
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
34814a78:	e24aa001 	sub	sl, sl, #1
34814a7c:	e585a02c 	str	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
							this->boundary[die] + 1;
34814a80:	e590a004 	ldr	sl, [r0, #4]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814a84:	e599b00c 	ldr	fp, [r9, #12]
34814a88:	e08ab00b 	add	fp, sl, fp
34814a8c:	e28bb001 	add	fp, fp, #1
34814a90:	e589b00c 	str	fp, [r9, #12]
							this->boundary[die] + 1;
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814a94:	e28aa001 	add	sl, sl, #1
34814a98:	e2469001 	sub	r9, r6, #1
34814a9c:	e1a0a91a 	lsl	sl, sl, r9
34814aa0:	e092200a 	adds	r2, r2, sl
34814aa4:	e2a33000 	adc	r3, r3, #0
		}
		if (this->boundary[die] != maxbdry) {
34814aa8:	e5b09004 	ldr	r9, [r0, #4]!
34814aac:	e59d400c 	ldr	r4, [sp, #12]
34814ab0:	e1590004 	cmp	r9, r4
34814ab4:	0a00000f 	beq	34814af8 <flexonenand_get_size+0x2a8>
			i++;
34814ab8:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
34814abc:	e00b019e 	mul	fp, lr, r1
34814ac0:	e5954030 	ldr	r4, [r5, #48]	; 0x30
34814ac4:	e084a00b 	add	sl, r4, fp
34814ac8:	e18420fb 	strd	r2, [r4, fp]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
34814acc:	e3a04001 	mov	r4, #1
34814ad0:	e1a0b614 	lsl	fp, r4, r6
34814ad4:	e58ab008 	str	fp, [sl, #8]
			mtd->eraseregions[i].numblocks = maxbdry ^
34814ad8:	e59db00c 	ldr	fp, [sp, #12]
34814adc:	e02b9009 	eor	r9, fp, r9
34814ae0:	e58a900c 	str	r9, [sl, #12]
							 this->boundary[die];
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814ae4:	e1a09619 	lsl	r9, r9, r6
34814ae8:	e0922009 	adds	r2, r2, r9
34814aec:	e2a33000 	adc	r3, r3, #0
			eraseshift--;
34814af0:	e2466001 	sub	r6, r6, #1
34814af4:	ea000002 	b	34814b04 <flexonenand_get_size+0x2b4>
		} else
			mtd->numeraseregions -= 1;
34814af8:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
34814afc:	e24aa001 	sub	sl, sl, #1
34814b00:	e585a02c 	str	sl, [r5, #44]	; 0x2c
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
34814b04:	e28cc001 	add	ip, ip, #1
34814b08:	e59d4014 	ldr	r4, [sp, #20]
34814b0c:	e15c0004 	cmp	ip, r4
34814b10:	1affffbf 	bne	34814a14 <flexonenand_get_size+0x1c4>
34814b14:	e59d4008 	ldr	r4, [sp, #8]
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814b18:	e3a02001 	mov	r2, #1
34814b1c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	if (mtd->numeraseregions == 1)
34814b20:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814b24:	e1a03312 	lsl	r3, r2, r3
	if (mtd->numeraseregions == 1)
34814b28:	e1510002 	cmp	r1, r2
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814b2c:	e5853010 	str	r3, [r5, #16]
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
34814b30:	01a03233 	lsreq	r3, r3, r2

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814b34:	e59f00b8 	ldr	r0, [pc, #184]	; 34814bf4 <flexonenand_get_size+0x3a4>
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
34814b38:	05853010 	streq	r3, [r5, #16]

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814b3c:	e3a06000 	mov	r6, #0
	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814b40:	ebffd3e0 	bl	34809ac8 <printf>
	for (i = 0; i < mtd->numeraseregions; i++)
34814b44:	e1a0a006 	mov	sl, r6
34814b48:	ea00000a 	b	34814b78 <flexonenand_get_size+0x328>
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814b4c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814b50:	e59f00a0 	ldr	r0, [pc, #160]	; 34814bf8 <flexonenand_get_size+0x3a8>
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814b54:	e0832006 	add	r2, r3, r6
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814b58:	e5921008 	ldr	r1, [r2, #8]
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814b5c:	e28aa001 	add	sl, sl, #1
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814b60:	e58d1000 	str	r1, [sp]
34814b64:	e592200c 	ldr	r2, [r2, #12]
34814b68:	e58d2004 	str	r2, [sp, #4]
34814b6c:	e18320d6 	ldrd	r2, [r3, r6]
34814b70:	ebffd3d4 	bl	34809ac8 <printf>
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814b74:	e2866018 	add	r6, r6, #24
34814b78:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
34814b7c:	e15a0003 	cmp	sl, r3
34814b80:	bafffff1 	blt	34814b4c <flexonenand_get_size+0x2fc>
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814b84:	e5946004 	ldr	r6, [r4, #4]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814b88:	e3a02000 	mov	r2, #0
34814b8c:	e3a03000 	mov	r3, #0
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814b90:	e0846106 	add	r6, r4, r6, lsl #2
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814b94:	e1c520f8 	strd	r2, [r5, #8]
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814b98:	e2866004 	add	r6, r6, #4
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814b9c:	ea00000d 	b	34814bd8 <flexonenand_get_size+0x388>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814ba0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814ba4:	e5b70004 	ldr	r0, [r7, #4]!
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814ba8:	e59d9010 	ldr	r9, [sp, #16]
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814bac:	e2800001 	add	r0, r0, #1
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814bb0:	e1a0a219 	lsl	sl, r9, r2
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814bb4:	e3a01000 	mov	r1, #0
34814bb8:	e2422001 	sub	r2, r2, #1
34814bbc:	eb002d22 	bl	3482004c <__ashldi3>
		mtd->size += this->diesize[die];
34814bc0:	e1c520d8 	ldrd	r2, [r5, #8]
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814bc4:	e060000a 	rsb	r0, r0, sl
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814bc8:	e0922000 	adds	r2, r2, r0
34814bcc:	e2a33000 	adc	r3, r3, #0
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814bd0:	e5870008 	str	r0, [r7, #8]
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814bd4:	e1c520f8 	strd	r2, [r5, #8]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814bd8:	e1570006 	cmp	r7, r6
34814bdc:	1affffef 	bne	34814ba0 <flexonenand_get_size+0x350>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
	}
}
34814be0:	e28dd018 	add	sp, sp, #24
34814be4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814be8:	34827410 	.word	0x34827410
34814bec:	34827419 	.word	0x34827419
34814bf0:	34827424 	.word	0x34827424
34814bf4:	3482743b 	.word	0x3482743b
34814bf8:	34827457 	.word	0x34827457

34814bfc <onenand_read_ecc>:
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
34814bfc:	e590301c 	ldr	r3, [r0, #28]
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
34814c00:	e92d4070 	push	{r4, r5, r6, lr}
	int ecc, i;

	if (!FLEXONENAND(this))
34814c04:	e3130c02 	tst	r3, #512	; 0x200
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
34814c08:	e1a04000 	mov	r4, r0
	int ecc, i;

	if (!FLEXONENAND(this))
34814c0c:	1a000005 	bne	34814c28 <onenand_read_ecc+0x2c>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);
34814c10:	e5900000 	ldr	r0, [r0]
34814c14:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814c18:	e2800b7f 	add	r0, r0, #130048	; 0x1fc00
34814c1c:	e2800c02 	add	r0, r0, #512	; 0x200
34814c20:	e12fff33 	blx	r3
34814c24:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
34814c28:	e59f5044 	ldr	r5, [pc, #68]	; 34814c74 <onenand_read_ecc+0x78>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
34814c2c:	e59f6044 	ldr	r6, [pc, #68]	; 34814c78 <onenand_read_ecc+0x7c>
		ecc = this->read_word(this->base
34814c30:	e5940000 	ldr	r0, [r4]
34814c34:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814c38:	e0800085 	add	r0, r0, r5, lsl #1
34814c3c:	e12fff33 	blx	r3
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
34814c40:	e3500000 	cmp	r0, #0
34814c44:	0a000003 	beq	34814c58 <onenand_read_ecc+0x5c>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
34814c48:	e3013010 	movw	r3, #4112	; 0x1010
34814c4c:	e0003003 	and	r3, r0, r3
34814c50:	e3530000 	cmp	r3, #0
34814c54:	1a000004 	bne	34814c6c <onenand_read_ecc+0x70>
34814c58:	e2855001 	add	r5, r5, #1
	int ecc, i;

	if (!FLEXONENAND(this))
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
34814c5c:	e1550006 	cmp	r5, r6
34814c60:	1afffff2 	bne	34814c30 <onenand_read_ecc+0x34>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
	}

	return 0;
34814c64:	e3a00000 	mov	r0, #0
34814c68:	e8bd8070 	pop	{r4, r5, r6, pc}
		ecc = this->read_word(this->base
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
34814c6c:	e30a0aaa 	movw	r0, #43690	; 0xaaaa
	}

	return 0;
}
34814c70:	e8bd8070 	pop	{r4, r5, r6, pc}
34814c74:	0001fe00 	.word	0x0001fe00
34814c78:	0001fe04 	.word	0x0001fe04

34814c7c <onenand_bbt_wait>:
 * @param state		state to select the max. timeout value
 *
 * Wait for command done.
 */
static int onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34814c7c:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34814c80:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814c84:	e5960000 	ldr	r0, [r6]
34814c88:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814c8c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814c90:	e2800082 	add	r0, r0, #130	; 0x82
34814c94:	e12fff33 	blx	r3
		if (interrupt & flags)
34814c98:	e3100902 	tst	r0, #32768	; 0x8000
34814c9c:	0afffff8 	beq	34814c84 <onenand_bbt_wait+0x8>
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814ca0:	e5960000 	ldr	r0, [r6]
34814ca4:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814ca8:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814cac:	e2800082 	add	r0, r0, #130	; 0x82
34814cb0:	e12fff33 	blx	r3
34814cb4:	e1a05000 	mov	r5, r0
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814cb8:	e5960000 	ldr	r0, [r6]
34814cbc:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814cc0:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814cc4:	e2800080 	add	r0, r0, #128	; 0x80
34814cc8:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34814ccc:	e3150080 	tst	r5, #128	; 0x80
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814cd0:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34814cd4:	0a00000b 	beq	34814d08 <onenand_bbt_wait+0x8c>
		int ecc = onenand_read_ecc(this);
34814cd8:	e1a00006 	mov	r0, r6
34814cdc:	ebffffc6 	bl	34814bfc <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814ce0:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34814ce4:	e0003003 	and	r3, r0, r3
34814ce8:	e3530000 	cmp	r3, #0
	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34814cec:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814cf0:	0a00000a 	beq	34814d20 <onenand_bbt_wait+0xa4>
			printk(KERN_INFO "onenand_bbt_wait: ecc error = 0x%04x"
34814cf4:	e59f0040 	ldr	r0, [pc, #64]	; 34814d3c <onenand_bbt_wait+0xc0>
34814cf8:	e1a02004 	mov	r2, r4
34814cfc:	ebffd371 	bl	34809ac8 <printf>
				", controller = 0x%04x\n", ecc, ctrl);
			return ONENAND_BBT_READ_ERROR;
34814d00:	e3a00001 	mov	r0, #1
34814d04:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	} else {
		printk(KERN_ERR "onenand_bbt_wait: read timeout!"
34814d08:	e59f0030 	ldr	r0, [pc, #48]	; 34814d40 <onenand_bbt_wait+0xc4>
34814d0c:	e1a01004 	mov	r1, r4
34814d10:	e1a02005 	mov	r2, r5
34814d14:	ebffd36b 	bl	34809ac8 <printf>
				"ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
		return ONENAND_BBT_READ_FATAL_ERROR;
34814d18:	e3a00004 	mov	r0, #4
34814d1c:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* Initial bad block case: 0x2400 or 0x0400 */
	if (ctrl & ONENAND_CTRL_ERROR) {
34814d20:	e2140b01 	ands	r0, r4, #1024	; 0x400
34814d24:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
34814d28:	e1a01004 	mov	r1, r4
34814d2c:	e59f0010 	ldr	r0, [pc, #16]	; 34814d44 <onenand_bbt_wait+0xc8>
34814d30:	ebffd364 	bl	34809ac8 <printf>
		return ONENAND_BBT_READ_ERROR;
34814d34:	e3a00001 	mov	r0, #1
	}

	return 0;
}
34814d38:	e8bd8070 	pop	{r4, r5, r6, pc}
34814d3c:	3482748f 	.word	0x3482748f
34814d40:	348274ca 	.word	0x348274ca
34814d44:	34827502 	.word	0x34827502

34814d48 <onenand_wait>:
 * Wait for command done. This applies to all OneNAND command
 * Read can take up to 30us, erase up to 2ms and program up to 350us
 * according to general OneNAND specs
 */
static int onenand_wait(struct mtd_info *mtd, int state)
{
34814d48:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34814d4c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814d50:	e5950000 	ldr	r0, [r5]
34814d54:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34814d58:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814d5c:	e2800082 	add	r0, r0, #130	; 0x82
34814d60:	e12fff33 	blx	r3
		if (interrupt & flags)
34814d64:	e3100902 	tst	r0, #32768	; 0x8000
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814d68:	e1a06000 	mov	r6, r0
		if (interrupt & flags)
34814d6c:	0afffff7 	beq	34814d50 <onenand_wait+0x8>
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814d70:	e5950000 	ldr	r0, [r5]
34814d74:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34814d78:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814d7c:	e2800080 	add	r0, r0, #128	; 0x80
34814d80:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34814d84:	e3160080 	tst	r6, #128	; 0x80
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
		if (interrupt & flags)
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814d88:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34814d8c:	0a00000a 	beq	34814dbc <onenand_wait+0x74>
		int ecc = onenand_read_ecc(this);
34814d90:	e1a00005 	mov	r0, r5
34814d94:	ebffff98 	bl	34814bfc <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814d98:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34814d9c:	e0003003 	and	r3, r0, r3
34814da0:	e3530000 	cmp	r3, #0
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34814da4:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814da8:	0a000003 	beq	34814dbc <onenand_wait+0x74>
			printk("onenand_wait: ECC error = 0x%04x\n", ecc);
34814dac:	e59f0040 	ldr	r0, [pc, #64]	; 34814df4 <onenand_wait+0xac>
34814db0:	ebffd344 	bl	34809ac8 <printf>
			return -EBADMSG;
34814db4:	e3e00049 	mvn	r0, #73	; 0x49
34814db8:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	if (ctrl & ONENAND_CTRL_ERROR) {
34814dbc:	e2140b01 	ands	r0, r4, #1024	; 0x400
34814dc0:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
34814dc4:	e59f002c 	ldr	r0, [pc, #44]	; 34814df8 <onenand_wait+0xb0>
34814dc8:	e1a01004 	mov	r1, r4
34814dcc:	ebffd33d 	bl	34809ac8 <printf>
		if (ctrl & ONENAND_CTRL_LOCK)
34814dd0:	e3140901 	tst	r4, #16384	; 0x4000
34814dd4:	0a000004 	beq	34814dec <onenand_wait+0xa4>
			printk("onenand_wait: it's locked error = 0x%04x\n",
34814dd8:	e59f001c 	ldr	r0, [pc, #28]	; 34814dfc <onenand_wait+0xb4>
34814ddc:	e1a01004 	mov	r1, r4
34814de0:	ebffd338 	bl	34809ac8 <printf>
				ctrl);

		return -EIO;
34814de4:	e3e00004 	mvn	r0, #4
34814de8:	e8bd8070 	pop	{r4, r5, r6, pc}
34814dec:	e3e00004 	mvn	r0, #4
	}


	return 0;
}
34814df0:	e8bd8070 	pop	{r4, r5, r6, pc}
34814df4:	3482752f 	.word	0x3482752f
34814df8:	34827551 	.word	0x34827551
34814dfc:	3482757a 	.word	0x3482757a

34814e00 <onenand_transfer_auto_oob>:
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
34814e00:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34814e04:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
34814e08:	e0835002 	add	r5, r3, r2
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
34814e0c:	e5973090 	ldr	r3, [r7, #144]	; 0x90
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
34814e10:	e24dd018 	sub	sp, sp, #24
34814e14:	e1a09001 	mov	r9, r1
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
34814e18:	e597109c 	ldr	r1, [r7, #156]	; 0x9c
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
34814e1c:	e58d3014 	str	r3, [sp, #20]

	free = this->ecclayout->oobfree;
34814e20:	e3a03000 	mov	r3, #0
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
34814e24:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
34814e28:	e1a04002 	mov	r4, r2
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
34814e2c:	e2811f82 	add	r1, r1, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
34814e30:	e1a02003 	mov	r2, r3
34814e34:	ea00000c 	b	34814e6c <onenand_transfer_auto_oob+0x6c>
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (readcol >= lastgap)
34814e38:	e1540002 	cmp	r4, r2
			readcol += free->offset - lastgap;
34814e3c:	a791e003 	ldrge	lr, [r1, r3]
34814e40:	a084400e 	addge	r4, r4, lr
34814e44:	a0624004 	rsbge	r4, r2, r4
		if (readend >= lastgap)
34814e48:	e1550002 	cmp	r5, r2
			readend += free->offset - lastgap;
34814e4c:	a791e003 	ldrge	lr, [r1, r3]
34814e50:	a085500e 	addge	r5, r5, lr
34814e54:	a0625005 	rsbge	r5, r2, r5
		lastgap = free->offset + free->length;
34814e58:	e7912003 	ldr	r2, [r1, r3]
34814e5c:	e2833008 	add	r3, r3, #8
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814e60:	e3530040 	cmp	r3, #64	; 0x40
34814e64:	0a000004 	beq	34814e7c <onenand_transfer_auto_oob+0x7c>
		if (readcol >= lastgap)
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
34814e68:	e082200c 	add	r2, r2, ip
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
34814e6c:	e081c003 	add	ip, r1, r3
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814e70:	e59cc004 	ldr	ip, [ip, #4]
34814e74:	e35c0000 	cmp	ip, #0
34814e78:	1affffee 	bne	34814e38 <onenand_transfer_auto_oob+0x38>
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
34814e7c:	e59f30bc 	ldr	r3, [pc, #188]	; 34814f40 <onenand_transfer_auto_oob+0x140>
34814e80:	e3a0a000 	mov	sl, #0
34814e84:	e58d3000 	str	r3, [sp]
34814e88:	e59d3014 	ldr	r3, [sp, #20]
34814e8c:	e98d0408 	stmib	sp, {r3, sl}
34814e90:	e5903018 	ldr	r3, [r0, #24]
34814e94:	e3a02000 	mov	r2, #0
34814e98:	e58d300c 	str	r3, [sp, #12]
34814e9c:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34814ea0:	e3a03000 	mov	r3, #0
34814ea4:	e12fff31 	blx	r1
	free = this->ecclayout->oobfree;
34814ea8:	e597b09c 	ldr	fp, [r7, #156]	; 0x9c
34814eac:	e1a0700a 	mov	r7, sl
34814eb0:	e28bbf82 	add	fp, fp, #520	; 0x208
34814eb4:	ea00001a 	b	34814f24 <onenand_transfer_auto_oob+0x124>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
34814eb8:	e79b1007 	ldr	r1, [fp, r7]
34814ebc:	e081a00a 	add	sl, r1, sl
		if (free->offset < readend && free_end > readcol) {
34814ec0:	e1510005 	cmp	r1, r5
34814ec4:	23a03000 	movcs	r3, #0
34814ec8:	33a03001 	movcc	r3, #1
34814ecc:	e15a0004 	cmp	sl, r4
34814ed0:	d3a03000 	movle	r3, #0
34814ed4:	e3530000 	cmp	r3, #0
34814ed8:	0a00000c 	beq	34814f10 <onenand_transfer_auto_oob+0x110>
			int st = max_t(int,free->offset,readcol);
34814edc:	e1540001 	cmp	r4, r1
34814ee0:	a1a01004 	movge	r1, r4
34814ee4:	b1a01001 	movlt	r1, r1
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
			memcpy(buf, oob_buf + st, n);
34814ee8:	e59d3014 	ldr	r3, [sp, #20]
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
		if (free->offset < readend && free_end > readcol) {
			int st = max_t(int,free->offset,readcol);
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
34814eec:	e155000a 	cmp	r5, sl
34814ef0:	d061a005 	rsble	sl, r1, r5
34814ef4:	c061a00a 	rsbgt	sl, r1, sl
			memcpy(buf, oob_buf + st, n);
34814ef8:	e1a00009 	mov	r0, r9
34814efc:	e0831001 	add	r1, r3, r1
34814f00:	e1a0200a 	mov	r2, sl
34814f04:	eb001de7 	bl	3481c6a8 <memcpy>
			buf += n;
34814f08:	e089900a 	add	r9, r9, sl
34814f0c:	ea000001 	b	34814f18 <onenand_transfer_auto_oob+0x118>
		} else if (column == 0)
34814f10:	e3560000 	cmp	r6, #0
34814f14:	0a000006 	beq	34814f34 <onenand_transfer_auto_oob+0x134>
34814f18:	e2877008 	add	r7, r7, #8
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814f1c:	e3570040 	cmp	r7, #64	; 0x40
34814f20:	0a000003 	beq	34814f34 <onenand_transfer_auto_oob+0x134>
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
34814f24:	e08b3007 	add	r3, fp, r7
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814f28:	e593a004 	ldr	sl, [r3, #4]
34814f2c:	e35a0000 	cmp	sl, #0
34814f30:	1affffe0 	bne	34814eb8 <onenand_transfer_auto_oob+0xb8>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
34814f34:	e3a00000 	mov	r0, #0
34814f38:	e28dd018 	add	sp, sp, #24
34814f3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814f40:	00010020 	.word	0x00010020

34814f44 <onenand_update_bufferram.clone.2>:
 * @param addr		address to update
 * @param valid		valid flag
 *
 * Update BufferRAM information
 */
static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
34814f44:	e92d4010 	push	{r4, lr}
34814f48:	e1a04000 	mov	r4, r0
	unsigned int i;

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int)(addr >> this->page_shift);
34814f4c:	e1a01003 	mov	r1, r3
34814f50:	e1a00002 	mov	r0, r2
34814f54:	e5942034 	ldr	r2, [r4, #52]	; 0x34
34814f58:	eb002c34 	bl	34820030 <__ashrdi3>

	/* Invalidate another BufferRAM */
	i = ONENAND_NEXT_BUFFERRAM(this);
34814f5c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34814f60:	e2232001 	eor	r2, r3, #1
	if (this->bufferram[i].blockpage == blockpage)
34814f64:	e2822012 	add	r2, r2, #18
34814f68:	e7941102 	ldr	r1, [r4, r2, lsl #2]
34814f6c:	e2833012 	add	r3, r3, #18
34814f70:	e1510000 	cmp	r1, r0
		this->bufferram[i].blockpage = -1;
34814f74:	03e01000 	mvneq	r1, #0
34814f78:	07841102 	streq	r1, [r4, r2, lsl #2]

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
34814f7c:	e59d2008 	ldr	r2, [sp, #8]
34814f80:	e3520000 	cmp	r2, #0
		this->bufferram[i].blockpage = blockpage;
	else
		this->bufferram[i].blockpage = -1;
34814f84:	03e02000 	mvneq	r2, #0
		this->bufferram[i].blockpage = -1;

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
		this->bufferram[i].blockpage = blockpage;
34814f88:	17840103 	strne	r0, [r4, r3, lsl #2]
	else
		this->bufferram[i].blockpage = -1;
34814f8c:	07842103 	streq	r2, [r4, r3, lsl #2]

	return 0;
}
34814f90:	e3a00000 	mov	r0, #0
34814f94:	e8bd8010 	pop	{r4, pc}

34814f98 <onenand_fill_auto_oob.clone.7>:
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814f98:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
34814f9c:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34814fa0:	e590409c 	ldr	r4, [r0, #156]	; 0x9c
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814fa4:	e1a09003 	mov	r9, r3
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
34814fa8:	e0877003 	add	r7, r7, r3
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
34814fac:	e1a06003 	mov	r6, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34814fb0:	e3a03000 	mov	r3, #0
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814fb4:	e1a0b002 	mov	fp, r2
34814fb8:	e1a0c001 	mov	ip, r1
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34814fbc:	e2844f82 	add	r4, r4, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
34814fc0:	e1a02003 	mov	r2, r3
34814fc4:	ea00000c 	b	34814ffc <onenand_fill_auto_oob.clone.7+0x64>
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (writecol >= lastgap)
34814fc8:	e1560002 	cmp	r6, r2
			writecol += free->offset - lastgap;
34814fcc:	a7940003 	ldrge	r0, [r4, r3]
34814fd0:	a0866000 	addge	r6, r6, r0
34814fd4:	a0626006 	rsbge	r6, r2, r6
		if (writeend >= lastgap)
34814fd8:	e1570002 	cmp	r7, r2
			writeend += free->offset - lastgap;
34814fdc:	a7940003 	ldrge	r0, [r4, r3]
34814fe0:	a0877000 	addge	r7, r7, r0
34814fe4:	a0627007 	rsbge	r7, r2, r7
		lastgap = free->offset + free->length;
34814fe8:	e7942003 	ldr	r2, [r4, r3]
34814fec:	e2833008 	add	r3, r3, #8
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814ff0:	e3530040 	cmp	r3, #64	; 0x40
34814ff4:	0a000004 	beq	3481500c <onenand_fill_auto_oob.clone.7+0x74>
		if (writecol >= lastgap)
			writecol += free->offset - lastgap;
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
34814ff8:	e0812002 	add	r2, r1, r2
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814ffc:	e0841003 	add	r1, r4, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815000:	e5911004 	ldr	r1, [r1, #4]
34815004:	e3510000 	cmp	r1, #0
34815008:	1affffee 	bne	34814fc8 <onenand_fill_auto_oob.clone.7+0x30>
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
3481500c:	e3a05000 	mov	r5, #0
34815010:	ea00001b 	b	34815084 <onenand_fill_auto_oob.clone.7+0xec>
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
34815014:	e7940005 	ldr	r0, [r4, r5]
34815018:	e08aa000 	add	sl, sl, r0
		if (free->offset < writeend && free_end > writecol) {
3481501c:	e1500007 	cmp	r0, r7
34815020:	23a03000 	movcs	r3, #0
34815024:	33a03001 	movcc	r3, #1
34815028:	e15a0006 	cmp	sl, r6
3481502c:	d3a03000 	movle	r3, #0
34815030:	e3530000 	cmp	r3, #0
34815034:	0a00000d 	beq	34815070 <onenand_fill_auto_oob.clone.7+0xd8>
			int st = max_t(int,free->offset,writecol);
34815038:	e1560000 	cmp	r6, r0
3481503c:	a1a00006 	movge	r0, r6
34815040:	b1a00000 	movlt	r0, r0
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
34815044:	e157000a 	cmp	r7, sl
34815048:	d060a007 	rsble	sl, r0, r7
3481504c:	c060a00a 	rsbgt	sl, r0, sl
			memcpy(oob_buf + st, buf, n);
34815050:	e1a0100b 	mov	r1, fp
34815054:	e08c0000 	add	r0, ip, r0
34815058:	e1a0200a 	mov	r2, sl
3481505c:	e58dc004 	str	ip, [sp, #4]
			buf += n;
34815060:	e08bb00a 	add	fp, fp, sl
		int free_end = free->offset + free->length;
		if (free->offset < writeend && free_end > writecol) {
			int st = max_t(int,free->offset,writecol);
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
			memcpy(oob_buf + st, buf, n);
34815064:	eb001d8f 	bl	3481c6a8 <memcpy>
34815068:	e59dc004 	ldr	ip, [sp, #4]
3481506c:	ea000001 	b	34815078 <onenand_fill_auto_oob.clone.7+0xe0>
			buf += n;
		} else if (column == 0)
34815070:	e3590000 	cmp	r9, #0
34815074:	0a000006 	beq	34815094 <onenand_fill_auto_oob.clone.7+0xfc>
34815078:	e2855008 	add	r5, r5, #8
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481507c:	e3550040 	cmp	r5, #64	; 0x40
34815080:	0a000003 	beq	34815094 <onenand_fill_auto_oob.clone.7+0xfc>
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34815084:	e0843005 	add	r3, r4, r5
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815088:	e593a004 	ldr	sl, [r3, #4]
3481508c:	e35a0000 	cmp	sl, #0
34815090:	1affffdf 	bne	34815014 <onenand_fill_auto_oob.clone.7+0x7c>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
34815094:	e3a00000 	mov	r0, #0
34815098:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3481509c <onenand_write_oob_nolock>:
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
3481509c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348150a0:	e24dd038 	sub	sp, sp, #56	; 0x38
348150a4:	e59db058 	ldr	fp, [sp, #88]	; 0x58
	struct onenand_chip *this = mtd->priv;
348150a8:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
348150ac:	e59b101c 	ldr	r1, [fp, #28]
	mtd_oob_mode_t mode = ops->mode;
348150b0:	e59b4000 	ldr	r4, [fp]
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
348150b4:	e58d1028 	str	r1, [sp, #40]	; 0x28
	mtd_oob_mode_t mode = ops->mode;

	to += ops->ooboffs;
348150b8:	e59b1014 	ldr	r1, [fp, #20]
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
	mtd_oob_mode_t mode = ops->mode;
348150bc:	e58d4030 	str	r4, [sp, #48]	; 0x30

	to += ops->ooboffs;
348150c0:	e0924001 	adds	r4, r2, r1
348150c4:	e2a35000 	adc	r5, r3, #0
348150c8:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
348150cc:	e59d5030 	ldr	r5, [sp, #48]	; 0x30
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
348150d0:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
348150d4:	e3550001 	cmp	r5, #1
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
348150d8:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
348150dc:	e59b000c 	ldr	r0, [fp, #12]
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
348150e0:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
348150e4:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348150e8:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
348150ec:	e58d002c 	str	r0, [sp, #44]	; 0x2c
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
348150f0:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348150f4:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
348150f8:	1596a018 	ldrne	sl, [r6, #24]

	column = to & (mtd->oobsize - 1);
348150fc:	e2499001 	sub	r9, r9, #1
34815100:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
34815104:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
34815108:	a59f0280 	ldrge	r0, [pc, #640]	; 34815390 <onenand_write_oob_nolock+0x2f4>
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
3481510c:	aa000004 	bge	34815124 <onenand_write_oob_nolock+0x88>
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
		return -EINVAL;
	}

	/* For compatibility with NAND: Do not allow write past end of page */
	if (unlikely(column + len > oobsize)) {
34815110:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34815114:	e089c001 	add	ip, r9, r1
34815118:	e15c000a 	cmp	ip, sl
3481511c:	9a000003 	bls	34815130 <onenand_write_oob_nolock+0x94>
		printk(KERN_ERR "onenand_write_oob_nolock: "
34815120:	e59f026c 	ldr	r0, [pc, #620]	; 34815394 <onenand_write_oob_nolock+0x2f8>
34815124:	ebffd267 	bl	34809ac8 <printf>
				"Attempt to write past end of page\n");
		return -EINVAL;
34815128:	e3e09015 	mvn	r9, #21
3481512c:	ea000094 	b	34815384 <onenand_write_oob_nolock+0x2e8>
	}

	/* Do not allow reads past end of device */
	if (unlikely(to >= mtd->size ||
34815130:	e596100c 	ldr	r1, [r6, #12]
34815134:	e59d201c 	ldr	r2, [sp, #28]
34815138:	e5960008 	ldr	r0, [r6, #8]
3481513c:	e1510002 	cmp	r1, r2
34815140:	8a000003 	bhi	34815154 <onenand_write_oob_nolock+0xb8>
34815144:	1a00001c 	bne	348151bc <onenand_write_oob_nolock+0x120>
34815148:	e59d3018 	ldr	r3, [sp, #24]
3481514c:	e1500003 	cmp	r0, r3
34815150:	9a000019 	bls	348151bc <onenand_write_oob_nolock+0x120>
34815154:	e5973034 	ldr	r3, [r7, #52]	; 0x34
34815158:	e1a0400a 	mov	r4, sl
3481515c:	e1a05fc4 	asr	r5, r4, #31
34815160:	e1a02003 	mov	r2, r3
34815164:	e1cd42f0 	strd	r4, [sp, #32]
34815168:	e58dc010 	str	ip, [sp, #16]
3481516c:	e58d3014 	str	r3, [sp, #20]
34815170:	eb002ba7 	bl	34820014 <__lshrdi3>
34815174:	e59d3014 	ldr	r3, [sp, #20]
34815178:	e1a04000 	mov	r4, r0
3481517c:	e1a05001 	mov	r5, r1
34815180:	e1a02003 	mov	r2, r3
34815184:	e1cd01d8 	ldrd	r0, [sp, #24]
34815188:	eb002ba8 	bl	34820030 <__ashrdi3>
3481518c:	e0544000 	subs	r4, r4, r0
34815190:	e0c55001 	sbc	r5, r5, r1
34815194:	e003059a 	mul	r3, sl, r5
34815198:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3481519c:	e59dc010 	ldr	ip, [sp, #16]
348151a0:	e0233094 	mla	r3, r4, r0, r3
348151a4:	e085449a 	umull	r4, r5, sl, r4
348151a8:	e0835005 	add	r5, r3, r5
348151ac:	e3550000 	cmp	r5, #0
348151b0:	1a000003 	bne	348151c4 <onenand_write_oob_nolock+0x128>
348151b4:	e15c0004 	cmp	ip, r4
348151b8:	9a000001 	bls	348151c4 <onenand_write_oob_nolock+0x128>
				column + len > ((mtd->size >> this->page_shift) -
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
348151bc:	e59f01d4 	ldr	r0, [pc, #468]	; 34815398 <onenand_write_oob_nolock+0x2fc>
348151c0:	eaffffd7 	b	34815124 <onenand_write_oob_nolock+0x88>
		return -EINVAL;
	}

	oobbuf = this->oob_buf;

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
348151c4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
348151c8:	e5971090 	ldr	r1, [r7, #144]	; 0x90

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
348151cc:	e3130008 	tst	r3, #8
348151d0:	03a0201a 	moveq	r2, #26
348151d4:	13a02080 	movne	r2, #128	; 0x80
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
348151d8:	e58d1020 	str	r1, [sp, #32]

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
348151dc:	e58d2034 	str	r2, [sp, #52]	; 0x34
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
348151e0:	e3a04000 	mov	r4, #0

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
348151e4:	ea000061 	b	34815370 <onenand_write_oob_nolock+0x2d4>
		int thislen = min_t(int, oobsize, len - written);
348151e8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
348151ec:	e3011978 	movw	r1, #6520	; 0x1978
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
348151f0:	e0645003 	rsb	r5, r4, r3

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
348151f4:	e5963018 	ldr	r3, [r6, #24]
348151f8:	e1a00006 	mov	r0, r6
348151fc:	e58d3000 	str	r3, [sp]
34815200:	e597c050 	ldr	ip, [r7, #80]	; 0x50
34815204:	e1cd21d8 	ldrd	r2, [sp, #24]
34815208:	e12fff3c 	blx	ip

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
3481520c:	e59d0020 	ldr	r0, [sp, #32]
34815210:	e3a010ff 	mov	r1, #255	; 0xff
34815214:	e5962018 	ldr	r2, [r6, #24]
34815218:	eb001cfe 	bl	3481c618 <memset>
		if (mode == MTD_OOB_AUTO)
3481521c:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
34815220:	e155000a 	cmp	r5, sl
34815224:	a1a0500a 	movge	r5, sl
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
		if (mode == MTD_OOB_AUTO)
34815228:	e3500001 	cmp	r0, #1
3481522c:	1a000006 	bne	3481524c <onenand_write_oob_nolock+0x1b0>
			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
34815230:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34815234:	e59d1020 	ldr	r1, [sp, #32]
34815238:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3481523c:	e1a03009 	mov	r3, r9
34815240:	e58d5000 	str	r5, [sp]
34815244:	ebffff53 	bl	34814f98 <onenand_fill_auto_oob.clone.7>
34815248:	ea000004 	b	34815260 <onenand_write_oob_nolock+0x1c4>
		else
			memcpy(oobbuf + column, buf, thislen);
3481524c:	e59d1020 	ldr	r1, [sp, #32]
34815250:	e1a02005 	mov	r2, r5
34815254:	e0810009 	add	r0, r1, r9
34815258:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481525c:	eb001d11 	bl	3481c6a8 <memcpy>
		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
34815260:	e59d3020 	ldr	r3, [sp, #32]
34815264:	e59f2130 	ldr	r2, [pc, #304]	; 3481539c <onenand_write_oob_nolock+0x300>
34815268:	e58d3004 	str	r3, [sp, #4]
3481526c:	e5963018 	ldr	r3, [r6, #24]
34815270:	e3a00000 	mov	r0, #0
34815274:	e58d2000 	str	r2, [sp]
34815278:	e58d0008 	str	r0, [sp, #8]
3481527c:	e58d300c 	str	r3, [sp, #12]
34815280:	e5971064 	ldr	r1, [r7, #100]	; 0x64
34815284:	e3a03000 	mov	r3, #0
34815288:	e1a00006 	mov	r0, r6
3481528c:	e3a02000 	mov	r2, #0
34815290:	e12fff31 	blx	r1

		if (ONENAND_IS_4KB_PAGE(this)) {
34815294:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34815298:	e3130008 	tst	r3, #8
3481529c:	0a000010 	beq	348152e4 <onenand_write_oob_nolock+0x248>
			/* Set main area of DataRAM to 0xff*/
			memset(this->page_buf, 0xff, mtd->writesize);
348152a0:	e3a010ff 	mov	r1, #255	; 0xff
348152a4:	e5962014 	ldr	r2, [r6, #20]
348152a8:	e597008c 	ldr	r0, [r7, #140]	; 0x8c
348152ac:	eb001cd9 	bl	3481c618 <memset>
			this->write_bufferram(mtd, 0, ONENAND_DATARAM,
348152b0:	e3a01b01 	mov	r1, #1024	; 0x400
348152b4:	e58d1000 	str	r1, [sp]
348152b8:	e597308c 	ldr	r3, [r7, #140]	; 0x8c
348152bc:	e3a02000 	mov	r2, #0
348152c0:	e58d3004 	str	r3, [sp, #4]
348152c4:	e5963014 	ldr	r3, [r6, #20]
348152c8:	e58d2008 	str	r2, [sp, #8]
348152cc:	e58d300c 	str	r3, [sp, #12]
348152d0:	e5971064 	ldr	r1, [r7, #100]	; 0x64
348152d4:	e1a00006 	mov	r0, r6
348152d8:	e3a02000 	mov	r2, #0
348152dc:	e3a03000 	mov	r3, #0
348152e0:	e12fff31 	blx	r1
				this->page_buf,	0, mtd->writesize);
		}

		this->command(mtd, oobcmd, to, mtd->oobsize);
348152e4:	e5963018 	ldr	r3, [r6, #24]
348152e8:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
348152ec:	e58d3000 	str	r3, [sp]
348152f0:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348152f4:	e1cd21d8 	ldrd	r2, [sp, #24]
348152f8:	e1a00006 	mov	r0, r6
348152fc:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, to, 0);
34815300:	e3a03000 	mov	r3, #0
34815304:	e58d3000 	str	r3, [sp]
34815308:	e5960094 	ldr	r0, [r6, #148]	; 0x94
3481530c:	e1cd21d8 	ldrd	r2, [sp, #24]
34815310:	ebffff0b 	bl	34814f44 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, 0);
		}

		ret = this->wait(mtd, FL_WRITING);
34815314:	e5973054 	ldr	r3, [r7, #84]	; 0x54
34815318:	e1a00006 	mov	r0, r6
3481531c:	e3a01002 	mov	r1, #2
34815320:	e12fff33 	blx	r3
		if (ret) {
34815324:	e2509000 	subs	r9, r0, #0
34815328:	0a000003 	beq	3481533c <onenand_write_oob_nolock+0x2a0>
			printk(KERN_ERR "onenand_write_oob_nolock: write failed %d\n", ret);
3481532c:	e1a01009 	mov	r1, r9
34815330:	e59f0068 	ldr	r0, [pc, #104]	; 348153a0 <onenand_write_oob_nolock+0x304>
34815334:	ebffd1e3 	bl	34809ac8 <printf>
			break;
34815338:	ea000010 	b	34815380 <onenand_write_oob_nolock+0x2e4>
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
		if (written == len)
3481533c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
		if (ret) {
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34815340:	e0844005 	add	r4, r4, r5
		if (written == len)
34815344:	e1540000 	cmp	r4, r0
34815348:	0a00000c 	beq	34815380 <onenand_write_oob_nolock+0x2e4>
			break;

		to += mtd->writesize;
3481534c:	e5963014 	ldr	r3, [r6, #20]
34815350:	e1cd01d8 	ldrd	r0, [sp, #24]
34815354:	e0900003 	adds	r0, r0, r3
34815358:	e2a11000 	adc	r1, r1, #0
3481535c:	e1cd01f8 	strd	r0, [sp, #24]
		buf += thislen;
34815360:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		column = 0;
34815364:	e3a09000 	mov	r9, #0
		written += thislen;
		if (written == len)
			break;

		to += mtd->writesize;
		buf += thislen;
34815368:	e0811005 	add	r1, r1, r5
3481536c:	e58d1028 	str	r1, [sp, #40]	; 0x28

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
34815370:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34815374:	e1540002 	cmp	r4, r2
34815378:	3affff9a 	bcc	348151e8 <onenand_write_oob_nolock+0x14c>
3481537c:	e3a09000 	mov	r9, #0
		to += mtd->writesize;
		buf += thislen;
		column = 0;
	}

	ops->oobretlen = written;
34815380:	e58b4010 	str	r4, [fp, #16]

	return ret;
}
34815384:	e1a00009 	mov	r0, r9
34815388:	e28dd038 	add	sp, sp, #56	; 0x38
3481538c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815390:	348275a4 	.word	0x348275a4
34815394:	348275e4 	.word	0x348275e4
34815398:	34827621 	.word	0x34827621
3481539c:	00010020 	.word	0x00010020
348153a0:	34827662 	.word	0x34827662

348153a4 <onenand_write_ops_nolock>:
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
348153a4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348153a8:	e24dd038 	sub	sp, sp, #56	; 0x38
348153ac:	e59d6058 	ldr	r6, [sp, #88]	; 0x58
348153b0:	e1cd21f0 	strd	r2, [sp, #16]
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
	const u_char *oob = ops->oobbuf;
348153b4:	e596301c 	ldr	r3, [r6, #28]
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
348153b8:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
348153bc:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
348153c0:	e596100c 	ldr	r1, [r6, #12]
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
348153c4:	e5960004 	ldr	r0, [r6, #4]
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
348153c8:	e5962018 	ldr	r2, [r6, #24]
	const u_char *oob = ops->oobbuf;
348153cc:	e58d301c 	str	r3, [sp, #28]
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
348153d0:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
348153d4:	e58d1034 	str	r1, [sp, #52]	; 0x34
	const u_char *buf = ops->datbuf;
348153d8:	e58d2028 	str	r2, [sp, #40]	; 0x28
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
348153dc:	e5863008 	str	r3, [r6, #8]
	ops->oobretlen = 0;
348153e0:	e5863010 	str	r3, [r6, #16]

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
348153e4:	e594100c 	ldr	r1, [r4, #12]
348153e8:	e1cd21d0 	ldrd	r2, [sp, #16]
348153ec:	e0922000 	adds	r2, r2, r0
348153f0:	e2a33000 	adc	r3, r3, #0
348153f4:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
348153f8:	e58d0020 	str	r0, [sp, #32]
	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
	ops->oobretlen = 0;

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
348153fc:	3a000003 	bcc	34815410 <onenand_write_ops_nolock+0x6c>
34815400:	1a000004 	bne	34815418 <onenand_write_ops_nolock+0x74>
34815404:	e5941008 	ldr	r1, [r4, #8]
34815408:	e1510002 	cmp	r1, r2
3481540c:	2a000001 	bcs	34815418 <onenand_write_ops_nolock+0x74>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt write to past end of device\n");
34815410:	e59f02c0 	ldr	r0, [pc, #704]	; 348156d8 <onenand_write_ops_nolock+0x334>
34815414:	ea00000a 	b	34815444 <onenand_write_ops_nolock+0xa0>
		return -EINVAL;
	}

	/* Reject writes, which are not page aligned */
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
34815418:	e5951098 	ldr	r1, [r5, #152]	; 0x98
3481541c:	e1cd21d0 	ldrd	r2, [sp, #16]
34815420:	e2411001 	sub	r1, r1, #1
34815424:	e0022001 	and	r2, r2, r1
34815428:	e0033fc1 	and	r3, r3, r1, asr #31
3481542c:	e1920003 	orrs	r0, r2, r3
34815430:	1a000002 	bne	34815440 <onenand_write_ops_nolock+0x9c>
34815434:	e59d2020 	ldr	r2, [sp, #32]
34815438:	e1110002 	tst	r1, r2
3481543c:	0a000003 	beq	34815450 <onenand_write_ops_nolock+0xac>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
34815440:	e59f0294 	ldr	r0, [pc, #660]	; 348156dc <onenand_write_ops_nolock+0x338>
34815444:	ebffd19f 	bl	34809ac8 <printf>
		return -EINVAL;
34815448:	e3e07015 	mvn	r7, #21
3481544c:	ea00009e 	b	348156cc <onenand_write_ops_nolock+0x328>
	}

	if (ops->mode == MTD_OOB_AUTO)
34815450:	e5963000 	ldr	r3, [r6]
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34815454:	e5942018 	ldr	r2, [r4, #24]
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
34815458:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
3481545c:	0595309c 	ldreq	r3, [r5, #156]	; 0x9c
	else
		oobsize = mtd->oobsize;
34815460:	15943018 	ldrne	r3, [r4, #24]
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815464:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);
34815468:	e5947014 	ldr	r7, [r4, #20]
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
3481546c:	e58d302c 	str	r3, [sp, #44]	; 0x2c

	oobcolumn = to & (mtd->oobsize - 1);
34815470:	e59d3010 	ldr	r3, [sp, #16]
34815474:	e2422001 	sub	r2, r2, #1
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34815478:	e3a00000 	mov	r0, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
3481547c:	e0032002 	and	r2, r3, r2

	column = to & (mtd->writesize - 1);
34815480:	e2477001 	sub	r7, r7, #1
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34815484:	e58d2024 	str	r2, [sp, #36]	; 0x24

	column = to & (mtd->writesize - 1);
34815488:	e0037007 	and	r7, r3, r7
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
3481548c:	e58d0018 	str	r0, [sp, #24]
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
34815490:	e1a0b000 	mov	fp, r0
34815494:	e1a09006 	mov	r9, r6
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
34815498:	ea000083 	b	348156ac <onenand_write_ops_nolock+0x308>
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
3481549c:	e59d1020 	ldr	r1, [sp, #32]
348154a0:	e594a014 	ldr	sl, [r4, #20]
348154a4:	e06b3001 	rsb	r3, fp, r1
348154a8:	e067a00a 	rsb	sl, r7, sl
348154ac:	e153000a 	cmp	r3, sl
348154b0:	b1a0a003 	movlt	sl, r3
348154b4:	a1a0a00a 	movge	sl, sl
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
348154b8:	e58da000 	str	sl, [sp]
348154bc:	e1cd21d0 	ldrd	r2, [sp, #16]
348154c0:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348154c4:	e1a00004 	mov	r0, r4
348154c8:	e3011978 	movw	r1, #6520	; 0x1978
348154cc:	e12fff3c 	blx	ip

		/* Partial page write */
		subpage = thislen < mtd->writesize;
348154d0:	e5942014 	ldr	r2, [r4, #20]
348154d4:	e15a0002 	cmp	sl, r2
348154d8:	23a03000 	movcs	r3, #0
348154dc:	33a03001 	movcc	r3, #1
		if (subpage) {
348154e0:	e3530000 	cmp	r3, #0
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
348154e4:	e58d3030 	str	r3, [sp, #48]	; 0x30

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;
348154e8:	059d3028 	ldreq	r3, [sp, #40]	; 0x28

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
		if (subpage) {
348154ec:	0a000008 	beq	34815514 <onenand_write_ops_nolock+0x170>
			memset(this->page_buf, 0xff, mtd->writesize);
348154f0:	e3a010ff 	mov	r1, #255	; 0xff
348154f4:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
348154f8:	eb001c46 	bl	3481c618 <memset>
			memcpy(this->page_buf + column, buf, thislen);
348154fc:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
34815500:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34815504:	e0800007 	add	r0, r0, r7
34815508:	e1a0200a 	mov	r2, sl
3481550c:	eb001c65 	bl	3481c6a8 <memcpy>
			wbuf = this->page_buf;
34815510:	e595308c 	ldr	r3, [r5, #140]	; 0x8c
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
34815514:	e58d3004 	str	r3, [sp, #4]
34815518:	e5943014 	ldr	r3, [r4, #20]
3481551c:	e3a00b01 	mov	r0, #1024	; 0x400
34815520:	e3a01000 	mov	r1, #0
34815524:	e58d0000 	str	r0, [sp]
34815528:	e58d300c 	str	r3, [sp, #12]
3481552c:	e58d1008 	str	r1, [sp, #8]
34815530:	e1cd21d0 	ldrd	r2, [sp, #16]
34815534:	e5951064 	ldr	r1, [r5, #100]	; 0x64
34815538:	e1a00004 	mov	r0, r4
3481553c:	e12fff31 	blx	r1

		if (oob) {
34815540:	e59d201c 	ldr	r2, [sp, #28]
34815544:	e3520000 	cmp	r2, #0

			oobwritten += thisooblen;
			oob += thisooblen;
			oobcolumn = 0;
		} else
			oobbuf = (u_char *) ffchars;
34815548:	059f6190 	ldreq	r6, [pc, #400]	; 348156e0 <onenand_write_ops_nolock+0x33c>
			wbuf = this->page_buf;
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
3481554c:	0a000023 	beq	348155e0 <onenand_write_ops_nolock+0x23c>
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34815550:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
34815554:	e59d0018 	ldr	r0, [sp, #24]
34815558:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481555c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
			oobbuf = this->oob_buf;
34815560:	e5956090 	ldr	r6, [r5, #144]	; 0x90
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34815564:	e0607003 	rsb	r7, r0, r3
34815568:	e0623001 	rsb	r3, r2, r1
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
3481556c:	e1a00006 	mov	r0, r6
34815570:	e3a010ff 	mov	r1, #255	; 0xff
34815574:	e5942018 	ldr	r2, [r4, #24]
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34815578:	e1570003 	cmp	r7, r3
3481557c:	a1a07003 	movge	r7, r3
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
34815580:	eb001c24 	bl	3481c618 <memset>
			if (ops->mode == MTD_OOB_AUTO)
34815584:	e5993000 	ldr	r3, [r9]
34815588:	e3530001 	cmp	r3, #1
3481558c:	1a000006 	bne	348155ac <onenand_write_ops_nolock+0x208>
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
34815590:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34815594:	e1a01006 	mov	r1, r6
34815598:	e59d201c 	ldr	r2, [sp, #28]
3481559c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
348155a0:	e58d7000 	str	r7, [sp]
348155a4:	ebfffe7b 	bl	34814f98 <onenand_fill_auto_oob.clone.7>
348155a8:	ea000004 	b	348155c0 <onenand_write_ops_nolock+0x21c>
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);
348155ac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
348155b0:	e59d101c 	ldr	r1, [sp, #28]
348155b4:	e0860003 	add	r0, r6, r3
348155b8:	e1a02007 	mov	r2, r7
348155bc:	eb001c39 	bl	3481c6a8 <memcpy>

			oobwritten += thisooblen;
348155c0:	e59d0018 	ldr	r0, [sp, #24]
			oob += thisooblen;
348155c4:	e59d101c 	ldr	r1, [sp, #28]
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
348155c8:	e0800007 	add	r0, r0, r7
			oob += thisooblen;
348155cc:	e0811007 	add	r1, r1, r7
			oobcolumn = 0;
348155d0:	e3a02000 	mov	r2, #0
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
348155d4:	e58d0018 	str	r0, [sp, #24]
			oob += thisooblen;
348155d8:	e58d101c 	str	r1, [sp, #28]
			oobcolumn = 0;
348155dc:	e58d2024 	str	r2, [sp, #36]	; 0x24
		} else
			oobbuf = (u_char *) ffchars;

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
348155e0:	e59f30fc 	ldr	r3, [pc, #252]	; 348156e4 <onenand_write_ops_nolock+0x340>
348155e4:	e3a00000 	mov	r0, #0
348155e8:	e58d3000 	str	r3, [sp]
348155ec:	e5943018 	ldr	r3, [r4, #24]
348155f0:	e58d0008 	str	r0, [sp, #8]
348155f4:	e58d300c 	str	r3, [sp, #12]
348155f8:	e58d6004 	str	r6, [sp, #4]
348155fc:	e5951064 	ldr	r1, [r5, #100]	; 0x64
34815600:	e3a02000 	mov	r2, #0
34815604:	e3a03000 	mov	r3, #0
34815608:	e1a00004 	mov	r0, r4
3481560c:	e12fff31 	blx	r1

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
34815610:	e5943014 	ldr	r3, [r4, #20]
34815614:	e3a01080 	mov	r1, #128	; 0x80
34815618:	e58d3000 	str	r3, [sp]
3481561c:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34815620:	e1cd21d0 	ldrd	r2, [sp, #16]
34815624:	e1a00004 	mov	r0, r4
34815628:	e12fff3c 	blx	ip

		ret = this->wait(mtd, FL_WRITING);
3481562c:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34815630:	e3a01002 	mov	r1, #2
34815634:	e1a00004 	mov	r0, r4
34815638:	e12fff33 	blx	r3

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
3481563c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);

		ret = this->wait(mtd, FL_WRITING);
34815640:	e1a07000 	mov	r7, r0

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34815644:	e1901001 	orrs	r1, r0, r1
34815648:	13a03000 	movne	r3, #0
3481564c:	03a03001 	moveq	r3, #1
34815650:	e58d3000 	str	r3, [sp]
34815654:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34815658:	e1cd21d0 	ldrd	r2, [sp, #16]
3481565c:	ebfffe38 	bl	34814f44 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);
		}

		if (ret) {
34815660:	e3570000 	cmp	r7, #0
34815664:	0a000004 	beq	3481567c <onenand_write_ops_nolock+0x2d8>
			printk(KERN_ERR "onenand_write_ops_nolock: write filaed %d\n", ret);
34815668:	e1a01007 	mov	r1, r7
3481566c:	e59f0074 	ldr	r0, [pc, #116]	; 348156e8 <onenand_write_ops_nolock+0x344>
34815670:	e1a06009 	mov	r6, r9
34815674:	ebffd113 	bl	34809ac8 <printf>
			break;
34815678:	ea000012 	b	348156c8 <onenand_write_ops_nolock+0x324>
			break;
		}

		written += thislen;

		if (written == len)
3481567c:	e59d2020 	ldr	r2, [sp, #32]
		if (ret) {
			printk(KERN_ERR "onenand_write_ops_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34815680:	e08bb00a 	add	fp, fp, sl

		if (written == len)
34815684:	e15b0002 	cmp	fp, r2
34815688:	0a00000d 	beq	348156c4 <onenand_write_ops_nolock+0x320>
			break;

		column = 0;
		to += thislen;
3481568c:	e1cd01d0 	ldrd	r0, [sp, #16]
34815690:	e090000a 	adds	r0, r0, sl
34815694:	e0a11fca 	adc	r1, r1, sl, asr #31
34815698:	e1cd01f0 	strd	r0, [sp, #16]
		buf += thislen;
3481569c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		written += thislen;

		if (written == len)
			break;

		column = 0;
348156a0:	e3a07000 	mov	r7, #0
		to += thislen;
		buf += thislen;
348156a4:	e081100a 	add	r1, r1, sl
348156a8:	e58d1028 	str	r1, [sp, #40]	; 0x28
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
348156ac:	e59d2020 	ldr	r2, [sp, #32]
348156b0:	e15b0002 	cmp	fp, r2
348156b4:	3affff78 	bcc	3481549c <onenand_write_ops_nolock+0xf8>
348156b8:	e1a06009 	mov	r6, r9
348156bc:	e3a07000 	mov	r7, #0
348156c0:	ea000000 	b	348156c8 <onenand_write_ops_nolock+0x324>
348156c4:	e1a06009 	mov	r6, r9
		column = 0;
		to += thislen;
		buf += thislen;
	}

	ops->retlen = written;
348156c8:	e586b008 	str	fp, [r6, #8]

	return ret;
}
348156cc:	e1a00007 	mov	r0, r7
348156d0:	e28dd038 	add	sp, sp, #56	; 0x38
348156d4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348156d8:	3482768d 	.word	0x3482768d
348156dc:	348276cc 	.word	0x348276cc
348156e0:	348214c0 	.word	0x348214c0
348156e4:	00010020 	.word	0x00010020
348156e8:	3482770e 	.word	0x3482770e

348156ec <onenand_write_oob>:
 *
 * OneNAND write main and/or out-of-band
 */
int onenand_write_oob(struct mtd_info *mtd, loff_t to,
			struct mtd_oob_ops *ops)
{
348156ec:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
348156f0:	e591c000 	ldr	ip, [r1]
348156f4:	e35c0001 	cmp	ip, #1
348156f8:	8a000005 	bhi	34815714 <onenand_write_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_WRITING);
	if (ops->datbuf)
348156fc:	e591c018 	ldr	ip, [r1, #24]
34815700:	e35c0000 	cmp	ip, #0
34815704:	0a000000 	beq	3481570c <onenand_write_oob+0x20>
		ret = onenand_write_ops_nolock(mtd, to, ops);
34815708:	eaffff25 	b	348153a4 <onenand_write_ops_nolock>
	else
		ret = onenand_write_oob_nolock(mtd, to, ops);
3481570c:	e58d1000 	str	r1, [sp]
34815710:	eafffe61 	b	3481509c <onenand_write_oob_nolock>
	onenand_release_device(mtd);

	return ret;

}
34815714:	e3e00015 	mvn	r0, #21
34815718:	e12fff1e 	bx	lr

3481571c <onenand_write>:
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
3481571c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34815720:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34815724:	e28d7008 	add	r7, sp, #8
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34815728:	e1a06000 	mov	r6, r0
3481572c:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
34815730:	e3a01000 	mov	r1, #0
34815734:	e1a00007 	mov	r0, r7
34815738:	e3a02020 	mov	r2, #32
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
3481573c:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
34815740:	eb001bb4 	bl	3481c618 <memset>
34815744:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815748:	e1a02004 	mov	r2, r4
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
3481574c:	e58d300c 	str	r3, [sp, #12]
34815750:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815754:	e1a00006 	mov	r0, r6
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
34815758:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
3481575c:	e1a03005 	mov	r3, r5
34815760:	e58d7000 	str	r7, [sp]
34815764:	ebffff0e 	bl	348153a4 <onenand_write_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
34815768:	e59d2010 	ldr	r2, [sp, #16]
3481576c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34815770:	e5832000 	str	r2, [r3]
	return ret;
}
34815774:	e28dd02c 	add	sp, sp, #44	; 0x2c
34815778:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3481577c <onenand_block>:
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
3481577c:	e92d4070 	push	{r4, r5, r6, lr}
34815780:	e1a04000 	mov	r4, r0
	if (!FLEXONENAND(this))
34815784:	e594501c 	ldr	r5, [r4, #28]
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815788:	e1a00002 	mov	r0, r2
	if (!FLEXONENAND(this))
3481578c:	e3150c02 	tst	r5, #512	; 0x200
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815790:	e1a01003 	mov	r1, r3
	if (!FLEXONENAND(this))
34815794:	1a000002 	bne	348157a4 <onenand_block+0x28>
		return addr >> this->erase_shift;
34815798:	e5942030 	ldr	r2, [r4, #48]	; 0x30
3481579c:	eb002a23 	bl	34820030 <__ashrdi3>
348157a0:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
348157a4:	e2155008 	ands	r5, r5, #8
348157a8:	0a00000b 	beq	348157dc <onenand_block+0x60>
348157ac:	e5942010 	ldr	r2, [r4, #16]
348157b0:	e3a03000 	mov	r3, #0
348157b4:	e1530001 	cmp	r3, r1
348157b8:	ca000006 	bgt	348157d8 <onenand_block+0x5c>
348157bc:	1a000001 	bne	348157c8 <onenand_block+0x4c>
348157c0:	e1520000 	cmp	r2, r0
348157c4:	8a000003 	bhi	348157d8 <onenand_block+0x5c>
		die = 1;
		addr -= this->diesize[0];
348157c8:	e0500002 	subs	r0, r0, r2
348157cc:	e0c11003 	sbc	r1, r1, r3
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
348157d0:	e3a05001 	mov	r5, #1
348157d4:	ea000000 	b	348157dc <onenand_block+0x60>
 * @param this		- OneNAND device structure
 * @param addr		- Address for which block number is needed
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;
348157d8:	e3a05000 	mov	r5, #0
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];

	blk = addr >> (this->erase_shift - 1);
348157dc:	e5942030 	ldr	r2, [r4, #48]	; 0x30
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
348157e0:	e2853002 	add	r3, r5, #2

	blk = addr >> (this->erase_shift - 1);
348157e4:	e2422001 	sub	r2, r2, #1
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
348157e8:	e7946103 	ldr	r6, [r4, r3, lsl #2]

	blk = addr >> (this->erase_shift - 1);
348157ec:	eb002a0f 	bl	34820030 <__ashrdi3>
	if (blk > boundary)
348157f0:	e1500006 	cmp	r0, r6
		blk = (blk + boundary + 1) >> 1;
348157f4:	82866001 	addhi	r6, r6, #1
348157f8:	80860000 	addhi	r0, r6, r0
348157fc:	81a000a0 	lsrhi	r0, r0, #1

	blk += die ? this->density_mask : 0;
34815800:	e3550000 	cmp	r5, #0
34815804:	15945028 	ldrne	r5, [r4, #40]	; 0x28
34815808:	e0850000 	add	r0, r5, r0
unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
	if (!FLEXONENAND(this))
		return addr >> this->erase_shift;
	return flexonenand_block(this, addr);
}
3481580c:	e8bd8070 	pop	{r4, r5, r6, pc}

34815810 <onenand_default_block_markbad>:
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815810:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34815814:	e590a094 	ldr	sl, [r0, #148]	; 0x94
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815818:	e24dd030 	sub	sp, sp, #48	; 0x30
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
3481581c:	e3a01000 	mov	r1, #0
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815820:	e1a06002 	mov	r6, r2
34815824:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
	struct mtd_oob_ops ops = {
34815828:	e3a02020 	mov	r2, #32
3481582c:	e28d000c 	add	r0, sp, #12
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815830:	e1a07003 	mov	r7, r3
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34815834:	e59a50a0 	ldr	r5, [sl, #160]	; 0xa0
	u_char buf[2] = {0, 0};
34815838:	e5cd102c 	strb	r1, [sp, #44]	; 0x2c
3481583c:	e5cd102d 	strb	r1, [sp, #45]	; 0x2d
	struct mtd_oob_ops ops = {
34815840:	eb001b74 	bl	3481c618 <memset>
34815844:	e3a03002 	mov	r3, #2
34815848:	e58d3018 	str	r3, [sp, #24]
3481584c:	e28d302c 	add	r3, sp, #44	; 0x2c
34815850:	e58d3028 	str	r3, [sp, #40]	; 0x28
		.ooboffs = 0,
	};
	int block;

	/* Get block number */
	block = onenand_block(this, ofs);
34815854:	e1a0000a 	mov	r0, sl
34815858:	e1a03007 	mov	r3, r7
3481585c:	e1a02006 	mov	r2, r6
34815860:	ebffffc5 	bl	3481577c <onenand_block>
	if (bbm->bbt)
34815864:	e595300c 	ldr	r3, [r5, #12]
34815868:	e3530000 	cmp	r3, #0
3481586c:	0a000005 	beq	34815888 <onenand_default_block_markbad+0x78>
		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
34815870:	e7d31140 	ldrb	r1, [r3, r0, asr #2]
34815874:	e2002003 	and	r2, r0, #3
34815878:	e1a02082 	lsl	r2, r2, #1
3481587c:	e3a0c001 	mov	ip, #1
34815880:	e181221c 	orr	r2, r1, ip, lsl r2
34815884:	e7c32140 	strb	r2, [r3, r0, asr #2]

	/* We write two bytes, so we dont have to mess with 16 bit access */
	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
34815888:	e5952004 	ldr	r2, [r5, #4]
3481588c:	e5943018 	ldr	r3, [r4, #24]
34815890:	e3c22001 	bic	r2, r2, #1
34815894:	e0822003 	add	r2, r2, r3
	return onenand_write_oob_nolock(mtd, ofs, &ops);
34815898:	e1a00004 	mov	r0, r4
3481589c:	e0964002 	adds	r4, r6, r2
348158a0:	e28d300c 	add	r3, sp, #12
348158a4:	e2a75000 	adc	r5, r7, #0
348158a8:	e58d3000 	str	r3, [sp]
348158ac:	e1a02004 	mov	r2, r4
348158b0:	e1a03005 	mov	r3, r5
348158b4:	ebfffdf8 	bl	3481509c <onenand_write_oob_nolock>
}
348158b8:	e28dd030 	add	sp, sp, #48	; 0x30
348158bc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

348158c0 <onenand_addr>:
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
348158c0:	e590201c 	ldr	r2, [r0, #28]
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
348158c4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	if (!FLEXONENAND(this))
348158c8:	e3120c02 	tst	r2, #512	; 0x200
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
348158cc:	e1a03000 	mov	r3, r0
348158d0:	e1a06001 	mov	r6, r1
	if (!FLEXONENAND(this))
348158d4:	1a000006 	bne	348158f4 <onenand_addr+0x34>
		return (loff_t) block << this->erase_shift;
348158d8:	e1a00001 	mov	r0, r1
348158dc:	e1a01fc0 	asr	r1, r0, #31
348158e0:	e5932030 	ldr	r2, [r3, #48]	; 0x30
348158e4:	eb0029d8 	bl	3482004c <__ashldi3>
348158e8:	e1a04000 	mov	r4, r0
348158ec:	e1a05001 	mov	r5, r1
348158f0:	ea000020 	b	34815978 <onenand_addr+0xb8>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
348158f4:	e2122008 	ands	r2, r2, #8
348158f8:	0a000007 	beq	3481591c <onenand_addr+0x5c>
348158fc:	e5902028 	ldr	r2, [r0, #40]	; 0x28
34815900:	e1510002 	cmp	r1, r2
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
34815904:	33a02000 	movcc	r2, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
34815908:	25904010 	ldrcs	r4, [r0, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
3481590c:	20626001 	rsbcs	r6, r2, r1
		die = 1;
		ofs = this->diesize[0];
34815910:	23a05000 	movcs	r5, #0
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
34815914:	23a02001 	movcs	r2, #1
34815918:	2a000001 	bcs	34815924 <onenand_addr+0x64>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
3481591c:	e3a04000 	mov	r4, #0
34815920:	e3a05000 	mov	r5, #0
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
34815924:	e5937030 	ldr	r7, [r3, #48]	; 0x30
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34815928:	e2822002 	add	r2, r2, #2
	ofs += (loff_t) block << (this->erase_shift - 1);
3481592c:	e2477001 	sub	r7, r7, #1
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34815930:	e793a102 	ldr	sl, [r3, r2, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
34815934:	e1a00006 	mov	r0, r6
34815938:	e1a01fc0 	asr	r1, r0, #31
3481593c:	e1a02007 	mov	r2, r7
34815940:	eb0029c1 	bl	3482004c <__ashldi3>
	if (block > (boundary + 1))
34815944:	e28a3001 	add	r3, sl, #1
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
34815948:	e0944000 	adds	r4, r4, r0
3481594c:	e0a55001 	adc	r5, r5, r1
	if (block > (boundary + 1))
34815950:	e1560003 	cmp	r6, r3
34815954:	da000007 	ble	34815978 <onenand_addr+0xb8>
		ofs += (loff_t) (block - boundary - 1)
34815958:	e2466001 	sub	r6, r6, #1
3481595c:	e06aa006 	rsb	sl, sl, r6
			<< (this->erase_shift - 1);
34815960:	e1a0000a 	mov	r0, sl
34815964:	e1a01fc0 	asr	r1, r0, #31
34815968:	e1a02007 	mov	r2, r7
3481596c:	eb0029b6 	bl	3482004c <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
34815970:	e0944000 	adds	r4, r4, r0
34815974:	e0a55001 	adc	r5, r5, r1
loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
		return (loff_t) block << this->erase_shift;
	return flexonenand_addr(this, block);
}
34815978:	e1a00004 	mov	r0, r4
3481597c:	e1a01005 	mov	r1, r5
34815980:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34815984 <onenand_command>:

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815984:	e351002c 	cmp	r1, #44	; 0x2c
 * Send command to OneNAND device. This function is used for middle/large page
 * devices (1KB/2KB Bytes per page)
 */
static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
			   size_t len)
{
34815988:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481598c:	e1a05001 	mov	r5, r1
34815990:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
34815994:	e5904094 	ldr	r4, [r0, #148]	; 0x94

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815998:	0a000079 	beq	34815b84 <onenand_command+0x200>
3481599c:	ca000006 	bgt	348159bc <onenand_command+0x38>
348159a0:	e3510027 	cmp	r1, #39	; 0x27
348159a4:	0a000076 	beq	34815b84 <onenand_command+0x200>
348159a8:	e351002a 	cmp	r1, #42	; 0x2a
348159ac:	0a000074 	beq	34815b84 <onenand_command+0x200>
348159b0:	e3510023 	cmp	r1, #35	; 0x23
348159b4:	1a00001c 	bne	34815a2c <onenand_command+0xa8>
348159b8:	ea000071 	b	34815b84 <onenand_command+0x200>
348159bc:	e3510094 	cmp	r1, #148	; 0x94
348159c0:	0a00000e 	beq	34815a00 <onenand_command+0x7c>
348159c4:	ca000002 	bgt	348159d4 <onenand_command+0x50>
348159c8:	e3510066 	cmp	r1, #102	; 0x66
348159cc:	1a000016 	bne	34815a2c <onenand_command+0xa8>
348159d0:	ea000006 	b	348159f0 <onenand_command+0x6c>
348159d4:	e3012978 	movw	r2, #6520	; 0x1978
348159d8:	e1510002 	cmp	r1, r2
348159dc:	0a000007 	beq	34815a00 <onenand_command+0x7c>
348159e0:	e282200d 	add	r2, r2, #13
348159e4:	e1510002 	cmp	r1, r2
348159e8:	1a00000f 	bne	34815a2c <onenand_command+0xa8>
348159ec:	ea000009 	b	34815a18 <onenand_command+0x94>
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
348159f0:	e5947028 	ldr	r7, [r4, #40]	; 0x28
		page = -1;
348159f4:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
348159f8:	e0070792 	mul	r7, r2, r7
		page = -1;
		break;
348159fc:	ea000029 	b	34815aa8 <onenand_command+0x124>

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
34815a00:	e1a02006 	mov	r2, r6
34815a04:	e1a00004 	mov	r0, r4
34815a08:	ebffff5b 	bl	3481577c <onenand_block>
		page = -1;
34815a0c:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
34815a10:	e1a07000 	mov	r7, r0
		page = -1;
		break;
34815a14:	ea00000f 	b	34815a58 <onenand_command+0xd4>

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
		block = addr * this->density_mask;
34815a18:	e5947028 	ldr	r7, [r4, #40]	; 0x28
34815a1c:	e0070796 	mul	r7, r6, r7
		page = 0;
34815a20:	e3a06000 	mov	r6, #0
		block = onenand_block(this, addr);
		page = -1;
		break;

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
34815a24:	e1a05006 	mov	r5, r6
		block = addr * this->density_mask;
		page = 0;
		break;
34815a28:	ea00001e 	b	34815aa8 <onenand_command+0x124>

	default:
		block = onenand_block(this, addr);
34815a2c:	e1a02006 	mov	r2, r6
34815a30:	e1a00004 	mov	r0, r4
34815a34:	ebffff50 	bl	3481577c <onenand_block>
34815a38:	e1a07000 	mov	r7, r0
		page = (int) (addr
			- onenand_addr(this, block)) >> this->page_shift;
34815a3c:	e1a01007 	mov	r1, r7
34815a40:	e1a00004 	mov	r0, r4
34815a44:	ebffff9d 	bl	348158c0 <onenand_addr>
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
34815a48:	e5942034 	ldr	r2, [r4, #52]	; 0x34
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
34815a4c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
34815a50:	e0606006 	rsb	r6, r0, r6
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
34815a54:	e0036256 	and	r6, r3, r6, asr r2
		break;
	}

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
34815a58:	e3013978 	movw	r3, #6520	; 0x1978
34815a5c:	e1550003 	cmp	r5, r3
34815a60:	1a000010 	bne	34815aa8 <onenand_command+0x124>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815a64:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815a68:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815a6c:	e0177003 	ands	r7, r7, r3

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815a70:	e59f1144 	ldr	r1, [pc, #324]	; 34815bbc <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815a74:	01a00007 	moveq	r0, r7
34815a78:	13a00902 	movne	r0, #32768	; 0x8000

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815a7c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815a80:	e6ff0070 	uxth	r0, r0
34815a84:	e0821001 	add	r1, r2, r1
34815a88:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
34815a8c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34815a90:	e3130008 	tst	r3, #8
			ONENAND_SET_BUFFERRAM0(this);
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815a94:	05943044 	ldreq	r3, [r4, #68]	; 0x44
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_BUFFERRAM0(this);
34815a98:	13a03000 	movne	r3, #0
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815a9c:	02233001 	eoreq	r3, r3, #1
34815aa0:	e5843044 	str	r3, [r4, #68]	; 0x44
34815aa4:	ea000042 	b	34815bb4 <onenand_command+0x230>

		return 0;
	}

	if (block != -1) {
34815aa8:	e3770001 	cmn	r7, #1
34815aac:	0a000014 	beq	34815b04 <onenand_command+0x180>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34815ab0:	e5940028 	ldr	r0, [r4, #40]	; 0x28
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815ab4:	e5941000 	ldr	r1, [r4]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815ab8:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34815abc:	10270000 	eorne	r0, r7, r0
34815ac0:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815ac4:	01a00007 	moveq	r0, r7
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815ac8:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34815acc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815ad0:	e6ff0070 	uxth	r0, r0
34815ad4:	e2811c02 	add	r1, r1, #512	; 0x200
34815ad8:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815adc:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815ae0:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815ae4:	e0177003 	ands	r7, r7, r3
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815ae8:	e59f10cc 	ldr	r1, [pc, #204]	; 34815bbc <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815aec:	01a00007 	moveq	r0, r7
34815af0:	13a00902 	movne	r0, #32768	; 0x8000
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815af4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815af8:	e6ff0070 	uxth	r0, r0
34815afc:	e0821001 	add	r1, r2, r1
34815b00:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);
	}

	if (page != -1) {
34815b04:	e3760001 	cmn	r6, #1
34815b08:	0a00001d 	beq	34815b84 <onenand_command+0x200>
		int dataram;

		switch (cmd) {
34815b0c:	e3550013 	cmp	r5, #19
34815b10:	8a00000c 	bhi	34815b48 <onenand_command+0x1c4>
34815b14:	e3a02001 	mov	r2, #1
34815b18:	e1a02512 	lsl	r2, r2, r5
34815b1c:	e59f309c 	ldr	r3, [pc, #156]	; 34815bc0 <onenand_command+0x23c>
34815b20:	e0023003 	and	r3, r2, r3
34815b24:	e3530000 	cmp	r3, #0
34815b28:	0a000006 	beq	34815b48 <onenand_command+0x1c4>
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
34815b2c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34815b30:	e3130008 	tst	r3, #8
				dataram = ONENAND_SET_BUFFERRAM0(this);
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
34815b34:	05947044 	ldreq	r7, [r4, #68]	; 0x44
		switch (cmd) {
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
				dataram = ONENAND_SET_BUFFERRAM0(this);
34815b38:	13a07000 	movne	r7, #0
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
34815b3c:	02277001 	eoreq	r7, r7, #1
34815b40:	e5847044 	str	r7, [r4, #68]	; 0x44
34815b44:	ea000000 	b	34815b4c <onenand_command+0x1c8>

			break;

		default:
			dataram = ONENAND_CURRENT_BUFFERRAM(this);
34815b48:	e5947044 	ldr	r7, [r4, #68]	; 0x44
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
34815b4c:	e5942000 	ldr	r2, [r4]
34815b50:	e59f106c 	ldr	r1, [pc, #108]	; 34815bc4 <onenand_command+0x240>
static int onenand_page_address(int page, int sector)
{
	/* Flash Page Address, Flash Sector Address */
	int fpa, fsa;

	fpa = page & ONENAND_FPA_MASK;
34815b54:	e206607f 	and	r6, r6, #127	; 0x7f
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
34815b58:	e1a00106 	lsl	r0, r6, #2
34815b5c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815b60:	e0821001 	add	r1, r2, r1
34815b64:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS8);

		/* Write 'BSA, BSC' of DataRAM */
		value = onenand_buffer_address(dataram, sectors, count);
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
34815b68:	e5941000 	ldr	r1, [r4]
34815b6c:	e3570000 	cmp	r7, #0
34815b70:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815b74:	13a00b03 	movne	r0, #3072	; 0xc00
34815b78:	03a00b02 	moveq	r0, #2048	; 0x800
34815b7c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815b80:	e12fff33 	blx	r3
	}

	/* Interrupt clear */
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
34815b84:	e5941000 	ldr	r1, [r4]
34815b88:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815b8c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815b90:	e3a00000 	mov	r0, #0
34815b94:	e2811082 	add	r1, r1, #130	; 0x82
34815b98:	e12fff33 	blx	r3
	/* Write command */
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
34815b9c:	e5941000 	ldr	r1, [r4]
34815ba0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815ba4:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815ba8:	e6ff0075 	uxth	r0, r5
34815bac:	e2811040 	add	r1, r1, #64	; 0x40
34815bb0:	e12fff33 	blx	r3

	return 0;
}
34815bb4:	e3a00000 	mov	r0, #0
34815bb8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34815bbc:	0001e202 	.word	0x0001e202
34815bc0:	00080021 	.word	0x00080021
34815bc4:	0001e20e 	.word	0x0001e20e

34815bc8 <flexonenand_region>:
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815bc8:	e3a0c000 	mov	ip, #0
 * flexonenand_region - [Flex-OneNAND] Return erase region of addr
 * @param mtd		MTD device structure
 * @param addr		address whose erase region needs to be identified
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
34815bcc:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815bd0:	e1a0100c 	mov	r1, ip
34815bd4:	e590502c 	ldr	r5, [r0, #44]	; 0x2c
34815bd8:	ea000009 	b	34815c04 <flexonenand_region+0x3c>
		if (addr < mtd->eraseregions[i].offset)
34815bdc:	e5904030 	ldr	r4, [r0, #48]	; 0x30
34815be0:	e7b4600c 	ldr	r6, [r4, ip]!
34815be4:	e28cc018 	add	ip, ip, #24
34815be8:	e5944004 	ldr	r4, [r4, #4]
34815bec:	e1540003 	cmp	r4, r3
34815bf0:	8a000005 	bhi	34815c0c <flexonenand_region+0x44>
34815bf4:	1a000001 	bne	34815c00 <flexonenand_region+0x38>
34815bf8:	e1560002 	cmp	r6, r2
34815bfc:	8a000002 	bhi	34815c0c <flexonenand_region+0x44>
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815c00:	e2811001 	add	r1, r1, #1
34815c04:	e1510005 	cmp	r1, r5
34815c08:	bafffff3 	blt	34815bdc <flexonenand_region+0x14>
		if (addr < mtd->eraseregions[i].offset)
			break;
	return i - 1;
}
34815c0c:	e2410001 	sub	r0, r1, #1
34815c10:	e8bd8070 	pop	{r4, r5, r6, pc}

34815c14 <onenand_recover_lsb>:
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815c14:	e92d4c73 	push	{r0, r1, r4, r5, r6, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34815c18:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815c1c:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815c20:	e594101c 	ldr	r1, [r4, #28]
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815c24:	e1a0a002 	mov	sl, r2
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815c28:	e3110c02 	tst	r1, #512	; 0x200
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815c2c:	e1a0b003 	mov	fp, r3
34815c30:	e59d6020 	ldr	r6, [sp, #32]
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815c34:	0a000019 	beq	34815ca0 <onenand_recover_lsb+0x8c>
		return status;

	/* check if we failed due to uncorrectable error */
	if (status != -EBADMSG && status != ONENAND_BBT_READ_ECC_ERROR)
34815c38:	e3560002 	cmp	r6, #2
34815c3c:	1376004a 	cmnne	r6, #74	; 0x4a
34815c40:	1a000016 	bne	34815ca0 <onenand_recover_lsb+0x8c>
		return status;

	/* check if address lies in MLC region */
	i = flexonenand_region(mtd, addr);
34815c44:	ebffffdf 	bl	34815bc8 <flexonenand_region>
	if (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))
34815c48:	e5953030 	ldr	r3, [r5, #48]	; 0x30
34815c4c:	e3a02018 	mov	r2, #24
34815c50:	e0233092 	mla	r3, r2, r0, r3
34815c54:	e5932008 	ldr	r2, [r3, #8]
34815c58:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34815c5c:	e1b03332 	lsrs	r3, r2, r3
34815c60:	0a00000e 	beq	34815ca0 <onenand_recover_lsb+0x8c>
		return status;

	printk("onenand_recover_lsb:"
34815c64:	e59f003c 	ldr	r0, [pc, #60]	; 34815ca8 <onenand_recover_lsb+0x94>
34815c68:	ebffcf96 	bl	34809ac8 <printf>
		"Attempting to recover from uncorrectable read\n");

	/* Issue the LSB page recovery command */
	this->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);
34815c6c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
34815c70:	e3a01005 	mov	r1, #5
34815c74:	e58d3000 	str	r3, [sp]
34815c78:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815c7c:	e1a0200a 	mov	r2, sl
34815c80:	e1a0300b 	mov	r3, fp
34815c84:	e1a00005 	mov	r0, r5
34815c88:	e12fff3c 	blx	ip
	return this->wait(mtd, FL_READING);
34815c8c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815c90:	e1a00005 	mov	r0, r5
34815c94:	e3a01001 	mov	r1, #1
34815c98:	e12fff33 	blx	r3
34815c9c:	e1a06000 	mov	r6, r0
}
34815ca0:	e1a00006 	mov	r0, r6
34815ca4:	e8bd8c7c 	pop	{r2, r3, r4, r5, r6, sl, fp, pc}
34815ca8:	34827739 	.word	0x34827739

34815cac <onenand_read_oob_nolock>:
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815cac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815cb0:	e24dd040 	sub	sp, sp, #64	; 0x40
34815cb4:	e59db060 	ldr	fp, [sp, #96]	; 0x60
	struct onenand_chip *this = mtd->priv;
34815cb8:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815cbc:	e59b1000 	ldr	r1, [fp]
	u_char *buf = ops->oobbuf;
34815cc0:	e59b401c 	ldr	r4, [fp, #28]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815cc4:	e58d1034 	str	r1, [sp, #52]	; 0x34
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;

	from += ops->ooboffs;
34815cc8:	e59b1014 	ldr	r1, [fp, #20]
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
34815ccc:	e58d4024 	str	r4, [sp, #36]	; 0x24
	int ret = 0, readcmd;

	from += ops->ooboffs;
34815cd0:	e0924001 	adds	r4, r2, r1
34815cd4:	e2a35000 	adc	r5, r3, #0
34815cd8:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815cdc:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815ce0:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815ce4:	e3550001 	cmp	r5, #1
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
34815ce8:	e3a03000 	mov	r3, #0
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
34815cec:	e59b000c 	ldr	r0, [fp, #12]
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
34815cf0:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
34815cf4:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815cf8:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
34815cfc:	e58d0030 	str	r0, [sp, #48]	; 0x30
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
34815d00:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815d04:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
34815d08:	1596a018 	ldrne	sl, [r6, #24]

	column = from & (mtd->oobsize - 1);
34815d0c:	e2499001 	sub	r9, r9, #1
34815d10:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
34815d14:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
34815d18:	a59f0220 	ldrge	r0, [pc, #544]	; 34815f40 <onenand_read_oob_nolock+0x294>
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
34815d1c:	aa000025 	bge	34815db8 <onenand_read_oob_nolock+0x10c>
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
		return -EINVAL;
	}

	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
34815d20:	e596100c 	ldr	r1, [r6, #12]
34815d24:	e59d201c 	ldr	r2, [sp, #28]
34815d28:	e5960008 	ldr	r0, [r6, #8]
34815d2c:	e1510002 	cmp	r1, r2
34815d30:	8a000003 	bhi	34815d44 <onenand_read_oob_nolock+0x98>
34815d34:	1a00001e 	bne	34815db4 <onenand_read_oob_nolock+0x108>
34815d38:	e59d3018 	ldr	r3, [sp, #24]
34815d3c:	e1500003 	cmp	r0, r3
34815d40:	9a00001b 	bls	34815db4 <onenand_read_oob_nolock+0x108>
34815d44:	e5973034 	ldr	r3, [r7, #52]	; 0x34
34815d48:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
34815d4c:	e1a02003 	mov	r2, r3
34815d50:	e089c004 	add	ip, r9, r4
34815d54:	e1a0400a 	mov	r4, sl
34815d58:	e1a05fc4 	asr	r5, r4, #31
34815d5c:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
34815d60:	e58dc010 	str	ip, [sp, #16]
34815d64:	e58d3014 	str	r3, [sp, #20]
34815d68:	eb0028a9 	bl	34820014 <__lshrdi3>
34815d6c:	e59d3014 	ldr	r3, [sp, #20]
34815d70:	e1a04000 	mov	r4, r0
34815d74:	e1a05001 	mov	r5, r1
34815d78:	e1a02003 	mov	r2, r3
34815d7c:	e1cd01d8 	ldrd	r0, [sp, #24]
34815d80:	eb0028aa 	bl	34820030 <__ashrdi3>
34815d84:	e0544000 	subs	r4, r4, r0
34815d88:	e0c55001 	sbc	r5, r5, r1
34815d8c:	e003059a 	mul	r3, sl, r5
34815d90:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
34815d94:	e59dc010 	ldr	ip, [sp, #16]
34815d98:	e0233094 	mla	r3, r4, r0, r3
34815d9c:	e085449a 	umull	r4, r5, sl, r4
34815da0:	e0835005 	add	r5, r3, r5
34815da4:	e3550000 	cmp	r5, #0
34815da8:	1a000005 	bne	34815dc4 <onenand_read_oob_nolock+0x118>
34815dac:	e15c0004 	cmp	ip, r4
34815db0:	9a000003 	bls	34815dc4 <onenand_read_oob_nolock+0x118>
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
34815db4:	e59f0188 	ldr	r0, [pc, #392]	; 34815f44 <onenand_read_oob_nolock+0x298>
34815db8:	ebffcf42 	bl	34809ac8 <printf>
		return -EINVAL;
34815dbc:	e3e04015 	mvn	r4, #21
34815dc0:	ea00005b 	b	34815f34 <onenand_read_oob_nolock+0x288>
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34815dc4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
34815dc8:	e5961084 	ldr	r1, [r6, #132]	; 0x84
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34815dcc:	e3130008 	tst	r3, #8
34815dd0:	03a02013 	moveq	r2, #19
34815dd4:	13a02000 	movne	r2, #0
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;
34815dd8:	e3a04000 	mov	r4, #0
34815ddc:	e58db028 	str	fp, [sp, #40]	; 0x28
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
34815de0:	e58d103c 	str	r1, [sp, #60]	; 0x3c
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34815de4:	e58d2038 	str	r2, [sp, #56]	; 0x38
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
34815de8:	e1a05004 	mov	r5, r4
34815dec:	e1a0b00a 	mov	fp, sl
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
34815df0:	ea000043 	b	34815f04 <onenand_read_oob_nolock+0x258>
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
34815df4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		this->command(mtd, readcmd, from, mtd->oobsize);
34815df8:	e59d1038 	ldr	r1, [sp, #56]	; 0x38

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
34815dfc:	e5873084 	str	r3, [r7, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
34815e00:	e5963018 	ldr	r3, [r6, #24]
34815e04:	e1a00006 	mov	r0, r6
34815e08:	e58d3000 	str	r3, [sp]
34815e0c:	e597c050 	ldr	ip, [r7, #80]	; 0x50
34815e10:	e1cd21d8 	ldrd	r2, [sp, #24]
34815e14:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
34815e18:	e1cd21d8 	ldrd	r2, [sp, #24]
34815e1c:	e3a04000 	mov	r4, #0
34815e20:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34815e24:	e58d4000 	str	r4, [sp]
34815e28:	ebfffc45 	bl	34814f44 <onenand_update_bufferram.clone.2>

		ret = this->wait(mtd, FL_READING);
34815e2c:	e5973054 	ldr	r3, [r7, #84]	; 0x54
34815e30:	e1a00006 	mov	r0, r6
34815e34:	e3a01001 	mov	r1, #1
34815e38:	e12fff33 	blx	r3
		if (unlikely(ret))
34815e3c:	e2504000 	subs	r4, r0, #0
34815e40:	0a000004 	beq	34815e58 <onenand_read_oob_nolock+0x1ac>
			ret = onenand_recover_lsb(mtd, from, ret);
34815e44:	e1a00006 	mov	r0, r6
34815e48:	e1cd21d8 	ldrd	r2, [sp, #24]
34815e4c:	e58d4000 	str	r4, [sp]
34815e50:	ebffff6f 	bl	34815c14 <onenand_recover_lsb>
34815e54:	e1a04000 	mov	r4, r0

		if (ret && ret != -EBADMSG) {
34815e58:	e3540000 	cmp	r4, #0
34815e5c:	1374004a 	cmnne	r4, #74	; 0x4a
34815e60:	0a000004 	beq	34815e78 <onenand_read_oob_nolock+0x1cc>
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
34815e64:	e1a01004 	mov	r1, r4
34815e68:	e59f00d8 	ldr	r0, [pc, #216]	; 34815f48 <onenand_read_oob_nolock+0x29c>
34815e6c:	e59db028 	ldr	fp, [sp, #40]	; 0x28
34815e70:	ebffcf14 	bl	34809ac8 <printf>
			break;
34815e74:	ea000026 	b	34815f14 <onenand_read_oob_nolock+0x268>
	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);
34815e78:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34815e7c:	e59d1034 	ldr	r1, [sp, #52]	; 0x34

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
34815e80:	e069a00b 	rsb	sl, r9, fp
		thislen = min_t(int, thislen, len);
34815e84:	e15a0000 	cmp	sl, r0
34815e88:	a1a0a000 	movge	sl, r0
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34815e8c:	e3510001 	cmp	r1, #1
34815e90:	1a000005 	bne	34815eac <onenand_read_oob_nolock+0x200>
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
34815e94:	e1a00006 	mov	r0, r6
34815e98:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34815e9c:	e1a02009 	mov	r2, r9
34815ea0:	e1a0300a 	mov	r3, sl
34815ea4:	ebfffbd5 	bl	34814e00 <onenand_transfer_auto_oob>
34815ea8:	ea000007 	b	34815ecc <onenand_read_oob_nolock+0x220>
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34815eac:	e59f2098 	ldr	r2, [pc, #152]	; 34815f4c <onenand_read_oob_nolock+0x2a0>
34815eb0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34815eb4:	e88d060c 	stm	sp, {r2, r3, r9, sl}
34815eb8:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34815ebc:	e1a00006 	mov	r0, r6
34815ec0:	e3a02000 	mov	r2, #0
34815ec4:	e3a03000 	mov	r3, #0
34815ec8:	e12fff31 	blx	r1

		read += thislen;

		if (read == len)
34815ecc:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (mode == MTD_OOB_AUTO)
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);

		read += thislen;
34815ed0:	e085500a 	add	r5, r5, sl

		if (read == len)
34815ed4:	e1550000 	cmp	r5, r0
34815ed8:	0a00000c 	beq	34815f10 <onenand_read_oob_nolock+0x264>
			break;

		buf += thislen;
34815edc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34815ee0:	e081100a 	add	r1, r1, sl
34815ee4:	e58d1024 	str	r1, [sp, #36]	; 0x24

		/* Read more? */
		if (read < len) {
34815ee8:	2a000005 	bcs	34815f04 <onenand_read_oob_nolock+0x258>
			/* Page size */
			from += mtd->writesize;
34815eec:	e5963014 	ldr	r3, [r6, #20]
34815ef0:	e1cd01d8 	ldrd	r0, [sp, #24]
34815ef4:	e0900003 	adds	r0, r0, r3
34815ef8:	e2a11000 	adc	r1, r1, #0
34815efc:	e1cd01f8 	strd	r0, [sp, #24]
			column = 0;
34815f00:	e3a09000 	mov	r9, #0
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
34815f04:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34815f08:	e1550001 	cmp	r5, r1
34815f0c:	3affffb8 	bcc	34815df4 <onenand_read_oob_nolock+0x148>
34815f10:	e59db028 	ldr	fp, [sp, #40]	; 0x28
		}
	}

	ops->oobretlen = read;

	if (ret)
34815f14:	e3540000 	cmp	r4, #0
			from += mtd->writesize;
			column = 0;
		}
	}

	ops->oobretlen = read;
34815f18:	e58b5010 	str	r5, [fp, #16]

	if (ret)
34815f1c:	1a000004 	bne	34815f34 <onenand_read_oob_nolock+0x288>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34815f20:	e5963084 	ldr	r3, [r6, #132]	; 0x84
		return -EBADMSG;
34815f24:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
34815f28:	e1530002 	cmp	r3, r2
34815f2c:	03a04000 	moveq	r4, #0
34815f30:	13e04049 	mvnne	r4, #73	; 0x49

	return 0;
}
34815f34:	e1a00004 	mov	r0, r4
34815f38:	e28dd040 	add	sp, sp, #64	; 0x40
34815f3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815f40:	3482777c 	.word	0x3482777c
34815f44:	348277ba 	.word	0x348277ba
34815f48:	348277fb 	.word	0x348277fb
34815f4c:	00010020 	.word	0x00010020

34815f50 <onenand_read_ops_nolock>:
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815f50:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815f54:	e24dd058 	sub	sp, sp, #88	; 0x58
34815f58:	e59d7078 	ldr	r7, [sp, #120]	; 0x78
34815f5c:	e1cd21f8 	strd	r2, [sp, #24]
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
34815f60:	e5973000 	ldr	r3, [r7]
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
34815f64:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
34815f68:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34815f6c:	0594309c 	ldreq	r3, [r4, #156]	; 0x9c
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815f70:	e1a05000 	mov	r5, r0
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815f74:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
34815f78:	15953018 	ldrne	r3, [r5, #24]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
34815f7c:	e5971018 	ldr	r1, [r7, #24]
	u_char *oobbuf = ops->oobbuf;
34815f80:	e597201c 	ldr	r2, [r7, #28]
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
34815f84:	e597b004 	ldr	fp, [r7, #4]
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
34815f88:	e58d1028 	str	r1, [sp, #40]	; 0x28
	u_char *oobbuf = ops->oobbuf;
34815f8c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
34815f90:	e58d303c 	str	r3, [sp, #60]	; 0x3c

	oobcolumn = from & (mtd->oobsize - 1);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815f94:	e595100c 	ldr	r1, [r5, #12]
34815f98:	e1cd21d8 	ldrd	r2, [sp, #24]
34815f9c:	e092200b 	adds	r2, r2, fp
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34815fa0:	e597000c 	ldr	r0, [r7, #12]
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34815fa4:	e5956018 	ldr	r6, [r5, #24]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815fa8:	e2a33000 	adc	r3, r3, #0
34815fac:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34815fb0:	e58d004c 	str	r0, [sp, #76]	; 0x4c
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
	int writesize = this->writesize;
34815fb4:	e5949040 	ldr	r9, [r4, #64]	; 0x40
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34815fb8:	e58d6020 	str	r6, [sp, #32]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815fbc:	3a000003 	bcc	34815fd0 <onenand_read_ops_nolock+0x80>
34815fc0:	1a000009 	bne	34815fec <onenand_read_ops_nolock+0x9c>
34815fc4:	e5951008 	ldr	r1, [r5, #8]
34815fc8:	e1510002 	cmp	r1, r2
34815fcc:	2a000006 	bcs	34815fec <onenand_read_ops_nolock+0x9c>
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
34815fd0:	e59f047c 	ldr	r0, [pc, #1148]	; 34816454 <onenand_read_ops_nolock+0x504>
34815fd4:	ebffcebb 	bl	34809ac8 <printf>
		ops->retlen = 0;
34815fd8:	e3a03000 	mov	r3, #0
34815fdc:	e5873008 	str	r3, [r7, #8]
		ops->oobretlen = 0;
34815fe0:	e5873010 	str	r3, [r7, #16]
		return -EINVAL;
34815fe4:	e3e06015 	mvn	r6, #21
34815fe8:	ea000114 	b	34816440 <onenand_read_ops_nolock+0x4f0>
34815fec:	e5950080 	ldr	r0, [r5, #128]	; 0x80
34815ff0:	e5951084 	ldr	r1, [r5, #132]	; 0x84

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
34815ff4:	e35b0000 	cmp	fp, #0
	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
		ops->retlen = 0;
		ops->oobretlen = 0;
		return -EINVAL;
34815ff8:	e58d0054 	str	r0, [sp, #84]	; 0x54
34815ffc:	e58d1050 	str	r1, [sp, #80]	; 0x50
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
34816000:	01a0600b 	moveq	r6, fp

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
34816004:	0a000038 	beq	348160ec <onenand_read_ops_nolock+0x19c>
#endif

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int) (addr >> this->page_shift);
34816008:	e5942034 	ldr	r2, [r4, #52]	; 0x34
3481600c:	e1cd01d8 	ldrd	r0, [sp, #24]
34816010:	eb002806 	bl	34820030 <__ashrdi3>

	/* Is there valid data? */
	i = ONENAND_CURRENT_BUFFERRAM(this);
34816014:	e5943044 	ldr	r3, [r4, #68]	; 0x44
	if (this->bufferram[i].blockpage == blockpage)
34816018:	e2832012 	add	r2, r3, #18
3481601c:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34816020:	e1520000 	cmp	r2, r0
34816024:	0a000005 	beq	34816040 <onenand_read_ops_nolock+0xf0>
		found = 1;
	else {
		/* Check another BufferRAM */
		i = ONENAND_NEXT_BUFFERRAM(this);
34816028:	e2233001 	eor	r3, r3, #1
		if (this->bufferram[i].blockpage == blockpage) {
3481602c:	e2832012 	add	r2, r3, #18
34816030:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34816034:	e1520000 	cmp	r2, r0
34816038:	1a000010 	bne	34816080 <onenand_read_ops_nolock+0x130>
			ONENAND_SET_NEXT_BUFFERRAM(this);
3481603c:	e5843044 	str	r3, [r4, #68]	; 0x44
			found = 1;
		}
	}

	if (found && ONENAND_IS_DDP(this)) {
34816040:	e594301c 	ldr	r3, [r4, #28]
34816044:	e3130008 	tst	r3, #8
34816048:	0a0000ff 	beq	3481644c <onenand_read_ops_nolock+0x4fc>
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
3481604c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816050:	e1a00004 	mov	r0, r4
34816054:	ebfffdc8 	bl	3481577c <onenand_block>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34816058:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
3481605c:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816060:	e0100003 	ands	r0, r0, r3

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816064:	e59f13ec 	ldr	r1, [pc, #1004]	; 34816458 <onenand_read_ops_nolock+0x508>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816068:	13a00902 	movne	r0, #32768	; 0x8000

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
3481606c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816070:	e6ff0070 	uxth	r0, r0
34816074:	e0821001 	add	r1, r2, r1
34816078:	e12fff33 	blx	r3
3481607c:	ea0000f2 	b	3481644c <onenand_read_ops_nolock+0x4fc>
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
34816080:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34816084:	e3a01000 	mov	r1, #0
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
34816088:	e5842080 	str	r2, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
3481608c:	e58d9000 	str	r9, [sp]
34816090:	e1cd21d8 	ldrd	r2, [sp, #24]
34816094:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816098:	e1a00005 	mov	r0, r5
3481609c:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
348160a0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348160a4:	e1a00005 	mov	r0, r5
348160a8:	e3a01001 	mov	r1, #1
348160ac:	e12fff33 	blx	r3
			if (unlikely(ret))
348160b0:	e2506000 	subs	r6, r0, #0
348160b4:	0a000004 	beq	348160cc <onenand_read_ops_nolock+0x17c>
				ret = onenand_recover_lsb(mtd, from, ret);
348160b8:	e1a00005 	mov	r0, r5
348160bc:	e1cd21d8 	ldrd	r2, [sp, #24]
348160c0:	e58d6000 	str	r6, [sp]
348160c4:	ebfffed2 	bl	34815c14 <onenand_recover_lsb>
348160c8:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
348160cc:	e2763001 	rsbs	r3, r6, #1
348160d0:	33a03000 	movcc	r3, #0
348160d4:	e58d3000 	str	r3, [sp]
348160d8:	e5950094 	ldr	r0, [r5, #148]	; 0x94
348160dc:	e1cd21d8 	ldrd	r2, [sp, #24]
348160e0:	ebfffb97 	bl	34814f44 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
348160e4:	e376004a 	cmn	r6, #74	; 0x4a
348160e8:	03a06000 	moveq	r6, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
348160ec:	e59d2018 	ldr	r2, [sp, #24]
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
348160f0:	e2493001 	sub	r3, r9, #1
			if (ret == -EBADMSG)
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
348160f4:	e15b0009 	cmp	fp, r9
348160f8:	b1a0a00b 	movlt	sl, fp
348160fc:	a1a0a009 	movge	sl, r9
	column = from & (writesize - 1);
34816100:	e0023003 	and	r3, r2, r3
34816104:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if (column + thislen > writesize)
34816108:	e083300a 	add	r3, r3, sl
3481610c:	e1530009 	cmp	r3, r9
		thislen = writesize - column;
34816110:	c59d3030 	ldrgt	r3, [sp, #48]	; 0x30
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34816114:	e59d0020 	ldr	r0, [sp, #32]
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;
34816118:	c063a009 	rsbgt	sl, r3, r9
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
3481611c:	e2403001 	sub	r3, r0, #1
34816120:	e3a01000 	mov	r1, #0
34816124:	e0023003 	and	r3, r2, r3
34816128:	e58d3038 	str	r3, [sp, #56]	; 0x38
3481612c:	e58d1024 	str	r1, [sp, #36]	; 0x24
34816130:	e58d1034 	str	r1, [sp, #52]	; 0x34
34816134:	e58d1020 	str	r1, [sp, #32]
34816138:	e58d7014 	str	r7, [sp, #20]
3481613c:	ea0000ac 	b	348163f4 <onenand_read_ops_nolock+0x4a4>
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
34816140:	e1a0200a 	mov	r2, sl
34816144:	e1a03fc2 	asr	r3, r2, #31
34816148:	e1cd01d8 	ldrd	r0, [sp, #24]
3481614c:	e0900002 	adds	r0, r0, r2
34816150:	e0a11003 	adc	r1, r1, r3
34816154:	e1cd24f0 	strd	r2, [sp, #64]	; 0x40
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34816158:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
3481615c:	e1cd01f8 	strd	r0, [sp, #24]
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34816160:	e3130008 	tst	r3, #8
34816164:	1a000025 	bne	34816200 <onenand_read_ops_nolock+0x2b0>
34816168:	e59d1020 	ldr	r1, [sp, #32]
3481616c:	e08a3001 	add	r3, sl, r1
34816170:	e153000b 	cmp	r3, fp
34816174:	2a000021 	bcs	34816200 <onenand_read_ops_nolock+0x2b0>
			this->main_buf = buf + thislen;
34816178:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
3481617c:	e1a00005 	mov	r0, r5

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
			this->main_buf = buf + thislen;
34816180:	e082300a 	add	r3, r2, sl
34816184:	e5843080 	str	r3, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34816188:	e58d9000 	str	r9, [sp]
3481618c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816190:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816194:	e1a01006 	mov	r1, r6
34816198:	e12fff3c 	blx	ip
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
3481619c:	e594301c 	ldr	r3, [r4, #28]
348161a0:	e3130008 	tst	r3, #8
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
				boundary = 1;
			} else
				boundary = 0;
348161a4:	058d6024 	streq	r6, [sp, #36]	; 0x24
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
348161a8:	0a000011 	beq	348161f4 <onenand_read_ops_nolock+0x2a4>
					unlikely(from == (this->chipsize >> 1))) {
348161ac:	e5943018 	ldr	r3, [r4, #24]
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
348161b0:	e59d6018 	ldr	r6, [sp, #24]
348161b4:	e15600a3 	cmp	r6, r3, lsr #1
348161b8:	1a00000b 	bne	348161ec <onenand_read_ops_nolock+0x29c>
348161bc:	e59d701c 	ldr	r7, [sp, #28]
348161c0:	e3570000 	cmp	r7, #0
348161c4:	1a000008 	bne	348161ec <onenand_read_ops_nolock+0x29c>
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
348161c8:	e5942000 	ldr	r2, [r4]
348161cc:	e59f1284 	ldr	r1, [pc, #644]	; 34816458 <onenand_read_ops_nolock+0x508>
348161d0:	e1a00007 	mov	r0, r7
348161d4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348161d8:	e0821001 	add	r1, r2, r1
348161dc:	e12fff33 	blx	r3
				boundary = 1;
348161e0:	e3a00001 	mov	r0, #1
348161e4:	e58d0024 	str	r0, [sp, #36]	; 0x24
348161e8:	ea000001 	b	348161f4 <onenand_read_ops_nolock+0x2a4>
			} else
				boundary = 0;
348161ec:	e3a01000 	mov	r1, #0
348161f0:	e58d1024 	str	r1, [sp, #36]	; 0x24
			ONENAND_SET_PREV_BUFFERRAM(this);
348161f4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348161f8:	e2233001 	eor	r3, r3, #1
348161fc:	e5843044 	str	r3, [r4, #68]	; 0x44
		}

		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
34816200:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34816204:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
34816208:	e3a02b01 	mov	r2, #1024	; 0x400
3481620c:	e88d044c 	stm	sp, {r2, r3, r6, sl}
34816210:	e1cd64d0 	ldrd	r6, [sp, #64]	; 0x40
34816214:	e1cd21d8 	ldrd	r2, [sp, #24]
34816218:	e5941060 	ldr	r1, [r4, #96]	; 0x60
3481621c:	e0522006 	subs	r2, r2, r6
34816220:	e0c33007 	sbc	r3, r3, r7
34816224:	e1a00005 	mov	r0, r5
34816228:	e12fff31 	blx	r1

		/* Read oob area if needed */
		if (oobbuf) {
3481622c:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
34816230:	e3570000 	cmp	r7, #0
34816234:	0a000022 	beq	348162c4 <onenand_read_ops_nolock+0x374>
			thisooblen = oobsize - oobcolumn;
34816238:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
3481623c:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34816240:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
34816244:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
34816248:	e0613000 	rsb	r3, r1, r0
			thisooblen = min_t(int, thisooblen, ooblen - oobread);

			if (ops->mode == MTD_OOB_AUTO)
3481624c:	e59d0014 	ldr	r0, [sp, #20]
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34816250:	e0676002 	rsb	r6, r7, r2
34816254:	e1560003 	cmp	r6, r3
34816258:	a1a06003 	movge	r6, r3

			if (ops->mode == MTD_OOB_AUTO)
3481625c:	e5903000 	ldr	r3, [r0]
34816260:	e3530001 	cmp	r3, #1
34816264:	1a000005 	bne	34816280 <onenand_read_ops_nolock+0x330>
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
34816268:	e1a00005 	mov	r0, r5
3481626c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34816270:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
34816274:	e1a03006 	mov	r3, r6
34816278:	ebfffae0 	bl	34814e00 <onenand_transfer_auto_oob>
3481627c:	ea000008 	b	348162a4 <onenand_read_ops_nolock+0x354>
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
34816280:	e59f11d4 	ldr	r1, [pc, #468]	; 3481645c <onenand_read_ops_nolock+0x50c>
34816284:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34816288:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3481628c:	e88d004e 	stm	sp, {r1, r2, r3, r6}
34816290:	e5941060 	ldr	r1, [r4, #96]	; 0x60
34816294:	e1a00005 	mov	r0, r5
34816298:	e3a02000 	mov	r2, #0
3481629c:	e3a03000 	mov	r3, #0
348162a0:	e12fff31 	blx	r1
			oobread += thisooblen;
348162a4:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
348162a8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
348162ac:	e0877006 	add	r7, r7, r6
			oobbuf += thisooblen;
348162b0:	e0800006 	add	r0, r0, r6
			oobcolumn = 0;
348162b4:	e3a01000 	mov	r1, #0

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
348162b8:	e58d7034 	str	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
348162bc:	e58d002c 	str	r0, [sp, #44]	; 0x2c
			oobcolumn = 0;
348162c0:	e58d1038 	str	r1, [sp, #56]	; 0x38
		}

		if (ONENAND_IS_4KB_PAGE(this) && (read + thislen < len)) {
348162c4:	e594602c 	ldr	r6, [r4, #44]	; 0x2c
348162c8:	e2166008 	ands	r6, r6, #8
348162cc:	0a00001d 	beq	34816348 <onenand_read_ops_nolock+0x3f8>
348162d0:	e59d2020 	ldr	r2, [sp, #32]
348162d4:	e08a3002 	add	r3, sl, r2
348162d8:	e153000b 	cmp	r3, fp
348162dc:	23a06000 	movcs	r6, #0
348162e0:	2a000018 	bcs	34816348 <onenand_read_ops_nolock+0x3f8>
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
348162e4:	e58d9000 	str	r9, [sp]
348162e8:	e1cd21d8 	ldrd	r2, [sp, #24]
348162ec:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348162f0:	e3a01000 	mov	r1, #0
348162f4:	e1a00005 	mov	r0, r5
348162f8:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
348162fc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816300:	e1a00005 	mov	r0, r5
34816304:	e3a01001 	mov	r1, #1
34816308:	e12fff33 	blx	r3
			if (unlikely(ret))
3481630c:	e2506000 	subs	r6, r0, #0
34816310:	0a000004 	beq	34816328 <onenand_read_ops_nolock+0x3d8>
				ret = onenand_recover_lsb(mtd, from, ret);
34816314:	e1a00005 	mov	r0, r5
34816318:	e1cd21d8 	ldrd	r2, [sp, #24]
3481631c:	e58d6000 	str	r6, [sp]
34816320:	ebfffe3b 	bl	34815c14 <onenand_recover_lsb>
34816324:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
34816328:	e2763001 	rsbs	r3, r6, #1
3481632c:	33a03000 	movcc	r3, #0
34816330:	e58d3000 	str	r3, [sp]
34816334:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34816338:	e1cd21d8 	ldrd	r2, [sp, #24]
3481633c:	ebfffb00 	bl	34814f44 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
34816340:	e376004a 	cmn	r6, #74	; 0x4a
34816344:	03a06000 	moveq	r6, #0
		}

		/* See if we are done */
		read += thislen;
34816348:	e59d3020 	ldr	r3, [sp, #32]
3481634c:	e083300a 	add	r3, r3, sl
		if (read == len)
34816350:	e153000b 	cmp	r3, fp
			if (ret == -EBADMSG)
				ret = 0;
		}

		/* See if we are done */
		read += thislen;
34816354:	e58d3020 	str	r3, [sp, #32]
		if (read == len)
34816358:	0a000027 	beq	348163fc <onenand_read_ops_nolock+0x4ac>
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
3481635c:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34816360:	e3570000 	cmp	r7, #0
34816364:	0a000005 	beq	34816380 <onenand_read_ops_nolock+0x430>
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
34816368:	e5942000 	ldr	r2, [r4]
3481636c:	e59f10e4 	ldr	r1, [pc, #228]	; 34816458 <onenand_read_ops_nolock+0x508>
34816370:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816374:	e3a00902 	mov	r0, #32768	; 0x8000
34816378:	e0821001 	add	r1, r2, r1
3481637c:	e12fff33 	blx	r3
		if (!ONENAND_IS_4KB_PAGE(this))
34816380:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
34816384:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
		if (read == len)
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
34816388:	e2133008 	ands	r3, r3, #8
			ONENAND_SET_NEXT_BUFFERRAM(this);
3481638c:	05942044 	ldreq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
34816390:	e59d1020 	ldr	r1, [sp, #32]
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
34816394:	02222001 	eoreq	r2, r2, #1
		buf += thislen;
34816398:	e080000a 	add	r0, r0, sl
		thislen = min_t(int, writesize, len - read);
3481639c:	e061a00b 	rsb	sl, r1, fp
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
348163a0:	05842044 	streq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
348163a4:	e15a0009 	cmp	sl, r9
348163a8:	a1a0a009 	movge	sl, r9
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
348163ac:	e3530000 	cmp	r3, #0
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
348163b0:	e58d0028 	str	r0, [sp, #40]	; 0x28
		thislen = min_t(int, writesize, len - read);
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
348163b4:	1a00000c 	bne	348163ec <onenand_read_ops_nolock+0x49c>
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
348163b8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348163bc:	e3a01001 	mov	r1, #1
348163c0:	e1a00005 	mov	r0, r5
348163c4:	e12fff33 	blx	r3
			onenand_update_bufferram(mtd, from, !ret);
348163c8:	e2703001 	rsbs	r3, r0, #1
348163cc:	33a03000 	movcc	r3, #0
348163d0:	e1a06000 	mov	r6, r0
348163d4:	e58d3000 	str	r3, [sp]
348163d8:	e5950094 	ldr	r0, [r5, #148]	; 0x94
348163dc:	e1cd21d8 	ldrd	r2, [sp, #24]
348163e0:	ebfffad7 	bl	34814f44 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
348163e4:	e376004a 	cmn	r6, #74	; 0x4a
348163e8:	03a06000 	moveq	r6, #0

		if (!ONENAND_IS_4KB_PAGE(this)) {
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
			onenand_update_bufferram(mtd, from, !ret);
			if (ret == -EBADMSG)
348163ec:	e3a02000 	mov	r2, #0
348163f0:	e58d2030 	str	r2, [sp, #48]	; 0x30
	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
348163f4:	e3560000 	cmp	r6, #0
348163f8:	0affff50 	beq	34816140 <onenand_read_ops_nolock+0x1f0>
348163fc:	e59d7014 	ldr	r7, [sp, #20]
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
34816400:	e59d3020 	ldr	r3, [sp, #32]
	ops->oobretlen = oobread;
34816404:	e59d0034 	ldr	r0, [sp, #52]	; 0x34

	if (ret)
34816408:	e3560000 	cmp	r6, #0
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
3481640c:	e5873008 	str	r3, [r7, #8]
	ops->oobretlen = oobread;
34816410:	e5870010 	str	r0, [r7, #16]

	if (ret)
34816414:	1a000009 	bne	34816440 <onenand_read_ops_nolock+0x4f0>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34816418:	e5953084 	ldr	r3, [r5, #132]	; 0x84
3481641c:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34816420:	e1530001 	cmp	r3, r1
		return -EBADMSG;
34816424:	13e06049 	mvnne	r6, #73	; 0x49
	ops->oobretlen = oobread;

	if (ret)
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34816428:	1a000004 	bne	34816440 <onenand_read_ops_nolock+0x4f0>
		return -EBADMSG;

	return mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
3481642c:	e5953080 	ldr	r3, [r5, #128]	; 0x80
34816430:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
34816434:	e1530002 	cmp	r3, r2
34816438:	03a06000 	moveq	r6, #0
3481643c:	13e06074 	mvnne	r6, #116	; 0x74
}
34816440:	e1a00006 	mov	r0, r6
34816444:	e28dd058 	add	sp, sp, #88	; 0x58
34816448:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
3481644c:	e3a06000 	mov	r6, #0
34816450:	eaffff25 	b	348160ec <onenand_read_ops_nolock+0x19c>
34816454:	34827828 	.word	0x34827828
34816458:	0001e202 	.word	0x0001e202
3481645c:	00010020 	.word	0x00010020

34816460 <onenand_read_oob>:
 *
 * OneNAND main and/or out-of-band
 */
int onenand_read_oob(struct mtd_info *mtd, loff_t from,
			struct mtd_oob_ops *ops)
{
34816460:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
34816464:	e591c000 	ldr	ip, [r1]
34816468:	e35c0001 	cmp	ip, #1
3481646c:	8a000005 	bhi	34816488 <onenand_read_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_READING);
	if (ops->datbuf)
34816470:	e591c018 	ldr	ip, [r1, #24]
34816474:	e35c0000 	cmp	ip, #0
34816478:	0a000000 	beq	34816480 <onenand_read_oob+0x20>
		ret = onenand_read_ops_nolock(mtd, from, ops);
3481647c:	eafffeb3 	b	34815f50 <onenand_read_ops_nolock>
	else
		ret = onenand_read_oob_nolock(mtd, from, ops);
34816480:	e58d1000 	str	r1, [sp]
34816484:	eafffe08 	b	34815cac <onenand_read_oob_nolock>
	onenand_release_device(mtd);

	return ret;
}
34816488:	e3e00015 	mvn	r0, #21
3481648c:	e12fff1e 	bx	lr

34816490 <onenand_read>:
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34816490:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34816494:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34816498:	e28d7008 	add	r7, sp, #8
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
3481649c:	e1a06000 	mov	r6, r0
348164a0:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
348164a4:	e3a01000 	mov	r1, #0
348164a8:	e1a00007 	mov	r0, r7
348164ac:	e3a02020 	mov	r2, #32
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
348164b0:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
348164b4:	eb001857 	bl	3481c618 <memset>
348164b8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348164bc:	e1a02004 	mov	r2, r4
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
348164c0:	e58d300c 	str	r3, [sp, #12]
348164c4:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348164c8:	e1a00006 	mov	r0, r6
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
348164cc:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348164d0:	e1a03005 	mov	r3, r5
348164d4:	e58d7000 	str	r7, [sp]
348164d8:	ebfffe9c 	bl	34815f50 <onenand_read_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
348164dc:	e59d2010 	ldr	r2, [sp, #16]
348164e0:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
348164e4:	e5832000 	str	r2, [r3]
	return ret;
}
348164e8:	e28dd02c 	add	sp, sp, #44	; 0x2c
348164ec:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

348164f0 <onenand_erase>:
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
348164f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348164f4:	e1a06001 	mov	r6, r1
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
348164f8:	e5969010 	ldr	r9, [r6, #16]
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
348164fc:	e24dd028 	sub	sp, sp, #40	; 0x28
34816500:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
34816504:	e590a094 	ldr	sl, [r0, #148]	; 0x94
	unsigned int block_size;
	loff_t addr = instr->addr;
34816508:	e1c100d8 	ldrd	r0, [r1, #8]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
3481650c:	e0902009 	adds	r2, r0, r9
34816510:	e2a13000 	adc	r3, r1, #0
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
34816514:	e1cd01f0 	strd	r0, [sp, #16]
34816518:	e1cd01f8 	strd	r0, [sp, #24]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
3481651c:	e595100c 	ldr	r1, [r5, #12]
34816520:	e1510003 	cmp	r1, r3
34816524:	3a0000b4 	bcc	348167fc <onenand_erase+0x30c>
34816528:	1a000002 	bne	34816538 <onenand_erase+0x48>
3481652c:	e5951008 	ldr	r1, [r5, #8]
34816530:	e1510002 	cmp	r1, r2
34816534:	3a0000b0 	bcc	348167fc <onenand_erase+0x30c>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
					"Erase past end of device\n");
		return -EINVAL;
	}

	if (FLEXONENAND(this)) {
34816538:	e59a301c 	ldr	r3, [sl, #28]
3481653c:	e3130c02 	tst	r3, #512	; 0x200
34816540:	0a000015 	beq	3481659c <onenand_erase+0xac>
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
34816544:	e1cd21d0 	ldrd	r2, [sp, #16]
34816548:	e1a00005 	mov	r0, r5
3481654c:	ebfffd9d 	bl	34815bc8 <flexonenand_region>
		region = &mtd->eraseregions[i];
34816550:	e3a03018 	mov	r3, #24
34816554:	e0000093 	mul	r0, r3, r0
34816558:	e5951030 	ldr	r1, [r5, #48]	; 0x30
3481655c:	e0817000 	add	r7, r1, r0

		block_size = region->erasesize;
34816560:	e5974008 	ldr	r4, [r7, #8]
		region_end = region->offset
34816564:	e18120d0 	ldrd	r2, [r1, r0]
34816568:	e1cd22f0 	strd	r2, [sp, #32]
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
3481656c:	e1cd02d0 	ldrd	r0, [sp, #32]
34816570:	e1cd21d0 	ldrd	r2, [sp, #16]
34816574:	e244c001 	sub	ip, r4, #1
34816578:	e0522000 	subs	r2, r2, r0
3481657c:	e0c33001 	sbc	r3, r3, r1
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
			+ region->erasesize * region->numblocks;
34816580:	e597b00c 	ldr	fp, [r7, #12]

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34816584:	e002200c 	and	r2, r2, ip
34816588:	e3a03000 	mov	r3, #0
3481658c:	e1921003 	orrs	r1, r2, r3
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
34816590:	002b0b94 	mlaeq	fp, r4, fp, r0
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34816594:	0a00000a 	beq	348165c4 <onenand_erase+0xd4>
34816598:	ea000097 	b	348167fc <onenand_erase+0x30c>
			MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
				" Unaligned address\n");
			return -EINVAL;
		}
	} else {
		block_size = 1 << this->erase_shift;
3481659c:	e59a3030 	ldr	r3, [sl, #48]	; 0x30
348165a0:	e3a04001 	mov	r4, #1
348165a4:	e1a04314 	lsl	r4, r4, r3

		/* Start address must align on block boundary */
		if (unlikely(addr & (block_size - 1))) {
348165a8:	e1cd21d0 	ldrd	r2, [sp, #16]
348165ac:	e2441001 	sub	r1, r4, #1
348165b0:	e0022001 	and	r2, r2, r1
348165b4:	e3a03000 	mov	r3, #0
348165b8:	e192b003 	orrs	fp, r2, r3
348165bc:	1a00008e 	bne	348167fc <onenand_erase+0x30c>
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
	int ret = 0, i;
	struct mtd_erase_region_info *region = NULL;
348165c0:	e1a0700b 	mov	r7, fp
			return -EINVAL;
		}
	}

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
348165c4:	e2443001 	sub	r3, r4, #1
348165c8:	e1130009 	tst	r3, r9
348165cc:	1a00008a 	bne	348167fc <onenand_erase+0x30c>
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
	}

	instr->fail_addr = 0xffffffff;
348165d0:	e3a03000 	mov	r3, #0
348165d4:	e3e02000 	mvn	r2, #0
348165d8:	e1c621f8 	strd	r2, [r6, #24]

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;
348165dc:	e3a03002 	mov	r3, #2
348165e0:	e5c63038 	strb	r3, [r6, #56]	; 0x38
348165e4:	e58db00c 	str	fp, [sp, #12]

	while (len) {
348165e8:	ea000077 	b	348167cc <onenand_erase+0x2dc>

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
348165ec:	e5963034 	ldr	r3, [r6, #52]	; 0x34
348165f0:	e3530000 	cmp	r3, #0
348165f4:	1a00000d 	bne	34816630 <onenand_erase+0x140>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348165f8:	e5952094 	ldr	r2, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
348165fc:	e1a00005 	mov	r0, r5
34816600:	e59220a0 	ldr	r2, [r2, #160]	; 0xa0
34816604:	e58d3000 	str	r3, [sp]
34816608:	e5921010 	ldr	r1, [r2, #16]
3481660c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816610:	e12fff31 	blx	r1
	instr->state = MTD_ERASING;

	while (len) {

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
34816614:	e3500000 	cmp	r0, #0
34816618:	0a000004 	beq	34816630 <onenand_erase+0x140>
			printk(KERN_WARNING "onenand_erase: attempt to erase"
3481661c:	e59f01e4 	ldr	r0, [pc, #484]	; 34816808 <onenand_erase+0x318>
34816620:	e59d1018 	ldr	r1, [sp, #24]
34816624:	ebffcd27 	bl	34809ac8 <printf>
				" a bad block at addr 0x%08x\n",
				(unsigned int) addr);
			instr->state = MTD_ERASE_FAILED;
34816628:	e3a03010 	mov	r3, #16
3481662c:	ea000069 	b	348167d8 <onenand_erase+0x2e8>
			goto erase_exit;
		}

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
34816630:	e58d4000 	str	r4, [sp]
34816634:	e1cd21d8 	ldrd	r2, [sp, #24]
34816638:	e59ac050 	ldr	ip, [sl, #80]	; 0x50
3481663c:	e3a01094 	mov	r1, #148	; 0x94
34816640:	e1a00005 	mov	r0, r5
34816644:	e12fff3c 	blx	ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816648:	e1cd01d8 	ldrd	r0, [sp, #24]
 * Invalidate BufferRAM information
 */
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
3481664c:	e5953094 	ldr	r3, [r5, #148]	; 0x94
	int i;
	loff_t end_addr = addr + len;
34816650:	e0900004 	adds	r0, r0, r4

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816654:	e593c034 	ldr	ip, [r3, #52]	; 0x34
34816658:	e5932048 	ldr	r2, [r3, #72]	; 0x48
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
3481665c:	e2a11000 	adc	r1, r1, #0

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816660:	e1a02c12 	lsl	r2, r2, ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816664:	e1cd01f0 	strd	r0, [sp, #16]

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
34816668:	e59db014 	ldr	fp, [sp, #20]
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
3481666c:	e1a00002 	mov	r0, r2
34816670:	e1a01fc0 	asr	r1, r0, #31

		if (buf_addr >= addr && buf_addr < end_addr)
34816674:	e15b0001 	cmp	fp, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816678:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
3481667c:	e3a00001 	mov	r0, #1
34816680:	ca000004 	bgt	34816698 <onenand_erase+0x1a8>
34816684:	1a000002 	bne	34816694 <onenand_erase+0x1a4>
34816688:	e59de010 	ldr	lr, [sp, #16]
3481668c:	e15e0002 	cmp	lr, r2
34816690:	8a000000 	bhi	34816698 <onenand_erase+0x1a8>
34816694:	e3a00000 	mov	r0, #0
34816698:	e59db01c 	ldr	fp, [sp, #28]
3481669c:	e59de024 	ldr	lr, [sp, #36]	; 0x24
348166a0:	e3a01001 	mov	r1, #1
348166a4:	e15b000e 	cmp	fp, lr
348166a8:	ca000003 	bgt	348166bc <onenand_erase+0x1cc>
348166ac:	1a000003 	bne	348166c0 <onenand_erase+0x1d0>
348166b0:	e59db018 	ldr	fp, [sp, #24]
348166b4:	e15b0002 	cmp	fp, r2
348166b8:	9a000000 	bls	348166c0 <onenand_erase+0x1d0>
348166bc:	e3a01000 	mov	r1, #0
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348166c0:	e593204c 	ldr	r2, [r3, #76]	; 0x4c

		if (buf_addr >= addr && buf_addr < end_addr)
348166c4:	e0001001 	and	r1, r0, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348166c8:	e1a0cc12 	lsl	ip, r2, ip

		if (buf_addr >= addr && buf_addr < end_addr)
348166cc:	e31100ff 	tst	r1, #255	; 0xff
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348166d0:	e1a0000c 	mov	r0, ip
348166d4:	e1a01fc0 	asr	r1, r0, #31
348166d8:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
348166dc:	e59d2014 	ldr	r2, [sp, #20]
348166e0:	e59db024 	ldr	fp, [sp, #36]	; 0x24
			this->bufferram[i].blockpage = -1;
348166e4:	13e0e000 	mvnne	lr, #0
348166e8:	1583e048 	strne	lr, [r3, #72]	; 0x48

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
348166ec:	e152000b 	cmp	r2, fp
348166f0:	e3a01001 	mov	r1, #1
348166f4:	ca000004 	bgt	3481670c <onenand_erase+0x21c>
348166f8:	1a000002 	bne	34816708 <onenand_erase+0x218>
348166fc:	e59de010 	ldr	lr, [sp, #16]
34816700:	e15e000c 	cmp	lr, ip
34816704:	8a000000 	bhi	3481670c <onenand_erase+0x21c>
34816708:	e3a01000 	mov	r1, #0
3481670c:	e59d001c 	ldr	r0, [sp, #28]
34816710:	e59db024 	ldr	fp, [sp, #36]	; 0x24
34816714:	e3a02001 	mov	r2, #1
34816718:	e150000b 	cmp	r0, fp
3481671c:	ca000003 	bgt	34816730 <onenand_erase+0x240>
34816720:	1a000003 	bne	34816734 <onenand_erase+0x244>
34816724:	e59de018 	ldr	lr, [sp, #24]
34816728:	e15e000c 	cmp	lr, ip
3481672c:	9a000000 	bls	34816734 <onenand_erase+0x244>
34816730:	e3a02000 	mov	r2, #0
34816734:	e0012002 	and	r2, r1, r2
34816738:	e31200ff 	tst	r2, #255	; 0xff
			this->bufferram[i].blockpage = -1;
3481673c:	13e00000 	mvnne	r0, #0
34816740:	1583004c 	strne	r0, [r3, #76]	; 0x4c

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);

		onenand_invalidate_bufferram(mtd, addr, block_size);

		ret = this->wait(mtd, FL_ERASING);
34816744:	e3a01003 	mov	r1, #3
34816748:	e59a3054 	ldr	r3, [sl, #84]	; 0x54
3481674c:	e1a00005 	mov	r0, r5
34816750:	e12fff33 	blx	r3
		/* Check, if it is write protected */
		if (ret) {
34816754:	e3500000 	cmp	r0, #0
					  "Device is write protected!!!\n");
			else
				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
					  "Failed erase, block %d\n",
					onenand_block(this, addr));
			instr->state = MTD_ERASE_FAILED;
34816758:	13a03010 	movne	r3, #16
3481675c:	15c63038 	strbne	r3, [r6, #56]	; 0x38
			instr->fail_addr = addr;
34816760:	11cd21d8 	ldrdne	r2, [sp, #24]
34816764:	11c621f8 	strdne	r2, [r6, #24]

			goto erase_exit;
34816768:	1a00001b 	bne	348167dc <onenand_erase+0x2ec>
		}

		len -= block_size;
		addr += block_size;

		if (addr == region_end) {
3481676c:	e59d3010 	ldr	r3, [sp, #16]
34816770:	e59db00c 	ldr	fp, [sp, #12]
			instr->fail_addr = addr;

			goto erase_exit;
		}

		len -= block_size;
34816774:	e0649009 	rsb	r9, r4, r9
		addr += block_size;

		if (addr == region_end) {
34816778:	e153000b 	cmp	r3, fp
3481677c:	1a000010 	bne	348167c4 <onenand_erase+0x2d4>
34816780:	e59d0014 	ldr	r0, [sp, #20]
34816784:	e3500000 	cmp	r0, #0
34816788:	1a00000d 	bne	348167c4 <onenand_erase+0x2d4>
			if (!len)
3481678c:	e3590000 	cmp	r9, #0
34816790:	0a00000f 	beq	348167d4 <onenand_erase+0x2e4>
				break;
			region++;
34816794:	e2877018 	add	r7, r7, #24

			block_size = region->erasesize;
34816798:	e5974008 	ldr	r4, [r7, #8]
			region_end = region->offset
3481679c:	e5973000 	ldr	r3, [r7]
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
348167a0:	e2442001 	sub	r2, r4, #1
348167a4:	e1190002 	tst	r9, r2
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
				+ region->erasesize * region->numblocks;
348167a8:	e597b00c 	ldr	fp, [r7, #12]
			if (!len)
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
348167ac:	00233b94 	mlaeq	r3, r4, fp, r3
348167b0:	058d300c 	streq	r3, [sp, #12]
348167b4:	0a000002 	beq	348167c4 <onenand_erase+0x2d4>
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
				/* This has been checked at MTD
				 * partitioning level. */
				printk("onenand_erase: Unaligned address\n");
348167b8:	e59f004c 	ldr	r0, [pc, #76]	; 3481680c <onenand_erase+0x31c>
348167bc:	ebffccc1 	bl	34809ac8 <printf>
				goto erase_exit;
348167c0:	ea000005 	b	348167dc <onenand_erase+0x2ec>
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
348167c4:	e1cd21d0 	ldrd	r2, [sp, #16]
348167c8:	e1cd21f8 	strd	r2, [sp, #24]
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;

	while (len) {
348167cc:	e3590000 	cmp	r9, #0
348167d0:	1affff85 	bne	348165ec <onenand_erase+0xfc>
				goto erase_exit;
			}
		}
	}

	instr->state = MTD_ERASE_DONE;
348167d4:	e3a03008 	mov	r3, #8
348167d8:	e5c63038 	strb	r3, [r6, #56]	; 0x38

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
348167dc:	e5d63038 	ldrb	r3, [r6, #56]	; 0x38
348167e0:	e3530008 	cmp	r3, #8
348167e4:	13e00004 	mvnne	r0, #4
348167e8:	1a000004 	bne	34816800 <onenand_erase+0x310>
	/* Do call back function */
	if (!ret)
		mtd_erase_callback(instr);
348167ec:	e1a00006 	mov	r0, r6
348167f0:	ebfff548 	bl	34813d18 <mtd_erase_callback>
348167f4:	e3a00000 	mov	r0, #0
348167f8:	ea000000 	b	34816800 <onenand_erase+0x310>

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
348167fc:	e3e00015 	mvn	r0, #21

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	return ret;
}
34816800:	e28dd028 	add	sp, sp, #40	; 0x28
34816804:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816808:	34827864 	.word	0x34827864
3481680c:	348278a0 	.word	0x348278a0

34816810 <onenand_bbt_read_oob>:
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816810:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816814:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816818:	e24dd020 	sub	sp, sp, #32
3481681c:	e1a04000 	mov	r4, r0
34816820:	e1cd21f0 	strd	r2, [sp, #16]
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
34816824:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34816828:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
3481682c:	e590700c 	ldr	r7, [r0, #12]
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34816830:	e3130008 	tst	r3, #8
34816834:	03a01013 	moveq	r1, #19
34816838:	13a01000 	movne	r1, #0

	/* Initialize return value */
	ops->oobretlen = 0;
3481683c:	e3a03000 	mov	r3, #0
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34816840:	e58d101c 	str	r1, [sp, #28]

	/* Initialize return value */
	ops->oobretlen = 0;
34816844:	e5803010 	str	r3, [r0, #16]

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
34816848:	e594100c 	ldr	r1, [r4, #12]
3481684c:	e1cd21d0 	ldrd	r2, [sp, #16]
34816850:	e0922007 	adds	r2, r2, r7
34816854:	e2a33000 	adc	r3, r3, #0
34816858:	e1510003 	cmp	r1, r3
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
	u_char *buf = ops->oobbuf;
3481685c:	e590a01c 	ldr	sl, [r0, #28]

	/* Initialize return value */
	ops->oobretlen = 0;

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
34816860:	3a000003 	bcc	34816874 <onenand_bbt_read_oob+0x64>
34816864:	1a000006 	bne	34816884 <onenand_bbt_read_oob+0x74>
34816868:	e5941008 	ldr	r1, [r4, #8]
3481686c:	e1510002 	cmp	r1, r2
34816870:	2a000003 	bcs	34816884 <onenand_bbt_read_oob+0x74>
		printk(KERN_ERR "onenand_bbt_read_oob: Attempt read beyond end of device\n");
34816874:	e59f00f8 	ldr	r0, [pc, #248]	; 34816974 <onenand_bbt_read_oob+0x164>
34816878:	ebffcc92 	bl	34809ac8 <printf>
		return ONENAND_BBT_READ_FATAL_ERROR;
3481687c:	e3a00004 	mov	r0, #4
34816880:	ea000039 	b	3481696c <onenand_bbt_read_oob+0x15c>
	}

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);
34816884:	e594b018 	ldr	fp, [r4, #24]
34816888:	e59d2010 	ldr	r2, [sp, #16]
3481688c:	e24bb001 	sub	fp, fp, #1
34816890:	e00bb002 	and	fp, fp, r2
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
34816894:	e3a06000 	mov	r6, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816898:	ea00002e 	b	34816958 <onenand_bbt_read_oob+0x148>

		thislen = mtd->oobsize - column;
3481689c:	e5949018 	ldr	r9, [r4, #24]
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
348168a0:	e585a084 	str	sl, [r5, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
348168a4:	e58d9000 	str	r9, [sp]
348168a8:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348168ac:	e59d101c 	ldr	r1, [sp, #28]
348168b0:	e1cd21d0 	ldrd	r2, [sp, #16]
348168b4:	e1a00004 	mov	r0, r4
348168b8:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
348168bc:	e3a03000 	mov	r3, #0
348168c0:	e58d3000 	str	r3, [sp]
348168c4:	e5940094 	ldr	r0, [r4, #148]	; 0x94
348168c8:	e1cd21d0 	ldrd	r2, [sp, #16]
348168cc:	ebfff99c 	bl	34814f44 <onenand_update_bufferram.clone.2>

		ret = this->bbt_wait(mtd, FL_READING);
348168d0:	e5953058 	ldr	r3, [r5, #88]	; 0x58
348168d4:	e1a00004 	mov	r0, r4
348168d8:	e3a01001 	mov	r1, #1
348168dc:	e12fff33 	blx	r3
		if (unlikely(ret))
348168e0:	e3500000 	cmp	r0, #0
348168e4:	0a000005 	beq	34816900 <onenand_bbt_read_oob+0xf0>
			ret = onenand_recover_lsb(mtd, from, ret);
348168e8:	e58d0000 	str	r0, [sp]
348168ec:	e1cd21d0 	ldrd	r2, [sp, #16]
348168f0:	e1a00004 	mov	r0, r4
348168f4:	ebfffcc6 	bl	34815c14 <onenand_recover_lsb>

		if (ret)
348168f8:	e3500000 	cmp	r0, #0
348168fc:	1a000018 	bne	34816964 <onenand_bbt_read_oob+0x154>
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816900:	e59f0070 	ldr	r0, [pc, #112]	; 34816978 <onenand_bbt_read_oob+0x168>

	column = from & (mtd->oobsize - 1);

	while (read < len) {

		thislen = mtd->oobsize - column;
34816904:	e06b9009 	rsb	r9, fp, r9
		thislen = min_t(int, thislen, len);
34816908:	e1590007 	cmp	r9, r7
3481690c:	a1a09007 	movge	r9, r7
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816910:	e88d0c01 	stm	sp, {r0, sl, fp}
34816914:	e58d900c 	str	r9, [sp, #12]
34816918:	e5951060 	ldr	r1, [r5, #96]	; 0x60
3481691c:	e1a00004 	mov	r0, r4
34816920:	e3a02000 	mov	r2, #0
34816924:	e3a03000 	mov	r3, #0
		read += thislen;
34816928:	e0866009 	add	r6, r6, r9
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
3481692c:	e12fff31 	blx	r1
		read += thislen;
		if (read == len)
34816930:	e1560007 	cmp	r6, r7
34816934:	0a000009 	beq	34816960 <onenand_bbt_read_oob+0x150>
			break;

		buf += thislen;
34816938:	e08aa009 	add	sl, sl, r9

		/* Read more? */
		if (read < len) {
3481693c:	2a000005 	bcs	34816958 <onenand_bbt_read_oob+0x148>
			/* Update Page size */
			from += this->writesize;
34816940:	e5953040 	ldr	r3, [r5, #64]	; 0x40
34816944:	e1cd01d0 	ldrd	r0, [sp, #16]
34816948:	e0900003 	adds	r0, r0, r3
3481694c:	e2a11000 	adc	r1, r1, #0
34816950:	e1cd01f0 	strd	r0, [sp, #16]
			column = 0;
34816954:	e3a0b000 	mov	fp, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816958:	e1560007 	cmp	r6, r7
3481695c:	3affffce 	bcc	3481689c <onenand_bbt_read_oob+0x8c>
		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
		read += thislen;
		if (read == len)
34816960:	e3a00000 	mov	r0, #0
	}

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	ops->oobretlen = read;
34816964:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
34816968:	e5816010 	str	r6, [r1, #16]
	return ret;
}
3481696c:	e28dd020 	add	sp, sp, #32
34816970:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816974:	348278c2 	.word	0x348278c2
34816978:	00010020 	.word	0x00010020

3481697c <onenand_print_device_info>:
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
3481697c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34816980:	e1a06000 	mov	r6, r0
34816984:	e24dd014 	sub	sp, sp, #20
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816988:	e3a00050 	mov	r0, #80	; 0x50
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
3481698c:	e1a05001 	mov	r5, r1
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816990:	ebffce13 	bl	3480a1e4 <malloc>
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816994:	e59f1080 	ldr	r1, [pc, #128]	; 34816a1c <onenand_print_device_info+0xa0>
34816998:	e59f2080 	ldr	r2, [pc, #128]	; 34816a20 <onenand_print_device_info+0xa4>
3481699c:	e3160004 	tst	r6, #4
348169a0:	e59f307c 	ldr	r3, [pc, #124]	; 34816a24 <onenand_print_device_info+0xa8>
348169a4:	11a02001 	movne	r2, r1
348169a8:	e59fe078 	ldr	lr, [pc, #120]	; 34816a28 <onenand_print_device_info+0xac>
348169ac:	e3160c02 	tst	r6, #512	; 0x200
348169b0:	01a03001 	moveq	r3, r1
348169b4:	e3160008 	tst	r6, #8
348169b8:	11a0100e 	movne	r1, lr
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
348169bc:	e7e3c256 	ubfx	ip, r6, #4, #4
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
348169c0:	e3a0e010 	mov	lr, #16
348169c4:	e1a0ec1e 	lsl	lr, lr, ip
348169c8:	e59f705c 	ldr	r7, [pc, #92]	; 34816a2c <onenand_print_device_info+0xb0>
348169cc:	e59fc05c 	ldr	ip, [pc, #92]	; 34816a30 <onenand_print_device_info+0xb4>
348169d0:	e3160003 	tst	r6, #3
348169d4:	01a0c007 	moveq	ip, r7
348169d8:	e58d1000 	str	r1, [sp]
348169dc:	e59f1050 	ldr	r1, [pc, #80]	; 34816a34 <onenand_print_device_info+0xb8>
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
348169e0:	e1a04000 	mov	r4, r0
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
348169e4:	e58de004 	str	lr, [sp, #4]
348169e8:	e58dc008 	str	ip, [sp, #8]
348169ec:	e58d600c 	str	r6, [sp, #12]
348169f0:	eb001aa1 	bl	3481d47c <sprintf>
	       demuxed ? "" : "Muxed ",
	       flexonenand ? "Flex-" : "",
	       ddp ? "(DDP)" : "",
	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);

	sprintf(p, "\nOneNAND version = 0x%04x", version);
348169f4:	e1a02005 	mov	r2, r5
348169f8:	e0840000 	add	r0, r4, r0
348169fc:	e59f1034 	ldr	r1, [pc, #52]	; 34816a38 <onenand_print_device_info+0xbc>
34816a00:	eb001a9d 	bl	3481d47c <sprintf>
	printk("%s\n", dev_info);
34816a04:	e1a01004 	mov	r1, r4
34816a08:	e59f002c 	ldr	r0, [pc, #44]	; 34816a3c <onenand_print_device_info+0xc0>
34816a0c:	ebffcc2d 	bl	34809ac8 <printf>

	return dev_info;
}
34816a10:	e1a00004 	mov	r0, r4
34816a14:	e28dd014 	add	sp, sp, #20
34816a18:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34816a1c:	34823d17 	.word	0x34823d17
34816a20:	348278fb 	.word	0x348278fb
34816a24:	34827400 	.word	0x34827400
34816a28:	34827902 	.word	0x34827902
34816a2c:	34827911 	.word	0x34827911
34816a30:	34827908 	.word	0x34827908
34816a34:	34827915 	.word	0x34827915
34816a38:	3482793c 	.word	0x3482793c
34816a3c:	34825e78 	.word	0x34825e78

34816a40 <flexonenand_set_boundary>:
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816a40:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816a44:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816a48:	e24dd048 	sub	sp, sp, #72	; 0x48
34816a4c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816a50:	e5943004 	ldr	r3, [r4, #4]
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816a54:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816a58:	e1510003 	cmp	r1, r3
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816a5c:	e1a07001 	mov	r7, r1
34816a60:	e1a09002 	mov	r9, r2
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816a64:	2a0000d9 	bcs	34816dd0 <flexonenand_set_boundary+0x390>
		return -EINVAL;

	if (boundary == this->boundary[die])
34816a68:	e2813002 	add	r3, r1, #2
34816a6c:	e7943103 	ldr	r3, [r4, r3, lsl #2]
34816a70:	e1520003 	cmp	r2, r3
		return 0;
34816a74:	03a0a000 	moveq	sl, #0
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;

	if (boundary == this->boundary[die])
34816a78:	0a0000d5 	beq	34816dd4 <flexonenand_set_boundary+0x394>
		return 0;

	density = onenand_get_density(this->device_id);
34816a7c:	e594201c 	ldr	r2, [r4, #28]
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816a80:	e3a00401 	mov	r0, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816a84:	e7e31252 	ubfx	r1, r2, #4, #4

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816a88:	e1a01110 	lsl	r1, r0, r1
34816a8c:	e5940030 	ldr	r0, [r4, #48]	; 0x30
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34816a90:	e7e021d2 	ubfx	r2, r2, #3, #1

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816a94:	e1a01051 	asr	r1, r1, r0
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;

	if (boundary >= blksperdie) {
34816a98:	e1590251 	cmp	r9, r1, asr r2
34816a9c:	ba000002 	blt	34816aac <flexonenand_set_boundary+0x6c>
		printk("flexonenand_set_boundary:"
34816aa0:	e59f03c0 	ldr	r0, [pc, #960]	; 34816e68 <flexonenand_set_boundary+0x428>
34816aa4:	ebffcc07 	bl	34809ac8 <printf>
34816aa8:	ea0000c8 	b	34816dd0 <flexonenand_set_boundary+0x390>
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816aac:	e5942028 	ldr	r2, [r4, #40]	; 0x28
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816ab0:	e28da028 	add	sl, sp, #40	; 0x28
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816ab4:	e0020792 	mul	r2, r2, r7
34816ab8:	e0823003 	add	r3, r2, r3
	new = boundary + (die * this->density_mask);
34816abc:	e0822009 	add	r2, r2, r9
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
34816ac0:	e1520003 	cmp	r2, r3
34816ac4:	b1a06002 	movlt	r6, r2
34816ac8:	a1a06003 	movge	r6, r3
						+ 1, max(old, new));
34816acc:	e1520003 	cmp	r2, r3
34816ad0:	b1a02003 	movlt	r2, r3
	struct mtd_oob_ops ops = {
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
34816ad4:	e5943090 	ldr	r3, [r4, #144]	; 0x90

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
34816ad8:	e58d2018 	str	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816adc:	e3a01000 	mov	r1, #0
34816ae0:	e3a02020 	mov	r2, #32
34816ae4:	e1a0000a 	mov	r0, sl
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
34816ae8:	e595b018 	ldr	fp, [r5, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816aec:	e58d300c 	str	r3, [sp, #12]
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
34816af0:	e2866001 	add	r6, r6, #1
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816af4:	eb0016c7 	bl	3481c618 <memset>
34816af8:	e59d300c 	ldr	r3, [sp, #12]
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
34816afc:	e59f0368 	ldr	r0, [pc, #872]	; 34816e6c <flexonenand_set_boundary+0x42c>
34816b00:	e1a01006 	mov	r1, r6
34816b04:	e59d2018 	ldr	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816b08:	e58db034 	str	fp, [sp, #52]	; 0x34
34816b0c:	e58d3044 	str	r3, [sp, #68]	; 0x44
34816b10:	e1a0b007 	mov	fp, r7
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
34816b14:	ebffcbeb 	bl	34809ac8 <printf>
34816b18:	ea00004f 	b	34816c5c <flexonenand_set_boundary+0x21c>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34816b1c:	e594301c 	ldr	r3, [r4, #28]
34816b20:	e2133008 	ands	r3, r3, #8
34816b24:	01a07006 	moveq	r7, r6
34816b28:	0a00000b 	beq	34816b5c <flexonenand_set_boundary+0x11c>
34816b2c:	e5947028 	ldr	r7, [r4, #40]	; 0x28
34816b30:	e1560007 	cmp	r6, r7
34816b34:	31a07006 	movcc	r7, r6
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
34816b38:	33a03000 	movcc	r3, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34816b3c:	3a000006 	bcc	34816b5c <flexonenand_set_boundary+0x11c>
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
34816b40:	e5943010 	ldr	r3, [r4, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
34816b44:	e0677006 	rsb	r7, r7, r6
		die = 1;
		ofs = this->diesize[0];
34816b48:	e1a00003 	mov	r0, r3
34816b4c:	e3a01000 	mov	r1, #0
34816b50:	e1cd01f0 	strd	r0, [sp, #16]
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
34816b54:	e3a03001 	mov	r3, #1
34816b58:	ea000002 	b	34816b68 <flexonenand_set_boundary+0x128>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
34816b5c:	e3a00000 	mov	r0, #0
34816b60:	e3a01000 	mov	r1, #0
34816b64:	e1cd01f0 	strd	r0, [sp, #16]
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34816b68:	e2833002 	add	r3, r3, #2
34816b6c:	e794a103 	ldr	sl, [r4, r3, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
34816b70:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34816b74:	e1a00007 	mov	r0, r7
34816b78:	e1a01fc0 	asr	r1, r0, #31
34816b7c:	e243c001 	sub	ip, r3, #1
34816b80:	e1a0200c 	mov	r2, ip
34816b84:	e58dc00c 	str	ip, [sp, #12]
34816b88:	eb00252f 	bl	3482004c <__ashldi3>
34816b8c:	e1cd21d0 	ldrd	r2, [sp, #16]
34816b90:	e0922000 	adds	r2, r2, r0
34816b94:	e0a33001 	adc	r3, r3, r1
34816b98:	e1cd21f0 	strd	r2, [sp, #16]
	if (block > (boundary + 1))
34816b9c:	e28a2001 	add	r2, sl, #1
34816ba0:	e1570002 	cmp	r7, r2
34816ba4:	e59dc00c 	ldr	ip, [sp, #12]
34816ba8:	da000009 	ble	34816bd4 <flexonenand_set_boundary+0x194>
		ofs += (loff_t) (block - boundary - 1)
34816bac:	e2477001 	sub	r7, r7, #1
34816bb0:	e06aa007 	rsb	sl, sl, r7
			<< (this->erase_shift - 1);
34816bb4:	e1a0200c 	mov	r2, ip
34816bb8:	e1a0000a 	mov	r0, sl
34816bbc:	e1a01fc0 	asr	r1, r0, #31
34816bc0:	eb002521 	bl	3482004c <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
34816bc4:	e1cd21d0 	ldrd	r2, [sp, #16]
34816bc8:	e0922000 	adds	r2, r2, r0
34816bcc:	e0a33001 	adc	r3, r3, r1
34816bd0:	e1cd21f0 	strd	r2, [sp, #16]
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34816bd4:	e5953094 	ldr	r3, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34816bd8:	e3a0e000 	mov	lr, #0
34816bdc:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
34816be0:	e58de000 	str	lr, [sp]
34816be4:	e5931010 	ldr	r1, [r3, #16]
34816be8:	e1a00005 	mov	r0, r5
34816bec:	e1cd21d0 	ldrd	r2, [sp, #16]
34816bf0:	e12fff31 	blx	r1

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
		addr = flexonenand_addr(this, block);
		if (onenand_block_isbad_nolock(mtd, addr, 0))
34816bf4:	e3500000 	cmp	r0, #0
34816bf8:	1a000016 	bne	34816c58 <flexonenand_set_boundary+0x218>

		/*
		 * Since main area write results in ECC write to spare,
		 * it is sufficient to check only ECC bytes for change.
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
34816bfc:	e28d0028 	add	r0, sp, #40	; 0x28
34816c00:	e58d0000 	str	r0, [sp]
34816c04:	e1cd21d0 	ldrd	r2, [sp, #16]
34816c08:	e1a00005 	mov	r0, r5
34816c0c:	ebfffc26 	bl	34815cac <onenand_read_oob_nolock>
		if (ret)
34816c10:	e250a000 	subs	sl, r0, #0
34816c14:	1a000014 	bne	34816c6c <flexonenand_set_boundary+0x22c>
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
34816c18:	e5952018 	ldr	r2, [r5, #24]
34816c1c:	e3a03000 	mov	r3, #0
34816c20:	ea000004 	b	34816c38 <flexonenand_set_boundary+0x1f8>
			if (this->oob_buf[i] != 0xff)
34816c24:	e5941090 	ldr	r1, [r4, #144]	; 0x90
34816c28:	e7d11003 	ldrb	r1, [r1, r3]
34816c2c:	e35100ff 	cmp	r1, #255	; 0xff
34816c30:	1a000003 	bne	34816c44 <flexonenand_set_boundary+0x204>
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
		if (ret)
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
34816c34:	e2833001 	add	r3, r3, #1
34816c38:	e1530002 	cmp	r3, r2
34816c3c:	3afffff8 	bcc	34816c24 <flexonenand_set_boundary+0x1e4>
			if (this->oob_buf[i] != 0xff)
				break;

		if (i != mtd->oobsize) {
34816c40:	0a000004 	beq	34816c58 <flexonenand_set_boundary+0x218>
			printk(KERN_WARNING "Block %d not erased.\n", block);
34816c44:	e59f0224 	ldr	r0, [pc, #548]	; 34816e70 <flexonenand_set_boundary+0x430>
34816c48:	e1a01006 	mov	r1, r6
34816c4c:	ebffcb9d 	bl	34809ac8 <printf>
			return 1;
34816c50:	e3a0a001 	mov	sl, #1
34816c54:	ea000004 	b	34816c6c <flexonenand_set_boundary+0x22c>
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
34816c58:	e2866001 	add	r6, r6, #1
34816c5c:	e59d1018 	ldr	r1, [sp, #24]
34816c60:	e1560001 	cmp	r6, r1
34816c64:	daffffac 	ble	34816b1c <flexonenand_set_boundary+0xdc>
34816c68:	ea00005c 	b	34816de0 <flexonenand_set_boundary+0x3a0>
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
34816c6c:	e59f0200 	ldr	r0, [pc, #512]	; 34816e74 <flexonenand_set_boundary+0x434>
34816c70:	ebffcb94 	bl	34809ac8 <printf>
		return ret;
34816c74:	ea000056 	b	34816dd4 <flexonenand_set_boundary+0x394>
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
	ret = this->wait(mtd, FL_READING);

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
		printk(KERN_ERR "flexonenand_set_boundary: boundary locked\n");
34816c78:	e59f01f8 	ldr	r0, [pc, #504]	; 34816e78 <flexonenand_set_boundary+0x438>
34816c7c:	ebffcb91 	bl	34809ac8 <printf>
		goto out;
34816c80:	ea000043 	b	34816d94 <flexonenand_set_boundary+0x354>
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
34816c84:	e59de024 	ldr	lr, [sp, #36]	; 0x24
34816c88:	e59fc1ec 	ldr	ip, [pc, #492]	; 34816e7c <flexonenand_set_boundary+0x43c>
34816c8c:	e35e0000 	cmp	lr, #0
34816c90:	e59f31e8 	ldr	r3, [pc, #488]	; 34816e80 <flexonenand_set_boundary+0x440>
34816c94:	e59f01e8 	ldr	r0, [pc, #488]	; 34816e84 <flexonenand_set_boundary+0x444>
34816c98:	01a0300c 	moveq	r3, ip
34816c9c:	e1a01007 	mov	r1, r7
34816ca0:	e1a02009 	mov	r2, r9
34816ca4:	ebffcb87 	bl	34809ac8 <printf>
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
34816ca8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34816cac:	e3500000 	cmp	r0, #0
34816cb0:	03a06903 	moveq	r6, #49152	; 0xc000
34816cb4:	13a06000 	movne	r6, #0

	addr = die ? this->diesize[0] : 0;
34816cb8:	e3570000 	cmp	r7, #0
34816cbc:	15943010 	ldrne	r3, [r4, #16]
34816cc0:	11a00003 	movne	r0, r3
34816cc4:	13a01000 	movne	r1, #0
34816cc8:	11cd01f0 	strdne	r0, [sp, #16]
34816ccc:	03a02000 	moveq	r2, #0
34816cd0:	03a03000 	moveq	r3, #0
34816cd4:	01cd21f0 	strdeq	r2, [sp, #16]
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
34816cd8:	e3a03000 	mov	r3, #0
34816cdc:	e58d3000 	str	r3, [sp]
34816ce0:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816ce4:	e1cd21d0 	ldrd	r2, [sp, #16]
34816ce8:	e3a01094 	mov	r1, #148	; 0x94
34816cec:	e1a00005 	mov	r0, r5
34816cf0:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_ERASING);
34816cf4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816cf8:	e1a00005 	mov	r0, r5
34816cfc:	e3a01003 	mov	r1, #3
34816d00:	e12fff33 	blx	r3
	if (ret) {
34816d04:	e250a000 	subs	sl, r0, #0
		printk("flexonenand_set_boundary:"
34816d08:	159f0178 	ldrne	r0, [pc, #376]	; 34816e88 <flexonenand_set_boundary+0x448>
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);

	addr = die ? this->diesize[0] : 0;
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
	ret = this->wait(mtd, FL_ERASING);
	if (ret) {
34816d0c:	1a000012 	bne	34816d5c <flexonenand_set_boundary+0x31c>
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
34816d10:	e5941000 	ldr	r1, [r4]
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
34816d14:	e1a00b09 	lsl	r0, r9, #22
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
34816d18:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816d1c:	e1860b20 	orr	r0, r6, r0, lsr #22
34816d20:	e2811b01 	add	r1, r1, #1024	; 0x400
34816d24:	e12fff33 	blx	r3
	this->command(mtd, ONENAND_CMD_PROG, addr, 0);
34816d28:	e1cd21d0 	ldrd	r2, [sp, #16]
34816d2c:	e58da000 	str	sl, [sp]
34816d30:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816d34:	e3a01080 	mov	r1, #128	; 0x80
34816d38:	e1a00005 	mov	r0, r5
34816d3c:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
34816d40:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816d44:	e1a00005 	mov	r0, r5
34816d48:	e3a01002 	mov	r1, #2
34816d4c:	e12fff33 	blx	r3
	if (ret) {
34816d50:	e250a000 	subs	sl, r0, #0
34816d54:	0a000003 	beq	34816d68 <flexonenand_set_boundary+0x328>
		printk("flexonenand_set_boundary:"
34816d58:	e59f012c 	ldr	r0, [pc, #300]	; 34816e8c <flexonenand_set_boundary+0x44c>
34816d5c:	e1a01007 	mov	r1, r7
34816d60:	ebffcb58 	bl	34809ac8 <printf>
			"Failed PI write for Die %d\n", die);
		goto out;
34816d64:	ea00000a 	b	34816d94 <flexonenand_set_boundary+0x354>
	}

	this->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);
34816d68:	e58da000 	str	sl, [sp]
34816d6c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816d70:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816d74:	e3a01005 	mov	r1, #5
34816d78:	e1a00005 	mov	r0, r5
34816d7c:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
34816d80:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816d84:	e1a00005 	mov	r0, r5
34816d88:	e3a01002 	mov	r1, #2
34816d8c:	e12fff33 	blx	r3
34816d90:	e1a0a000 	mov	sl, r0
out:
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);
34816d94:	e5941000 	ldr	r1, [r4]
34816d98:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816d9c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816da0:	e3a000f0 	mov	r0, #240	; 0xf0
34816da4:	e2811040 	add	r1, r1, #64	; 0x40
34816da8:	e12fff33 	blx	r3
	this->wait(mtd, FL_RESETING);
34816dac:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816db0:	e1a00005 	mov	r0, r5
34816db4:	e3a01006 	mov	r1, #6
34816db8:	e12fff33 	blx	r3
	if (!ret)
34816dbc:	e35a0000 	cmp	sl, #0
34816dc0:	1a000003 	bne	34816dd4 <flexonenand_set_boundary+0x394>
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);
34816dc4:	e1a00005 	mov	r0, r5
34816dc8:	ebfff6a0 	bl	34814850 <flexonenand_get_size>
34816dcc:	ea000000 	b	34816dd4 <flexonenand_set_boundary+0x394>
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;
34816dd0:	e3e0a015 	mvn	sl, #21
	if (!ret)
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);

	return ret;
}
34816dd4:	e1a0000a 	mov	r0, sl
34816dd8:	e28dd048 	add	sp, sp, #72	; 0x48
34816ddc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
		return ret;
	}

	this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
34816de0:	e1a0000b 	mov	r0, fp
34816de4:	e1a01fc0 	asr	r1, r0, #31
34816de8:	e3a06000 	mov	r6, #0
34816dec:	e1cd01f8 	strd	r0, [sp, #24]
34816df0:	e1cd21d8 	ldrd	r2, [sp, #24]
34816df4:	e58d6000 	str	r6, [sp]
34816df8:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816dfc:	e3a01066 	mov	r1, #102	; 0x66
34816e00:	e1a00005 	mov	r0, r5
34816e04:	e12fff3c 	blx	ip
	this->wait(mtd, FL_SYNCING);
34816e08:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816e0c:	e3a01004 	mov	r1, #4
34816e10:	e1a00005 	mov	r0, r5
34816e14:	e12fff33 	blx	r3

	/* Check is boundary is locked */
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
34816e18:	e1cd21d8 	ldrd	r2, [sp, #24]
34816e1c:	e58d6000 	str	r6, [sp]
34816e20:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816e24:	e3011985 	movw	r1, #6533	; 0x1985
34816e28:	e1a00005 	mov	r0, r5
34816e2c:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_READING);
34816e30:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816e34:	e3a01001 	mov	r1, #1
34816e38:	e1a00005 	mov	r0, r5
34816e3c:	e12fff33 	blx	r3
34816e40:	e1a0a000 	mov	sl, r0

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
34816e44:	e5940000 	ldr	r0, [r4]
34816e48:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816e4c:	e2800b01 	add	r0, r0, #1024	; 0x400
34816e50:	e12fff33 	blx	r3
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
34816e54:	e1a00740 	asr	r0, r0, #14
34816e58:	e3500003 	cmp	r0, #3
34816e5c:	e1a0700b 	mov	r7, fp
34816e60:	1affff84 	bne	34816c78 <flexonenand_set_boundary+0x238>
34816e64:	eaffff86 	b	34816c84 <flexonenand_set_boundary+0x244>
34816e68:	34827956 	.word	0x34827956
34816e6c:	3482799e 	.word	0x3482799e
34816e70:	348279ba 	.word	0x348279ba
34816e74:	348279d0 	.word	0x348279d0
34816e78:	34827a16 	.word	0x34827a16
34816e7c:	34827419 	.word	0x34827419
34816e80:	34827410 	.word	0x34827410
34816e84:	34827a41 	.word	0x34827a41
34816e88:	34827a7b 	.word	0x34827a7b
34816e8c:	34827ab0 	.word	0x34827ab0

34816e90 <onenand_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
34816e90:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816e94:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
34816e98:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int dev_id, ver_id;
	int density;
	int ret;

	ret = this->chip_probe(mtd);
34816e9c:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34816ea0:	e12fff33 	blx	r3
	if (ret)
34816ea4:	e250a000 	subs	sl, r0, #0
34816ea8:	1a0000b6 	bne	34817188 <onenand_probe+0x2f8>
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
34816eac:	e5940000 	ldr	r0, [r4]
34816eb0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816eb4:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816eb8:	e2800002 	add	r0, r0, #2
34816ebc:	e12fff33 	blx	r3
34816ec0:	e1a06000 	mov	r6, r0
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
34816ec4:	e5940000 	ldr	r0, [r4]
34816ec8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816ecc:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816ed0:	e2800004 	add	r0, r0, #4
34816ed4:	e12fff33 	blx	r3
34816ed8:	e1a07000 	mov	r7, r0
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
34816edc:	e5940000 	ldr	r0, [r4]
34816ee0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816ee4:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816ee8:	e280000c 	add	r0, r0, #12
34816eec:	e12fff33 	blx	r3

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
34816ef0:	e1a01007 	mov	r1, r7
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
34816ef4:	e5840024 	str	r0, [r4, #36]	; 0x24

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
34816ef8:	e1a00006 	mov	r0, r6
34816efc:	ebfffe9e 	bl	3481697c <onenand_print_device_info>
34816f00:	e5850020 	str	r0, [r5, #32]
	this->device_id = dev_id;
	this->version_id = ver_id;
34816f04:	e5847020 	str	r7, [r4, #32]
 * - lock scheme
 * - two plane
 */
static void onenand_check_features(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34816f08:	e5957094 	ldr	r7, [r5, #148]	; 0x94
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
	this->device_id = dev_id;
34816f0c:	e584601c 	str	r6, [r4, #28]
{
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
34816f10:	e597301c 	ldr	r3, [r7, #28]
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
34816f14:	e5971020 	ldr	r1, [r7, #32]
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816f18:	e7e32253 	ubfx	r2, r3, #4, #4
	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;

	/* Lock scheme */
	switch (density) {
34816f1c:	e3520004 	cmp	r2, #4
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
34816f20:	e1a01421 	lsr	r1, r1, #8

	/* Lock scheme */
	switch (density) {
34816f24:	0a000009 	beq	34816f50 <onenand_probe+0xc0>
34816f28:	e3520005 	cmp	r2, #5
34816f2c:	0a000002 	beq	34816f3c <onenand_probe+0xac>
34816f30:	e3520003 	cmp	r2, #3
34816f34:	1a000011 	bne	34816f80 <onenand_probe+0xf0>
34816f38:	ea00000b 	b	34816f6c <onenand_probe+0xdc>
34816f3c:	e597202c 	ldr	r2, [r7, #44]	; 0x2c
	case ONENAND_DEVICE_DENSITY_4Gb:
		if (ONENAND_IS_DDP(this))
34816f40:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
34816f44:	13822004 	orrne	r2, r2, #4
		else
			this->options |= ONENAND_HAS_4KB_PAGE;
34816f48:	03822008 	orreq	r2, r2, #8
34816f4c:	e587202c 	str	r2, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_2Gb:
		/* 2Gb DDP don't have 2 plane */
		if (!ONENAND_IS_DDP(this))
34816f50:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
34816f54:	0597302c 	ldreq	r3, [r7, #44]	; 0x2c
34816f58:	03833004 	orreq	r3, r3, #4
34816f5c:	0587302c 	streq	r3, [r7, #44]	; 0x2c
		this->options |= ONENAND_HAS_UNLOCK_ALL;
34816f60:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816f64:	e3833002 	orr	r3, r3, #2
34816f68:	e587302c 	str	r3, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
34816f6c:	e3510000 	cmp	r1, #0
			this->options |= ONENAND_HAS_UNLOCK_ALL;
34816f70:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34816f74:	13833002 	orrne	r3, r3, #2
			this->options |= ONENAND_HAS_2PLANE;
		this->options |= ONENAND_HAS_UNLOCK_ALL;

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
34816f78:	1a000004 	bne	34816f90 <onenand_probe+0x100>
34816f7c:	ea000004 	b	34816f94 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_UNLOCK_ALL;
		break;

	default:
		/* Some OneNAND has continuous lock scheme */
		if (!process)
34816f80:	e3510000 	cmp	r1, #0
34816f84:	1a000002 	bne	34816f94 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_CONT_LOCK;
34816f88:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816f8c:	e3833001 	orr	r3, r3, #1
34816f90:	e587302c 	str	r3, [r7, #44]	; 0x2c
		break;
	}

	if (ONENAND_IS_MLC(this))
34816f94:	e5973024 	ldr	r3, [r7, #36]	; 0x24
34816f98:	e3130001 	tst	r3, #1
		this->options |= ONENAND_HAS_4KB_PAGE;
34816f9c:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34816fa0:	13833008 	orrne	r3, r3, #8
34816fa4:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (ONENAND_IS_4KB_PAGE(this))
34816fa8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816fac:	e3130008 	tst	r3, #8
		this->options &= ~ONENAND_HAS_2PLANE;
34816fb0:	13c33004 	bicne	r3, r3, #4
34816fb4:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (FLEXONENAND(this)) {
34816fb8:	e597301c 	ldr	r3, [r7, #28]
34816fbc:	e3130c02 	tst	r3, #512	; 0x200
		this->options &= ~ONENAND_HAS_CONT_LOCK;
34816fc0:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34816fc4:	13c33001 	bicne	r3, r3, #1
		this->options |= ONENAND_HAS_UNLOCK_ALL;
34816fc8:	13833002 	orrne	r3, r3, #2
34816fcc:	1587302c 	strne	r3, [r7, #44]	; 0x2c
	}

	if (this->options & ONENAND_HAS_CONT_LOCK)
34816fd0:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816fd4:	e3130001 	tst	r3, #1
34816fd8:	0a000001 	beq	34816fe4 <onenand_probe+0x154>
		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
34816fdc:	e59f01ac 	ldr	r0, [pc, #428]	; 34817190 <onenand_probe+0x300>
34816fe0:	ebffcab8 	bl	34809ac8 <printf>
	if (this->options & ONENAND_HAS_UNLOCK_ALL)
34816fe4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816fe8:	e3130002 	tst	r3, #2
34816fec:	0a000001 	beq	34816ff8 <onenand_probe+0x168>
		printk(KERN_DEBUG "Chip support all block unlock\n");
34816ff0:	e59f019c 	ldr	r0, [pc, #412]	; 34817194 <onenand_probe+0x304>
34816ff4:	ebffcab3 	bl	34809ac8 <printf>
	if (this->options & ONENAND_HAS_2PLANE)
34816ff8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816ffc:	e3130004 	tst	r3, #4
34817000:	0a000001 	beq	3481700c <onenand_probe+0x17c>
		printk(KERN_DEBUG "Chip has 2 plane\n");
34817004:	e59f018c 	ldr	r0, [pc, #396]	; 34817198 <onenand_probe+0x308>
34817008:	ebffcaae 	bl	34809ac8 <printf>
	if (this->options & ONENAND_HAS_4KB_PAGE)
3481700c:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34817010:	e3130008 	tst	r3, #8
34817014:	0a000001 	beq	34817020 <onenand_probe+0x190>
		printk(KERN_DEBUG "Chip has 4KiB pagesize\n");
34817018:	e59f017c 	ldr	r0, [pc, #380]	; 3481719c <onenand_probe+0x30c>
3481701c:	ebffcaa9 	bl	34809ac8 <printf>

	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
34817020:	e594301c 	ldr	r3, [r4, #28]
34817024:	e3130c02 	tst	r3, #512	; 0x200
34817028:	0a00000c 	beq	34817060 <onenand_probe+0x1d0>
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
3481702c:	e3130008 	tst	r3, #8
34817030:	03a03001 	moveq	r3, #1
34817034:	13a03002 	movne	r3, #2
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
34817038:	e1a02083 	lsl	r2, r3, #1
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
3481703c:	e3a00030 	mov	r0, #48	; 0x30
	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
34817040:	e5843004 	str	r3, [r4, #4]
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817044:	e0000390 	mul	r0, r0, r3

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
34817048:	e585202c 	str	r2, [r5, #44]	; 0x2c
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
3481704c:	ebffcc64 	bl	3480a1e4 <malloc>
					* (this->dies << 1));
		if (!mtd->eraseregions)
34817050:	e3500000 	cmp	r0, #0
	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817054:	e5850030 	str	r0, [r5, #48]	; 0x30
					* (this->dies << 1));
		if (!mtd->eraseregions)
			return -ENOMEM;
34817058:	03e0a00b 	mvneq	sl, #11
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
					* (this->dies << 1));
		if (!mtd->eraseregions)
3481705c:	0a000049 	beq	34817188 <onenand_probe+0x2f8>

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34817060:	e3a03401 	mov	r3, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34817064:	e7e36256 	ubfx	r6, r6, #4, #4

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34817068:	e1a06613 	lsl	r6, r3, r6

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
3481706c:	e5940000 	ldr	r0, [r4]

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34817070:	e5846018 	str	r6, [r4, #24]

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34817074:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34817078:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481707c:	e2800006 	add	r0, r0, #6
34817080:	e12fff33 	blx	r3
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34817084:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	 */
	this->chipsize = (16 << density) << 20;

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
34817088:	e5850014 	str	r0, [r5, #20]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
3481708c:	e3130008 	tst	r3, #8
		mtd->writesize <<= 1;
34817090:	11a00080 	lslne	r0, r0, #1
34817094:	15850014 	strne	r0, [r5, #20]

	mtd->oobsize = mtd->writesize >> 5;
34817098:	e5956014 	ldr	r6, [r5, #20]
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
3481709c:	e594701c 	ldr	r7, [r4, #28]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
348170a0:	e1a032a6 	lsr	r3, r6, #5
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
348170a4:	e2179c02 	ands	r9, r7, #512	; 0x200
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
348170a8:	e5853018 	str	r3, [r5, #24]
	/* Pagers per block is always 64 in OneNAND */
	mtd->erasesize = mtd->writesize << 6;
348170ac:	e1a03306 	lsl	r3, r6, #6
348170b0:	e5853010 	str	r3, [r5, #16]
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;
348170b4:	11a03386 	lslne	r3, r6, #7
348170b8:	15853010 	strne	r3, [r5, #16]

	this->erase_shift = ffs(mtd->erasesize) - 1;
348170bc:	e5953010 	ldr	r3, [r5, #16]
348170c0:	e1a00003 	mov	r0, r3
348170c4:	e58d3000 	str	r3, [sp]
348170c8:	ebfff50a 	bl	348144f8 <generic_ffs>
348170cc:	e2402001 	sub	r2, r0, #1
348170d0:	e1a0b000 	mov	fp, r0
348170d4:	e5842030 	str	r2, [r4, #48]	; 0x30
	this->page_shift = ffs(mtd->writesize) - 1;
348170d8:	e1a00006 	mov	r0, r6
348170dc:	e58d2004 	str	r2, [sp, #4]
348170e0:	ebfff504 	bl	348144f8 <generic_ffs>
	this->ppb_shift = (this->erase_shift - this->page_shift);
348170e4:	e59d2004 	ldr	r2, [sp, #4]
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348170e8:	e59d3000 	ldr	r3, [sp]
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
348170ec:	e2400001 	sub	r0, r0, #1
	this->ppb_shift = (this->erase_shift - this->page_shift);
348170f0:	e0602002 	rsb	r2, r0, r2
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
348170f4:	e5840034 	str	r0, [r4, #52]	; 0x34
	this->ppb_shift = (this->erase_shift - this->page_shift);
348170f8:	e5842038 	str	r2, [r4, #56]	; 0x38
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348170fc:	e1a00003 	mov	r0, r3
34817100:	e1a01006 	mov	r1, r6
34817104:	eb0022af 	bl	3481fbc8 <__udivsi3>
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
34817108:	e3170008 	tst	r7, #8
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
3481710c:	15943018 	ldrne	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
34817110:	e2400001 	sub	r0, r0, #1
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
34817114:	11a0bb33 	lsrne	fp, r3, fp
34817118:	1584b028 	strne	fp, [r4, #40]	; 0x28
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
3481711c:	e3590000 	cmp	r9, #0
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
34817120:	05943018 	ldreq	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
34817124:	e584003c 	str	r0, [r4, #60]	; 0x3c
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
	/* It's real page size */
	this->writesize = mtd->writesize;
34817128:	e5846040 	str	r6, [r4, #64]	; 0x40
	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
3481712c:	05853008 	streq	r3, [r5, #8]
34817130:	0585900c 	streq	r9, [r5, #12]
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
34817134:	0a000001 	beq	34817140 <onenand_probe+0x2b0>
		flexonenand_get_size(mtd);
34817138:	e1a00005 	mov	r0, r5
3481713c:	ebfff5c3 	bl	34814850 <flexonenand_get_size>
	else
		mtd->size = this->chipsize;

	mtd->flags = MTD_CAP_NANDFLASH;
34817140:	e3a03b01 	mov	r3, #1024	; 0x400
34817144:	e5853004 	str	r3, [r5, #4]
	mtd->erase = onenand_erase;
34817148:	e59f3050 	ldr	r3, [pc, #80]	; 348171a0 <onenand_probe+0x310>
3481714c:	e5853034 	str	r3, [r5, #52]	; 0x34
	mtd->read = onenand_read;
34817150:	e59f304c 	ldr	r3, [pc, #76]	; 348171a4 <onenand_probe+0x314>
34817154:	e5853040 	str	r3, [r5, #64]	; 0x40
	mtd->write = onenand_write;
34817158:	e59f3048 	ldr	r3, [pc, #72]	; 348171a8 <onenand_probe+0x318>
3481715c:	e5853044 	str	r3, [r5, #68]	; 0x44
	mtd->read_oob = onenand_read_oob;
34817160:	e59f3044 	ldr	r3, [pc, #68]	; 348171ac <onenand_probe+0x31c>
34817164:	e585304c 	str	r3, [r5, #76]	; 0x4c
	mtd->write_oob = onenand_write_oob;
34817168:	e59f3040 	ldr	r3, [pc, #64]	; 348171b0 <onenand_probe+0x320>
3481716c:	e5853050 	str	r3, [r5, #80]	; 0x50
	mtd->sync = onenand_sync;
34817170:	e59f303c 	ldr	r3, [pc, #60]	; 348171b4 <onenand_probe+0x324>
34817174:	e585306c 	str	r3, [r5, #108]	; 0x6c
	mtd->block_isbad = onenand_block_isbad;
34817178:	e59f3038 	ldr	r3, [pc, #56]	; 348171b8 <onenand_probe+0x328>
3481717c:	e5853078 	str	r3, [r5, #120]	; 0x78
	mtd->block_markbad = onenand_block_markbad;
34817180:	e59f3034 	ldr	r3, [pc, #52]	; 348171bc <onenand_probe+0x32c>
34817184:	e585307c 	str	r3, [r5, #124]	; 0x7c

	return 0;
}
34817188:	e1a0000a 	mov	r0, sl
3481718c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34817190:	34827ae5 	.word	0x34827ae5
34817194:	34827b05 	.word	0x34827b05
34817198:	34827b24 	.word	0x34827b24
3481719c:	34827b36 	.word	0x34827b36
348171a0:	348164f0 	.word	0x348164f0
348171a4:	34816490 	.word	0x34816490
348171a8:	3481571c 	.word	0x3481571c
348171ac:	34816460 	.word	0x34816460
348171b0:	348156ec 	.word	0x348156ec
348171b4:	348146c8 	.word	0x348146c8
348171b8:	348146cc 	.word	0x348146cc
348171bc:	34814710 	.word	0x34814710

348171c0 <onenand_scan>:
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
348171c0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	struct onenand_chip *this = mtd->priv;
348171c4:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
348171c8:	e1a06000 	mov	r6, r0
	int i;
	struct onenand_chip *this = mtd->priv;

	if (!this->read_word)
348171cc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348171d0:	e3530000 	cmp	r3, #0
		this->read_word = onenand_readw;
348171d4:	059f3568 	ldreq	r3, [pc, #1384]	; 34817744 <onenand_scan+0x584>
348171d8:	05843068 	streq	r3, [r4, #104]	; 0x68
	if (!this->write_word)
348171dc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348171e0:	e3530000 	cmp	r3, #0
		this->write_word = onenand_writew;
348171e4:	059f355c 	ldreq	r3, [pc, #1372]	; 34817748 <onenand_scan+0x588>
348171e8:	0584306c 	streq	r3, [r4, #108]	; 0x6c

	if (!this->command)
348171ec:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348171f0:	e3530000 	cmp	r3, #0
		this->command = onenand_command;
348171f4:	059f3550 	ldreq	r3, [pc, #1360]	; 3481774c <onenand_scan+0x58c>
348171f8:	05843050 	streq	r3, [r4, #80]	; 0x50
	if (!this->wait)
348171fc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34817200:	e3530000 	cmp	r3, #0
		this->wait = onenand_wait;
34817204:	059f3544 	ldreq	r3, [pc, #1348]	; 34817750 <onenand_scan+0x590>
34817208:	05843054 	streq	r3, [r4, #84]	; 0x54
	if (!this->bbt_wait)
3481720c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34817210:	e3530000 	cmp	r3, #0
		this->bbt_wait = onenand_bbt_wait;
34817214:	059f3538 	ldreq	r3, [pc, #1336]	; 34817754 <onenand_scan+0x594>
34817218:	05843058 	streq	r3, [r4, #88]	; 0x58

	if (!this->read_bufferram)
3481721c:	e5943060 	ldr	r3, [r4, #96]	; 0x60
34817220:	e3530000 	cmp	r3, #0
		this->read_bufferram = onenand_read_bufferram;
34817224:	059f352c 	ldreq	r3, [pc, #1324]	; 34817758 <onenand_scan+0x598>
34817228:	05843060 	streq	r3, [r4, #96]	; 0x60
	if (!this->write_bufferram)
3481722c:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34817230:	e3530000 	cmp	r3, #0
		this->write_bufferram = onenand_write_bufferram;
34817234:	059f3520 	ldreq	r3, [pc, #1312]	; 3481775c <onenand_scan+0x59c>
34817238:	05843064 	streq	r3, [r4, #100]	; 0x64

	if (!this->chip_probe)
3481723c:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34817240:	e3530000 	cmp	r3, #0
		this->chip_probe = onenand_chip_probe;
34817244:	059f3514 	ldreq	r3, [pc, #1300]	; 34817760 <onenand_scan+0x5a0>
34817248:	05843070 	streq	r3, [r4, #112]	; 0x70

	if (!this->block_markbad)
3481724c:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34817250:	e3530000 	cmp	r3, #0
		this->block_markbad = onenand_default_block_markbad;
34817254:	059f3508 	ldreq	r3, [pc, #1288]	; 34817764 <onenand_scan+0x5a4>
34817258:	05843078 	streq	r3, [r4, #120]	; 0x78
	if (!this->scan_bbt)
3481725c:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34817260:	e3530000 	cmp	r3, #0
		this->scan_bbt = onenand_default_bbt;
34817264:	059f34fc 	ldreq	r3, [pc, #1276]	; 34817768 <onenand_scan+0x5a8>
34817268:	0584307c 	streq	r3, [r4, #124]	; 0x7c

	if (onenand_probe(mtd))
3481726c:	ebffff07 	bl	34816e90 <onenand_probe>
34817270:	e3500000 	cmp	r0, #0
		return -ENXIO;
34817274:	13e00005 	mvnne	r0, #5
	if (!this->block_markbad)
		this->block_markbad = onenand_default_block_markbad;
	if (!this->scan_bbt)
		this->scan_bbt = onenand_default_bbt;

	if (onenand_probe(mtd))
34817278:	1a00012f 	bne	3481773c <onenand_scan+0x57c>
		return -ENXIO;

	/* Set Sync. Burst Read after probing */
	if (this->mmcontrol) {
3481727c:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34817280:	e3530000 	cmp	r3, #0
34817284:	0a000003 	beq	34817298 <onenand_scan+0xd8>
		printk(KERN_INFO "OneNAND Sync. Burst Read support\n");
34817288:	e59f04dc 	ldr	r0, [pc, #1244]	; 3481776c <onenand_scan+0x5ac>
3481728c:	ebffca0d 	bl	34809ac8 <printf>
		this->read_bufferram = onenand_sync_read_bufferram;
34817290:	e59f34d8 	ldr	r3, [pc, #1240]	; 34817770 <onenand_scan+0x5b0>
34817294:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
34817298:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
3481729c:	e3530000 	cmp	r3, #0
348172a0:	1a00000b 	bne	348172d4 <onenand_scan+0x114>
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
348172a4:	e5960014 	ldr	r0, [r6, #20]
348172a8:	e3a01001 	mov	r1, #1
348172ac:	ebffcd39 	bl	3480a798 <calloc>
		if (!this->page_buf) {
348172b0:	e3500000 	cmp	r0, #0
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
348172b4:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
		this->read_bufferram = onenand_sync_read_bufferram;
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
348172b8:	e584008c 	str	r0, [r4, #140]	; 0x8c
		if (!this->page_buf) {
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
348172bc:	13833a01 	orrne	r3, r3, #4096	; 0x1000
348172c0:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
		if (!this->page_buf) {
348172c4:	1a000002 	bne	348172d4 <onenand_scan+0x114>
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
348172c8:	e59f04a4 	ldr	r0, [pc, #1188]	; 34817774 <onenand_scan+0x5b4>
348172cc:	ebffc9fd 	bl	34809ac8 <printf>
348172d0:	ea000118 	b	34817738 <onenand_scan+0x578>
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
348172d4:	e5943090 	ldr	r3, [r4, #144]	; 0x90
348172d8:	e3530000 	cmp	r3, #0
348172dc:	1a000012 	bne	3481732c <onenand_scan+0x16c>
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
348172e0:	e5960018 	ldr	r0, [r6, #24]
348172e4:	e3a01001 	mov	r1, #1
348172e8:	ebffcd2a 	bl	3480a798 <calloc>
		if (!this->oob_buf) {
348172ec:	e3500000 	cmp	r0, #0
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
348172f0:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
348172f4:	e5840090 	str	r0, [r4, #144]	; 0x90
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
348172f8:	13833a02 	orrne	r3, r3, #8192	; 0x2000
348172fc:	1584302c 	strne	r3, [r4, #44]	; 0x2c
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
		if (!this->oob_buf) {
34817300:	1a000009 	bne	3481732c <onenand_scan+0x16c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
34817304:	e59f046c 	ldr	r0, [pc, #1132]	; 34817778 <onenand_scan+0x5b8>
34817308:	ebffc9ee 	bl	34809ac8 <printf>
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
3481730c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34817310:	e3130a01 	tst	r3, #4096	; 0x1000
34817314:	0a000107 	beq	34817738 <onenand_scan+0x578>
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
34817318:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
3481731c:	e584302c 	str	r3, [r4, #44]	; 0x2c
				kfree(this->page_buf);
34817320:	e594008c 	ldr	r0, [r4, #140]	; 0x8c
34817324:	ebffcb25 	bl	34809fc0 <free>
34817328:	ea000102 	b	34817738 <onenand_scan+0x578>
	this->state = FL_READY;

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
3481732c:	e5961018 	ldr	r1, [r6, #24]
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
34817330:	e3a05000 	mov	r5, #0

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34817334:	e3510040 	cmp	r1, #64	; 0x40
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
34817338:	e5845088 	str	r5, [r4, #136]	; 0x88

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
3481733c:	0a000009 	beq	34817368 <onenand_scan+0x1a8>
34817340:	e3510080 	cmp	r1, #128	; 0x80
34817344:	0a000003 	beq	34817358 <onenand_scan+0x198>
34817348:	e3510020 	cmp	r1, #32
3481734c:	e59f7428 	ldr	r7, [pc, #1064]	; 3481777c <onenand_scan+0x5bc>
34817350:	1a00000c 	bne	34817388 <onenand_scan+0x1c8>
34817354:	ea000007 	b	34817378 <onenand_scan+0x1b8>
	case 128:
		this->ecclayout = &onenand_oob_128;
34817358:	e59f3420 	ldr	r3, [pc, #1056]	; 34817780 <onenand_scan+0x5c0>
3481735c:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 0;
34817360:	e5865090 	str	r5, [r6, #144]	; 0x90
		break;
34817364:	ea00000b 	b	34817398 <onenand_scan+0x1d8>

	case 64:
		this->ecclayout = &onenand_oob_64;
34817368:	e59f3414 	ldr	r3, [pc, #1044]	; 34817784 <onenand_scan+0x5c4>
3481736c:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 2;
34817370:	e3a03002 	mov	r3, #2
34817374:	ea000001 	b	34817380 <onenand_scan+0x1c0>
		break;

	case 32:
		this->ecclayout = &onenand_oob_32;
34817378:	e584709c 	str	r7, [r4, #156]	; 0x9c
		mtd->subpage_sft = 1;
3481737c:	e3a03001 	mov	r3, #1
34817380:	e5863090 	str	r3, [r6, #144]	; 0x90
		break;
34817384:	ea000003 	b	34817398 <onenand_scan+0x1d8>

	default:
		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
34817388:	e59f03f8 	ldr	r0, [pc, #1016]	; 34817788 <onenand_scan+0x5c8>
3481738c:	ebffc9cd 	bl	34809ac8 <printf>
			mtd->oobsize);
		mtd->subpage_sft = 0;
34817390:	e5865090 	str	r5, [r6, #144]	; 0x90
		/* To prevent kernel oops */
		this->ecclayout = &onenand_oob_32;
34817394:	e584709c 	str	r7, [r4, #156]	; 0x9c
		break;
	}

	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
34817398:	e5962014 	ldr	r2, [r6, #20]
3481739c:	e5963090 	ldr	r3, [r6, #144]	; 0x90
348173a0:	e1a03332 	lsr	r3, r2, r3
348173a4:	e5843098 	str	r3, [r4, #152]	; 0x98

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
348173a8:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
348173ac:	e3a02000 	mov	r2, #0
348173b0:	e5832204 	str	r2, [r3, #516]	; 0x204
 * This fills out all the not initialized function pointers
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
348173b4:	e2830040 	add	r0, r3, #64	; 0x40

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
348173b8:	e1a02003 	mov	r2, r3
348173bc:	ea000005 	b	348173d8 <onenand_scan+0x218>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
348173c0:	e593c204 	ldr	ip, [r3, #516]	; 0x204
348173c4:	e2822008 	add	r2, r2, #8
348173c8:	e08c1001 	add	r1, ip, r1
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348173cc:	e1520000 	cmp	r2, r0
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
348173d0:	e5831204 	str	r1, [r3, #516]	; 0x204
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348173d4:	0a000002 	beq	348173e4 <onenand_scan+0x224>
	    this->ecclayout->oobfree[i].length; i++)
348173d8:	e592120c 	ldr	r1, [r2, #524]	; 0x20c
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348173dc:	e3510000 	cmp	r1, #0
348173e0:	1afffff6 	bne	348173c0 <onenand_scan+0x200>
 *
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
348173e4:	e5965094 	ldr	r5, [r6, #148]	; 0x94
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
348173e8:	e5932204 	ldr	r2, [r3, #516]	; 0x204

	mtd->ecclayout = this->ecclayout;
348173ec:	e5863028 	str	r3, [r6, #40]	; 0x28
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348173f0:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
348173f4:	e586201c 	str	r2, [r6, #28]
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348173f8:	e3130002 	tst	r3, #2
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;
348173fc:	e596a008 	ldr	sl, [r6, #8]

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817400:	0a000050 	beq	34817548 <onenand_scan+0x388>
		/* Set start block address */
		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
34817404:	e5951000 	ldr	r1, [r5]
34817408:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481740c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34817410:	e3a00000 	mov	r0, #0
34817414:	e2811098 	add	r1, r1, #152	; 0x98
34817418:	e12fff33 	blx	r3
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
3481741c:	e3a03000 	mov	r3, #0
34817420:	e58d3000 	str	r3, [sp]
34817424:	e3a01027 	mov	r1, #39	; 0x27
34817428:	e3a03000 	mov	r3, #0
3481742c:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34817430:	e1a00006 	mov	r0, r6
34817434:	e3a02000 	mov	r2, #0
34817438:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_LOCKING);
3481743c:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34817440:	e1a00006 	mov	r0, r6
34817444:	e3a01008 	mov	r1, #8
34817448:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
3481744c:	e5950000 	ldr	r0, [r5]
34817450:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34817454:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34817458:	e2800080 	add	r0, r0, #128	; 0x80
3481745c:	e12fff33 	blx	r3
34817460:	e3100902 	tst	r0, #32768	; 0x8000
34817464:	1afffff8 	bne	3481744c <onenand_scan+0x28c>
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
34817468:	e5959018 	ldr	r9, [r5, #24]
3481746c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	for (block = 0; block < end; block++) {
34817470:	e3a07000 	mov	r7, #0
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
34817474:	e1a09339 	lsr	r9, r9, r3
34817478:	ea00002f 	b	3481753c <onenand_scan+0x37c>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
3481747c:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817480:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817484:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34817488:	10270000 	eorne	r0, r7, r0
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
3481748c:	01a00007 	moveq	r0, r7
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34817490:	13800902 	orrne	r0, r0, #32768	; 0x8000

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817494:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34817498:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481749c:	e6ff0070 	uxth	r0, r0
348174a0:	e2811c02 	add	r1, r1, #512	; 0x200
348174a4:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
348174a8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
348174ac:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
348174b0:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
348174b4:	e59f12d0 	ldr	r1, [pc, #720]	; 3481778c <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
348174b8:	01a00003 	moveq	r0, r3
348174bc:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
348174c0:	e0821001 	add	r1, r2, r1
348174c4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348174c8:	e6ff0070 	uxth	r0, r0
348174cc:	e12fff33 	blx	r3
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
348174d0:	e5951000 	ldr	r1, [r5]
348174d4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348174d8:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348174dc:	e6ff0077 	uxth	r0, r7
348174e0:	e2811098 	add	r1, r1, #152	; 0x98
348174e4:	e12fff33 	blx	r3

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348174e8:	e5950000 	ldr	r0, [r5]
348174ec:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348174f0:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348174f4:	e280009c 	add	r0, r0, #156	; 0x9c
348174f8:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US)) {
348174fc:	e3100004 	tst	r0, #4
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34817500:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US)) {
34817504:	1a00000b 	bne	34817538 <onenand_scan+0x378>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
34817508:	e59f0280 	ldr	r0, [pc, #640]	; 34817790 <onenand_scan+0x5d0>
3481750c:	e1a01007 	mov	r1, r7
34817510:	ebffc96c 	bl	34809ac8 <printf>
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34817514:	e595301c 	ldr	r3, [r5, #28]
34817518:	e2033f82 	and	r3, r3, #520	; 0x208
3481751c:	e3530008 	cmp	r3, #8
			/* All blocks on another chip */
			ofs = this->chipsize >> 1;
34817520:	0595a018 	ldreq	sl, [r5, #24]
34817524:	01a0a0aa 	lsreq	sl, sl, #1
34817528:	01a0200a 	moveq	r2, sl
3481752c:	03a03000 	moveq	r3, #0
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34817530:	1a000004 	bne	34817548 <onenand_scan+0x388>
34817534:	ea000005 	b	34817550 <onenand_scan+0x390>
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
34817538:	e2877001 	add	r7, r7, #1
3481753c:	e1570009 	cmp	r7, r9
34817540:	3affffcd 	bcc	3481747c <onenand_scan+0x2bc>
34817544:	ea000077 	b	34817728 <onenand_scan+0x568>
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34817548:	e3a02000 	mov	r2, #0
3481754c:	e3a03000 	mov	r3, #0
 *
 * Lock or unlock one or more blocks
 */
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
34817550:	e5965094 	ldr	r5, [r6, #148]	; 0x94
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34817554:	e1cd20f8 	strd	r2, [sp, #8]
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
34817558:	e1cd20d8 	ldrd	r2, [sp, #8]
3481755c:	e1a00005 	mov	r0, r5
34817560:	ebfff885 	bl	3481577c <onenand_block>
	end = onenand_block(this, ofs + len);
34817564:	e1cd20d8 	ldrd	r2, [sp, #8]
34817568:	e092200a 	adds	r2, r2, sl
3481756c:	e2a33000 	adc	r3, r3, #0
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
34817570:	e1a07000 	mov	r7, r0
34817574:	e1a0b000 	mov	fp, r0
	end = onenand_block(this, ofs + len);
34817578:	e1a00005 	mov	r0, r5
3481757c:	ebfff87e 	bl	3481577c <onenand_block>

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34817580:	e595902c 	ldr	r9, [r5, #44]	; 0x2c
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
	end = onenand_block(this, ofs + len);
34817584:	e1a0a000 	mov	sl, r0

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34817588:	e2199001 	ands	r9, r9, #1
3481758c:	0a000063 	beq	34817720 <onenand_scan+0x560>
		/* Set start block address */
		this->write_word(start,
34817590:	e5951000 	ldr	r1, [r5]
34817594:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34817598:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481759c:	e6ff0077 	uxth	r0, r7
348175a0:	e2811098 	add	r1, r1, #152	; 0x98
348175a4:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Set end block address */
		this->write_word(end - 1,
348175a8:	e5951000 	ldr	r1, [r5]
348175ac:	e24a0001 	sub	r0, sl, #1
348175b0:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348175b4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348175b8:	e6ff0070 	uxth	r0, r0
348175bc:	e281109a 	add	r1, r1, #154	; 0x9a
348175c0:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, cmd, 0, 0);
348175c4:	e3a03000 	mov	r3, #0
348175c8:	e58d3000 	str	r3, [sp]
348175cc:	e3a01023 	mov	r1, #35	; 0x23
348175d0:	e3a03000 	mov	r3, #0
348175d4:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348175d8:	e1a00006 	mov	r0, r6
348175dc:	e3a02000 	mov	r2, #0
348175e0:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
348175e4:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348175e8:	e1a00006 	mov	r0, r6
348175ec:	e3a01007 	mov	r1, #7
348175f0:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
348175f4:	e5950000 	ldr	r0, [r5]
348175f8:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348175fc:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34817600:	e2800080 	add	r0, r0, #128	; 0x80
34817604:	e12fff33 	blx	r3
34817608:	e3100902 	tst	r0, #32768	; 0x8000
3481760c:	1afffff8 	bne	348175f4 <onenand_scan+0x434>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34817610:	e5950000 	ldr	r0, [r5]
34817614:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34817618:	e2800b79 	add	r0, r0, #123904	; 0x1e400
3481761c:	e280009c 	add	r0, r0, #156	; 0x9c
34817620:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34817624:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34817628:	e1a01000 	mov	r1, r0
		if (!(status & ONENAND_WP_US))
3481762c:	1a00003d 	bne	34817728 <onenand_scan+0x568>
			printk(KERN_ERR "wp status = 0x%x\n", status);
34817630:	e59f015c 	ldr	r0, [pc, #348]	; 34817794 <onenand_scan+0x5d4>
34817634:	ebffc923 	bl	34809ac8 <printf>
34817638:	ea00003a 	b	34817728 <onenand_scan+0x568>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
3481763c:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817640:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817644:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34817648:	10270000 	eorne	r0, r7, r0
3481764c:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817650:	01a00007 	moveq	r0, r7

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817654:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34817658:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481765c:	e6ff0070 	uxth	r0, r0
34817660:	e2811c02 	add	r1, r1, #512	; 0x200
34817664:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34817668:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
3481766c:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34817670:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817674:	e59f1110 	ldr	r1, [pc, #272]	; 3481778c <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34817678:	01a00003 	moveq	r0, r3
3481767c:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817680:	e0821001 	add	r1, r2, r1
34817684:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34817688:	e6ff0070 	uxth	r0, r0
3481768c:	e12fff33 	blx	r3

		/* Set start block address */
		this->write_word(block,
34817690:	e5951000 	ldr	r1, [r5]
34817694:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34817698:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481769c:	e6ff0077 	uxth	r0, r7
348176a0:	e2811098 	add	r1, r1, #152	; 0x98
348176a4:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
348176a8:	e58d9000 	str	r9, [sp]
348176ac:	e3a01023 	mov	r1, #35	; 0x23
348176b0:	e3a03000 	mov	r3, #0
348176b4:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348176b8:	e1a00006 	mov	r0, r6
348176bc:	e3a02000 	mov	r2, #0
348176c0:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
348176c4:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348176c8:	e1a00006 	mov	r0, r6
348176cc:	e3a01007 	mov	r1, #7
348176d0:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
348176d4:	e5950000 	ldr	r0, [r5]
348176d8:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348176dc:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348176e0:	e2800080 	add	r0, r0, #128	; 0x80
348176e4:	e12fff33 	blx	r3
348176e8:	e3100902 	tst	r0, #32768	; 0x8000
348176ec:	1afffff8 	bne	348176d4 <onenand_scan+0x514>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348176f0:	e5950000 	ldr	r0, [r5]
348176f4:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348176f8:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348176fc:	e280009c 	add	r0, r0, #156	; 0x9c
34817700:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34817704:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34817708:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US))
3481770c:	1a000002 	bne	3481771c <onenand_scan+0x55c>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n",
34817710:	e59f0078 	ldr	r0, [pc, #120]	; 34817790 <onenand_scan+0x5d0>
34817714:	e1a01007 	mov	r1, r7
34817718:	ebffc8ea 	bl	34809ac8 <printf>

		return 0;
	}

	/* Block lock scheme */
	for (block = start; block < end; block++) {
3481771c:	e2877001 	add	r7, r7, #1
34817720:	e157000a 	cmp	r7, sl
34817724:	baffffc4 	blt	3481763c <onenand_scan+0x47c>
	mtd->ecclayout = this->ecclayout;

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
34817728:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
3481772c:	e1a00006 	mov	r0, r6
34817730:	e12fff33 	blx	r3
34817734:	ea000000 	b	3481773c <onenand_scan+0x57c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
34817738:	e3e0000b 	mvn	r0, #11

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
}
3481773c:	e28dd010 	add	sp, sp, #16
34817740:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817744:	34814574 	.word	0x34814574
34817748:	3481457c 	.word	0x3481457c
3481774c:	34815984 	.word	0x34815984
34817750:	34814d48 	.word	0x34814d48
34817754:	34814c7c 	.word	0x34814c7c
34817758:	34814584 	.word	0x34814584
3481775c:	34814668 	.word	0x34814668
34817760:	3481474c 	.word	0x3481474c
34817764:	34815810 	.word	0x34815810
34817768:	34817a60 	.word	0x34817a60
3481776c:	34827b4e 	.word	0x34827b4e
34817770:	348145e4 	.word	0x348145e4
34817774:	34827b70 	.word	0x34827b70
34817778:	34827b99 	.word	0x34827b99
3481777c:	34828f38 	.word	0x34828f38
34817780:	34828aa8 	.word	0x34828aa8
34817784:	34828cf0 	.word	0x34828cf0
34817788:	34827bbf 	.word	0x34827bbf
3481778c:	0001e202 	.word	0x0001e202
34817790:	34827be5 	.word	0x34827be5
34817794:	34827bf1 	.word	0x34827bf1

34817798 <onenand_release>:
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34817798:	e12fff1e 	bx	lr

3481779c <onenand_isbad_bbt>:
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
3481779c:	e5900094 	ldr	r0, [r0, #148]	; 0x94
 * @param mtd		MTD device structure
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
348177a0:	e92d4010 	push	{r4, lr}
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348177a4:	e59040a0 	ldr	r4, [r0, #160]	; 0xa0
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
348177a8:	ebfff7f3 	bl	3481577c <onenand_block>
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
348177ac:	e594300c 	ldr	r3, [r4, #12]
	struct bbm_info *bbm = this->bbm;
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
348177b0:	e1a00080 	lsl	r0, r0, #1
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
348177b4:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
348177b8:	e2000006 	and	r0, r0, #6
348177bc:	e1a00053 	asr	r0, r3, r0

	MTDDEBUG (MTD_DEBUG_LEVEL2,
		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
		(unsigned int)offs, block >> 1, res);

	switch ((int)res) {
348177c0:	e2100003 	ands	r0, r0, #3
348177c4:	08bd8010 	popeq	{r4, pc}
348177c8:	e3500002 	cmp	r0, #2
348177cc:	1a000003 	bne	348177e0 <onenand_isbad_bbt+0x44>
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 1;
348177d0:	e59d0008 	ldr	r0, [sp, #8]
348177d4:	e2700001 	rsbs	r0, r0, #1
348177d8:	33a00000 	movcc	r0, #0
348177dc:	e8bd8010 	pop	{r4, pc}

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
348177e0:	e3a00001 	mov	r0, #1
	case 0x02:
		return allowbbt ? 0 : 1;
	}

	return 1;
}
348177e4:	e8bd8010 	pop	{r4, pc}

348177e8 <onenand_memory_bbt>:
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
348177e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
348177ec:	e5913000 	ldr	r3, [r1]
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
348177f0:	e590a094 	ldr	sl, [r0, #148]	; 0x94
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
348177f4:	e3c33b02 	bic	r3, r3, #2048	; 0x800
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348177f8:	e59a60a0 	ldr	r6, [sl, #160]	; 0xa0
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
348177fc:	e24ddd42 	sub	sp, sp, #4224	; 0x1080
34817800:	e24dd038 	sub	sp, sp, #56	; 0x38
34817804:	e1a05001 	mov	r5, r1
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
34817808:	e5813000 	str	r3, [r1]
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
3481780c:	e1a07000 	mov	r7, r0
	loff_t from;
	size_t readlen, ooblen;
	struct mtd_oob_ops ops;
	int rgn;

	printk(KERN_INFO "Scanning device for bad blocks\n");
34817810:	e59f018c 	ldr	r0, [pc, #396]	; 348179a4 <onenand_memory_bbt+0x1bc>
34817814:	ebffc8ab 	bl	34809ac8 <printf>

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817818:	e5969000 	ldr	r9, [r6]

	len = 1;

	/* We need only read few bytes from the OOB area */
	scanlen = ooblen = 0;
	readlen = bd->len;
3481781c:	e5953014 	ldr	r3, [r5, #20]
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817820:	e28d0a01 	add	r0, sp, #4096	; 0x1000

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817824:	e59a2018 	ldr	r2, [sl, #24]
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
34817828:	e58030a4 	str	r3, [r0, #164]	; 0xa4

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
3481782c:	e2499001 	sub	r9, r9, #1
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
34817830:	e28d3038 	add	r3, sp, #56	; 0x38
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817834:	e3a04000 	mov	r4, #0

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817838:	e1a09932 	lsr	r9, r2, r9
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
3481783c:	e2432020 	sub	r2, r3, #32
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817840:	e5804098 	str	r4, [r0, #152]	; 0x98
	ops.ooblen = readlen;
	ops.oobbuf = buf;
34817844:	e58020b4 	str	r2, [r0, #180]	; 0xb4
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
34817848:	e58040a8 	str	r4, [r0, #168]	; 0xa8
3481784c:	e58040a0 	str	r4, [r0, #160]	; 0xa0
34817850:	e58040ac 	str	r4, [r0, #172]	; 0xac
34817854:	e580409c 	str	r4, [r0, #156]	; 0x9c
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;
34817858:	e3a01000 	mov	r1, #0
3481785c:	e3a00000 	mov	r0, #0
34817860:	e1cd01f0 	strd	r0, [sp, #16]
34817864:	e1a0c00a 	mov	ip, sl
34817868:	ea000045 	b	34817984 <onenand_memory_bbt+0x19c>
		int ret;

		for (j = 0; j < len; j++) {
			/* No need to read pages fully,
			 * just read required OOB bytes */
			ret = onenand_bbt_read_oob(mtd,
3481786c:	e5952008 	ldr	r2, [r5, #8]
34817870:	e1cda1d0 	ldrd	sl, [sp, #16]
34817874:	e09aa002 	adds	sl, sl, r2
34817878:	e0abbfc2 	adc	fp, fp, r2, asr #31
3481787c:	e28d1d42 	add	r1, sp, #4224	; 0x1080
34817880:	e2811018 	add	r1, r1, #24
34817884:	e1a00007 	mov	r0, r7
34817888:	e1a0200a 	mov	r2, sl
3481788c:	e1a0300b 	mov	r3, fp
34817890:	e58dc00c 	str	ip, [sp, #12]
34817894:	e58d1000 	str	r1, [sp]
34817898:	ebfffbdc 	bl	34816810 <onenand_bbt_read_oob>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
3481789c:	e3500004 	cmp	r0, #4
348178a0:	e59dc00c 	ldr	ip, [sp, #12]
348178a4:	0a00003a 	beq	34817994 <onenand_memory_bbt+0x1ac>
				return -EIO;

			if (ret || check_short_pattern
348178a8:	e3500000 	cmp	r0, #0
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
348178ac:	05953014 	ldreq	r3, [r5, #20]
348178b0:	01a0a00c 	moveq	sl, ip

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
348178b4:	0a000008 	beq	348178dc <onenand_memory_bbt+0xf4>
348178b8:	ea00000c 	b	348178f0 <onenand_memory_bbt+0x108>
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
348178bc:	e28db038 	add	fp, sp, #56	; 0x38
348178c0:	e5952020 	ldr	r2, [r5, #32]
348178c4:	e24b1020 	sub	r1, fp, #32
348178c8:	e7d11000 	ldrb	r1, [r1, r0]
348178cc:	e7d22000 	ldrb	r2, [r2, r0]
348178d0:	e1510002 	cmp	r1, r2
348178d4:	1a000004 	bne	348178ec <onenand_memory_bbt+0x104>
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
348178d8:	e2800001 	add	r0, r0, #1
348178dc:	e1500003 	cmp	r0, r3
348178e0:	bafffff5 	blt	348178bc <onenand_memory_bbt+0xd4>
348178e4:	e1a0c00a 	mov	ip, sl
348178e8:	ea00000c 	b	34817920 <onenand_memory_bbt+0x138>
348178ec:	e1a0c00a 	mov	ip, sl
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
			    (&buf[j * scanlen], scanlen, mtd->writesize, bd)) {
				bbm->bbt[i >> 3] |= 0x03 << (i & 0x6);
348178f0:	e596300c 	ldr	r3, [r6, #12]
348178f4:	e2041006 	and	r1, r4, #6
348178f8:	e7d321c4 	ldrb	r2, [r3, r4, asr #3]
348178fc:	e3a00003 	mov	r0, #3
34817900:	e1822110 	orr	r2, r2, r0, lsl r1
34817904:	e7c321c4 	strb	r2, [r3, r4, asr #3]
				printk(KERN_WARNING
34817908:	e59f0098 	ldr	r0, [pc, #152]	; 348179a8 <onenand_memory_bbt+0x1c0>
3481790c:	e1a010c4 	asr	r1, r4, #1
34817910:	e59d2010 	ldr	r2, [sp, #16]
34817914:	e58dc00c 	str	ip, [sp, #12]
34817918:	ebffc86a 	bl	34809ac8 <printf>
3481791c:	e59dc00c 	ldr	ip, [sp, #12]
				break;
			}
		}
		i += 2;

		if (FLEXONENAND(this)) {
34817920:	e59c301c 	ldr	r3, [ip, #28]
				       "Bad eraseblock %d at 0x%08x\n", i >> 1,
				       (unsigned int)from);
				break;
			}
		}
		i += 2;
34817924:	e2844002 	add	r4, r4, #2

		if (FLEXONENAND(this)) {
34817928:	e3130c02 	tst	r3, #512	; 0x200
3481792c:	0a00000d 	beq	34817968 <onenand_memory_bbt+0x180>
			rgn = flexonenand_region(mtd, from);
34817930:	e1cd21d0 	ldrd	r2, [sp, #16]
34817934:	e1a00007 	mov	r0, r7
34817938:	e58dc00c 	str	ip, [sp, #12]
3481793c:	ebfff8a1 	bl	34815bc8 <flexonenand_region>
			from += mtd->eraseregions[rgn].erasesize;
34817940:	e1cda1d0 	ldrd	sl, [sp, #16]
34817944:	e5973030 	ldr	r3, [r7, #48]	; 0x30
34817948:	e3a01018 	mov	r1, #24
3481794c:	e0233091 	mla	r3, r1, r0, r3
34817950:	e5933008 	ldr	r3, [r3, #8]
34817954:	e59dc00c 	ldr	ip, [sp, #12]
34817958:	e09aa003 	adds	sl, sl, r3
3481795c:	e2abb000 	adc	fp, fp, #0
34817960:	e1cda1f0 	strd	sl, [sp, #16]
34817964:	ea000006 	b	34817984 <onenand_memory_bbt+0x19c>
		} else
			from += (1 << bbm->bbt_erase_shift);
34817968:	e5963000 	ldr	r3, [r6]
3481796c:	e3a0b001 	mov	fp, #1
34817970:	e1a0331b 	lsl	r3, fp, r3
34817974:	e1cd01d0 	ldrd	r0, [sp, #16]
34817978:	e0900003 	adds	r0, r0, r3
3481797c:	e0a11fc3 	adc	r1, r1, r3, asr #31
34817980:	e1cd01f0 	strd	r0, [sp, #16]
	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;

	for (i = startblock; i < numblocks;) {
34817984:	e1540009 	cmp	r4, r9
34817988:	baffffb7 	blt	3481786c <onenand_memory_bbt+0x84>
			from += mtd->eraseregions[rgn].erasesize;
		} else
			from += (1 << bbm->bbt_erase_shift);
	}

	return 0;
3481798c:	e3a00000 	mov	r0, #0
34817990:	ea000000 	b	34817998 <onenand_memory_bbt+0x1b0>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;
34817994:	e3e00004 	mvn	r0, #4
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
	return create_bbt(mtd, data_buf, bd, -1);
}
34817998:	e28dd0b8 	add	sp, sp, #184	; 0xb8
3481799c:	e28dda01 	add	sp, sp, #4096	; 0x1000
348179a0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348179a4:	34827c03 	.word	0x34827c03
348179a8:	34827c23 	.word	0x34827c23

348179ac <onenand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
348179ac:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
348179b0:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
348179b4:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
348179b8:	e595a030 	ldr	sl, [r5, #48]	; 0x30
348179bc:	e5953018 	ldr	r3, [r5, #24]
348179c0:	e28aa002 	add	sl, sl, #2
348179c4:	e1a0aa33 	lsr	sl, r3, sl
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
348179c8:	e1a0000a 	mov	r0, sl
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348179cc:	e59540a0 	ldr	r4, [r5, #160]	; 0xa0
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
348179d0:	e1a07001 	mov	r7, r1
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
348179d4:	ebffca02 	bl	3480a1e4 <malloc>
	if (!bbm->bbt) {
348179d8:	e3500000 	cmp	r0, #0
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
348179dc:	e584000c 	str	r0, [r4, #12]
	if (!bbm->bbt) {
348179e0:	1a000003 	bne	348179f4 <onenand_scan_bbt+0x48>
		printk(KERN_ERR "onenand_scan_bbt: Out of memory\n");
348179e4:	e59f0068 	ldr	r0, [pc, #104]	; 34817a54 <onenand_scan_bbt+0xa8>
348179e8:	ebffc836 	bl	34809ac8 <printf>
		return -ENOMEM;
348179ec:	e3e0500b 	mvn	r5, #11
348179f0:	ea000015 	b	34817a4c <onenand_scan_bbt+0xa0>
	}
	/* Clear the memory bad block table */
	memset(bbm->bbt, 0x00, len);
348179f4:	e3a01000 	mov	r1, #0
348179f8:	e1a0200a 	mov	r2, sl
348179fc:	eb001305 	bl	3481c618 <memset>

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;
34817a00:	e3a03000 	mov	r3, #0
34817a04:	e5843004 	str	r3, [r4, #4]

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
34817a08:	e5953030 	ldr	r3, [r5, #48]	; 0x30

	if (!bbm->isbad_bbt)
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817a0c:	e1a00006 	mov	r0, r6

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
34817a10:	e5843000 	str	r3, [r4]

	if (!bbm->isbad_bbt)
34817a14:	e5943010 	ldr	r3, [r4, #16]
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817a18:	e1a01007 	mov	r1, r7
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;

	if (!bbm->isbad_bbt)
34817a1c:	e3530000 	cmp	r3, #0
		bbm->isbad_bbt = onenand_isbad_bbt;
34817a20:	059f3030 	ldreq	r3, [pc, #48]	; 34817a58 <onenand_scan_bbt+0xac>
34817a24:	05843010 	streq	r3, [r4, #16]

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817a28:	ebffff6e 	bl	348177e8 <onenand_memory_bbt>
34817a2c:	e2505000 	subs	r5, r0, #0
34817a30:	0a000005 	beq	34817a4c <onenand_scan_bbt+0xa0>
		printk(KERN_ERR
34817a34:	e59f0020 	ldr	r0, [pc, #32]	; 34817a5c <onenand_scan_bbt+0xb0>
34817a38:	ebffc822 	bl	34809ac8 <printf>
		       "onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\n");
		free(bbm->bbt);
34817a3c:	e594000c 	ldr	r0, [r4, #12]
34817a40:	ebffc95e 	bl	34809fc0 <free>
		bbm->bbt = NULL;
34817a44:	e3a03000 	mov	r3, #0
34817a48:	e584300c 	str	r3, [r4, #12]
	}

	return ret;
}
34817a4c:	e1a00005 	mov	r0, r5
34817a50:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34817a54:	34827c40 	.word	0x34827c40
34817a58:	3481779c 	.word	0x3481779c
34817a5c:	34827c61 	.word	0x34827c61

34817a60 <onenand_default_bbt>:
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817a60:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34817a64:	e5906094 	ldr	r6, [r0, #148]	; 0x94
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817a68:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817a6c:	e3a0001c 	mov	r0, #28
34817a70:	ebffc9db 	bl	3480a1e4 <malloc>
	if (!this->bbm)
34817a74:	e3500000 	cmp	r0, #0
int onenand_default_bbt(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817a78:	e1a04000 	mov	r4, r0
34817a7c:	e58600a0 	str	r0, [r6, #160]	; 0xa0
	if (!this->bbm)
34817a80:	0a00000a 	beq	34817ab0 <onenand_default_bbt+0x50>
		return -ENOMEM;

	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));
34817a84:	e3a01000 	mov	r1, #0
34817a88:	e3a0201c 	mov	r2, #28
34817a8c:	eb0012e1 	bl	3481c618 <memset>

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817a90:	e5943014 	ldr	r3, [r4, #20]
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817a94:	e1a00005 	mov	r0, r5
	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817a98:	e3530000 	cmp	r3, #0
		bbm->badblock_pattern = &largepage_memorybased;
34817a9c:	059f3014 	ldreq	r3, [pc, #20]	; 34817ab8 <onenand_default_bbt+0x58>
34817aa0:	05843014 	streq	r3, [r4, #20]

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817aa4:	e5941014 	ldr	r1, [r4, #20]
}
34817aa8:	e8bd4070 	pop	{r4, r5, r6, lr}

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817aac:	eaffffbe 	b	348179ac <onenand_scan_bbt>
}
34817ab0:	e3e0000b 	mvn	r0, #11
34817ab4:	e8bd8070 	pop	{r4, r5, r6, pc}
34817ab8:	34829180 	.word	0x34829180

34817abc <s3c_read_cmd>:

static struct s3c_onenand *onenand;

static int s3c_read_cmd(unsigned int cmd)
{
	return readl(onenand->ahb_addr + cmd);
34817abc:	e59f300c 	ldr	r3, [pc, #12]	; 34817ad0 <s3c_read_cmd+0x14>
34817ac0:	e5933000 	ldr	r3, [r3]
34817ac4:	e5933008 	ldr	r3, [r3, #8]
34817ac8:	e7930000 	ldr	r0, [r3, r0]
}
34817acc:	e12fff1e 	bx	lr
34817ad0:	3482bb70 	.word	0x3482bb70

34817ad4 <s3c_write_cmd>:

static void s3c_write_cmd(int value, unsigned int cmd)
{
	writel(value, onenand->ahb_addr + cmd);
34817ad4:	e59f300c 	ldr	r3, [pc, #12]	; 34817ae8 <s3c_write_cmd+0x14>
34817ad8:	e5933000 	ldr	r3, [r3]
34817adc:	e5933008 	ldr	r3, [r3, #8]
34817ae0:	e7830001 	str	r0, [r3, r1]
}
34817ae4:	e12fff1e 	bx	lr
34817ae8:	3482bb70 	.word	0x3482bb70

34817aec <s3c_mem_addr>:
	return (fba << 12) | (fpa << 6) | (fsa << 4);
}
#elif defined(CONFIG_S5P)
static unsigned int s3c_mem_addr(int fba, int fpa, int fsa)
{
	return (fba << 13) | (fpa << 7) | (fsa << 5);
34817aec:	e1a00680 	lsl	r0, r0, #13
34817af0:	e1800381 	orr	r0, r0, r1, lsl #7
}
34817af4:	e1800282 	orr	r0, r0, r2, lsl #5
34817af8:	e12fff1e 	bx	lr

34817afc <s3c_onenand_reset>:
static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
34817afc:	e59f206c 	ldr	r2, [pc, #108]	; 34817b70 <s3c_onenand_reset+0x74>
34817b00:	e3a01002 	mov	r1, #2
34817b04:	e5923000 	ldr	r3, [r2]
34817b08:	e593301c 	ldr	r3, [r3, #28]
34817b0c:	e5831020 	str	r1, [r3, #32]
}
#endif

static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
34817b10:	e3a03801 	mov	r3, #65536	; 0x10000
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34817b14:	ea000004 	b	34817b2c <s3c_onenand_reset+0x30>
		stat = readl(&onenand->reg->int_err_stat);
34817b18:	e5921000 	ldr	r1, [r2]
34817b1c:	e591101c 	ldr	r1, [r1, #28]
34817b20:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & RST_CMP)
34817b24:	e3110a01 	tst	r1, #4096	; 0x1000
34817b28:	1a000001 	bne	34817b34 <s3c_onenand_reset+0x38>
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34817b2c:	e2533001 	subs	r3, r3, #1
34817b30:	2afffff8 	bcs	34817b18 <s3c_onenand_reset+0x1c>
		stat = readl(&onenand->reg->int_err_stat);
		if (stat & RST_CMP)
			break;
	}
	stat = readl(&onenand->reg->int_err_stat);
34817b34:	e59f3034 	ldr	r3, [pc, #52]	; 34817b70 <s3c_onenand_reset+0x74>
34817b38:	e5932000 	ldr	r2, [r3]
34817b3c:	e592201c 	ldr	r2, [r2, #28]
34817b40:	e5921030 	ldr	r1, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817b44:	e5932000 	ldr	r2, [r3]
34817b48:	e592201c 	ldr	r2, [r2, #28]
34817b4c:	e5821050 	str	r1, [r2, #80]	; 0x50

	/* Clear interrupt */
	writel(0x0, &onenand->reg->int_err_ack);
34817b50:	e5932000 	ldr	r2, [r3]
34817b54:	e592101c 	ldr	r1, [r2, #28]
34817b58:	e3a02000 	mov	r2, #0
34817b5c:	e5812050 	str	r2, [r1, #80]	; 0x50
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
34817b60:	e5933000 	ldr	r3, [r3]
34817b64:	e593301c 	ldr	r3, [r3, #28]
34817b68:	e5832060 	str	r2, [r3, #96]	; 0x60
}
34817b6c:	e12fff1e 	bx	lr
34817b70:	3482bb70 	.word	0x3482bb70

34817b74 <s3c_onenand_command>:
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817b74:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34817b78:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817b7c:	e1cd20f0 	strd	r2, [sp]
34817b80:	e1a04001 	mov	r4, r1
34817b84:	e1a05000 	mov	r5, r0
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
34817b88:	e1a01003 	mov	r1, r3
34817b8c:	e1a00002 	mov	r0, r2
34817b90:	e5962034 	ldr	r2, [r6, #52]	; 0x34
34817b94:	eb002125 	bl	34820030 <__ashrdi3>
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817b98:	e59f3230 	ldr	r3, [pc, #560]	; 34817dd0 <s3c_onenand_command+0x25c>
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817b9c:	e596703c 	ldr	r7, [r6, #60]	; 0x3c

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817ba0:	e593a000 	ldr	sl, [r3]
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817ba4:	e0077000 	and	r7, r7, r0
	int fba, fpa, fsa = 0;
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
34817ba8:	e5962030 	ldr	r2, [r6, #48]	; 0x30
34817bac:	e1cd00d0 	ldrd	r0, [sp]
34817bb0:	eb00211e 	bl	34820030 <__ashrdi3>
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817bb4:	e1a01007 	mov	r1, r7
34817bb8:	e59a3018 	ldr	r3, [sl, #24]
34817bbc:	e3a02000 	mov	r2, #0
34817bc0:	e12fff33 	blx	r3

	switch (cmd) {
34817bc4:	e3540013 	cmp	r4, #19

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817bc8:	e1a07000 	mov	r7, r0

	switch (cmd) {
34817bcc:	0a000004 	beq	34817be4 <s3c_onenand_command+0x70>
34817bd0:	e3013978 	movw	r3, #6520	; 0x1978
34817bd4:	e1540003 	cmp	r4, r3
34817bd8:	0a000001 	beq	34817be4 <s3c_onenand_command+0x70>
34817bdc:	e3540000 	cmp	r4, #0
34817be0:	1a000002 	bne	34817bf0 <s3c_onenand_command+0x7c>
	case ONENAND_CMD_READ:
	case ONENAND_CMD_READOOB:
	case ONENAND_CMD_BUFFERRAM:
		ONENAND_SET_NEXT_BUFFERRAM(this);
34817be4:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34817be8:	e2233001 	eor	r3, r3, #1
34817bec:	e5863044 	str	r3, [r6, #68]	; 0x44
	index = ONENAND_CURRENT_BUFFERRAM(this);

	/*
	 * Emulate Two BufferRAMs and access with 4 bytes pointer
	 */
	m = (unsigned int *) onenand->page_buf;
34817bf0:	e59f31d8 	ldr	r3, [pc, #472]	; 34817dd0 <s3c_onenand_command+0x25c>
34817bf4:	e5933000 	ldr	r3, [r3]
34817bf8:	e593a010 	ldr	sl, [r3, #16]
	s = (unsigned int *) onenand->oob_buf;
34817bfc:	e5939014 	ldr	r9, [r3, #20]

	if (index) {
34817c00:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34817c04:	e3530000 	cmp	r3, #0
34817c08:	0a000005 	beq	34817c24 <s3c_onenand_command+0xb0>
		m += (this->writesize >> 2);
34817c0c:	e5963040 	ldr	r3, [r6, #64]	; 0x40
34817c10:	e3c33003 	bic	r3, r3, #3
34817c14:	e08aa003 	add	sl, sl, r3
		s += (mtd->oobsize >> 2);
34817c18:	e5953018 	ldr	r3, [r5, #24]
34817c1c:	e3c33003 	bic	r3, r3, #3
34817c20:	e0899003 	add	r9, r9, r3
	}

	mcount = mtd->writesize >> 2;
34817c24:	e5956014 	ldr	r6, [r5, #20]
	scount = mtd->oobsize >> 2;
34817c28:	e5955018 	ldr	r5, [r5, #24]

	switch (cmd) {
34817c2c:	e3540027 	cmp	r4, #39	; 0x27
	if (index) {
		m += (this->writesize >> 2);
		s += (mtd->oobsize >> 2);
	}

	mcount = mtd->writesize >> 2;
34817c30:	e1a06126 	lsr	r6, r6, #2
	scount = mtd->oobsize >> 2;
34817c34:	e1a05125 	lsr	r5, r5, #2

	switch (cmd) {
34817c38:	0a000059 	beq	34817da4 <s3c_onenand_command+0x230>
34817c3c:	ca000007 	bgt	34817c60 <s3c_onenand_command+0xec>
34817c40:	e3540013 	cmp	r4, #19
34817c44:	0a00001a 	beq	34817cb4 <s3c_onenand_command+0x140>
34817c48:	e354001a 	cmp	r4, #26
34817c4c:	0a000037 	beq	34817d30 <s3c_onenand_command+0x1bc>
34817c50:	e3540000 	cmp	r4, #0
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817c54:	03877301 	orreq	r7, r7, #67108864	; 0x4000000
	}

	mcount = mtd->writesize >> 2;
	scount = mtd->oobsize >> 2;

	switch (cmd) {
34817c58:	0a000012 	beq	34817ca8 <s3c_onenand_command+0x134>
34817c5c:	ea000059 	b	34817dc8 <s3c_onenand_command+0x254>
34817c60:	e3540080 	cmp	r4, #128	; 0x80
34817c64:	0a000008 	beq	34817c8c <s3c_onenand_command+0x118>
34817c68:	ca000002 	bgt	34817c78 <s3c_onenand_command+0x104>
34817c6c:	e3540071 	cmp	r4, #113	; 0x71
34817c70:	1a000054 	bne	34817dc8 <s3c_onenand_command+0x254>
34817c74:	ea000050 	b	34817dbc <s3c_onenand_command+0x248>
34817c78:	e3540094 	cmp	r4, #148	; 0x94
34817c7c:	0a00004a 	beq	34817dac <s3c_onenand_command+0x238>
34817c80:	e3540095 	cmp	r4, #149	; 0x95
34817c84:	1a00004f 	bne	34817dc8 <s3c_onenand_command+0x254>
34817c88:	ea000049 	b	34817db4 <s3c_onenand_command+0x240>
34817c8c:	e3a04000 	mov	r4, #0
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817c90:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817c94:	ea000022 	b	34817d24 <s3c_onenand_command+0x1b0>

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817c98:	e1a00007 	mov	r0, r7
34817c9c:	ebffff86 	bl	34817abc <s3c_read_cmd>
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34817ca0:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817ca4:	e48a0004 	str	r0, [sl], #4
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34817ca8:	e1540006 	cmp	r4, r6
34817cac:	bafffff9 	blt	34817c98 <s3c_onenand_command+0x124>
34817cb0:	ea000044 	b	34817dc8 <s3c_onenand_command+0x254>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817cb4:	e59f3114 	ldr	r3, [pc, #276]	; 34817dd0 <s3c_onenand_command+0x25c>
34817cb8:	e3a02001 	mov	r2, #1
34817cbc:	e5933000 	ldr	r3, [r3]
		/* Main */
		for (i = 0; i < mcount; i++)
34817cc0:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817cc4:	e593301c 	ldr	r3, [r3, #28]
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817cc8:	e387b301 	orr	fp, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817ccc:	e5832140 	str	r2, [r3, #320]	; 0x140
		/* Main */
		for (i = 0; i < mcount; i++)
34817cd0:	ea000003 	b	34817ce4 <s3c_onenand_command+0x170>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817cd4:	e1a0000b 	mov	r0, fp
34817cd8:	ebffff77 	bl	34817abc <s3c_read_cmd>
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817cdc:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817ce0:	e48a0004 	str	r0, [sl], #4
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817ce4:	e1540006 	cmp	r4, r6
34817ce8:	bafffff9 	blt	34817cd4 <s3c_onenand_command+0x160>
34817cec:	e3a04000 	mov	r4, #0
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817cf0:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817cf4:	ea000003 	b	34817d08 <s3c_onenand_command+0x194>
34817cf8:	e1a00007 	mov	r0, r7
34817cfc:	ebffff6e 	bl	34817abc <s3c_read_cmd>
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34817d00:	e2844001 	add	r4, r4, #1
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817d04:	e4890004 	str	r0, [r9], #4
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34817d08:	e1540005 	cmp	r4, r5
34817d0c:	bafffff9 	blt	34817cf8 <s3c_onenand_command+0x184>
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34817d10:	ea00001d 	b	34817d8c <s3c_onenand_command+0x218>
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817d14:	e49a0004 	ldr	r0, [sl], #4
34817d18:	e1a01007 	mov	r1, r7
34817d1c:	ebffff6c 	bl	34817ad4 <s3c_write_cmd>
		writel(0, &onenand->reg->trans_spare);
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
34817d20:	e2844001 	add	r4, r4, #1
34817d24:	e1540006 	cmp	r4, r6
34817d28:	bafffff9 	blt	34817d14 <s3c_onenand_command+0x1a0>
34817d2c:	ea000025 	b	34817dc8 <s3c_onenand_command+0x254>
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817d30:	e59f3098 	ldr	r3, [pc, #152]	; 34817dd0 <s3c_onenand_command+0x25c>
34817d34:	e3a02001 	mov	r2, #1
34817d38:	e5933000 	ldr	r3, [r3]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34817d3c:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817d40:	e593301c 	ldr	r3, [r3, #28]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34817d44:	e387a301 	orr	sl, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817d48:	e5832140 	str	r2, [r3, #320]	; 0x140

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34817d4c:	ea000003 	b	34817d60 <s3c_onenand_command+0x1ec>
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34817d50:	e3e00000 	mvn	r0, #0
34817d54:	e1a0100a 	mov	r1, sl
34817d58:	ebffff5d 	bl	34817ad4 <s3c_write_cmd>

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34817d5c:	e2844001 	add	r4, r4, #1
34817d60:	e1540006 	cmp	r4, r6
34817d64:	bafffff9 	blt	34817d50 <s3c_onenand_command+0x1dc>
34817d68:	e3a04000 	mov	r4, #0
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34817d6c:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817d70:	ea000003 	b	34817d84 <s3c_onenand_command+0x210>
34817d74:	e4990004 	ldr	r0, [r9], #4
34817d78:	e1a01007 	mov	r1, r7
34817d7c:	ebffff54 	bl	34817ad4 <s3c_write_cmd>
		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34817d80:	e2844001 	add	r4, r4, #1
34817d84:	e1540005 	cmp	r4, r5
34817d88:	bafffff9 	blt	34817d74 <s3c_onenand_command+0x200>
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34817d8c:	e59f303c 	ldr	r3, [pc, #60]	; 34817dd0 <s3c_onenand_command+0x25c>
34817d90:	e3a02000 	mov	r2, #0
34817d94:	e5933000 	ldr	r3, [r3]
34817d98:	e593301c 	ldr	r3, [r3, #28]
34817d9c:	e5832140 	str	r2, [r3, #320]	; 0x140
		return 0;
34817da0:	ea000008 	b	34817dc8 <s3c_onenand_command+0x254>

	case ONENAND_CMD_UNLOCK_ALL:
		s3c_write_cmd(ONENAND_UNLOCK_ALL, CMD_MAP_10(mem_addr));
34817da4:	e3a0000e 	mov	r0, #14
34817da8:	ea000004 	b	34817dc0 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE:
		s3c_write_cmd(ONENAND_ERASE_START, CMD_MAP_10(mem_addr));
34817dac:	e3a00003 	mov	r0, #3
34817db0:	ea000002 	b	34817dc0 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_MULTIBLOCK_ERASE:
		s3c_write_cmd(ONENAND_MULTI_ERASE_SET, CMD_MAP_10(mem_addr));
34817db4:	e3a00001 	mov	r0, #1
34817db8:	ea000000 	b	34817dc0 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE_VERIFY:
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
34817dbc:	e3a00015 	mov	r0, #21
34817dc0:	e3871302 	orr	r1, r7, #134217728	; 0x8000000
34817dc4:	ebffff42 	bl	34817ad4 <s3c_write_cmd>
	default:
		break;
	}

	return 0;
}
34817dc8:	e3a00000 	mov	r0, #0
34817dcc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34817dd0:	3482bb70 	.word	0x3482bb70

34817dd4 <s3c_get_bufferram>:

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;
34817dd4:	e590c094 	ldr	ip, [r0, #148]	; 0x94
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34817dd8:	e3510b01 	cmp	r1, #1024	; 0x400

	return 0;
}

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
34817ddc:	e1a03000 	mov	r3, r0
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
34817de0:	e59c2044 	ldr	r2, [ip, #68]	; 0x44
34817de4:	e59f1030 	ldr	r1, [pc, #48]	; 34817e1c <s3c_get_bufferram+0x48>
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34817de8:	1a000005 	bne	34817e04 <s3c_get_bufferram+0x30>
		p = (unsigned char *) onenand->page_buf;
34817dec:	e5913000 	ldr	r3, [r1]
		if (index == 1)
34817df0:	e3520001 	cmp	r2, #1
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
34817df4:	e5930010 	ldr	r0, [r3, #16]
		if (index == 1)
			p += this->writesize;
34817df8:	059c3040 	ldreq	r3, [ip, #64]	; 0x40
34817dfc:	00800003 	addeq	r0, r0, r3
34817e00:	e12fff1e 	bx	lr
	} else {
		p = (unsigned char *) onenand->oob_buf;
34817e04:	e5911000 	ldr	r1, [r1]
		if (index == 1)
34817e08:	e3520001 	cmp	r2, #1
	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
		if (index == 1)
			p += this->writesize;
	} else {
		p = (unsigned char *) onenand->oob_buf;
34817e0c:	e5910014 	ldr	r0, [r1, #20]
		if (index == 1)
			p += mtd->oobsize;
34817e10:	05933018 	ldreq	r3, [r3, #24]
34817e14:	00800003 	addeq	r0, r0, r3
	}

	return p;
}
34817e18:	e12fff1e 	bx	lr
34817e1c:	3482bb70 	.word	0x3482bb70

34817e20 <s3c_onenand_bbt_wait>:
	memcpy(p + offset, buffer, count);
	return 0;
}

static int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34817e20:	e92d4008 	push	{r3, lr}
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
34817e24:	e59f3078 	ldr	r3, [pc, #120]	; 34817ea4 <s3c_onenand_bbt_wait+0x84>
34817e28:	e5933000 	ldr	r3, [r3]
34817e2c:	e5932004 	ldr	r2, [r3, #4]
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;
34817e30:	e3a03801 	mov	r3, #65536	; 0x10000

	while (timeout--) {
34817e34:	ea000002 	b	34817e44 <s3c_onenand_bbt_wait+0x24>
		stat = readl(&reg->int_err_stat);
34817e38:	e5921030 	ldr	r1, [r2, #48]	; 0x30
		if (stat & flags)
34817e3c:	e3110e41 	tst	r1, #1040	; 0x410
34817e40:	1a000001 	bne	34817e4c <s3c_onenand_bbt_wait+0x2c>
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;

	while (timeout--) {
34817e44:	e2533001 	subs	r3, r3, #1
34817e48:	2afffffa 	bcs	34817e38 <s3c_onenand_bbt_wait+0x18>
		stat = readl(&reg->int_err_stat);
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34817e4c:	e59f3050 	ldr	r3, [pc, #80]	; 34817ea4 <s3c_onenand_bbt_wait+0x84>
34817e50:	e5932000 	ldr	r2, [r3]
34817e54:	e592201c 	ldr	r2, [r2, #28]
34817e58:	e5920030 	ldr	r0, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817e5c:	e5933000 	ldr	r3, [r3]

	if (stat & LD_FAIL_ECC_ERR) {
34817e60:	e3100001 	tst	r0, #1
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34817e64:	e593301c 	ldr	r3, [r3, #28]
34817e68:	e5830050 	str	r0, [r3, #80]	; 0x50

	if (stat & LD_FAIL_ECC_ERR) {
34817e6c:	0a000002 	beq	34817e7c <s3c_onenand_bbt_wait+0x5c>
		s3c_onenand_reset();
34817e70:	ebffff21 	bl	34817afc <s3c_onenand_reset>
		return ONENAND_BBT_READ_ERROR;
34817e74:	e3a00001 	mov	r0, #1
34817e78:	e8bd8008 	pop	{r3, pc}
	}

	if (stat & LOAD_CMP) {
34817e7c:	e2100010 	ands	r0, r0, #16
34817e80:	08bd8008 	popeq	{r3, pc}
		int ecc = readl(&onenand->reg->ecc_err_stat);
34817e84:	e5933060 	ldr	r3, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34817e88:	e3010010 	movw	r0, #4112	; 0x1010
34817e8c:	e0030000 	and	r0, r3, r0
34817e90:	e3500000 	cmp	r0, #0
34817e94:	08bd8008 	popeq	{r3, pc}
			s3c_onenand_reset();
34817e98:	ebffff17 	bl	34817afc <s3c_onenand_reset>
			return ONENAND_BBT_READ_ERROR;
34817e9c:	e3a00001 	mov	r0, #1
		}
	}

	return 0;
}
34817ea0:	e8bd8008 	pop	{r3, pc}
34817ea4:	3482bb70 	.word	0x3482bb70

34817ea8 <onenand_write_bufferram>:
}

static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34817ea8:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34817eac:	e59d1008 	ldr	r1, [sp, #8]
34817eb0:	ebffffc7 	bl	34817dd4 <s3c_get_bufferram>
	memcpy(p + offset, buffer, count);
34817eb4:	e59d3010 	ldr	r3, [sp, #16]
34817eb8:	e59d100c 	ldr	r1, [sp, #12]
34817ebc:	e0800003 	add	r0, r0, r3
34817ec0:	e59d2014 	ldr	r2, [sp, #20]
34817ec4:	eb0011f7 	bl	3481c6a8 <memcpy>
	return 0;
}
34817ec8:	e3a00000 	mov	r0, #0
34817ecc:	e8bd8008 	pop	{r3, pc}

34817ed0 <onenand_read_bufferram>:
}

static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34817ed0:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34817ed4:	e59d1008 	ldr	r1, [sp, #8]
34817ed8:	ebffffbd 	bl	34817dd4 <s3c_get_bufferram>
	memcpy(buffer, p + offset, count);
34817edc:	e59d1010 	ldr	r1, [sp, #16]
34817ee0:	e59d2014 	ldr	r2, [sp, #20]
34817ee4:	e0801001 	add	r1, r0, r1
34817ee8:	e59d000c 	ldr	r0, [sp, #12]
34817eec:	eb0011ed 	bl	3481c6a8 <memcpy>
	return 0;
}
34817ef0:	e3a00000 	mov	r0, #0
34817ef4:	e8bd8008 	pop	{r3, pc}

34817ef8 <s3c_onenand_wait>:
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34817ef8:	e2411001 	sub	r1, r1, #1
34817efc:	e3510007 	cmp	r1, #7

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34817f00:	e92d4038 	push	{r3, r4, r5, lr}
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34817f04:	959f30d8 	ldrls	r3, [pc, #216]	; 34817fe4 <s3c_onenand_wait+0xec>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34817f08:	e1a05000 	mov	r5, r0
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34817f0c:	97932101 	ldrls	r2, [r3, r1, lsl #2]
34817f10:	9a000007 	bls	34817f34 <s3c_onenand_wait+0x3c>
34817f14:	ea000005 	b	34817f30 <s3c_onenand_wait+0x38>
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
34817f18:	e5910000 	ldr	r0, [r1]
34817f1c:	e590001c 	ldr	r0, [r0, #28]
34817f20:	e5900030 	ldr	r0, [r0, #48]	; 0x30
		if (stat & flags)
34817f24:	e1120000 	tst	r2, r0
34817f28:	0a000003 	beq	34817f3c <s3c_onenand_wait+0x44>
34817f2c:	ea000004 	b	34817f44 <s3c_onenand_wait+0x4c>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34817f30:	e3a02b01 	mov	r2, #1024	; 0x400
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
34817f34:	e59f10ac 	ldr	r1, [pc, #172]	; 34817fe8 <s3c_onenand_wait+0xf0>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34817f38:	e3a03601 	mov	r3, #1048576	; 0x100000
		break;
	default:
		break;
	}

	while (timeout--) {
34817f3c:	e2533001 	subs	r3, r3, #1
34817f40:	2afffff4 	bcs	34817f18 <s3c_onenand_wait+0x20>
		if (stat & flags)
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34817f44:	e59f309c 	ldr	r3, [pc, #156]	; 34817fe8 <s3c_onenand_wait+0xf0>
34817f48:	e5932000 	ldr	r2, [r3]
34817f4c:	e592201c 	ldr	r2, [r2, #28]
34817f50:	e5924030 	ldr	r4, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817f54:	e5933000 	ldr	r3, [r3]
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34817f58:	e3140010 	tst	r4, #16
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34817f5c:	e593301c 	ldr	r3, [r3, #28]
34817f60:	e5834050 	str	r4, [r3, #80]	; 0x50
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34817f64:	0a00000c 	beq	34817f9c <s3c_onenand_wait+0xa4>
		ecc = readl(&onenand->reg->ecc_err_stat);
34817f68:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34817f6c:	e3013010 	movw	r3, #4112	; 0x1010
34817f70:	e0023003 	and	r3, r2, r3
34817f74:	e3530000 	cmp	r3, #0
34817f78:	0a000007 	beq	34817f9c <s3c_onenand_wait+0xa4>
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
34817f7c:	e59f0068 	ldr	r0, [pc, #104]	; 34817fec <s3c_onenand_wait+0xf4>
34817f80:	e59f1068 	ldr	r1, [pc, #104]	; 34817ff0 <s3c_onenand_wait+0xf8>
34817f84:	ebffc6cf 	bl	34809ac8 <printf>
					__func__, ecc);
			mtd->ecc_stats.failed++;
34817f88:	e5953084 	ldr	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34817f8c:	e3e00049 	mvn	r0, #73	; 0x49
	if (stat & LOAD_CMP) {
		ecc = readl(&onenand->reg->ecc_err_stat);
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
					__func__, ecc);
			mtd->ecc_stats.failed++;
34817f90:	e2833001 	add	r3, r3, #1
34817f94:	e5853084 	str	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34817f98:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	if (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {
34817f9c:	e300010d 	movw	r0, #269	; 0x10d
34817fa0:	e0040000 	and	r0, r4, r0
34817fa4:	e3500000 	cmp	r0, #0
34817fa8:	08bd8038 	popeq	{r3, r4, r5, pc}
		printk(KERN_INFO "%s: controller error = 0x%04x\n",
34817fac:	e59f0040 	ldr	r0, [pc, #64]	; 34817ff4 <s3c_onenand_wait+0xfc>
34817fb0:	e59f1038 	ldr	r1, [pc, #56]	; 34817ff0 <s3c_onenand_wait+0xf8>
34817fb4:	e1a02004 	mov	r2, r4
34817fb8:	ebffc6c2 	bl	34809ac8 <printf>
				__func__, stat);
		if (stat & LOCKED_BLK)
34817fbc:	e3140c01 	tst	r4, #256	; 0x100
34817fc0:	0a000005 	beq	34817fdc <s3c_onenand_wait+0xe4>
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
34817fc4:	e59f002c 	ldr	r0, [pc, #44]	; 34817ff8 <s3c_onenand_wait+0x100>
34817fc8:	e59f1020 	ldr	r1, [pc, #32]	; 34817ff0 <s3c_onenand_wait+0xf8>
34817fcc:	e1a02004 	mov	r2, r4
34817fd0:	ebffc6bc 	bl	34809ac8 <printf>
					__func__, stat);

		return -EIO;
34817fd4:	e3e00004 	mvn	r0, #4
34817fd8:	e8bd8038 	pop	{r3, r4, r5, pc}
34817fdc:	e3e00004 	mvn	r0, #4
	}

	return 0;
}
34817fe0:	e8bd8038 	pop	{r3, r4, r5, pc}
34817fe4:	34821540 	.word	0x34821540
34817fe8:	3482bb70 	.word	0x3482bb70
34817fec:	34827ca1 	.word	0x34827ca1
34817ff0:	34821560 	.word	0x34821560
34817ff4:	34827cb9 	.word	0x34827cb9
34817ff8:	34827cd8 	.word	0x34827cd8

34817ffc <s3c_onenand_writew>:
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
34817ffc:	e59f20c8 	ldr	r2, [pc, #200]	; 348180cc <s3c_onenand_writew+0xd0>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
34818000:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = onenand->mtd->priv;
34818004:	e5923000 	ldr	r3, [r2]
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
34818008:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = onenand->mtd->priv;
3481800c:	e5930000 	ldr	r0, [r3]
	int reg = addr - this->base;
34818010:	e5900094 	ldr	r0, [r0, #148]	; 0x94
34818014:	e5905000 	ldr	r5, [r0]
34818018:	e0655001 	rsb	r5, r5, r1
	int word_addr = reg >> 1;

	/* It's used for probing time */
	switch (reg) {
3481801c:	e59f10ac 	ldr	r1, [pc, #172]	; 348180d0 <s3c_onenand_writew+0xd4>
34818020:	e1550001 	cmp	r5, r1
34818024:	08bd8070 	popeq	{r4, r5, r6, pc}
34818028:	ca000003 	bgt	3481803c <s3c_onenand_writew+0x40>
3481802c:	e59f20a0 	ldr	r2, [pc, #160]	; 348180d4 <s3c_onenand_writew+0xd8>
34818030:	e1550002 	cmp	r5, r2
34818034:	1a00000b 	bne	34818068 <s3c_onenand_writew+0x6c>
34818038:	e8bd8070 	pop	{r4, r5, r6, pc}
3481803c:	e59f1094 	ldr	r1, [pc, #148]	; 348180d8 <s3c_onenand_writew+0xdc>
34818040:	e1550001 	cmp	r5, r1
34818044:	0a000003 	beq	34818058 <s3c_onenand_writew+0x5c>
34818048:	e59f208c 	ldr	r2, [pc, #140]	; 348180dc <s3c_onenand_writew+0xe0>
3481804c:	e1550002 	cmp	r5, r2
34818050:	1a000004 	bne	34818068 <s3c_onenand_writew+0x6c>
34818054:	e8bd8070 	pop	{r4, r5, r6, pc}
	case ONENAND_REG_SYS_CFG1:
		writel(value, &onenand->reg->mem_cfg);
34818058:	e5923000 	ldr	r3, [r2]
3481805c:	e593301c 	ldr	r3, [r3, #28]
34818060:	e5834000 	str	r4, [r3]
		return;
34818064:	e8bd8070 	pop	{r4, r5, r6, pc}
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
34818068:	e3550b01 	cmp	r5, #1024	; 0x400
3481806c:	aa00000c 	bge	348180a4 <s3c_onenand_writew+0xa8>
		if (value == ONENAND_CMD_READID) {
34818070:	e3540090 	cmp	r4, #144	; 0x90
			onenand->bootram_command = 1;
34818074:	03a02001 	moveq	r2, #1
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
		if (value == ONENAND_CMD_READID) {
34818078:	0a000007 	beq	3481809c <s3c_onenand_writew+0xa0>
			onenand->bootram_command = 1;
			return;
		}
		if (value == ONENAND_CMD_RESET) {
3481807c:	e35400f0 	cmp	r4, #240	; 0xf0
34818080:	1a000007 	bne	348180a4 <s3c_onenand_writew+0xa8>
			writel(ONENAND_MEM_RESET_COLD,
34818084:	e59f3040 	ldr	r3, [pc, #64]	; 348180cc <s3c_onenand_writew+0xd0>
34818088:	e3a01002 	mov	r1, #2
3481808c:	e5933000 	ldr	r3, [r3]
34818090:	e593201c 	ldr	r2, [r3, #28]
34818094:	e5821020 	str	r1, [r2, #32]
					&onenand->reg->mem_reset);
			onenand->bootram_command = 0;
34818098:	e3a02000 	mov	r2, #0
3481809c:	e583200c 	str	r2, [r3, #12]
348180a0:	e8bd8070 	pop	{r4, r5, r6, pc}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
348180a4:	e1a050c5 	asr	r5, r5, #1
			onenand->bootram_command = 0;
			return;
		}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
348180a8:	e1a01005 	mov	r1, r5
348180ac:	e1a02004 	mov	r2, r4
348180b0:	e59f0028 	ldr	r0, [pc, #40]	; 348180e0 <s3c_onenand_writew+0xe4>
348180b4:	ebffc683 	bl	34809ac8 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
348180b8:	e1a01105 	lsl	r1, r5, #2
348180bc:	e1a00004 	mov	r0, r4
348180c0:	e3811303 	orr	r1, r1, #201326592	; 0xc000000
}
348180c4:	e8bd4070 	pop	{r4, r5, r6, lr}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
348180c8:	eafffe81 	b	34817ad4 <s3c_write_cmd>
348180cc:	3482bb70 	.word	0x3482bb70
348180d0:	0001e202 	.word	0x0001e202
348180d4:	0001e200 	.word	0x0001e200
348180d8:	0001e442 	.word	0x0001e442
348180dc:	0001e498 	.word	0x0001e498
348180e0:	34827cf8 	.word	0x34827cf8

348180e4 <s3c_onenand_readw>:
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
348180e4:	e92d4038 	push	{r3, r4, r5, lr}
	struct onenand_chip *this = onenand->mtd->priv;
348180e8:	e59f3154 	ldr	r3, [pc, #340]	; 34818244 <s3c_onenand_readw+0x160>
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
348180ec:	e59f1154 	ldr	r1, [pc, #340]	; 34818248 <s3c_onenand_readw+0x164>
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
348180f0:	e5933000 	ldr	r3, [r3]
348180f4:	e5932000 	ldr	r2, [r3]
	int reg = addr - this->base;
348180f8:	e5922094 	ldr	r2, [r2, #148]	; 0x94
348180fc:	e5922000 	ldr	r2, [r2]
34818100:	e0622000 	rsb	r2, r2, r0
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34818104:	e1520001 	cmp	r2, r1
34818108:	0a000022 	beq	34818198 <s3c_onenand_readw+0xb4>
3481810c:	ca000008 	bgt	34818134 <s3c_onenand_readw+0x50>
34818110:	e2411004 	sub	r1, r1, #4
34818114:	e1520001 	cmp	r2, r1
34818118:	0a000018 	beq	34818180 <s3c_onenand_readw+0x9c>
3481811c:	e2811002 	add	r1, r1, #2
34818120:	e1520001 	cmp	r2, r1
34818124:	0a000018 	beq	3481818c <s3c_onenand_readw+0xa8>
34818128:	e3520a1e 	cmp	r2, #122880	; 0x1e000
3481812c:	1a000022 	bne	348181bc <s3c_onenand_readw+0xd8>
34818130:	ea00000f 	b	34818174 <s3c_onenand_readw+0x90>
34818134:	e59f1110 	ldr	r1, [pc, #272]	; 3481824c <s3c_onenand_readw+0x168>
34818138:	e1520001 	cmp	r2, r1
3481813c:	0a00001b 	beq	348181b0 <s3c_onenand_readw+0xcc>
34818140:	ca000003 	bgt	34818154 <s3c_onenand_readw+0x70>
34818144:	e59f1104 	ldr	r1, [pc, #260]	; 34818250 <s3c_onenand_readw+0x16c>
34818148:	e1520001 	cmp	r2, r1
3481814c:	1a00001a 	bne	348181bc <s3c_onenand_readw+0xd8>
34818150:	ea000013 	b	348181a4 <s3c_onenand_readw+0xc0>
34818154:	e59f10f8 	ldr	r1, [pc, #248]	; 34818254 <s3c_onenand_readw+0x170>
34818158:	e1520001 	cmp	r2, r1
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);

	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;
3481815c:	03a00000 	moveq	r0, #0
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34818160:	08bd8038 	popeq	{r3, r4, r5, pc}
34818164:	e281101c 	add	r1, r1, #28
34818168:	e1520001 	cmp	r2, r1
3481816c:	1a000012 	bne	348181bc <s3c_onenand_readw+0xd8>
34818170:	ea000031 	b	3481823c <s3c_onenand_readw+0x158>
	case ONENAND_REG_MANUFACTURER_ID:
		return readl(&onenand->reg->manufact_id);
34818174:	e593301c 	ldr	r3, [r3, #28]
34818178:	e5930070 	ldr	r0, [r3, #112]	; 0x70
3481817c:	ea000018 	b	348181e4 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DEVICE_ID:
		return readl(&onenand->reg->device_id);
34818180:	e593301c 	ldr	r3, [r3, #28]
34818184:	e5930080 	ldr	r0, [r3, #128]	; 0x80
34818188:	ea000015 	b	348181e4 <s3c_onenand_readw+0x100>
	case ONENAND_REG_VERSION_ID:
		return readl(&onenand->reg->flash_ver_id);
3481818c:	e593301c 	ldr	r3, [r3, #28]
34818190:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34818194:	ea000012 	b	348181e4 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DATA_BUFFER_SIZE:
		return readl(&onenand->reg->data_buf_size);
34818198:	e593301c 	ldr	r3, [r3, #28]
3481819c:	e5930090 	ldr	r0, [r3, #144]	; 0x90
348181a0:	ea00000f 	b	348181e4 <s3c_onenand_readw+0x100>
	case ONENAND_REG_TECHNOLOGY:
		return readl(&onenand->reg->tech);
348181a4:	e593301c 	ldr	r3, [r3, #28]
348181a8:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
348181ac:	ea00000c 	b	348181e4 <s3c_onenand_readw+0x100>
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);
348181b0:	e593301c 	ldr	r3, [r3, #28]
348181b4:	e5930000 	ldr	r0, [r3]
348181b8:	ea000009 	b	348181e4 <s3c_onenand_readw+0x100>
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348181bc:	e3520b01 	cmp	r2, #1024	; 0x400

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
348181c0:	e1a050c2 	asr	r5, r2, #1
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348181c4:	aa000012 	bge	34818214 <s3c_onenand_readw+0x130>
348181c8:	e593200c 	ldr	r2, [r3, #12]
348181cc:	e3520000 	cmp	r2, #0
348181d0:	0a00000f 	beq	34818214 <s3c_onenand_readw+0x130>
		if (word_addr == 0)
348181d4:	e3550000 	cmp	r5, #0
348181d8:	1a000003 	bne	348181ec <s3c_onenand_readw+0x108>
			return readl(&onenand->reg->manufact_id);
348181dc:	e593301c 	ldr	r3, [r3, #28]
348181e0:	e5930070 	ldr	r0, [r3, #112]	; 0x70
348181e4:	e6ff0070 	uxth	r0, r0
348181e8:	e8bd8038 	pop	{r3, r4, r5, pc}
		if (word_addr == 1)
348181ec:	e3550001 	cmp	r5, #1
348181f0:	1a000002 	bne	34818200 <s3c_onenand_readw+0x11c>
			return readl(&onenand->reg->device_id);
348181f4:	e593301c 	ldr	r3, [r3, #28]
348181f8:	e5930080 	ldr	r0, [r3, #128]	; 0x80
348181fc:	eafffff8 	b	348181e4 <s3c_onenand_readw+0x100>
		if (word_addr == 2)
34818200:	e3550002 	cmp	r5, #2
34818204:	1a000002 	bne	34818214 <s3c_onenand_readw+0x130>
			return readl(&onenand->reg->flash_ver_id);
34818208:	e593301c 	ldr	r3, [r3, #28]
3481820c:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34818210:	eafffff3 	b	348181e4 <s3c_onenand_readw+0x100>
	}

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
34818214:	e1a00105 	lsl	r0, r5, #2
34818218:	e3800303 	orr	r0, r0, #201326592	; 0xc000000
3481821c:	ebfffe26 	bl	34817abc <s3c_read_cmd>
34818220:	e6ff4070 	uxth	r4, r0
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
34818224:	e1a01005 	mov	r1, r5
34818228:	e59f0028 	ldr	r0, [pc, #40]	; 34818258 <s3c_onenand_readw+0x174>
3481822c:	e1a02004 	mov	r2, r4
34818230:	ebffc624 	bl	34809ac8 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
34818234:	e6ff0074 	uxth	r0, r4
34818238:	e8bd8038 	pop	{r3, r4, r5, pc}
	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;

	case ONENAND_REG_WP_STATUS:
		return ONENAND_WP_US;
3481823c:	e3a00004 	mov	r0, #4

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}
34818240:	e8bd8038 	pop	{r3, r4, r5, pc}
34818244:	3482bb70 	.word	0x3482bb70
34818248:	0001e006 	.word	0x0001e006
3481824c:	0001e442 	.word	0x0001e442
34818250:	0001e00c 	.word	0x0001e00c
34818254:	0001e480 	.word	0x0001e480
34818258:	34827d34 	.word	0x34827d34

3481825c <s3c_onenand_check_lock_status.clone.0>:
	}

	return 0;
}

static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
3481825c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34818260:	e5907018 	ldr	r7, [r0, #24]
34818264:	e5903030 	ldr	r3, [r0, #48]	; 0x30

	for (block = 0; block < end; block++) {
34818268:	e3a04000 	mov	r4, #0
static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
3481826c:	e1a07337 	lsr	r7, r7, r3

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34818270:	e59f5060 	ldr	r5, [pc, #96]	; 348182d8 <s3c_onenand_check_lock_status.clone.0+0x7c>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
34818274:	e3a06c01 	mov	r6, #256	; 0x100
34818278:	ea000013 	b	348182cc <s3c_onenand_check_lock_status.clone.0+0x70>
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
3481827c:	e5953000 	ldr	r3, [r5]
34818280:	e3a01000 	mov	r1, #0
34818284:	e5933018 	ldr	r3, [r3, #24]
34818288:	e1a02001 	mov	r2, r1
3481828c:	e1a00004 	mov	r0, r4
34818290:	e12fff33 	blx	r3
34818294:	e3800301 	orr	r0, r0, #67108864	; 0x4000000
34818298:	ebfffe07 	bl	34817abc <s3c_read_cmd>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
3481829c:	e5953000 	ldr	r3, [r5]
348182a0:	e593301c 	ldr	r3, [r3, #28]
348182a4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
348182a8:	e3130c01 	tst	r3, #256	; 0x100
348182ac:	0a000005 	beq	348182c8 <s3c_onenand_check_lock_status.clone.0+0x6c>
			printf("block %d is write-protected!\n", block);
348182b0:	e1a01004 	mov	r1, r4
348182b4:	e59f0020 	ldr	r0, [pc, #32]	; 348182dc <s3c_onenand_check_lock_status.clone.0+0x80>
348182b8:	ebffc602 	bl	34809ac8 <printf>
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
348182bc:	e5953000 	ldr	r3, [r5]
348182c0:	e593301c 	ldr	r3, [r3, #28]
348182c4:	e5836050 	str	r6, [r3, #80]	; 0x50
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
348182c8:	e2844001 	add	r4, r4, #1
348182cc:	e1540007 	cmp	r4, r7
348182d0:	3affffe9 	bcc	3481827c <s3c_onenand_check_lock_status.clone.0+0x20>
		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
		}
	}
}
348182d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348182d8:	3482bb70 	.word	0x3482bb70
348182dc:	34827d70 	.word	0x34827d70

348182e0 <s3c_onenand_unlock_all>:

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
348182e0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	struct onenand_chip *this = mtd->priv;
348182e4:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
348182e8:	e5903014 	ldr	r3, [r0, #20]
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348182ec:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
348182f0:	e5853098 	str	r3, [r5, #152]	; 0x98
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348182f4:	e3120002 	tst	r2, #2
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
348182f8:	e3a03000 	mov	r3, #0

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
348182fc:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;
34818300:	e5956018 	ldr	r6, [r5, #24]
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34818304:	03a01000 	moveq	r1, #0
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
34818308:	e5803090 	str	r3, [r0, #144]	; 0x90
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
3481830c:	03a00000 	moveq	r0, #0

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34818310:	0a000010 	beq	34818358 <s3c_onenand_unlock_all+0x78>
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34818314:	e58d3000 	str	r3, [sp]
34818318:	e595c050 	ldr	ip, [r5, #80]	; 0x50
3481831c:	e3a01027 	mov	r1, #39	; 0x27
34818320:	e3a02000 	mov	r2, #0
34818324:	e3a03000 	mov	r3, #0
34818328:	e12fff3c 	blx	ip

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);
3481832c:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34818330:	e3a01008 	mov	r1, #8
34818334:	e1a00004 	mov	r0, r4
34818338:	e12fff33 	blx	r3

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
3481833c:	e595301c 	ldr	r3, [r5, #28]
34818340:	e3130008 	tst	r3, #8
			s3c_onenand_check_lock_status(mtd);
			return;
		}

		/* All blocks on another chip */
		ofs = this->chipsize >> 1;
34818344:	15956018 	ldrne	r6, [r5, #24]
34818348:	11a060a6 	lsrne	r6, r6, #1
3481834c:	11a00006 	movne	r0, r6
34818350:	13a01000 	movne	r1, #0

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34818354:	0a00001e 	beq	348183d4 <s3c_onenand_unlock_all+0xf4>
}

static void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
34818358:	e5945094 	ldr	r5, [r4, #148]	; 0x94
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
3481835c:	e59f7080 	ldr	r7, [pc, #128]	; 348183e4 <s3c_onenand_unlock_all+0x104>
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34818360:	e5952030 	ldr	r2, [r5, #48]	; 0x30
34818364:	eb001f31 	bl	34820030 <__ashrdi3>
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34818368:	e5973000 	ldr	r3, [r7]
3481836c:	e3a01000 	mov	r1, #0
34818370:	e1a02001 	mov	r2, r1
34818374:	e5933018 	ldr	r3, [r3, #24]
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34818378:	e1a09000 	mov	r9, r0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
3481837c:	e12fff33 	blx	r3
34818380:	e1a0a000 	mov	sl, r0
	end = start + (len >> this->erase_shift) - 1;
34818384:	e5950030 	ldr	r0, [r5, #48]	; 0x30
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34818388:	e5973000 	ldr	r3, [r7]
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
3481838c:	e1a06036 	lsr	r6, r6, r0
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34818390:	e3a01000 	mov	r1, #0
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
34818394:	e2460001 	sub	r0, r6, #1
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34818398:	e5933018 	ldr	r3, [r3, #24]
3481839c:	e1a02001 	mov	r2, r1
348183a0:	e0800009 	add	r0, r0, r9
348183a4:	e12fff33 	blx	r3

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348183a8:	e38a1302 	orr	r1, sl, #134217728	; 0x8000000
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348183ac:	e1a06000 	mov	r6, r0

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348183b0:	e3a00008 	mov	r0, #8
348183b4:	ebfffdc6 	bl	34817ad4 <s3c_write_cmd>
		s3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(end_mem_addr));
348183b8:	e3a00009 	mov	r0, #9
348183bc:	e3861302 	orr	r1, r6, #134217728	; 0x8000000
348183c0:	ebfffdc3 	bl	34817ad4 <s3c_write_cmd>
	}

	this->wait(mtd, FL_LOCKING);
348183c4:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348183c8:	e1a00004 	mov	r0, r4
348183cc:	e3a01008 	mov	r1, #8
348183d0:	e12fff33 	blx	r3
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348183d4:	e5940094 	ldr	r0, [r4, #148]	; 0x94
}
348183d8:	e28dd00c 	add	sp, sp, #12
348183dc:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348183e0:	eaffff9d 	b	3481825c <s3c_onenand_check_lock_status.clone.0>
348183e4:	3482bb70 	.word	0x3482bb70

348183e8 <s5pc110_chip_probe>:
#endif

int s5pc110_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
348183e8:	e3a00000 	mov	r0, #0
348183ec:	e12fff1e 	bx	lr

348183f0 <s5pc210_chip_probe>:

int s5pc210_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
348183f0:	e3a00000 	mov	r0, #0
348183f4:	e12fff1e 	bx	lr

348183f8 <s3c_onenand_init>:

void s3c_onenand_init(struct mtd_info *mtd)
{
348183f8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
348183fc:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
	return 0;
}

void s3c_onenand_init(struct mtd_info *mtd)
{
34818400:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34818404:	e3a00020 	mov	r0, #32
34818408:	ebffc775 	bl	3480a1e4 <malloc>
3481840c:	e59f50d4 	ldr	r5, [pc, #212]	; 348184e8 <s3c_onenand_init+0xf0>
	if (!onenand)
34818410:	e3500000 	cmp	r0, #0
void s3c_onenand_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34818414:	e1a07000 	mov	r7, r0
34818418:	e5850000 	str	r0, [r5]
	if (!onenand)
3481841c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34818420:	e3a00a01 	mov	r0, #4096	; 0x1000
34818424:	ebffc76e 	bl	3480a1e4 <malloc>
	if (!onenand->page_buf)
34818428:	e5953000 	ldr	r3, [r5]

	onenand = malloc(sizeof(struct s3c_onenand));
	if (!onenand)
		return;

	onenand->page_buf = malloc(size * sizeof(char));
3481842c:	e5870010 	str	r0, [r7, #16]
	if (!onenand->page_buf)
34818430:	e5930010 	ldr	r0, [r3, #16]
34818434:	e3500000 	cmp	r0, #0
34818438:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->page_buf, 0xff, size);
3481843c:	e3a010ff 	mov	r1, #255	; 0xff
34818440:	e3a02a01 	mov	r2, #4096	; 0x1000
34818444:	eb001073 	bl	3481c618 <memset>

	onenand->oob_buf = malloc(128 * sizeof(char));
34818448:	e3a00080 	mov	r0, #128	; 0x80
3481844c:	e5957000 	ldr	r7, [r5]
34818450:	ebffc763 	bl	3480a1e4 <malloc>
	if (!onenand->oob_buf)
34818454:	e5953000 	ldr	r3, [r5]
	onenand->page_buf = malloc(size * sizeof(char));
	if (!onenand->page_buf)
		return;
	memset(onenand->page_buf, 0xff, size);

	onenand->oob_buf = malloc(128 * sizeof(char));
34818458:	e5870014 	str	r0, [r7, #20]
	if (!onenand->oob_buf)
3481845c:	e5930014 	ldr	r0, [r3, #20]
34818460:	e3500000 	cmp	r0, #0
34818464:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->oob_buf, 0xff, 128);
34818468:	e3a010ff 	mov	r1, #255	; 0xff
3481846c:	e3a02080 	mov	r2, #128	; 0x80
34818470:	eb001068 	bl	3481c618 <memset>

	onenand->mtd = mtd;
34818474:	e5953000 	ldr	r3, [r5]
#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
	onenand->ahb_addr = (void *)0xB0000000;
34818478:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
3481847c:	e5831008 	str	r1, [r3, #8]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
34818480:	e59f2064 	ldr	r2, [pc, #100]	; 348184ec <s3c_onenand_init+0xf4>
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34818484:	e59f1064 	ldr	r1, [pc, #100]	; 348184f0 <s3c_onenand_init+0xf8>
	onenand->oob_buf = malloc(128 * sizeof(char));
	if (!onenand->oob_buf)
		return;
	memset(onenand->oob_buf, 0xff, 128);

	onenand->mtd = mtd;
34818488:	e5836000 	str	r6, [r3]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
3481848c:	e5832004 	str	r2, [r3, #4]
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34818490:	e5831018 	str	r1, [r3, #24]
	onenand->reg = (struct samsung_onenand *)onenand->base;
34818494:	e583201c 	str	r2, [r3, #28]

	this->read_word = s3c_onenand_readw;
34818498:	e59f3054 	ldr	r3, [pc, #84]	; 348184f4 <s3c_onenand_init+0xfc>
3481849c:	e5843068 	str	r3, [r4, #104]	; 0x68
	this->write_word = s3c_onenand_writew;
348184a0:	e59f3050 	ldr	r3, [pc, #80]	; 348184f8 <s3c_onenand_init+0x100>
348184a4:	e584306c 	str	r3, [r4, #108]	; 0x6c

	this->wait = s3c_onenand_wait;
348184a8:	e59f304c 	ldr	r3, [pc, #76]	; 348184fc <s3c_onenand_init+0x104>
348184ac:	e5843054 	str	r3, [r4, #84]	; 0x54
	this->bbt_wait = s3c_onenand_bbt_wait;
348184b0:	e59f3048 	ldr	r3, [pc, #72]	; 34818500 <s3c_onenand_init+0x108>
348184b4:	e5843058 	str	r3, [r4, #88]	; 0x58
	this->unlock_all = s3c_onenand_unlock_all;
348184b8:	e59f3044 	ldr	r3, [pc, #68]	; 34818504 <s3c_onenand_init+0x10c>
348184bc:	e584305c 	str	r3, [r4, #92]	; 0x5c
	this->command = s3c_onenand_command;
348184c0:	e59f3040 	ldr	r3, [pc, #64]	; 34818508 <s3c_onenand_init+0x110>
348184c4:	e5843050 	str	r3, [r4, #80]	; 0x50

	this->read_bufferram = onenand_read_bufferram;
348184c8:	e59f303c 	ldr	r3, [pc, #60]	; 3481850c <s3c_onenand_init+0x114>
348184cc:	e5843060 	str	r3, [r4, #96]	; 0x60
	this->write_bufferram = onenand_write_bufferram;
348184d0:	e59f3038 	ldr	r3, [pc, #56]	; 34818510 <s3c_onenand_init+0x118>
348184d4:	e5843064 	str	r3, [r4, #100]	; 0x64

	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
348184d8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348184dc:	e3833c02 	orr	r3, r3, #512	; 0x200
348184e0:	e584302c 	str	r3, [r4, #44]	; 0x2c
348184e4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348184e8:	3482bb70 	.word	0x3482bb70
348184ec:	e7100000 	.word	0xe7100000
348184f0:	34817aec 	.word	0x34817aec
348184f4:	348180e4 	.word	0x348180e4
348184f8:	34817ffc 	.word	0x34817ffc
348184fc:	34817ef8 	.word	0x34817ef8
34818500:	34817e20 	.word	0x34817e20
34818504:	348182e0 	.word	0x348182e0
34818508:	34817b74 	.word	0x34817b74
3481850c:	34817ed0 	.word	0x34817ed0
34818510:	34817ea8 	.word	0x34817ea8

34818514 <samsung_get_base_uart>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34818514:	e59f3028 	ldr	r3, [pc, #40]	; 34818544 <samsung_get_base_uart+0x30>
34818518:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
3481851c:	e3530cc1 	cmp	r3, #49408	; 0xc100
34818520:	0a000005 	beq	3481853c <samsung_get_base_uart+0x28>
34818524:	e30c0110 	movw	r0, #49424	; 0xc110
34818528:	e59f2018 	ldr	r2, [pc, #24]	; 34818548 <samsung_get_base_uart+0x34>
3481852c:	e1530000 	cmp	r3, r0
34818530:	01a00002 	moveq	r0, r2
34818534:	13a00000 	movne	r0, #0
34818538:	e12fff1e 	bx	lr
3481853c:	e3a0033b 	mov	r0, #-335544320	; 0xec000000
34818540:	e12fff1e 	bx	lr
34818544:	34828288 	.word	0x34828288
34818548:	e2900000 	.word	0xe2900000

3481854c <serial_setbrg_dev>:
	0xdfdf,
	0xffdf,
};

void serial_setbrg_dev(const int dev_index)
{
3481854c:	e92d4038 	push	{r3, r4, r5, lr}
34818550:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818554:	ebffffee 	bl	34818514 <samsung_get_base_uart>
34818558:	e0804505 	add	r4, r0, r5, lsl #10
};

void serial_setbrg_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);
	u32 uclk = get_uart_clk(dev_index);
3481855c:	e1a00005 	mov	r0, r5
34818560:	ebffa504 	bl	34801978 <get_uart_clk>
	u32 baudrate = gd->baudrate;
34818564:	e5981008 	ldr	r1, [r8, #8]
	u32 val;

	val = uclk / baudrate;
34818568:	eb001d96 	bl	3481fbc8 <__udivsi3>

	writel(val / 16 - 1, &uart->ubrdiv);
3481856c:	e1a03220 	lsr	r3, r0, #4
34818570:	e2433001 	sub	r3, r3, #1
34818574:	e5843028 	str	r3, [r4, #40]	; 0x28

	if (s5p_uart_divslot())
		writew(udivslot[val % 16], &uart->rest.slot);
34818578:	e59f3010 	ldr	r3, [pc, #16]	; 34818590 <serial_setbrg_dev+0x44>
3481857c:	e200000f 	and	r0, r0, #15
34818580:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34818584:	e6ff3073 	uxth	r3, r3
34818588:	e1c432bc 	strh	r3, [r4, #44]	; 0x2c
	else
		writeb(val % 16, &uart->rest.value);
}
3481858c:	e8bd8038 	pop	{r3, r4, r5, pc}
34818590:	34821574 	.word	0x34821574

34818594 <s5p_serial3_setbrg>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818594:	e3a00003 	mov	r0, #3
34818598:	eaffffeb 	b	3481854c <serial_setbrg_dev>

3481859c <s5p_serial2_setbrg>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
3481859c:	e3a00002 	mov	r0, #2
348185a0:	eaffffe9 	b	3481854c <serial_setbrg_dev>

348185a4 <s5p_serial1_setbrg>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
348185a4:	e3a00001 	mov	r0, #1
348185a8:	eaffffe7 	b	3481854c <serial_setbrg_dev>

348185ac <s5p_serial0_setbrg>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
348185ac:	e3a00000 	mov	r0, #0
348185b0:	eaffffe5 	b	3481854c <serial_setbrg_dev>

348185b4 <serial_init_dev>:
/*
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 */
int serial_init_dev(const int dev_index)
{
348185b4:	e92d4038 	push	{r3, r4, r5, lr}
348185b8:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
348185bc:	ebffffd4 	bl	34818514 <samsung_get_base_uart>
348185c0:	e0803505 	add	r3, r0, r5, lsl #10
int serial_init_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* reset and enable FIFOs, set triggers to the maximum */
	writel(0, &uart->ufcon);
348185c4:	e3a04000 	mov	r4, #0
348185c8:	e5834008 	str	r4, [r3, #8]
	writel(0, &uart->umcon);
348185cc:	e583400c 	str	r4, [r3, #12]
	/* 8N1 */
	writel(0x3, &uart->ulcon);
348185d0:	e3a02003 	mov	r2, #3
348185d4:	e7802505 	str	r2, [r0, r5, lsl #10]
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
348185d8:	e3002245 	movw	r2, #581	; 0x245

	serial_setbrg_dev(dev_index);
348185dc:	e1a00005 	mov	r0, r5
	writel(0, &uart->ufcon);
	writel(0, &uart->umcon);
	/* 8N1 */
	writel(0x3, &uart->ulcon);
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
348185e0:	e5832004 	str	r2, [r3, #4]

	serial_setbrg_dev(dev_index);
348185e4:	ebffffd8 	bl	3481854c <serial_setbrg_dev>

	return 0;
}
348185e8:	e1a00004 	mov	r0, r4
348185ec:	e8bd8038 	pop	{r3, r4, r5, pc}

348185f0 <s5p_serial3_init>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
348185f0:	e3a00003 	mov	r0, #3
348185f4:	eaffffee 	b	348185b4 <serial_init_dev>

348185f8 <s5p_serial2_init>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
348185f8:	e3a00002 	mov	r0, #2
348185fc:	eaffffec 	b	348185b4 <serial_init_dev>

34818600 <s5p_serial1_init>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818600:	e3a00001 	mov	r0, #1
34818604:	eaffffea 	b	348185b4 <serial_init_dev>

34818608 <s5p_serial0_init>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818608:	e3a00000 	mov	r0, #0
3481860c:	eaffffe8 	b	348185b4 <serial_init_dev>

34818610 <serial_getc_dev>:
 * Read a single byte from the serial port. Returns 1 on success, 0
 * otherwise. When the function is succesfull, the character read is
 * written into its argument c.
 */
int serial_getc_dev(const int dev_index)
{
34818610:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34818614:	e1a05500 	lsl	r5, r0, #10
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818618:	ebffffbd 	bl	34818514 <samsung_get_base_uart>
3481861c:	e0804005 	add	r4, r0, r5
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34818620:	ea000004 	b	34818638 <serial_getc_dev+0x28>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818624:	ebffffba 	bl	34818514 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34818628:	e0800005 	add	r0, r0, r5
3481862c:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
34818630:	e313000f 	tst	r3, #15
34818634:	1a000004 	bne	3481864c <serial_getc_dev+0x3c>
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34818638:	e5946010 	ldr	r6, [r4, #16]
3481863c:	e2166001 	ands	r6, r6, #1
34818640:	0afffff7 	beq	34818624 <serial_getc_dev+0x14>
		if (serial_err_check(dev_index, 0))
			return 0;
	}

	return (int)(readb(&uart->urxh) & 0xff);
34818644:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
34818648:	e8bd8070 	pop	{r4, r5, r6, pc}
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
			return 0;
3481864c:	e1a00006 	mov	r0, r6
	}

	return (int)(readb(&uart->urxh) & 0xff);
}
34818650:	e8bd8070 	pop	{r4, r5, r6, pc}

34818654 <s5p_serial3_getc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818654:	e3a00003 	mov	r0, #3
34818658:	eaffffec 	b	34818610 <serial_getc_dev>

3481865c <s5p_serial2_getc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
3481865c:	e3a00002 	mov	r0, #2
34818660:	eaffffea 	b	34818610 <serial_getc_dev>

34818664 <s5p_serial1_getc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818664:	e3a00001 	mov	r0, #1
34818668:	eaffffe8 	b	34818610 <serial_getc_dev>

3481866c <s5p_serial0_getc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
3481866c:	e3a00000 	mov	r0, #0
34818670:	eaffffe6 	b	34818610 <serial_getc_dev>

34818674 <serial_putc_dev>:

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34818674:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34818678:	e1a06501 	lsl	r6, r1, #10

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
3481867c:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818680:	ebffffa3 	bl	34818514 <samsung_get_base_uart>
34818684:	e0805006 	add	r5, r0, r6
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34818688:	ea000004 	b	348186a0 <serial_putc_dev+0x2c>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
3481868c:	ebffffa0 	bl	34818514 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34818690:	e0800006 	add	r0, r0, r6
34818694:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
34818698:	e3130008 	tst	r3, #8
3481869c:	18bd8070 	popne	{r4, r5, r6, pc}
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
348186a0:	e5953010 	ldr	r3, [r5, #16]
348186a4:	e3130002 	tst	r3, #2
348186a8:	0afffff7 	beq	3481868c <serial_putc_dev+0x18>
	}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
348186ac:	e354000a 	cmp	r4, #10
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
			return;
	}

	writeb(c, &uart->utxh);
348186b0:	e5c54020 	strb	r4, [r5, #32]

	/* If \n, also do \r */
	if (c == '\n')
348186b4:	18bd8070 	popne	{r4, r5, r6, pc}
		serial_putc('\r');
348186b8:	e3a0000d 	mov	r0, #13
}
348186bc:	e8bd4070 	pop	{r4, r5, r6, lr}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
		serial_putc('\r');
348186c0:	eaffd9d0 	b	3480ee08 <serial_putc>

348186c4 <s5p_serial3_putc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
348186c4:	e3a01003 	mov	r1, #3
348186c8:	eaffffe9 	b	34818674 <serial_putc_dev>

348186cc <s5p_serial2_putc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
348186cc:	e3a01002 	mov	r1, #2
348186d0:	eaffffe7 	b	34818674 <serial_putc_dev>

348186d4 <s5p_serial1_putc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
348186d4:	e3a01001 	mov	r1, #1
348186d8:	eaffffe5 	b	34818674 <serial_putc_dev>

348186dc <s5p_serial0_putc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
348186dc:	e3a01000 	mov	r1, #0
348186e0:	eaffffe3 	b	34818674 <serial_putc_dev>

348186e4 <serial_tstc_dev>:

/*
 * Test whether a character is in the RX buffer
 */
int serial_tstc_dev(const int dev_index)
{
348186e4:	e92d4010 	push	{r4, lr}
348186e8:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
348186ec:	ebffff88 	bl	34818514 <samsung_get_base_uart>
 */
int serial_tstc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	return (int)(readl(&uart->utrstat) & 0x1);
348186f0:	e0800504 	add	r0, r0, r4, lsl #10
348186f4:	e5900010 	ldr	r0, [r0, #16]
}
348186f8:	e2000001 	and	r0, r0, #1
348186fc:	e8bd8010 	pop	{r4, pc}

34818700 <s5p_serial3_tstc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818700:	e3a00003 	mov	r0, #3
34818704:	eafffff6 	b	348186e4 <serial_tstc_dev>

34818708 <s5p_serial2_tstc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34818708:	e3a00002 	mov	r0, #2
3481870c:	eafffff4 	b	348186e4 <serial_tstc_dev>

34818710 <s5p_serial1_tstc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818710:	e3a00001 	mov	r0, #1
34818714:	eafffff2 	b	348186e4 <serial_tstc_dev>

34818718 <s5p_serial0_tstc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818718:	e3a00000 	mov	r0, #0
3481871c:	eafffff0 	b	348186e4 <serial_tstc_dev>

34818720 <serial_puts_dev>:

	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
34818720:	e92d4038 	push	{r3, r4, r5, lr}
34818724:	e1a05001 	mov	r5, r1
34818728:	e1a04000 	mov	r4, r0
	while (*s)
3481872c:	ea000001 	b	34818738 <serial_puts_dev+0x18>
		serial_putc_dev(*s++, dev_index);
34818730:	e1a01005 	mov	r1, r5
34818734:	ebffffce 	bl	34818674 <serial_putc_dev>
	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
	while (*s)
34818738:	e4d40001 	ldrb	r0, [r4], #1
3481873c:	e3500000 	cmp	r0, #0
34818740:	1afffffa 	bne	34818730 <serial_puts_dev+0x10>
		serial_putc_dev(*s++, dev_index);
}
34818744:	e8bd8038 	pop	{r3, r4, r5, pc}

34818748 <s5p_serial3_puts>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818748:	e3a01003 	mov	r1, #3
3481874c:	eafffff3 	b	34818720 <serial_puts_dev>

34818750 <s5p_serial2_puts>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34818750:	e3a01002 	mov	r1, #2
34818754:	eafffff1 	b	34818720 <serial_puts_dev>

34818758 <s5p_serial1_puts>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818758:	e3a01001 	mov	r1, #1
3481875c:	eaffffef 	b	34818720 <serial_puts_dev>

34818760 <s5p_serial0_puts>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818760:	e3a01000 	mov	r1, #0
34818764:	eaffffed 	b	34818720 <serial_puts_dev>

34818768 <default_serial_console>:
#elif defined(CONFIG_SERIAL3)
	return &s5p_serial3_device;
#else
#error "CONFIG_SERIAL? missing."
#endif
}
34818768:	e59f0000 	ldr	r0, [pc, #0]	; 34818770 <default_serial_console+0x8>
3481876c:	e12fff1e 	bx	lr
34818770:	348291a8 	.word	0x348291a8

34818774 <usb_ep_autoconfig>:
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34818774:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818778:	e1a07000 	mov	r7, r0
3481877c:	e5b74008 	ldr	r4, [r7, #8]!
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34818780:	e1a0a000 	mov	sl, r0
34818784:	e1a05001 	mov	r5, r1
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818788:	e244400c 	sub	r4, r4, #12
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
3481878c:	e59f9200 	ldr	r9, [pc, #512]	; 34818994 <usb_ep_autoconfig+0x220>

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
34818790:	e300b3ff 	movw	fp, #1023	; 0x3ff
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818794:	ea000078 	b	3481897c <usb_ep_autoconfig+0x208>
	u8		type;
	const char	*tmp;
	u16		max;

	/* endpoint already claimed? */
	if (NULL != ep->driver_data)
34818798:	e5943000 	ldr	r3, [r4]
3481879c:	e3530000 	cmp	r3, #0
348187a0:	1a000073 	bne	34818974 <usb_ep_autoconfig+0x200>
		return 0;

	/* only support ep0 for portable CONTROL traffic */
	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
348187a4:	e5d56003 	ldrb	r6, [r5, #3]
	if (USB_ENDPOINT_XFER_CONTROL == type)
348187a8:	e2166003 	ands	r6, r6, #3
348187ac:	0a000070 	beq	34818974 <usb_ep_autoconfig+0x200>
		return 0;

	/* some other naming convention */
	if ('e' != ep->name[0])
348187b0:	e5940004 	ldr	r0, [r4, #4]
348187b4:	e5d03000 	ldrb	r3, [r0]
348187b8:	e3530065 	cmp	r3, #101	; 0x65
348187bc:	1a00006c 	bne	34818974 <usb_ep_autoconfig+0x200>
		return 0;

	/* type-restriction:  "-iso", "-bulk", or "-int".
	 * direction-restriction:  "in", "out".
	 */
	if ('-' != ep->name[2]) {
348187c0:	e5d03002 	ldrb	r3, [r0, #2]
348187c4:	e353002d 	cmp	r3, #45	; 0x2d
348187c8:	0a000023 	beq	3481885c <usb_ep_autoconfig+0xe8>
		tmp = strrchr(ep->name, '-');
348187cc:	e3a0102d 	mov	r1, #45	; 0x2d
348187d0:	eb000f0c 	bl	3481c408 <strrchr>
		if (tmp) {
348187d4:	e3500000 	cmp	r0, #0
348187d8:	0a00000d 	beq	34818814 <usb_ep_autoconfig+0xa0>
			switch (type) {
348187dc:	e3560002 	cmp	r6, #2
348187e0:	0a000005 	beq	348187fc <usb_ep_autoconfig+0x88>
348187e4:	e3560003 	cmp	r6, #3
348187e8:	e5d03002 	ldrb	r3, [r0, #2]
348187ec:	1a000005 	bne	34818808 <usb_ep_autoconfig+0x94>
			case USB_ENDPOINT_XFER_INT:
				/* bulk endpoints handle interrupt transfers,
				 * except the toggle-quirky iso-synch kind
				 */
				if ('s' == tmp[2])	/* == "-iso" */
348187f0:	e3530073 	cmp	r3, #115	; 0x73
348187f4:	1a00000c 	bne	3481882c <usb_ep_autoconfig+0xb8>
348187f8:	ea00005d 	b	34818974 <usb_ep_autoconfig+0x200>
				if (gadget_is_pxa(gadget)
						&& 'i' == tmp[1])
					return 0;
				break;
			case USB_ENDPOINT_XFER_BULK:
				if ('b' != tmp[1])	/* != "-bulk" */
348187fc:	e5d03001 	ldrb	r3, [r0, #1]
34818800:	e3530062 	cmp	r3, #98	; 0x62
34818804:	ea000000 	b	3481880c <usb_ep_autoconfig+0x98>
					return 0;
				break;
			case USB_ENDPOINT_XFER_ISOC:
				if ('s' != tmp[2])	/* != "-iso" */
34818808:	e3530073 	cmp	r3, #115	; 0x73
3481880c:	1a000058 	bne	34818974 <usb_ep_autoconfig+0x200>
34818810:	ea000005 	b	3481882c <usb_ep_autoconfig+0xb8>
					return 0;
			}
		} else {
			tmp = ep->name + strlen(ep->name);
34818814:	e5943004 	ldr	r3, [r4, #4]
34818818:	e1a00003 	mov	r0, r3
3481881c:	e58d3000 	str	r3, [sp]
34818820:	eb000edc 	bl	3481c398 <strlen>
34818824:	e59d3000 	ldr	r3, [sp]
34818828:	e0830000 	add	r0, r3, r0
		}

		/* direction-restriction:  "..in-..", "out-.." */
		tmp--;
		if (!isdigit(*tmp)) {
3481882c:	e5503001 	ldrb	r3, [r0, #-1]
34818830:	e2432030 	sub	r2, r3, #48	; 0x30
34818834:	e6ef2072 	uxtb	r2, r2
34818838:	e3520009 	cmp	r2, #9
3481883c:	9a000006 	bls	3481885c <usb_ep_autoconfig+0xe8>
			if (desc->bEndpointAddress & USB_DIR_IN) {
34818840:	e1d520d2 	ldrsb	r2, [r5, #2]
34818844:	e3520000 	cmp	r2, #0
34818848:	aa000001 	bge	34818854 <usb_ep_autoconfig+0xe0>
				if ('n' != *tmp)
3481884c:	e353006e 	cmp	r3, #110	; 0x6e
34818850:	ea000000 	b	34818858 <usb_ep_autoconfig+0xe4>
					return 0;
			} else {
				if ('t' != *tmp)
34818854:	e3530074 	cmp	r3, #116	; 0x74
34818858:	1a000045 	bne	34818974 <usb_ep_autoconfig+0x200>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
3481885c:	e5d52004 	ldrb	r2, [r5, #4]
34818860:	e5d50005 	ldrb	r0, [r5, #5]
	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
	switch (type) {
34818864:	e3560001 	cmp	r6, #1
34818868:	e1820400 	orr	r0, r2, r0, lsl #8

	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
3481886c:	e1a02a80 	lsl	r2, r0, #21
34818870:	e2853004 	add	r3, r5, #4
34818874:	e285c005 	add	ip, r5, #5
34818878:	e1a02aa2 	lsr	r2, r2, #21
	switch (type) {
3481887c:	0a00000a 	beq	348188ac <usb_ep_autoconfig+0x138>
34818880:	e3560003 	cmp	r6, #3
34818884:	1a000018 	bne	348188ec <usb_ep_autoconfig+0x178>
	case USB_ENDPOINT_XFER_INT:
		/* INT:  limit 64 bytes full speed, 1024 high speed */
		if (!gadget->is_dualspeed && max > 64)
34818888:	e5da1014 	ldrb	r1, [sl, #20]
3481888c:	e3110001 	tst	r1, #1
34818890:	13a01000 	movne	r1, #0
34818894:	03a01001 	moveq	r1, #1
34818898:	e3520040 	cmp	r2, #64	; 0x40
3481889c:	93a01000 	movls	r1, #0
348188a0:	82011001 	andhi	r1, r1, #1
348188a4:	e3510000 	cmp	r1, #0
348188a8:	1a000031 	bne	34818974 <usb_ep_autoconfig+0x200>
			return 0;
		/* FALLTHROUGH */

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
348188ac:	e1d411b4 	ldrh	r1, [r4, #20]
348188b0:	e1510002 	cmp	r1, r2
348188b4:	3a00002e 	bcc	34818974 <usb_ep_autoconfig+0x200>
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
348188b8:	e5da1014 	ldrb	r1, [sl, #20]
348188bc:	e3110001 	tst	r1, #1
348188c0:	13a01000 	movne	r1, #0
348188c4:	03a01001 	moveq	r1, #1
348188c8:	e152000b 	cmp	r2, fp
348188cc:	93a02000 	movls	r2, #0
348188d0:	82012001 	andhi	r2, r1, #1
348188d4:	e3520000 	cmp	r2, #0
348188d8:	1a000025 	bne	34818974 <usb_ep_autoconfig+0x200>
			return 0;

		/* BOTH:  "high bandwidth" works only at high speed */
		if ((get_unaligned(&desc->wMaxPacketSize) &
348188dc:	e3100b06 	tst	r0, #6144	; 0x1800
348188e0:	0a000001 	beq	348188ec <usb_ep_autoconfig+0x178>
					__constant_cpu_to_le16(3<<11))) {
			if (!gadget->is_dualspeed)
348188e4:	e3510000 	cmp	r1, #0
348188e8:	1a000021 	bne	34818974 <usb_ep_autoconfig+0x200>
	}

	/* MATCH!! */

	/* report address */
	if (isdigit(ep->name[2])) {
348188ec:	e5942004 	ldr	r2, [r4, #4]
348188f0:	e2820002 	add	r0, r2, #2
348188f4:	e5d22002 	ldrb	r2, [r2, #2]
348188f8:	e2422030 	sub	r2, r2, #48	; 0x30
348188fc:	e6ef2072 	uxtb	r2, r2
34818900:	e3520009 	cmp	r2, #9
34818904:	8a000009 	bhi	34818930 <usb_ep_autoconfig+0x1bc>
		u8	num = simple_strtoul(&ep->name[2], NULL, 10);
34818908:	e3a0200a 	mov	r2, #10
3481890c:	e3a01000 	mov	r1, #0
34818910:	e88d1008 	stm	sp, {r3, ip}
34818914:	eb001232 	bl	3481d1e4 <simple_strtoul>
		desc->bEndpointAddress |= num;
34818918:	e5d52002 	ldrb	r2, [r5, #2]
3481891c:	e59d3000 	ldr	r3, [sp]
34818920:	e1802002 	orr	r2, r0, r2
34818924:	e5c52002 	strb	r2, [r5, #2]
34818928:	e59dc004 	ldr	ip, [sp, #4]
3481892c:	ea000007 	b	34818950 <usb_ep_autoconfig+0x1dc>
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34818930:	e5992000 	ldr	r2, [r9]
34818934:	e2822001 	add	r2, r2, #1
34818938:	e352000f 	cmp	r2, #15
3481893c:	e5892000 	str	r2, [r9]
34818940:	8a00000b 	bhi	34818974 <usb_ep_autoconfig+0x200>
			return 0;
		desc->bEndpointAddress |= epnum;
34818944:	e5d51002 	ldrb	r1, [r5, #2]
34818948:	e1822001 	orr	r2, r2, r1
3481894c:	e5c52002 	strb	r2, [r5, #2]
	}

	/* report (variable) full speed bulk maxpacket */
	if (USB_ENDPOINT_XFER_BULK == type) {
34818950:	e3560002 	cmp	r6, #2
34818954:	1a00000c 	bne	3481898c <usb_ep_autoconfig+0x218>
		int size = ep->maxpacket;
34818958:	e1d421b4 	ldrh	r2, [r4, #20]

		/* min() doesn't work on bitfields with gcc-3.5 */
		if (size > 64)
			size = 64;
		put_unaligned(cpu_to_le16(size), &desc->wMaxPacketSize);
3481895c:	e3520040 	cmp	r2, #64	; 0x40
34818960:	a3a02040 	movge	r2, #64	; 0x40
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
34818964:	e5c32000 	strb	r2, [r3]
	*p++ = val >> 8;
34818968:	e3a03000 	mov	r3, #0
3481896c:	e5cc3000 	strb	r3, [ip]
34818970:	ea000005 	b	3481898c <usb_ep_autoconfig+0x218>
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818974:	e594400c 	ldr	r4, [r4, #12]
34818978:	e244400c 	sub	r4, r4, #12
3481897c:	e284300c 	add	r3, r4, #12
34818980:	e1530007 	cmp	r3, r7
34818984:	1affff83 	bne	34818798 <usb_ep_autoconfig+0x24>
		if (ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Fail */
	return NULL;
34818988:	e3a04000 	mov	r4, #0
}
3481898c:	e1a00004 	mov	r0, r4
34818990:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34818994:	3482bb74 	.word	0x3482bb74

34818998 <usb_ep_autoconfig_reset>:
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818998:	e5b03008 	ldr	r3, [r0, #8]!
		ep->driver_data = NULL;
3481899c:	e3a02000 	mov	r2, #0
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
348189a0:	e243300c 	sub	r3, r3, #12
348189a4:	ea000002 	b	348189b4 <usb_ep_autoconfig_reset+0x1c>
		ep->driver_data = NULL;
348189a8:	e5832000 	str	r2, [r3]
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
348189ac:	e593300c 	ldr	r3, [r3, #12]
348189b0:	e243300c 	sub	r3, r3, #12
348189b4:	e283100c 	add	r1, r3, #12
348189b8:	e1510000 	cmp	r1, r0
348189bc:	1afffff9 	bne	348189a8 <usb_ep_autoconfig_reset+0x10>
		ep->driver_data = NULL;
	}
#ifdef	MANY_ENDPOINTS
	in_epnum = 0;
#endif
	epnum = 0;
348189c0:	e59f3008 	ldr	r3, [pc, #8]	; 348189d0 <usb_ep_autoconfig_reset+0x38>
348189c4:	e3a02000 	mov	r2, #0
348189c8:	e5832000 	str	r2, [r3]
}
348189cc:	e12fff1e 	bx	lr
348189d0:	3482bb74 	.word	0x3482bb74

348189d4 <usb_descriptor_fillbuf>:
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
348189d4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8	*dest = buf;

	if (!src)
348189d8:	e252a000 	subs	sl, r2, #0
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
348189dc:	e1a07000 	mov	r7, r0
348189e0:	e1a06001 	mov	r6, r1
	u8	*dest = buf;
348189e4:	11a04000 	movne	r4, r0

	if (!src)
348189e8:	1a000008 	bne	34818a10 <usb_descriptor_fillbuf+0x3c>
348189ec:	ea00000c 	b	34818a24 <usb_descriptor_fillbuf+0x50>
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;
348189f0:	e5d15000 	ldrb	r5, [r1]

		if (len > buflen)
348189f4:	e1550006 	cmp	r5, r6
348189f8:	8a00000b 	bhi	34818a2c <usb_descriptor_fillbuf+0x58>
			return -EINVAL;
		memcpy(dest, *src, len);
348189fc:	e1a00004 	mov	r0, r4
34818a00:	e1a02005 	mov	r2, r5
34818a04:	eb000f27 	bl	3481c6a8 <memcpy>
		buflen -= len;
34818a08:	e0656006 	rsb	r6, r5, r6
		dest += len;
34818a0c:	e0844005 	add	r4, r4, r5

	if (!src)
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
34818a10:	e49a1004 	ldr	r1, [sl], #4
34818a14:	e3510000 	cmp	r1, #0
34818a18:	1afffff4 	bne	348189f0 <usb_descriptor_fillbuf+0x1c>
			return -EINVAL;
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
34818a1c:	e0670004 	rsb	r0, r7, r4
34818a20:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		const struct usb_descriptor_header **src)
{
	u8	*dest = buf;

	if (!src)
		return -EINVAL;
34818a24:	e3e00015 	mvn	r0, #21
34818a28:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;

		if (len > buflen)
			return -EINVAL;
34818a2c:	e3e00015 	mvn	r0, #21
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
}
34818a30:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34818a34 <usb_gadget_config_buf>:
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818a34:	e3530000 	cmp	r3, #0
34818a38:	13520008 	cmpne	r2, #8
	const struct usb_config_descriptor	*config,
	void					*buf,
	unsigned				length,
	const struct usb_descriptor_header	**desc
)
{
34818a3c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34818a40:	e1a0c000 	mov	ip, r0
34818a44:	e1a04001 	mov	r4, r1
34818a48:	e1a05002 	mov	r5, r2
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818a4c:	e1a07003 	mov	r7, r3
		return -EINVAL;
34818a50:	93e00015 	mvnls	r0, #21
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818a54:	98bd80f8 	popls	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
	*cp = *config;
34818a58:	e3a06009 	mov	r6, #9
34818a5c:	e1a00001 	mov	r0, r1
34818a60:	e1a02006 	mov	r2, r6
34818a64:	e1a0100c 	mov	r1, ip
34818a68:	eb000f0e 	bl	3481c6a8 <memcpy>

	/* then interface/endpoint/class/vendor/... */
	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,
34818a6c:	e0840006 	add	r0, r4, r6
34818a70:	e2451009 	sub	r1, r5, #9
34818a74:	e1a02007 	mov	r2, r7
34818a78:	ebffffd5 	bl	348189d4 <usb_descriptor_fillbuf>
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
34818a7c:	e3500000 	cmp	r0, #0
34818a80:	b8bd80f8 	poplt	{r3, r4, r5, r6, r7, pc}
		return len;
	len += USB_DT_CONFIG_SIZE;
34818a84:	e0800006 	add	r0, r0, r6
	if (len > 0xffff)
34818a88:	e3500801 	cmp	r0, #65536	; 0x10000
34818a8c:	aa00000b 	bge	34818ac0 <usb_gadget_config_buf+0x8c>
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
34818a90:	e3a03002 	mov	r3, #2
34818a94:	e5c43001 	strb	r3, [r4, #1]
	cp->wTotalLength = cpu_to_le16(len);
34818a98:	e6ff3070 	uxth	r3, r0
34818a9c:	e5c43002 	strb	r3, [r4, #2]
34818aa0:	e1a03423 	lsr	r3, r3, #8
34818aa4:	e5c43003 	strb	r3, [r4, #3]
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34818aa8:	e5d43007 	ldrb	r3, [r4, #7]
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
34818aac:	e5c46000 	strb	r6, [r4]
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34818ab0:	e1e03c83 	mvn	r3, r3, lsl #25
34818ab4:	e1e03ca3 	mvn	r3, r3, lsr #25
34818ab8:	e5c43007 	strb	r3, [r4, #7]
	return len;
34818abc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
		return len;
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;
34818ac0:	e3e00015 	mvn	r0, #21
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
	return len;
}
34818ac4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34818ac8 <usb_gadget_get_string>:
{
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818ac8:	e3510000 	cmp	r1, #0
 * the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
 * characters (which are also widely used in C strings).
 */
int
usb_gadget_get_string(struct usb_gadget_strings *table, int id, u8 *buf)
{
34818acc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34818ad0:	e1a04002 	mov	r4, r2
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818ad4:	1a00000a 	bne	34818b04 <usb_gadget_get_string+0x3c>
		buf[0] = 4;
34818ad8:	e3a03004 	mov	r3, #4
34818adc:	e5c23000 	strb	r3, [r2]
		buf[1] = USB_DT_STRING;
34818ae0:	e3a02003 	mov	r2, #3
34818ae4:	e5c42001 	strb	r2, [r4, #1]
		buf[2] = (u8) table->language;
34818ae8:	e1d020b0 	ldrh	r2, [r0]
34818aec:	e5c42002 	strb	r2, [r4, #2]
		buf[3] = (u8) (table->language >> 8);
34818af0:	e1d020b0 	ldrh	r2, [r0]
		return 4;
34818af4:	e1a00003 	mov	r0, r3
	/* descriptor 0 has the language id */
	if (id == 0) {
		buf[0] = 4;
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
34818af8:	e1a02422 	lsr	r2, r2, #8
34818afc:	e5c42003 	strb	r2, [r4, #3]
		return 4;
34818b00:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	for (s = table->strings; s && s->s; s++)
34818b04:	e5905004 	ldr	r5, [r0, #4]
34818b08:	ea000003 	b	34818b1c <usb_gadget_get_string+0x54>
		if (s->id == id)
34818b0c:	e5d53000 	ldrb	r3, [r5]
34818b10:	e1530001 	cmp	r3, r1
34818b14:	0a000006 	beq	34818b34 <usb_gadget_get_string+0x6c>
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
		return 4;
	}
	for (s = table->strings; s && s->s; s++)
34818b18:	e2855008 	add	r5, r5, #8
34818b1c:	e3550000 	cmp	r5, #0
34818b20:	0a000041 	beq	34818c2c <usb_gadget_get_string+0x164>
34818b24:	e5950004 	ldr	r0, [r5, #4]
34818b28:	e3500000 	cmp	r0, #0
34818b2c:	1afffff6 	bne	34818b0c <usb_gadget_get_string+0x44>
34818b30:	ea00003d 	b	34818c2c <usb_gadget_get_string+0x164>
	/* unrecognized: stall. */
	if (!s || !s->s)
		return -EINVAL;

	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
34818b34:	eb000e17 	bl	3481c398 <strlen>
34818b38:	e350007e 	cmp	r0, #126	; 0x7e
34818b3c:	31a06000 	movcc	r6, r0
34818b40:	23a0607e 	movcs	r6, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
34818b44:	e3a01000 	mov	r1, #0
34818b48:	e2840002 	add	r0, r4, #2
34818b4c:	e1a02086 	lsl	r2, r6, #1
34818b50:	eb000eb0 	bl	3481c618 <memset>
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
34818b54:	e5953004 	ldr	r3, [r5, #4]
34818b58:	e1a01004 	mov	r1, r4
#include <asm/unaligned.h>


static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)
{
	int	count = 0;
34818b5c:	e3a00000 	mov	r0, #0
					goto fail;
				c &= 0x3f;
				uchar |= c;

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818b60:	e30057ff 	movw	r5, #2047	; 0x7ff
34818b64:	ea00002a 	b	34818c14 <usb_gadget_get_string+0x14c>
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
		if ((c & 0x80)) {
34818b68:	e3120080 	tst	r2, #128	; 0x80
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34818b6c:	e2833001 	add	r3, r3, #1
		if ((c & 0x80)) {
34818b70:	0a000022 	beq	34818c00 <usb_gadget_get_string+0x138>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
34818b74:	e202c0e0 	and	ip, r2, #224	; 0xe0
34818b78:	e35c00c0 	cmp	ip, #192	; 0xc0
34818b7c:	1a000008 	bne	34818ba4 <usb_gadget_get_string+0xdc>
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34818b80:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818b84:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818b88:	e3570080 	cmp	r7, #128	; 0x80
34818b8c:	1a000026 	bne	34818c2c <usb_gadget_get_string+0x164>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;
34818b90:	e202201f 	and	r2, r2, #31

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818b94:	e20cc03f 	and	ip, ip, #63	; 0x3f
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34818b98:	e2833001 	add	r3, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818b9c:	e18c2302 	orr	r2, ip, r2, lsl #6
34818ba0:	ea000016 	b	34818c00 <usb_gadget_get_string+0x138>

			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
34818ba4:	e202c0f0 	and	ip, r2, #240	; 0xf0
34818ba8:	e35c00e0 	cmp	ip, #224	; 0xe0
34818bac:	1a00001e 	bne	34818c2c <usb_gadget_get_string+0x164>
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
34818bb0:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818bb4:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818bb8:	e3570080 	cmp	r7, #128	; 0x80
34818bbc:	1a00001a 	bne	34818c2c <usb_gadget_get_string+0x164>
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
34818bc0:	e2837001 	add	r7, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
34818bc4:	e5d33001 	ldrb	r3, [r3, #1]
				if ((c & 0xc0) != 0x80)
34818bc8:	e203a0c0 	and	sl, r3, #192	; 0xc0
34818bcc:	e35a0080 	cmp	sl, #128	; 0x80
34818bd0:	1a000015 	bne	34818c2c <usb_gadget_get_string+0x164>

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818bd4:	e20cc03f 	and	ip, ip, #63	; 0x3f
			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;
34818bd8:	e1a02602 	lsl	r2, r2, #12

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818bdc:	e182230c 	orr	r2, r2, ip, lsl #6

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818be0:	e203303f 	and	r3, r3, #63	; 0x3f

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818be4:	e6ff2072 	uxth	r2, r2

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818be8:	e1822003 	orr	r2, r2, r3

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818bec:	e2823b0a 	add	r3, r2, #10240	; 0x2800
34818bf0:	e6ff3073 	uxth	r3, r3
34818bf4:	e1530005 	cmp	r3, r5
34818bf8:	9a00000d 	bls	34818c34 <usb_gadget_get_string+0x16c>
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
34818bfc:	e2873001 	add	r3, r7, #1
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
34818c00:	e5c12002 	strb	r2, [r1, #2]
	*p++ = val >> 8;
34818c04:	e1a02422 	lsr	r2, r2, #8
34818c08:	e5c12003 	strb	r2, [r1, #3]
			} else
				goto fail;
		} else
			uchar = c;
		put_unaligned_le16(uchar, cp++);
		count++;
34818c0c:	e2800001 	add	r0, r0, #1
34818c10:	e2811002 	add	r1, r1, #2
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34818c14:	e1560000 	cmp	r6, r0
34818c18:	0a000007 	beq	34818c3c <usb_gadget_get_string+0x174>
34818c1c:	e5d32000 	ldrb	r2, [r3]
34818c20:	e3520000 	cmp	r2, #0
34818c24:	1affffcf 	bne	34818b68 <usb_gadget_get_string+0xa0>
34818c28:	ea000003 	b	34818c3c <usb_gadget_get_string+0x174>
	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
34818c2c:	e3e00015 	mvn	r0, #21
34818c30:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34818c34:	e3e00015 	mvn	r0, #21
	buf[0] = (len + 1) * 2;
	buf[1] = USB_DT_STRING;
	return buf[0];
}
34818c38:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34818c3c:	e2800001 	add	r0, r0, #1
34818c40:	e1a00080 	lsl	r0, r0, #1
	buf[1] = USB_DT_STRING;
34818c44:	e3a03003 	mov	r3, #3
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34818c48:	e5c40000 	strb	r0, [r4]
	buf[1] = USB_DT_STRING;
34818c4c:	e5c43001 	strb	r3, [r4, #1]
	return buf[0];
34818c50:	e20000fe 	and	r0, r0, #254	; 0xfe
34818c54:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34818c58 <get_unaligned_le16>:

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34818c58:	e5d02001 	ldrb	r2, [r0, #1]
34818c5c:	e5d03000 	ldrb	r3, [r0]
}

static inline u16 get_unaligned_le16(const void *p)
{
	return __get_unaligned_le16((const u8 *)p);
}
34818c60:	e1830402 	orr	r0, r3, r2, lsl #8
34818c64:	e12fff1e 	bx	lr

34818c68 <set_max_pktsize>:
static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
{
	unsigned int ep_ctrl;
	int i;

	if (speed == USB_SPEED_HIGH) {
34818c68:	e3510003 	cmp	r1, #3
34818c6c:	e59f307c 	ldr	r3, [pc, #124]	; 34818cf0 <set_max_pktsize+0x88>
34818c70:	1a000007 	bne	34818c94 <set_max_pktsize+0x2c>
		ep0_fifo_size = 64;
34818c74:	e3a02040 	mov	r2, #64	; 0x40
34818c78:	e5832000 	str	r2, [r3]
		ep_fifo_size = 512;
34818c7c:	e2822d07 	add	r2, r2, #448	; 0x1c0
34818c80:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 1024;
34818c84:	e2822c02 	add	r2, r2, #512	; 0x200
34818c88:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_HIGH;
34818c8c:	e5801010 	str	r1, [r0, #16]
34818c90:	ea000005 	b	34818cac <set_max_pktsize+0x44>
	} else {
		ep0_fifo_size = 64;
34818c94:	e3a02040 	mov	r2, #64	; 0x40
34818c98:	e5832000 	str	r2, [r3]
		ep_fifo_size = 64;
34818c9c:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 64;
34818ca0:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_FULL;
34818ca4:	e3a03002 	mov	r3, #2
34818ca8:	e5803010 	str	r3, [r0, #16]
	}

	dev->ep[0].ep.maxpacket = ep0_fifo_size;
34818cac:	e3a03040 	mov	r3, #64	; 0x40
34818cb0:	e1c036bc 	strh	r3, [r0, #108]	; 0x6c
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
		dev->ep[i].ep.maxpacket = ep_fifo_size;
34818cb4:	e59f3034 	ldr	r3, [pc, #52]	; 34818cf0 <set_max_pktsize+0x88>
34818cb8:	e3a02f4b 	mov	r2, #300	; 0x12c
34818cbc:	e1d330b4 	ldrh	r3, [r3, #4]
34818cc0:	e18030b2 	strh	r3, [r0, r2]
34818cc4:	e1c03abc 	strh	r3, [r0, #172]	; 0xac
34818cc8:	e1c03ebc 	strh	r3, [r0, #236]	; 0xec

	/* EP0 - Control IN (64 bytes)*/
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818ccc:	e59f3020 	ldr	r3, [pc, #32]	; 34818cf4 <set_max_pktsize+0x8c>
34818cd0:	e5932000 	ldr	r2, [r3]
34818cd4:	e5921900 	ldr	r1, [r2, #2304]	; 0x900
	writel(ep_ctrl|(0<<0), &reg->in_endp[EP0_CON].diepctl);
34818cd8:	e5932000 	ldr	r2, [r3]
34818cdc:	e5821900 	str	r1, [r2, #2304]	; 0x900

	/* EP0 - Control OUT (64 bytes)*/
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34818ce0:	e5922b00 	ldr	r2, [r2, #2816]	; 0xb00
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
34818ce4:	e5933000 	ldr	r3, [r3]
34818ce8:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
}
34818cec:	e12fff1e 	bx	lr
34818cf0:	34829268 	.word	0x34829268
34818cf4:	3482bb78 	.word	0x3482bb78

34818cf8 <s3c_fifo_status>:
{
	int count = 0;
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
34818cf8:	e3500000 	cmp	r0, #0
34818cfc:	0a000004 	beq	34818d14 <s3c_fifo_status+0x1c>
	}

	debug("%s: %d\n", __func__, ep_index(ep));

	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
34818d00:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
34818d04:	e3530000 	cmp	r3, #0
		return -EOPNOTSUPP;
34818d08:	a3a00000 	movge	r0, #0
34818d0c:	b3e0005e 	mvnlt	r0, #94	; 0x5e
34818d10:	e12fff1e 	bx	lr
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
		debug("%s: bad ep\n", __func__);
		return -ENODEV;
34818d14:	e3e00012 	mvn	r0, #18
	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
		return -EOPNOTSUPP;

	return count;
}
34818d18:	e12fff1e 	bx	lr

34818d1c <s3c_fifo_flush>:
		debug("%s: bad ep\n", __func__);
		return;
	}

	debug("%s: %d\n", __func__, ep_index(ep));
}
34818d1c:	e12fff1e 	bx	lr

34818d20 <reconfig_usbd>:
	/* re-init driver-visible data structures */
	udc_reinit(dev);
}

static void reconfig_usbd(void)
{
34818d20:	e92d4038 	push	{r3, r4, r5, lr}
	/* 2. Soft-reset OTG Core and then unreset again. */
	int i;
	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
34818d24:	e59f4170 	ldr	r4, [pc, #368]	; 34818e9c <reconfig_usbd+0x17c>
34818d28:	e3a05001 	mov	r5, #1
34818d2c:	e5943000 	ldr	r3, [r4]
34818d30:	e5835010 	str	r5, [r3, #16]

	debug("Reseting OTG controller\n");

	writel(0<<15		/* PHY Low Power Clock sel*/
34818d34:	e5943000 	ldr	r3, [r4]
34818d38:	e305240f 	movw	r2, #21519	; 0x540f
34818d3c:	e583200c 	str	r2, [r3, #12]
		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
		|0x7<<0,	/* HS/FS Timeout**/
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
34818d40:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp |= SOFT_DISCONNECT;
34818d44:	e3822002 	orr	r2, r2, #2
	writel(uTemp, &reg->dctl);
34818d48:	e5943000 	ldr	r3, [r4]

	udelay(20);
34818d4c:	e3a00014 	mov	r0, #20
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
	uTemp |= SOFT_DISCONNECT;
	writel(uTemp, &reg->dctl);
34818d50:	e5832804 	str	r2, [r3, #2052]	; 0x804

	udelay(20);
34818d54:	eb000ede 	bl	3481c8d4 <udelay>

	/* 4. Make the OTG device core exit from the disconnected state.*/
	uTemp = readl(&reg->dctl);
34818d58:	e5943000 	ldr	r3, [r4]
34818d5c:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp = uTemp & ~SOFT_DISCONNECT;
34818d60:	e3c22002 	bic	r2, r2, #2
	writel(uTemp, &reg->dctl);
34818d64:	e5943000 	ldr	r3, [r4]
34818d68:	e5832804 	str	r2, [r3, #2052]	; 0x804

	/* 5. Configure OTG Core to initial settings of device mode.*/
	/* [][1: full speed(30Mhz) 0:high speed]*/
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
34818d6c:	e5943000 	ldr	r3, [r4]
34818d70:	e3a02701 	mov	r2, #262144	; 0x40000
34818d74:	e5832800 	str	r2, [r3, #2048]	; 0x800

	mdelay(1);
34818d78:	e1a00005 	mov	r0, r5
34818d7c:	eb000ee0 	bl	3481c904 <mdelay>

	/* 6. Unmask the core interrupts*/
	writel(GINTMSK_INIT, &reg->gintmsk);
34818d80:	e59f2118 	ldr	r2, [pc, #280]	; 34818ea0 <reconfig_usbd+0x180>
34818d84:	e5943000 	ldr	r3, [r4]
34818d88:	e5832018 	str	r2, [r3, #24]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
34818d8c:	e5942000 	ldr	r2, [r4]
34818d90:	e3a03312 	mov	r3, #1207959552	; 0x48000000
34818d94:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
34818d98:	e5942000 	ldr	r2, [r4]
34818d9c:	e5823900 	str	r3, [r2, #2304]	; 0x900

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
34818da0:	e1a02003 	mov	r2, r3
34818da4:	e5941000 	ldr	r1, [r4]
34818da8:	e2850058 	add	r0, r5, #88	; 0x58
34818dac:	e7812280 	str	r2, [r1, r0, lsl #5]
34818db0:	e59f30e4 	ldr	r3, [pc, #228]	; 34818e9c <reconfig_usbd+0x17c>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818db4:	e2850048 	add	r0, r5, #72	; 0x48
34818db8:	e5941000 	ldr	r1, [r4]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818dbc:	e2855001 	add	r5, r5, #1
34818dc0:	e3550004 	cmp	r5, #4
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818dc4:	e7812280 	str	r2, [r1, r0, lsl #5]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818dc8:	1afffff5 	bne	34818da4 <reconfig_usbd+0x84>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
	}

	/* 8. Unmask EPO interrupts*/
	writel(((1 << EP0_CON) << DAINT_OUT_BIT)
34818dcc:	e59f10d0 	ldr	r1, [pc, #208]	; 34818ea4 <reconfig_usbd+0x184>
34818dd0:	e5932000 	ldr	r2, [r3]
34818dd4:	e582181c 	str	r1, [r2, #2076]	; 0x81c
	       | (1 << EP0_CON), &reg->daintmsk);

	/* 9. Unmask device OUT EP common interrupts*/
	writel(DOEPMSK_INIT, &reg->doepmsk);
34818dd8:	e5931000 	ldr	r1, [r3]
34818ddc:	e3a0200d 	mov	r2, #13
34818de0:	e5812814 	str	r2, [r1, #2068]	; 0x814

	/* 10. Unmask device IN EP common interrupts*/
	writel(DIEPMSK_INIT, &reg->diepmsk);
34818de4:	e5931000 	ldr	r1, [r3]
34818de8:	e5812810 	str	r2, [r1, #2064]	; 0x810

	/* 11. Set Rx FIFO Size (in 32-bit words) */
	writel(RX_FIFO_SIZE >> 2, &reg->grxfsiz);
34818dec:	e5932000 	ldr	r2, [r3]
34818df0:	e3a01b01 	mov	r1, #1024	; 0x400
34818df4:	e5821024 	str	r1, [r2, #36]	; 0x24

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
34818df8:	e5932000 	ldr	r2, [r3]
34818dfc:	e2811301 	add	r1, r1, #67108864	; 0x4000000
34818e00:	e5821028 	str	r1, [r2, #40]	; 0x28
34818e04:	e3a01000 	mov	r1, #0
34818e08:	e3a02a02 	mov	r2, #8192	; 0x2000
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
		writel((PTX_FIFO_SIZE >> 2) << 16 |
34818e0c:	e1a04142 	asr	r4, r2, #2
34818e10:	e3844506 	orr	r4, r4, #25165824	; 0x1800000
34818e14:	e593c000 	ldr	ip, [r3]
34818e18:	e2822c06 	add	r2, r2, #1536	; 0x600
34818e1c:	e28ccf41 	add	ip, ip, #260	; 0x104

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34818e20:	e3520c7a 	cmp	r2, #31232	; 0x7a00
		writel((PTX_FIFO_SIZE >> 2) << 16 |
34818e24:	e78c4001 	str	r4, [ip, r1]
34818e28:	e59f006c 	ldr	r0, [pc, #108]	; 34818e9c <reconfig_usbd+0x17c>
34818e2c:	e2811004 	add	r1, r1, #4

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34818e30:	1afffff5 	bne	34818e0c <reconfig_usbd+0xec>
		       ((RX_FIFO_SIZE + NPTX_FIFO_SIZE +
			 PTX_FIFO_SIZE*(i-1)) >> 2) << 0,
		       &reg->dieptxf[i-1]);

	/* Flush the RX FIFO */
	writel(RX_FIFO_FLUSH, &reg->grstctl);
34818e34:	e5903000 	ldr	r3, [r0]
34818e38:	e3a02010 	mov	r2, #16
34818e3c:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
34818e40:	e5902000 	ldr	r2, [r0]
34818e44:	e59f3050 	ldr	r3, [pc, #80]	; 34818e9c <reconfig_usbd+0x17c>
34818e48:	e5922010 	ldr	r2, [r2, #16]
34818e4c:	e3120010 	tst	r2, #16
34818e50:	1afffffa 	bne	34818e40 <reconfig_usbd+0x120>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* Flush all the Tx FIFO's */
	writel(TX_FIFO_FLUSH_ALL, &reg->grstctl);
34818e54:	e5932000 	ldr	r2, [r3]
34818e58:	e3a01b01 	mov	r1, #1024	; 0x400
34818e5c:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_FLUSH_ALL | TX_FIFO_FLUSH, &reg->grstctl);
34818e60:	e5932000 	ldr	r2, [r3]
34818e64:	e2811020 	add	r1, r1, #32
34818e68:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34818e6c:	e5931000 	ldr	r1, [r3]
34818e70:	e59f2024 	ldr	r2, [pc, #36]	; 34818e9c <reconfig_usbd+0x17c>
34818e74:	e5911010 	ldr	r1, [r1, #16]
34818e78:	e3110020 	tst	r1, #32
34818e7c:	1afffffa 	bne	34818e6c <reconfig_usbd+0x14c>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* 13. Clear NAK bit of EP0, EP1, EP2*/
	/* For Slave mode*/
	/* EP0: Control OUT */
	writel(DEPCTL_EPDIS | DEPCTL_CNAK,
34818e80:	e5923000 	ldr	r3, [r2]
34818e84:	e3a01311 	mov	r1, #1140850688	; 0x44000000
34818e88:	e5831b00 	str	r1, [r3, #2816]	; 0xb00
	       &reg->out_endp[EP0_CON].doepctl);

	/* 14. Initialize OTG Link Core.*/
	writel(GAHBCFG_INIT, &reg->gahbcfg);
34818e8c:	e5923000 	ldr	r3, [r2]
34818e90:	e3a02027 	mov	r2, #39	; 0x27
34818e94:	e5832008 	str	r2, [r3, #8]
}
34818e98:	e8bd8038 	pop	{r3, r4, r5, pc}
34818e9c:	3482bb78 	.word	0x3482bb78
34818ea0:	800c3800 	.word	0x800c3800
34818ea4:	00010001 	.word	0x00010001

34818ea8 <done>:

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34818ea8:	e92d4038 	push	{r3, r4, r5, lr}
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34818eac:	e591c028 	ldr	ip, [r1, #40]	; 0x28
	unsigned int stopped = ep->stopped;
34818eb0:	e5d05034 	ldrb	r5, [r0, #52]	; 0x34

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34818eb4:	e1a04000 	mov	r4, r0
34818eb8:	e591002c 	ldr	r0, [r1, #44]	; 0x2c
	unsigned int stopped = ep->stopped;

	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);
34818ebc:	e2813028 	add	r3, r1, #40	; 0x28
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34818ec0:	e58c0004 	str	r0, [ip, #4]
	prev->next = next;
34818ec4:	e580c000 	str	ip, [r0]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
34818ec8:	e581302c 	str	r3, [r1, #44]	; 0x2c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34818ecc:	e5813028 	str	r3, [r1, #40]	; 0x28

	if (likely(req->req.status == -EINPROGRESS))
34818ed0:	e5913020 	ldr	r3, [r1, #32]
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
34818ed4:	e1a00004 	mov	r0, r4
	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
34818ed8:	e3730073 	cmn	r3, #115	; 0x73
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
34818edc:	e3a03001 	mov	r3, #1
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
		req->req.status = status;
34818ee0:	05812020 	streq	r2, [r1, #32]
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
34818ee4:	e5c43034 	strb	r3, [r4, #52]	; 0x34
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
34818ee8:	e5913010 	ldr	r3, [r1, #16]
34818eec:	e12fff33 	blx	r3
	spin_lock(&ep->dev->lock);

	debug("callback completed\n");

	ep->stopped = stopped;
34818ef0:	e5c45034 	strb	r5, [r4, #52]	; 0x34
}
34818ef4:	e8bd8038 	pop	{r3, r4, r5, pc}

34818ef8 <s3c_dequeue>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
34818ef8:	e3500000 	cmp	r0, #0
	kfree(req);
}

/* dequeue JUST ONE request */
static int s3c_dequeue(struct usb_ep *_ep, struct usb_request *_req)
{
34818efc:	e92d4008 	push	{r3, lr}
34818f00:	e1a03001 	mov	r3, r1
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
34818f04:	0a000013 	beq	34818f58 <s3c_dequeue+0x60>
34818f08:	e59f2058 	ldr	r2, [pc, #88]	; 34818f68 <s3c_dequeue+0x70>
34818f0c:	e5901004 	ldr	r1, [r0, #4]
34818f10:	e1510002 	cmp	r1, r2
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
34818f14:	11a02000 	movne	r2, r0
34818f18:	15b21020 	ldrne	r1, [r2, #32]!
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
34818f1c:	0a00000d 	beq	34818f58 <s3c_dequeue+0x60>
34818f20:	ea000002 	b	34818f30 <s3c_dequeue+0x38>

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
		if (&req->req == _req)
34818f24:	e1510003 	cmp	r1, r3
34818f28:	0a000006 	beq	34818f48 <s3c_dequeue+0x50>
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
34818f2c:	e5911028 	ldr	r1, [r1, #40]	; 0x28
34818f30:	e2411028 	sub	r1, r1, #40	; 0x28
34818f34:	e281c028 	add	ip, r1, #40	; 0x28
34818f38:	e15c0002 	cmp	ip, r2
34818f3c:	1afffff8 	bne	34818f24 <s3c_dequeue+0x2c>
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
34818f40:	e1510003 	cmp	r1, r3
34818f44:	1a000005 	bne	34818f60 <s3c_dequeue+0x68>
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
	}

	done(ep, req, -ECONNRESET);
34818f48:	e3e02067 	mvn	r2, #103	; 0x67
34818f4c:	ebffffd5 	bl	34818ea8 <done>

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
34818f50:	e3a00000 	mov	r0, #0
34818f54:	e8bd8008 	pop	{r3, pc}

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
		return -EINVAL;
34818f58:	e3e00015 	mvn	r0, #21
34818f5c:	e8bd8008 	pop	{r3, pc}
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
34818f60:	e3e00015 	mvn	r0, #21

	done(ep, req, -ECONNRESET);

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
}
34818f64:	e8bd8008 	pop	{r3, pc}
34818f68:	348215b4 	.word	0x348215b4

34818f6c <nuke>:

/*
 *	nuke - dequeue ALL requests
 */
static void nuke(struct s3c_ep *ep, int status)
{
34818f6c:	e92d4070 	push	{r4, r5, r6, lr}
34818f70:	e1a04000 	mov	r4, r0
34818f74:	e1a06001 	mov	r6, r1
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34818f78:	e2805020 	add	r5, r0, #32
34818f7c:	ea000003 	b	34818f90 <nuke+0x24>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
34818f80:	e1a00004 	mov	r0, r4
34818f84:	e2411028 	sub	r1, r1, #40	; 0x28
34818f88:	e1a02006 	mov	r2, r6
34818f8c:	ebffffc5 	bl	34818ea8 <done>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34818f90:	e5941020 	ldr	r1, [r4, #32]
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34818f94:	e1510005 	cmp	r1, r5
34818f98:	1afffff8 	bne	34818f80 <nuke+0x14>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
	}
}
34818f9c:	e8bd8070 	pop	{r4, r5, r6, pc}

34818fa0 <s3c_ep_disable>:

/*
 * Disable EP
 */
static int s3c_ep_disable(struct usb_ep *_ep)
{
34818fa0:	e92d4010 	push	{r4, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34818fa4:	e2504000 	subs	r4, r0, #0
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
34818fa8:	03e00015 	mvneq	r0, #21
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34818fac:	08bd8010 	popeq	{r4, pc}
34818fb0:	e594301c 	ldr	r3, [r4, #28]
34818fb4:	e3530000 	cmp	r3, #0
34818fb8:	0a000006 	beq	34818fd8 <s3c_ep_disable+0x38>
	}

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);
34818fbc:	e3e0106b 	mvn	r1, #107	; 0x6b
34818fc0:	ebffffe9 	bl	34818f6c <nuke>

	ep->desc = 0;
34818fc4:	e3a00000 	mov	r0, #0
	ep->stopped = 1;
34818fc8:	e3a03001 	mov	r3, #1
	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);

	ep->desc = 0;
34818fcc:	e584001c 	str	r0, [r4, #28]
	ep->stopped = 1;
34818fd0:	e5c43034 	strb	r3, [r4, #52]	; 0x34

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
34818fd4:	e8bd8010 	pop	{r4, pc}

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
34818fd8:	e3e00015 	mvn	r0, #21

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
}
34818fdc:	e8bd8010 	pop	{r4, pc}

34818fe0 <s3c_ep0_complete_out>:
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}

static inline void s3c_ep0_complete_out(void)
{
34818fe0:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
34818fe4:	e59f4034 	ldr	r4, [pc, #52]	; 34819020 <s3c_ep0_complete_out+0x40>
34818fe8:	e5940004 	ldr	r0, [r4, #4]
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
34818fec:	e2801901 	add	r1, r0, #16384	; 0x4000
34818ff0:	ebffa018 	bl	34801058 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34818ff4:	e59f2028 	ldr	r2, [pc, #40]	; 34819024 <s3c_ep0_complete_out+0x44>
34818ff8:	e5943000 	ldr	r3, [r4]
34818ffc:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
34819000:	e5942004 	ldr	r2, [r4, #4]
34819004:	e5943000 	ldr	r3, [r4]
34819008:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
3481900c:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819010:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34819014:	e5943000 	ldr	r3, [r4]
34819018:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
3481901c:	e8bd8010 	pop	{r4, pc}
34819020:	3482bb78 	.word	0x3482bb78
34819024:	00080008 	.word	0x00080008

34819028 <setdma_rx>:


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
34819028:	e92d4070 	push	{r4, r5, r6, lr}
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
3481902c:	e5913024 	ldr	r3, [r1, #36]	; 0x24
34819030:	e5912000 	ldr	r2, [r1]

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
34819034:	e5911004 	ldr	r1, [r1, #4]
34819038:	e1d061b4 	ldrh	r6, [r0, #20]
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
3481903c:	e0822003 	add	r2, r2, r3

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819040:	e5d05035 	ldrb	r5, [r0, #53]	; 0x35

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
34819044:	e0633001 	rsb	r3, r3, r1
34819048:	e1560003 	cmp	r6, r3
3481904c:	21a06003 	movcs	r6, r3

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34819050:	e5903018 	ldr	r3, [r0, #24]

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819054:	e205500f 	and	r5, r5, #15

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34819058:	e0833105 	add	r3, r3, r5, lsl #2
	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;
3481905c:	e5802030 	str	r2, [r0, #48]	; 0x30

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
34819060:	e580602c 	str	r6, [r0, #44]	; 0x2c

}


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
34819064:	e1a04000 	mov	r4, r0

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34819068:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
3481906c:	e2801901 	add	r1, r0, #16384	; 0x4000
34819070:	ebff9ff8 	bl	34801058 <invalidate_dcache_range>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;

	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
34819074:	e59f3050 	ldr	r3, [pc, #80]	; 348190cc <setdma_rx+0xa4>
34819078:	e2852058 	add	r2, r5, #88	; 0x58
3481907c:	e5931000 	ldr	r1, [r3]
34819080:	e7911282 	ldr	r1, [r1, r2, lsl #5]

	writel(the_controller->dma_addr[ep_index(ep)+1],
34819084:	e5d4c035 	ldrb	ip, [r4, #53]	; 0x35
34819088:	e5930008 	ldr	r0, [r3, #8]
3481908c:	e20cc00f 	and	ip, ip, #15
34819090:	e28cc011 	add	ip, ip, #17
34819094:	e790c10c 	ldr	ip, [r0, ip, lsl #2]
34819098:	e5930000 	ldr	r0, [r3]
3481909c:	e1a05285 	lsl	r5, r5, #5
348190a0:	e2855eb1 	add	r5, r5, #2832	; 0xb10
348190a4:	e0800005 	add	r0, r0, r5
348190a8:	e580c004 	str	ip, [r0, #4]
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
348190ac:	e3866702 	orr	r6, r6, #524288	; 0x80000
348190b0:	e5930000 	ldr	r0, [r3]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348190b4:	e3811321 	orr	r1, r1, #-2080374784	; 0x84000000
	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
348190b8:	e7806005 	str	r6, [r0, r5]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348190bc:	e5933000 	ldr	r3, [r3]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348190c0:	e3a00000 	mov	r0, #0

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348190c4:	e7831282 	str	r1, [r3, r2, lsl #5]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348190c8:	e8bd8070 	pop	{r4, r5, r6, pc}
348190cc:	3482bb78 	.word	0x3482bb78

348190d0 <s3c_free_request>:
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348190d0:	e5912028 	ldr	r2, [r1, #40]	; 0x28
348190d4:	e2813028 	add	r3, r1, #40	; 0x28
348190d8:	e1520003 	cmp	r2, r3

	return &req->req;
}

static void s3c_free_request(struct usb_ep *ep, struct usb_request *_req)
{
348190dc:	e92d4010 	push	{r4, lr}
348190e0:	e1a04001 	mov	r4, r1
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348190e4:	0a000003 	beq	348190f8 <s3c_free_request+0x28>
348190e8:	e59f0014 	ldr	r0, [pc, #20]	; 34819104 <s3c_free_request+0x34>
348190ec:	e59f1014 	ldr	r1, [pc, #20]	; 34819108 <s3c_free_request+0x38>
348190f0:	e3a02faf 	mov	r2, #700	; 0x2bc
348190f4:	ebffc273 	bl	34809ac8 <printf>
	kfree(req);
348190f8:	e1a00004 	mov	r0, r4
}
348190fc:	e8bd4010 	pop	{r4, lr}

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
	kfree(req);
34819100:	eaffc3ae 	b	34809fc0 <free>
34819104:	34827d8e 	.word	0x34827d8e
34819108:	34827da5 	.word	0x34827da5

3481910c <s3c_alloc_request>:
	return 0;
}

static struct usb_request *s3c_alloc_request(struct usb_ep *ep,
					     gfp_t gfp_flags)
{
3481910c:	e92d4010 	push	{r4, lr}
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->name, ep);

	req = memalign(CONFIG_SYS_CACHELINE_SIZE, sizeof(*req));
34819110:	e3a00040 	mov	r0, #64	; 0x40
34819114:	e3a01030 	mov	r1, #48	; 0x30
34819118:	ebffc5d6 	bl	3480a878 <memalign>
	if (!req)
3481911c:	e2504000 	subs	r4, r0, #0
34819120:	0a000005 	beq	3481913c <s3c_alloc_request+0x30>
		return 0;

	memset(req, 0, sizeof *req);
34819124:	e3a01000 	mov	r1, #0
34819128:	e3a02030 	mov	r2, #48	; 0x30
3481912c:	eb000d39 	bl	3481c618 <memset>
	INIT_LIST_HEAD(&req->queue);
34819130:	e2843028 	add	r3, r4, #40	; 0x28
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819134:	e5843028 	str	r3, [r4, #40]	; 0x28
	list->prev = list;
34819138:	e584302c 	str	r3, [r4, #44]	; 0x2c

	return &req->req;
}
3481913c:	e1a00004 	mov	r0, r4
34819140:	e8bd8010 	pop	{r4, pc}

34819144 <s3c_udc_ep0_zlp.clone.2>:

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
34819144:	e92d4038 	push	{r3, r4, r5, lr}
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
34819148:	e59f4040 	ldr	r4, [pc, #64]	; 34819190 <s3c_udc_ep0_zlp.clone.2+0x4c>

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
3481914c:	e1a05000 	mov	r5, r0
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
34819150:	e5940004 	ldr	r0, [r4, #4]

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
34819154:	e2801901 	add	r1, r0, #16384	; 0x4000
34819158:	ebff9fc7 	bl	3480107c <flush_dcache_range>
			   (unsigned long) usb_ctrl_dma_addr
			   + DMA_BUFFER_SIZE);

	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
3481915c:	e5942004 	ldr	r2, [r4, #4]
34819160:	e5943000 	ldr	r3, [r4]
34819164:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
34819168:	e5943000 	ldr	r3, [r4]
3481916c:	e3a02702 	mov	r2, #524288	; 0x80000
34819170:	e5832910 	str	r2, [r3, #2320]	; 0x910

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34819174:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819178:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
3481917c:	e5943000 	ldr	r3, [r4]
34819180:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);

	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
34819184:	e3a03007 	mov	r3, #7
34819188:	e5853000 	str	r3, [r5]
}
3481918c:	e8bd8038 	pop	{r3, r4, r5, pc}
34819190:	3482bb78 	.word	0x3482bb78

34819194 <complete_rx>:

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
34819194:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34819198:	e1a05001 	mov	r5, r1
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
3481919c:	e1a01301 	lsl	r1, r1, #6
348191a0:	e0802001 	add	r2, r0, r1
348191a4:	e59f3134 	ldr	r3, [pc, #308]	; 348192e0 <complete_rx+0x14c>

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
348191a8:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348191ac:	e5d2008d 	ldrb	r0, [r2, #141]	; 0x8d
348191b0:	e593c008 	ldr	ip, [r3, #8]

	if (list_empty(&ep->queue)) {
348191b4:	e2811078 	add	r1, r1, #120	; 0x78
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348191b8:	e5926078 	ldr	r6, [r2, #120]	; 0x78
348191bc:	e0841001 	add	r1, r4, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348191c0:	e200000f 	and	r0, r0, #15
348191c4:	e08c0100 	add	r0, ip, r0, lsl #2

	if (list_empty(&ep->queue)) {
348191c8:	e1560001 	cmp	r6, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348191cc:	e5909030 	ldr	r9, [r0, #48]	; 0x30

	if (list_empty(&ep->queue)) {
348191d0:	e58d100c 	str	r1, [sp, #12]
348191d4:	0a00003f 	beq	348192d8 <complete_rx+0x144>
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348191d8:	e5933000 	ldr	r3, [r3]
			   __func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
348191dc:	e246c028 	sub	ip, r6, #40	; 0x28
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348191e0:	e0833285 	add	r3, r3, r5, lsl #5
348191e4:	e5933b10 	ldr	r3, [r3, #2832]	; 0xb10
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348191e8:	e285b002 	add	fp, r5, #2
	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
348191ec:	e3550000 	cmp	r5, #0
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348191f0:	e084b30b 	add	fp, r4, fp, lsl #6
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
348191f4:	11a03883 	lslne	r3, r3, #17

	xfer_size = ep->len - xfer_size;
348191f8:	e59b2004 	ldr	r2, [fp, #4]

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
348191fc:	0203307f 	andeq	r3, r3, #127	; 0x7f
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
34819200:	11a038a3 	lsrne	r3, r3, #17
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819204:	e1a0a305 	lsl	sl, r5, #6
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
34819208:	e0633002 	rsb	r3, r3, r2
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481920c:	e28a7058 	add	r7, sl, #88	; 0x58
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
34819210:	e1a00009 	mov	r0, r9
34819214:	e2891901 	add	r1, r9, #16384	; 0x4000
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34819218:	e084a00a 	add	sl, r4, sl
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
3481921c:	e98d1008 	stmib	sp, {r3, ip}
34819220:	ebff9f8c 	bl	34801058 <invalidate_dcache_range>
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34819224:	e1a01009 	mov	r1, r9
34819228:	e59b2004 	ldr	r2, [fp, #4]
3481922c:	e59a0088 	ldr	r0, [sl, #136]	; 0x88
34819230:	eb000d1c 	bl	3481c6a8 <memcpy>

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819234:	e5161004 	ldr	r1, [r6, #-4]
34819238:	e5162024 	ldr	r2, [r6, #-36]	; 0x24
3481923c:	e59d3004 	ldr	r3, [sp, #4]
34819240:	e0610002 	rsb	r0, r1, r2
34819244:	e1530000 	cmp	r3, r0
34819248:	90811003 	addls	r1, r1, r3
3481924c:	80811000 	addhi	r1, r1, r0
	is_short = (xfer_size < ep->ep.maxpacket);
34819250:	e1da06bc 	ldrh	r0, [sl, #108]	; 0x6c
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819254:	e0847007 	add	r7, r4, r7
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34819258:	e1530000 	cmp	r3, r0
	invalidate_dcache_range((unsigned long) p,
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481925c:	e5061004 	str	r1, [r6, #-4]
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34819260:	e59dc008 	ldr	ip, [sp, #8]
34819264:	3a000003 	bcc	34819278 <complete_rx+0xe4>
34819268:	e1510002 	cmp	r1, r2
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
3481926c:	11a00007 	movne	r0, r7
34819270:	11a0100c 	movne	r1, ip
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34819274:	1a000014 	bne	348192cc <complete_rx+0x138>
		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
34819278:	e3550000 	cmp	r5, #0
3481927c:	1a000007 	bne	348192a0 <complete_rx+0x10c>
34819280:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819284:	e3530004 	cmp	r3, #4
34819288:	1a000004 	bne	348192a0 <complete_rx+0x10c>
			debug_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
			s3c_udc_ep0_zlp(dev);
3481928c:	e2840054 	add	r0, r4, #84	; 0x54
34819290:	ebffffab 	bl	34819144 <s3c_udc_ep0_zlp.clone.2>
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
34819294:	e3a03007 	mov	r3, #7
34819298:	e5843054 	str	r3, [r4, #84]	; 0x54
3481929c:	ea00000d 	b	348192d8 <complete_rx+0x144>
		} else {
			done(ep, req, 0);
348192a0:	e1a00007 	mov	r0, r7
348192a4:	e1a0100c 	mov	r1, ip
348192a8:	e3a02000 	mov	r2, #0
348192ac:	e0844305 	add	r4, r4, r5, lsl #6
348192b0:	ebfffefc 	bl	34818ea8 <done>
348192b4:	e5941078 	ldr	r1, [r4, #120]	; 0x78

			if (!list_empty(&ep->queue)) {
348192b8:	e59d200c 	ldr	r2, [sp, #12]
348192bc:	e1510002 	cmp	r1, r2
				req = list_entry(ep->queue.next,
					struct s3c_request, queue);
				debug_cond(DEBUG_OUT_EP != 0,
					   "%s: Next Rx request start...\n",
					   __func__);
				setdma_rx(ep, req);
348192c0:	11a00007 	movne	r0, r7
348192c4:	12411028 	subne	r1, r1, #40	; 0x28
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
		} else {
			done(ep, req, 0);

			if (!list_empty(&ep->queue)) {
348192c8:	0a000002 	beq	348192d8 <complete_rx+0x144>
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
}
348192cc:	e28dd010 	add	sp, sp, #16
348192d0:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
348192d4:	eaffff53 	b	34819028 <setdma_rx>
}
348192d8:	e28dd010 	add	sp, sp, #16
348192dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348192e0:	3482bb78 	.word	0x3482bb78

348192e4 <udc_set_address>:
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348192e4:	e92d4038 	push	{r3, r4, r5, lr}
	u32 ctrl = readl(&reg->dcfg);
348192e8:	e59f3028 	ldr	r3, [pc, #40]	; 34819318 <udc_set_address+0x34>
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348192ec:	e1a04000 	mov	r4, r0
	u32 ctrl = readl(&reg->dcfg);
348192f0:	e5932000 	ldr	r2, [r3]
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348192f4:	e1a05001 	mov	r5, r1
	u32 ctrl = readl(&reg->dcfg);
348192f8:	e5922800 	ldr	r2, [r2, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
348192fc:	e1822201 	orr	r2, r2, r1, lsl #4
34819300:	e5933000 	ldr	r3, [r3]

	s3c_udc_ep0_zlp(dev);
34819304:	e2800054 	add	r0, r0, #84	; 0x54
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
	u32 ctrl = readl(&reg->dcfg);
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34819308:	e5832800 	str	r2, [r3, #2048]	; 0x800

	s3c_udc_ep0_zlp(dev);
3481930c:	ebffff8c 	bl	34819144 <s3c_udc_ep0_zlp.clone.2>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
		   __func__, address, readl(&reg->dcfg));

	dev->usb_address = address;
34819310:	e5c45158 	strb	r5, [r4, #344]	; 0x158
}
34819314:	e8bd8038 	pop	{r3, r4, r5, pc}
34819318:	3482bb78 	.word	0x3482bb78

3481931c <set_udc_gadget_private_data>:
void set_udc_gadget_private_data(void *p)
{
	debug_cond(DEBUG_SETUP != 0,
		   "%s: the_controller: 0x%p, p: 0x%p\n", __func__,
		   the_controller, p);
	the_controller->gadget.dev.device_data = p;
3481931c:	e59f3008 	ldr	r3, [pc, #8]	; 3481932c <set_udc_gadget_private_data+0x10>
34819320:	e5933008 	ldr	r3, [r3, #8]
34819324:	e5830020 	str	r0, [r3, #32]
}
34819328:	e12fff1e 	bx	lr
3481932c:	3482bb78 	.word	0x3482bb78

34819330 <get_udc_gadget_private_data>:

void *get_udc_gadget_private_data(struct usb_gadget *gadget)
{
	return gadget->dev.device_data;
}
34819330:	e5900020 	ldr	r0, [r0, #32]
34819334:	e12fff1e 	bx	lr

34819338 <otg_phy_init>:
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
	dev->pdata->phy_control(1);
34819338:	e5903028 	ldr	r3, [r0, #40]	; 0x28
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
3481933c:	e92d4010 	push	{r4, lr}
	dev->pdata->phy_control(1);
34819340:	e5933000 	ldr	r3, [r3]
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34819344:	e1a04000 	mov	r4, r0
	dev->pdata->phy_control(1);
34819348:	e3a00001 	mov	r0, #1
3481934c:	e12fff33 	blx	r3

	/*USB PHY0 Enable */
	printf("USB PHY0 Enable\n");
34819350:	e59f00a4 	ldr	r0, [pc, #164]	; 348193fc <otg_phy_init+0xc4>
34819354:	ebffc1db 	bl	34809ac8 <printf>

	/* Enable PHY */
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
34819358:	e59f30a0 	ldr	r3, [pc, #160]	; 34819400 <otg_phy_init+0xc8>
3481935c:	e593200c 	ldr	r2, [r3, #12]
34819360:	e5921000 	ldr	r1, [r2]
34819364:	e3811001 	orr	r1, r1, #1
34819368:	e593200c 	ldr	r2, [r3, #12]
3481936c:	e5821000 	str	r1, [r2]

	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
34819370:	e5942028 	ldr	r2, [r4, #40]	; 0x28
34819374:	e5922010 	ldr	r2, [r2, #16]
34819378:	e3520020 	cmp	r2, #32
3481937c:	1a000003 	bne	34819390 <otg_phy_init+0x58>
		writel((readl(&phy->phypwr)
34819380:	e5932010 	ldr	r2, [r3, #16]
34819384:	e5922000 	ldr	r2, [r2]
34819388:	e3c22039 	bic	r2, r2, #57	; 0x39
3481938c:	ea000002 	b	3481939c <otg_phy_init+0x64>
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34819390:	e5932010 	ldr	r2, [r3, #16]
34819394:	e5922000 	ldr	r2, [r2]
34819398:	e3c22019 	bic	r2, r2, #25
3481939c:	e5933010 	ldr	r3, [r3, #16]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
348193a0:	e59f4058 	ldr	r4, [pc, #88]	; 34819400 <otg_phy_init+0xc8>
	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
		writel((readl(&phy->phypwr)
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
348193a4:	e5832000 	str	r2, [r3]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
348193a8:	e5943010 	ldr	r3, [r4, #16]
348193ac:	e5932004 	ldr	r2, [r3, #4]
348193b0:	e3c22017 	bic	r2, r2, #23
348193b4:	e3822003 	orr	r2, r2, #3
348193b8:	e5943010 	ldr	r3, [r4, #16]
348193bc:	e5832004 	str	r2, [r3, #4]
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
348193c0:	e5932008 	ldr	r2, [r3, #8]
348193c4:	e3c22007 	bic	r2, r2, #7
348193c8:	e3822001 	orr	r2, r2, #1
348193cc:	e5943010 	ldr	r3, [r4, #16]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
348193d0:	e3a0000a 	mov	r0, #10
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
348193d4:	e5832008 	str	r2, [r3, #8]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
348193d8:	eb000d3d 	bl	3481c8d4 <udelay>
	writel(readl(&phy->rstcon)
348193dc:	e5943010 	ldr	r3, [r4, #16]
348193e0:	e5932008 	ldr	r2, [r3, #8]
348193e4:	e3c22007 	bic	r2, r2, #7
348193e8:	e5943010 	ldr	r3, [r4, #16]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
348193ec:	e3a0000a 	mov	r0, #10
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
348193f0:	e5832008 	str	r2, [r3, #8]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
}
348193f4:	e8bd4010 	pop	{r4, lr}
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
348193f8:	ea000d35 	b	3481c8d4 <udelay>
348193fc:	34827db3 	.word	0x34827db3
34819400:	3482bb78 	.word	0x3482bb78

34819404 <otg_phy_off>:
}

void otg_phy_off(struct s3c_udc *dev)
{
34819404:	e92d4038 	push	{r3, r4, r5, lr}
34819408:	e1a05000 	mov	r5, r0
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
3481940c:	e59f4084 	ldr	r4, [pc, #132]	; 34819498 <otg_phy_off+0x94>
34819410:	e3a02001 	mov	r2, #1
34819414:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34819418:	e3a00014 	mov	r0, #20
}

void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
3481941c:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34819420:	eb000d2b 	bl	3481c8d4 <udelay>
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34819424:	e5943010 	ldr	r3, [r4, #16]
34819428:	e5932000 	ldr	r2, [r3]
3481942c:	e3c22001 	bic	r2, r2, #1
34819430:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34819434:	e3a00014 	mov	r0, #20
void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
	udelay(20);
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34819438:	e5832008 	str	r2, [r3, #8]
	udelay(20);
3481943c:	eb000d24 	bl	3481c8d4 <udelay>

	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
34819440:	e5943010 	ldr	r3, [r4, #16]
34819444:	e5932000 	ldr	r2, [r3]
34819448:	e3822019 	orr	r2, r2, #25
3481944c:	e5943010 	ldr	r3, [r4, #16]
34819450:	e5832000 	str	r2, [r3]
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);
34819454:	e594300c 	ldr	r3, [r4, #12]
34819458:	e5932000 	ldr	r2, [r3]
3481945c:	e3c22001 	bic	r2, r2, #1
34819460:	e594300c 	ldr	r3, [r4, #12]
34819464:	e5832000 	str	r2, [r3]

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34819468:	e5943010 	ldr	r3, [r4, #16]
3481946c:	e5932004 	ldr	r2, [r3, #4]
34819470:	e3c22014 	bic	r2, r2, #20
34819474:	e5943010 	ldr	r3, [r4, #16]
	      &phy->phyclk);

	udelay(10000);
34819478:	e3020710 	movw	r0, #10000	; 0x2710
	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
3481947c:	e5832004 	str	r2, [r3, #4]
	      &phy->phyclk);

	udelay(10000);
34819480:	eb000d13 	bl	3481c8d4 <udelay>

	dev->pdata->phy_control(0);
34819484:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34819488:	e3a00000 	mov	r0, #0
3481948c:	e5933000 	ldr	r3, [r3]
34819490:	e12fff33 	blx	r3
}
34819494:	e8bd8038 	pop	{r3, r4, r5, pc}
34819498:	3482bb78 	.word	0x3482bb78

3481949c <s3c_udc_pre_setup>:
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
}

void s3c_udc_pre_setup(void)
{
3481949c:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
348194a0:	e59f4034 	ldr	r4, [pc, #52]	; 348194dc <s3c_udc_pre_setup+0x40>
348194a4:	e5940004 	ldr	r0, [r4, #4]
	u32 ep_ctrl;

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
348194a8:	e2801901 	add	r1, r0, #16384	; 0x4000
348194ac:	ebff9ee9 	bl	34801058 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
348194b0:	e59f2028 	ldr	r2, [pc, #40]	; 348194e0 <s3c_udc_pre_setup+0x44>
348194b4:	e5943000 	ldr	r3, [r4]
348194b8:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
348194bc:	e5942004 	ldr	r2, [r4, #4]
348194c0:	e5943000 	ldr	r3, [r4]
348194c4:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348194c8:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA, &reg->out_endp[EP0_CON].doepctl);
348194cc:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
348194d0:	e5943000 	ldr	r3, [r4]
348194d4:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
348194d8:	e8bd8010 	pop	{r4, pc}
348194dc:	3482bb78 	.word	0x3482bb78
348194e0:	00080008 	.word	0x00080008

348194e4 <s3c_udc_ep0_set_stall.clone.3>:
{
	struct s3c_udc *dev;
	u32		ep_ctrl = 0;

	dev = ep->dev;
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348194e4:	e59f3028 	ldr	r3, [pc, #40]	; 34819514 <s3c_udc_ep0_set_stall.clone.3+0x30>
348194e8:	e5933000 	ldr	r3, [r3]
348194ec:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

	/* set the disable and stall bits */
	if (ep_ctrl & DEPCTL_EPENA)
348194f0:	e3530000 	cmp	r3, #0
		ep_ctrl |= DEPCTL_EPDIS;
348194f4:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

	ep_ctrl |= DEPCTL_STALL;
348194f8:	e3833602 	orr	r3, r3, #2097152	; 0x200000

	writel(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
348194fc:	e59f2010 	ldr	r2, [pc, #16]	; 34819514 <s3c_udc_ep0_set_stall.clone.3+0x30>
34819500:	e5922000 	ldr	r2, [r2]
34819504:	e5823900 	str	r3, [r2, #2304]	; 0x900
		   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
	/*
	 * The application can only set this bit, and the core clears it,
	 * when a SETUP token is received for this endpoint
	 */
	dev->ep0state = WAIT_FOR_SETUP;
34819508:	e3a03000 	mov	r3, #0
3481950c:	e5803054 	str	r3, [r0, #84]	; 0x54

	s3c_udc_pre_setup();
34819510:	eaffffe1 	b	3481949c <s3c_udc_pre_setup>
34819514:	3482bb78 	.word	0x3482bb78

34819518 <setdma_tx>:
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34819518:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
3481951c:	e59f211c 	ldr	r2, [pc, #284]	; 34819640 <setdma_tx+0x128>

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819520:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819524:	e5922008 	ldr	r2, [r2, #8]

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819528:	e206600f 	and	r6, r6, #15
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
3481952c:	e1a03001 	mov	r3, r1
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819530:	e0822106 	add	r2, r2, r6, lsl #2
34819534:	e5927030 	ldr	r7, [r2, #48]	; 0x30

	buf = req->req.buf + req->req.actual;
	length = req->req.length - req->req.actual;
34819538:	e5935004 	ldr	r5, [r3, #4]
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
3481953c:	e5912024 	ldr	r2, [r1, #36]	; 0x24
34819540:	e5911000 	ldr	r1, [r1]
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
34819544:	e3560000 	cmp	r6, #0
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34819548:	e1a04000 	mov	r4, r0
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
3481954c:	e0811002 	add	r1, r1, r2
	length = req->req.length - req->req.actual;
34819550:	e0625005 	rsb	r5, r2, r5

	if (ep_num == EP0_CON)
34819554:	1a000002 	bne	34819564 <setdma_tx+0x4c>
		length = min(length, (u32)ep_maxpacket(ep));
34819558:	e1d031b4 	ldrh	r3, [r0, #20]
3481955c:	e1550003 	cmp	r5, r3
34819560:	21a05003 	movcs	r5, r3

	ep->len = length;
	ep->dma_buf = buf;
34819564:	e5841030 	str	r1, [r4, #48]	; 0x30
	memcpy(p, ep->dma_buf, length);
34819568:	e1a02005 	mov	r2, r5
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
		length = min(length, (u32)ep_maxpacket(ep));

	ep->len = length;
3481956c:	e584502c 	str	r5, [r4, #44]	; 0x2c
	ep->dma_buf = buf;
	memcpy(p, ep->dma_buf, length);
34819570:	e1a00007 	mov	r0, r7
34819574:	eb000c4b 	bl	3481c6a8 <memcpy>

	flush_dcache_range((unsigned long) p ,
34819578:	e1a00007 	mov	r0, r7
3481957c:	e2871901 	add	r1, r7, #16384	; 0x4000
34819580:	ebff9ebd 	bl	3480107c <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34819584:	e3550000 	cmp	r5, #0
		pktcnt = 1;
34819588:	03a00001 	moveq	r0, #1
	memcpy(p, ep->dma_buf, length);

	flush_dcache_range((unsigned long) p ,
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
3481958c:	0a000003 	beq	348195a0 <setdma_tx+0x88>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
34819590:	e2450001 	sub	r0, r5, #1
34819594:	e1d411b4 	ldrh	r1, [r4, #20]
34819598:	eb00198a 	bl	3481fbc8 <__udivsi3>
3481959c:	e2800001 	add	r0, r0, #1

	/* Flush the endpoint's Tx FIFO */
	writel(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
348195a0:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
348195a4:	e1a01301 	lsl	r1, r1, #6
348195a8:	e59f3090 	ldr	r3, [pc, #144]	; 34819640 <setdma_tx+0x128>
348195ac:	e5932000 	ldr	r2, [r3]
348195b0:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
348195b4:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
348195b8:	e1a01301 	lsl	r1, r1, #6
348195bc:	e3811020 	orr	r1, r1, #32
348195c0:	e5932000 	ldr	r2, [r3]
348195c4:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
348195c8:	e1a02003 	mov	r2, r3
348195cc:	e5921000 	ldr	r1, [r2]
348195d0:	e59f3068 	ldr	r3, [pc, #104]	; 34819640 <setdma_tx+0x128>
348195d4:	e5911010 	ldr	r1, [r1, #16]
348195d8:	e3110020 	tst	r1, #32
348195dc:	1afffffa 	bne	348195cc <setdma_tx+0xb4>
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
348195e0:	e5d41035 	ldrb	r1, [r4, #53]	; 0x35
348195e4:	e5932008 	ldr	r2, [r3, #8]
348195e8:	e201100f 	and	r1, r1, #15
348195ec:	e2811011 	add	r1, r1, #17
348195f0:	e792c101 	ldr	ip, [r2, r1, lsl #2]
348195f4:	e5932000 	ldr	r2, [r3]
348195f8:	e1a01286 	lsl	r1, r6, #5
348195fc:	e2811e91 	add	r1, r1, #2320	; 0x910
34819600:	e0822001 	add	r2, r2, r1
34819604:	e582c004 	str	ip, [r2, #4]
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34819608:	e1850980 	orr	r0, r5, r0, lsl #19
3481960c:	e5932000 	ldr	r2, [r3]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819610:	e2866048 	add	r6, r6, #72	; 0x48
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34819614:	e7820001 	str	r0, [r2, r1]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819618:	e7922286 	ldr	r2, [r2, r6, lsl #5]

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
3481961c:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
34819620:	e3c2250f 	bic	r2, r2, #62914560	; 0x3c00000
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34819624:	e1822b01 	orr	r2, r2, r1, lsl #22

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
34819628:	e3c22b1e 	bic	r2, r2, #30720	; 0x7800

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
3481962c:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34819630:	e5933000 	ldr	r3, [r3]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34819634:	e1a00005 	mov	r0, r5
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34819638:	e7832286 	str	r2, [r3, r6, lsl #5]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
3481963c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34819640:	3482bb78 	.word	0x3482bb78

34819644 <write_fifo_ep0>:
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34819644:	e92d4070 	push	{r4, r5, r6, lr}
	u32 max;
	unsigned count;
	int is_last;

	max = ep_maxpacket(ep);
34819648:	e1d061b4 	ldrh	r6, [r0, #20]
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
3481964c:	e1a05000 	mov	r5, r0
34819650:	e1a04001 	mov	r4, r1

	max = ep_maxpacket(ep);

	debug_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);

	count = setdma_tx(ep, req);
34819654:	ebffffaf 	bl	34819518 <setdma_tx>

	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
34819658:	e1500006 	cmp	r0, r6
3481965c:	1a00000d 	bne	34819698 <write_fifo_ep0+0x54>
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
34819660:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819664:	e0800003 	add	r0, r0, r3
34819668:	e5943004 	ldr	r3, [r4, #4]
3481966c:	e1530000 	cmp	r3, r0
34819670:	1a000006 	bne	34819690 <write_fifo_ep0+0x4c>
		    || req->req.zero)
34819674:	e5d4300c 	ldrb	r3, [r4, #12]
34819678:	e2033002 	and	r3, r3, #2
3481967c:	e6ef3073 	uxtb	r3, r3
34819680:	e3530000 	cmp	r3, #0
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34819684:	13a00000 	movne	r0, #0
	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
		    || req->req.zero)
34819688:	18bd8070 	popne	{r4, r5, r6, pc}
3481968c:	ea000001 	b	34819698 <write_fifo_ep0+0x54>
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34819690:	e3a00000 	mov	r0, #0
}
34819694:	e8bd8070 	pop	{r4, r5, r6, pc}
		   is_last ? "/L" : "",
		   req->req.length - req->req.actual - count, req);

	/* requests complete when all IN data is in the FIFO */
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
34819698:	e5953018 	ldr	r3, [r5, #24]
3481969c:	e3a02000 	mov	r2, #0
348196a0:	e5832054 	str	r2, [r3, #84]	; 0x54
		return 1;
348196a4:	e3a00001 	mov	r0, #1
348196a8:	e8bd8070 	pop	{r4, r5, r6, pc}

348196ac <s3c_queue>:
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
348196ac:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
348196b0:	e2516000 	subs	r6, r1, #0
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
348196b4:	e1a04000 	mov	r4, r0
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
348196b8:	0a00006a 	beq	34819868 <s3c_queue+0x1bc>
348196bc:	e5963010 	ldr	r3, [r6, #16]
348196c0:	e3530000 	cmp	r3, #0
348196c4:	1a00006c 	bne	3481987c <s3c_queue+0x1d0>
348196c8:	ea000066 	b	34819868 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep = container_of(_ep, struct s3c_ep, ep);

	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
348196cc:	e3540000 	cmp	r4, #0
348196d0:	0a000064 	beq	34819868 <s3c_queue+0x1bc>
348196d4:	e594301c 	ldr	r3, [r4, #28]
348196d8:	e3530000 	cmp	r3, #0
348196dc:	1a00006e 	bne	3481989c <s3c_queue+0x1f0>
348196e0:	e5942004 	ldr	r2, [r4, #4]
348196e4:	e59f31c8 	ldr	r3, [pc, #456]	; 348198b4 <s3c_queue+0x208>
348196e8:	e1520003 	cmp	r2, r3
348196ec:	0a00006a 	beq	3481989c <s3c_queue+0x1f0>
348196f0:	ea00005c 	b	34819868 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
348196f4:	e5953010 	ldr	r3, [r5, #16]
348196f8:	e3530000 	cmp	r3, #0
348196fc:	0a00005b 	beq	34819870 <s3c_queue+0x1c4>
34819700:	e5942020 	ldr	r2, [r4, #32]
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
34819704:	e3e03072 	mvn	r3, #114	; 0x72
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34819708:	e2849020 	add	r9, r4, #32
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
3481970c:	e5863020 	str	r3, [r6, #32]
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34819710:	e1520009 	cmp	r2, r9
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
	_req->actual = 0;
34819714:	e2833073 	add	r3, r3, #115	; 0x73
34819718:	e5863024 	str	r3, [r6, #36]	; 0x24
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
3481971c:	1a000048 	bne	34819844 <s3c_queue+0x198>
34819720:	e5d43034 	ldrb	r3, [r4, #52]	; 0x34
34819724:	e3530000 	cmp	r3, #0
34819728:	1a000045 	bne	34819844 <s3c_queue+0x198>

		if (ep_num == 0) {
3481972c:	e21aa00f 	ands	sl, sl, #15
34819730:	1a000039 	bne	3481981c <s3c_queue+0x170>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34819734:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34819738:	e5862028 	str	r2, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481973c:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34819740:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34819744:	e586302c 	str	r3, [r6, #44]	; 0x2c

static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
34819748:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
3481974c:	e1a02005 	mov	r2, r5
34819750:	e3530000 	cmp	r3, #0
34819754:	e5b23078 	ldr	r3, [r2, #120]!	; 0x78
34819758:	aa000017 	bge	348197bc <s3c_queue+0x110>
		dev->ep0state = DATA_STATE_XMIT;
3481975c:	e3a04001 	mov	r4, #1
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34819760:	e1530002 	cmp	r3, r2
static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
34819764:	e5854054 	str	r4, [r5, #84]	; 0x54
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34819768:	0a000041 	beq	34819874 <s3c_queue+0x1c8>
		req = 0;
	else
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	if (!req) {
3481976c:	e2531028 	subs	r1, r3, #40	; 0x28
34819770:	0a00003a 	beq	34819860 <s3c_queue+0x1b4>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34819774:	e5137024 	ldr	r7, [r3, #-36]	; 0x24
34819778:	e5133004 	ldr	r3, [r3, #-4]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
3481977c:	e2850058 	add	r0, r5, #88	; 0x58

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34819780:	e0637007 	rsb	r7, r3, r7
34819784:	e59f312c 	ldr	r3, [pc, #300]	; 348198b8 <s3c_queue+0x20c>
34819788:	e5936000 	ldr	r6, [r3]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
3481978c:	ebffffac 	bl	34819644 <write_fifo_ep0>

	if ((ret == 1) && !need_zlp) {
34819790:	e1500004 	cmp	r0, r4
34819794:	13a01000 	movne	r1, #0
34819798:	03a01001 	moveq	r1, #1
3481979c:	e1570006 	cmp	r7, r6
348197a0:	03a01000 	moveq	r1, #0
348197a4:	e3510000 	cmp	r1, #0
		/* Last packet */
		dev->ep0state = WAIT_FOR_COMPLETE;
348197a8:	13a03005 	movne	r3, #5
348197ac:	15853054 	strne	r3, [r5, #84]	; 0x54
		debug_cond(DEBUG_EP0 != 0,
			   "%s: finished, waiting for status\n", __func__);

	} else {
		dev->ep0state = DATA_STATE_XMIT;
348197b0:	05854054 	streq	r4, [r5, #84]	; 0x54
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);

	if ((ret == 1) && !need_zlp) {
348197b4:	0a000029 	beq	34819860 <s3c_queue+0x1b4>
348197b8:	ea00002d 	b	34819874 <s3c_queue+0x1c8>
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
348197bc:	e3a01004 	mov	r1, #4
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
348197c0:	e1530002 	cmp	r3, r2
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
348197c4:	e5851054 	str	r1, [r5, #84]	; 0x54
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
348197c8:	0a000004 	beq	348197e0 <s3c_queue+0x134>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
348197cc:	e5134024 	ldr	r4, [r3, #-36]	; 0x24
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
348197d0:	e2431028 	sub	r1, r3, #40	; 0x28

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
348197d4:	e3540000 	cmp	r4, #0
348197d8:	1a00000c 	bne	34819810 <s3c_queue+0x164>
348197dc:	ea000006 	b	348197fc <s3c_queue+0x150>
	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	} else {
		debug("%s: ---> BUG\n", __func__);
		BUG();
348197e0:	e59f00d4 	ldr	r0, [pc, #212]	; 348198bc <s3c_queue+0x210>
348197e4:	e59f10d4 	ldr	r1, [pc, #212]	; 348198c0 <s3c_queue+0x214>
348197e8:	e3002332 	movw	r2, #818	; 0x332
348197ec:	e59f30d0 	ldr	r3, [pc, #208]	; 348198c4 <s3c_queue+0x218>
348197f0:	ebffc0b4 	bl	34809ac8 <printf>
348197f4:	e59f00cc 	ldr	r0, [pc, #204]	; 348198c8 <s3c_queue+0x21c>
348197f8:	eb000f28 	bl	3481d4a0 <panic>

	if (req->req.length == 0) {
		/* zlp for Set_configuration, Set_interface,
		 * or Bulk-Only mass storge reset */

		ep->len = 0;
348197fc:	e5854084 	str	r4, [r5, #132]	; 0x84
		s3c_udc_ep0_zlp(dev);
34819800:	e2850054 	add	r0, r5, #84	; 0x54
34819804:	ebfffe4e 	bl	34819144 <s3c_udc_ep0_zlp.clone.2>
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819808:	e1a0a004 	mov	sl, r4
3481980c:	ea000018 	b	34819874 <s3c_queue+0x1c8>
			   "%s: req.length = 0, bRequest = %d\n",
			   __func__, usb_ctrl->bRequest);
		return;
	}

	setdma_rx(ep, req);
34819810:	e2850058 	add	r0, r5, #88	; 0x58
34819814:	ebfffe03 	bl	34819028 <setdma_rx>
34819818:	ea000015 	b	34819874 <s3c_queue+0x1c8>
			/* EP0 */
			list_add_tail(&req->queue, &ep->queue);
			s3c_ep0_kick(dev, ep);
			req = 0;

		} else if (ep_is_in(ep)) {
3481981c:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34819820:	e3530000 	cmp	r3, #0
34819824:	aa000003 	bge	34819838 <s3c_queue+0x18c>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_IN_EP,
				   "%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_tx(ep, req);
34819828:	e1a00004 	mov	r0, r4
3481982c:	e1a01006 	mov	r1, r6
34819830:	ebffff38 	bl	34819518 <setdma_tx>
34819834:	ea000002 	b	34819844 <s3c_queue+0x198>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_OUT_EP != 0,
				   "%s:ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_rx(ep, req);
34819838:	e1a00004 	mov	r0, r4
3481983c:	e1a01006 	mov	r1, r6
34819840:	ebfffdf8 	bl	34819028 <setdma_rx>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34819844:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34819848:	e5869028 	str	r9, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481984c:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34819850:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34819854:	e586302c 	str	r3, [r6, #44]	; 0x2c
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819858:	e3a0a000 	mov	sl, #0
3481985c:	ea000004 	b	34819874 <s3c_queue+0x1c8>
34819860:	e1a0a001 	mov	sl, r1
34819864:	ea000002 	b	34819874 <s3c_queue+0x1c8>
	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
		     || !list_empty(&req->queue))) {

		debug("%s: bad params\n", __func__);
		return -EINVAL;
34819868:	e3e0a015 	mvn	sl, #21
3481986c:	ea000000 	b	34819874 <s3c_queue+0x1c8>
	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {

		debug("%s: bogus device state %p\n", __func__, dev->driver);
		return -ESHUTDOWN;
34819870:	e3e0a06b 	mvn	sl, #107	; 0x6b
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819874:	e1a0000a 	mov	r0, sl
34819878:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
3481987c:	e5963000 	ldr	r3, [r6]
34819880:	e3530000 	cmp	r3, #0
34819884:	0afffff7 	beq	34819868 <s3c_queue+0x1bc>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34819888:	e1a03006 	mov	r3, r6
3481988c:	e5b37028 	ldr	r7, [r3, #40]!	; 0x28
34819890:	e1570003 	cmp	r7, r3
34819894:	0affff8c 	beq	348196cc <s3c_queue+0x20>
34819898:	eafffff2 	b	34819868 <s3c_queue+0x1bc>
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
3481989c:	e5945018 	ldr	r5, [r4, #24]
		debug("%s: bad ep: %s, %d, %p\n", __func__,
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
348198a0:	e5d4a035 	ldrb	sl, [r4, #53]	; 0x35
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
348198a4:	e5953024 	ldr	r3, [r5, #36]	; 0x24
348198a8:	e3530000 	cmp	r3, #0
348198ac:	1affff90 	bne	348196f4 <s3c_queue+0x48>
348198b0:	eaffffee 	b	34819870 <s3c_queue+0x1c4>
348198b4:	348215b4 	.word	0x348215b4
348198b8:	34829268 	.word	0x34829268
348198bc:	3482733d 	.word	0x3482733d
348198c0:	34827dc4 	.word	0x34827dc4
348198c4:	348215c0 	.word	0x348215c0
348198c8:	34827364 	.word	0x34827364

348198cc <s3c_fifo_read>:

	return 0;
}

int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
{
348198cc:	e92d4008 	push	{r3, lr}
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
348198d0:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
348198d4:	e5902018 	ldr	r2, [r0, #24]
348198d8:	e203300f 	and	r3, r3, #15
348198dc:	e0823103 	add	r3, r2, r3, lsl #2
348198e0:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
{
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
348198e4:	e2801901 	add	r1, r0, #16384	; 0x4000
348198e8:	ebff9dda 	bl	34801058 <invalidate_dcache_range>
	debug_cond(DEBUG_EP0 != 0,
		   "%s: bytes=%d, ep_index=%d %p\n", __func__,
		   bytes, ep_index(ep), ep->dev->dma_buf[ep_index(ep)]);

	return bytes;
}
348198ec:	e3a00008 	mov	r0, #8
348198f0:	e8bd8008 	pop	{r3, pc}

348198f4 <s3c_udc_get_status>:

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348198f4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348198f8:	e59f70e8 	ldr	r7, [pc, #232]	; 348199e8 <s3c_udc_get_status+0xf4>
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
348198fc:	e5d13004 	ldrb	r3, [r1, #4]
34819900:	e5d1a005 	ldrb	sl, [r1, #5]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
34819904:	e1a04001 	mov	r4, r1
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819908:	e5d11000 	ldrb	r1, [r1]
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
3481990c:	e183a40a 	orr	sl, r3, sl, lsl #8
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34819910:	e5973008 	ldr	r3, [r7, #8]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
34819914:	e1a05000 	mov	r5, r0
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819918:	e201101f 	and	r1, r1, #31
3481991c:	e59f00c8 	ldr	r0, [pc, #200]	; 348199ec <s3c_udc_get_status+0xf8>
int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34819920:	e5936030 	ldr	r6, [r3, #48]	; 0x30

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819924:	ebffc067 	bl	34809ac8 <printf>
	switch (crq->bRequestType & USB_RECIP_MASK) {
34819928:	e5d43000 	ldrb	r3, [r4]
3481992c:	e203301f 	and	r3, r3, #31
34819930:	e3530001 	cmp	r3, #1
34819934:	0a000005 	beq	34819950 <s3c_udc_get_status+0x5c>
34819938:	e3530002 	cmp	r3, #2
3481993c:	0a000005 	beq	34819958 <s3c_udc_get_status+0x64>
34819940:	e3530000 	cmp	r3, #0
			   "\tGET_STATUS:USB_RECIP_INTERFACE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_DEVICE:
		g_status = 0x1; /* Self powered */
34819944:	03a03001 	moveq	r3, #1
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
	switch (crq->bRequestType & USB_RECIP_MASK) {
34819948:	0a00000a 	beq	34819978 <s3c_udc_get_status+0x84>
3481994c:	ea000021 	b	348199d8 <s3c_udc_get_status+0xe4>
	case USB_RECIP_INTERFACE:
		g_status = 0;
34819950:	e3a03000 	mov	r3, #0
34819954:	ea000007 	b	34819978 <s3c_udc_get_status+0x84>
			   "\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
34819958:	e5d43006 	ldrb	r3, [r4, #6]
3481995c:	e5d42007 	ldrb	r2, [r4, #7]
34819960:	e1833402 	orr	r3, r3, r2, lsl #8
34819964:	e3530002 	cmp	r3, #2
34819968:	8a00001c 	bhi	348199e0 <s3c_udc_get_status+0xec>
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
3481996c:	e20aa07f 	and	sl, sl, #127	; 0x7f
34819970:	e085a30a 	add	sl, r5, sl, lsl #6
34819974:	e5da308c 	ldrb	r3, [sl, #140]	; 0x8c

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34819978:	e59f4068 	ldr	r4, [pc, #104]	; 348199e8 <s3c_udc_get_status+0xf4>
3481997c:	e3a02002 	mov	r2, #2
34819980:	e2841014 	add	r1, r4, #20
34819984:	e1a00006 	mov	r0, r6
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34819988:	e1c731b4 	strh	r3, [r7, #20]

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
3481998c:	eb000b45 	bl	3481c6a8 <memcpy>

	flush_dcache_range((unsigned long) p,
34819990:	e1a00006 	mov	r0, r6
34819994:	e2861901 	add	r1, r6, #16384	; 0x4000
34819998:	ebff9db7 	bl	3480107c <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
3481999c:	e5943008 	ldr	r3, [r4, #8]
348199a0:	e5932044 	ldr	r2, [r3, #68]	; 0x44
348199a4:	e5943000 	ldr	r3, [r4]
348199a8:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
348199ac:	e59f203c 	ldr	r2, [pc, #60]	; 348199f0 <s3c_udc_get_status+0xfc>
348199b0:	e5943000 	ldr	r3, [r4]
348199b4:	e5832910 	str	r2, [r3, #2320]	; 0x910
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348199b8:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348199bc:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
348199c0:	e5943000 	ldr	r3, [r4]
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
348199c4:	e3a00000 	mov	r0, #0
	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348199c8:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
348199cc:	e3a03008 	mov	r3, #8
348199d0:	e5853054 	str	r3, [r5, #84]	; 0x54

	return 0;
348199d4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
			   g_status);

		break;

	default:
		return 1;
348199d8:	e3a00001 	mov	r0, #1
348199dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
348199e0:	e3a00001 	mov	r0, #1
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
}
348199e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348199e8:	3482bb78 	.word	0x3482bb78
348199ec:	34827ddb 	.word	0x34827ddb
348199f0:	00080002 	.word	0x00080002

348199f4 <s3c_udc_ep_set_stall>:
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348199f4:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348199f8:	e3130080 	tst	r3, #128	; 0x80
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348199fc:	e203200f 	and	r2, r3, #15
34819a00:	e59f3048 	ldr	r3, [pc, #72]	; 34819a50 <s3c_udc_ep_set_stall+0x5c>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819a04:	0a00000a 	beq	34819a34 <s3c_udc_ep_set_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819a08:	e5933000 	ldr	r3, [r3]
34819a0c:	e2821048 	add	r1, r2, #72	; 0x48
34819a10:	e7933281 	ldr	r3, [r3, r1, lsl #5]

		/* set the disable and stall bits */
		if (ep_ctrl & DEPCTL_EPENA)
34819a14:	e3530000 	cmp	r3, #0
			ep_ctrl |= DEPCTL_EPDIS;
34819a18:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

		ep_ctrl |= DEPCTL_STALL;
34819a1c:	e3833602 	orr	r3, r3, #2097152	; 0x200000

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819a20:	e59f1028 	ldr	r1, [pc, #40]	; 34819a50 <s3c_udc_ep_set_stall+0x5c>
34819a24:	e2822048 	add	r2, r2, #72	; 0x48
34819a28:	e5911000 	ldr	r1, [r1]
34819a2c:	e7813282 	str	r3, [r1, r2, lsl #5]
34819a30:	e12fff1e 	bx	lr
		debug("%s: set stall, DIEPCTL%d = 0x%x\n",
		      __func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819a34:	e5931000 	ldr	r1, [r3]
34819a38:	e2822058 	add	r2, r2, #88	; 0x58
34819a3c:	e7911282 	ldr	r1, [r1, r2, lsl #5]

		/* set the stall bit */
		ep_ctrl |= DEPCTL_STALL;
34819a40:	e3811602 	orr	r1, r1, #2097152	; 0x200000

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819a44:	e5933000 	ldr	r3, [r3]
34819a48:	e7831282 	str	r1, [r3, r2, lsl #5]
34819a4c:	e12fff1e 	bx	lr
34819a50:	3482bb78 	.word	0x3482bb78

34819a54 <s3c_udc_ep_clear_stall>:
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819a54:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819a58:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819a5c:	e202300f 	and	r3, r2, #15
34819a60:	e59f2064 	ldr	r2, [pc, #100]	; 34819acc <s3c_udc_ep_clear_stall+0x78>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819a64:	0a00000a 	beq	34819a94 <s3c_udc_ep_clear_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819a68:	e5922000 	ldr	r2, [r2]
34819a6c:	e2831048 	add	r1, r3, #72	; 0x48
34819a70:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819a74:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819a78:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819a7c:	e2411002 	sub	r1, r1, #2
		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819a80:	e6ef1071 	uxtb	r1, r1
34819a84:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819a88:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819a8c:	e2833048 	add	r3, r3, #72	; 0x48
34819a90:	ea000009 	b	34819abc <s3c_udc_ep_clear_stall+0x68>
		debug("%s: cleared stall, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819a94:	e5922000 	ldr	r2, [r2]
34819a98:	e2831058 	add	r1, r3, #88	; 0x58
34819a9c:	e7922281 	ldr	r2, [r2, r1, lsl #5]

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819aa0:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819aa4:	e3c22602 	bic	r2, r2, #2097152	; 0x200000

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819aa8:	e2411002 	sub	r1, r1, #2
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819aac:	e6ef1071 	uxtb	r1, r1
34819ab0:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819ab4:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819ab8:	e2833058 	add	r3, r3, #88	; 0x58
34819abc:	e59f1008 	ldr	r1, [pc, #8]	; 34819acc <s3c_udc_ep_clear_stall+0x78>
34819ac0:	e5911000 	ldr	r1, [r1]
34819ac4:	e7812283 	str	r2, [r1, r3, lsl #5]
34819ac8:	e12fff1e 	bx	lr
34819acc:	3482bb78 	.word	0x3482bb78

34819ad0 <s3c_udc_set_halt>:

	return;
}

static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
{
34819ad0:	e92d4010 	push	{r4, lr}
	struct s3c_udc	*dev;
	unsigned long	flags;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819ad4:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819ad8:	e590301c 	ldr	r3, [r0, #28]
34819adc:	e312000f 	tst	r2, #15
34819ae0:	13a0c000 	movne	ip, #0
34819ae4:	03a0c001 	moveq	ip, #1
34819ae8:	e3530000 	cmp	r3, #0
34819aec:	038cc001 	orreq	ip, ip, #1
34819af0:	e35c0000 	cmp	ip, #0
34819af4:	0a000019 	beq	34819b60 <s3c_udc_set_halt+0x90>
34819af8:	ea000014 	b	34819b50 <s3c_udc_set_halt+0x80>
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
34819afc:	e3510000 	cmp	r1, #0
34819b00:	0a000008 	beq	34819b28 <s3c_udc_set_halt+0x58>
34819b04:	e3120080 	tst	r2, #128	; 0x80
34819b08:	0a000004 	beq	34819b20 <s3c_udc_set_halt+0x50>
34819b0c:	e5902020 	ldr	r2, [r0, #32]
34819b10:	e2803020 	add	r3, r0, #32
34819b14:	e1520003 	cmp	r2, r3
		debug("%s: %s queue not empty, req = %p\n",
			__func__, ep->ep.name,
			list_entry(ep->queue.next, struct s3c_request, queue));

		return -EAGAIN;
34819b18:	13e0000a 	mvnne	r0, #10
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
34819b1c:	18bd8010 	popne	{r4, pc}
	dev = ep->dev;
	debug("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);

	spin_lock_irqsave(&dev->lock, flags);

	if (value == 0) {
34819b20:	e3510000 	cmp	r1, #0
34819b24:	1a000004 	bne	34819b3c <s3c_udc_set_halt+0x6c>
		ep->stopped = 0;
34819b28:	e3a04000 	mov	r4, #0
34819b2c:	e5c04034 	strb	r4, [r0, #52]	; 0x34
		s3c_udc_ep_clear_stall(ep);
34819b30:	ebffffc7 	bl	34819a54 <s3c_udc_ep_clear_stall>
		s3c_udc_ep_set_stall(ep);
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819b34:	e1a00004 	mov	r0, r4
34819b38:	e8bd8010 	pop	{r4, pc}
		s3c_udc_ep_clear_stall(ep);
	} else {
		if (ep_num == 0)
			dev->ep0state = WAIT_FOR_SETUP;

		ep->stopped = 1;
34819b3c:	e3a03001 	mov	r3, #1
34819b40:	e5c03034 	strb	r3, [r0, #52]	; 0x34
		s3c_udc_ep_set_stall(ep);
34819b44:	ebffffaa 	bl	348199f4 <s3c_udc_ep_set_stall>
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819b48:	e3a00000 	mov	r0, #0
34819b4c:	e8bd8010 	pop	{r4, pc}
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
		     ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
		debug("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
		return -EINVAL;
34819b50:	e3e00015 	mvn	r0, #21
34819b54:	e8bd8010 	pop	{r4, pc}
34819b58:	e3e00015 	mvn	r0, #21
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819b5c:	e8bd8010 	pop	{r4, pc}
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819b60:	e5d33003 	ldrb	r3, [r3, #3]
34819b64:	e3530001 	cmp	r3, #1
34819b68:	1affffe3 	bne	34819afc <s3c_udc_set_halt+0x2c>
34819b6c:	eafffff9 	b	34819b58 <s3c_udc_set_halt+0x88>

34819b70 <s3c_udc_ep_activate>:
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34819b70:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34819b74:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34819b78:	e202300f 	and	r3, r2, #15
34819b7c:	e59f2094 	ldr	r2, [pc, #148]	; 34819c18 <s3c_udc_ep_activate+0xa8>

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34819b80:	0a000004 	beq	34819b98 <s3c_udc_ep_activate+0x28>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819b84:	e5922000 	ldr	r2, [r2]
34819b88:	e2831048 	add	r1, r3, #72	; 0x48
34819b8c:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = 1 << ep_num;
34819b90:	e3a01001 	mov	r1, #1
34819b94:	ea000003 	b	34819ba8 <s3c_udc_ep_activate+0x38>
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819b98:	e5922000 	ldr	r2, [r2]
34819b9c:	e2831058 	add	r1, r3, #88	; 0x58
34819ba0:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819ba4:	e3a01801 	mov	r1, #65536	; 0x10000
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819ba8:	e3120902 	tst	r2, #32768	; 0x8000
	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
		daintmsk = 1 << ep_num;
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819bac:	e1a01311 	lsl	r1, r1, r3
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819bb0:	1a000011 	bne	34819bfc <s3c_udc_ep_activate+0x8c>
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
34819bb4:	e5d0c036 	ldrb	ip, [r0, #54]	; 0x36
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
34819bb8:	e3c22703 	bic	r2, r2, #786432	; 0xc0000
34819bbc:	e182290c 	orr	r2, r2, ip, lsl #18
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
34819bc0:	e1d0c1b4 	ldrh	ip, [r0, #20]
34819bc4:	e3c22e7f 	bic	r2, r2, #2032	; 0x7f0
34819bc8:	e38cc306 	orr	ip, ip, #402653184	; 0x18000000
34819bcc:	e3c2200f 	bic	r2, r2, #15
34819bd0:	e38cc902 	orr	ip, ip, #32768	; 0x8000
			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
34819bd4:	e18cc002 	orr	ip, ip, r2

		if (ep_is_in(ep)) {
34819bd8:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
34819bdc:	e3520000 	cmp	r2, #0
34819be0:	e59f2030 	ldr	r2, [pc, #48]	; 34819c18 <s3c_udc_ep_activate+0xa8>
34819be4:	aa000001 	bge	34819bf0 <s3c_udc_ep_activate+0x80>
			writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819be8:	e2833048 	add	r3, r3, #72	; 0x48
34819bec:	ea000000 	b	34819bf4 <s3c_udc_ep_activate+0x84>
			debug("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
			      __func__, ep_num, ep_num,
			      readl(&reg->in_endp[ep_num].diepctl));
		} else {
			writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819bf0:	e2833058 	add	r3, r3, #88	; 0x58
34819bf4:	e5922000 	ldr	r2, [r2]
34819bf8:	e782c283 	str	ip, [r2, r3, lsl #5]
			      readl(&reg->out_endp[ep_num].doepctl));
		}
	}

	/* Unmask EP Interrtupt */
	writel(readl(&reg->daintmsk)|daintmsk, &reg->daintmsk);
34819bfc:	e59f3014 	ldr	r3, [pc, #20]	; 34819c18 <s3c_udc_ep_activate+0xa8>
34819c00:	e5932000 	ldr	r2, [r3]
34819c04:	e592281c 	ldr	r2, [r2, #2076]	; 0x81c
34819c08:	e1811002 	orr	r1, r1, r2
34819c0c:	e5933000 	ldr	r3, [r3]
34819c10:	e583181c 	str	r1, [r3, #2076]	; 0x81c
	debug("%s: DAINTMSK = 0x%x\n", __func__, readl(&reg->daintmsk));

}
34819c14:	e12fff1e 	bx	lr
34819c18:	3482bb78 	.word	0x3482bb78

34819c1c <s3c_ep_enable>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34819c1c:	e3500000 	cmp	r0, #0
34819c20:	13510000 	cmpne	r1, #0
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
}

static int s3c_ep_enable(struct usb_ep *_ep,
			 const struct usb_endpoint_descriptor *desc)
{
34819c24:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34819c28:	e1a05001 	mov	r5, r1
34819c2c:	e1a04000 	mov	r4, r0
34819c30:	0a000047 	beq	34819d54 <s3c_ep_enable+0x138>
34819c34:	e590301c 	ldr	r3, [r0, #28]
34819c38:	e3530000 	cmp	r3, #0
34819c3c:	1a000044 	bne	34819d54 <s3c_ep_enable+0x138>
34819c40:	e5902004 	ldr	r2, [r0, #4]
34819c44:	e59f3120 	ldr	r3, [pc, #288]	; 34819d6c <s3c_ep_enable+0x150>
34819c48:	e1520003 	cmp	r2, r3
34819c4c:	0a000040 	beq	34819d54 <s3c_ep_enable+0x138>
	    || desc->bDescriptorType != USB_DT_ENDPOINT
34819c50:	e5d13001 	ldrb	r3, [r1, #1]
34819c54:	e3530005 	cmp	r3, #5
34819c58:	1a00003d 	bne	34819d54 <s3c_ep_enable+0x138>
	    || ep->bEndpointAddress != desc->bEndpointAddress
34819c5c:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
34819c60:	e5d13002 	ldrb	r3, [r1, #2]
34819c64:	e1530006 	cmp	r3, r6
34819c68:	1a000039 	bne	34819d54 <s3c_ep_enable+0x138>
	    || ep_maxpacket(ep) <
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819c6c:	e2817004 	add	r7, r1, #4

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34819c70:	e1d0a1b4 	ldrh	sl, [r0, #20]
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819c74:	e1a00007 	mov	r0, r7
34819c78:	ebfffbf6 	bl	34818c58 <get_unaligned_le16>

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34819c7c:	e15a0000 	cmp	sl, r0
34819c80:	3a000033 	bcc	34819d54 <s3c_ep_enable+0x138>
		debug("%s: bad ep or descriptor\n", __func__);
		return -EINVAL;
	}

	/* xfer types must match, except that interrupt ~= bulk */
	if (ep->bmAttributes != desc->bmAttributes
34819c84:	e5d42036 	ldrb	r2, [r4, #54]	; 0x36
34819c88:	e5d53003 	ldrb	r3, [r5, #3]
34819c8c:	e1520003 	cmp	r2, r3
34819c90:	0a000004 	beq	34819ca8 <s3c_ep_enable+0x8c>
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
34819c94:	e3520002 	cmp	r2, #2
34819c98:	0a000002 	beq	34819ca8 <s3c_ep_enable+0x8c>
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
34819c9c:	e3530003 	cmp	r3, #3
34819ca0:	1a00002b 	bne	34819d54 <s3c_ep_enable+0x138>
34819ca4:	ea000003 	b	34819cb8 <s3c_ep_enable+0x9c>
		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
	}

	/* hardware _could_ do smaller, but driver doesn't */
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
34819ca8:	e3530002 	cmp	r3, #2
34819cac:	1a000001 	bne	34819cb8 <s3c_ep_enable+0x9c>
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
34819cb0:	e150000a 	cmp	r0, sl
34819cb4:	1a000028 	bne	34819d5c <s3c_ep_enable+0x140>
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {
34819cb8:	e3500000 	cmp	r0, #0
34819cbc:	0a000026 	beq	34819d5c <s3c_ep_enable+0x140>

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
34819cc0:	e5943018 	ldr	r3, [r4, #24]
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
34819cc4:	e5932024 	ldr	r2, [r3, #36]	; 0x24
34819cc8:	e3520000 	cmp	r2, #0

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
34819ccc:	03e0006b 	mvneq	r0, #107	; 0x6b
		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
34819cd0:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
34819cd4:	e5933010 	ldr	r3, [r3, #16]
34819cd8:	e3530000 	cmp	r3, #0
34819cdc:	0a000020 	beq	34819d64 <s3c_ep_enable+0x148>

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
34819ce0:	e3a03000 	mov	r3, #0
34819ce4:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	ep->desc = desc;
	ep->pio_irqs = 0;
34819ce8:	e5843028 	str	r3, [r4, #40]	; 0x28
		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
	ep->desc = desc;
34819cec:	e584501c 	str	r5, [r4, #28]
	ep->pio_irqs = 0;
	ep->ep.maxpacket = le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34819cf0:	e1a00007 	mov	r0, r7
34819cf4:	ebfffbd7 	bl	34818c58 <get_unaligned_le16>
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819cf8:	e3160080 	tst	r6, #128	; 0x80
34819cfc:	e1c401b4 	strh	r0, [r4, #20]
static void s3c_udc_set_nak(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819d00:	e206200f 	and	r2, r6, #15
34819d04:	e59f3064 	ldr	r3, [pc, #100]	; 34819d70 <s3c_ep_enable+0x154>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819d08:	0a000004 	beq	34819d20 <s3c_ep_enable+0x104>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819d0c:	e5931000 	ldr	r1, [r3]
34819d10:	e2822048 	add	r2, r2, #72	; 0x48
34819d14:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
34819d18:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819d1c:	ea000003 	b	34819d30 <s3c_ep_enable+0x114>
		debug("%s: set NAK, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819d20:	e5931000 	ldr	r1, [r3]
34819d24:	e2822058 	add	r2, r2, #88	; 0x58
34819d28:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
34819d2c:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819d30:	e5933000 	ldr	r3, [r3]

	/* Reset halt state */
	s3c_udc_set_nak(ep);
	s3c_udc_set_halt(_ep, 0);
34819d34:	e1a00004 	mov	r0, r4
34819d38:	e7831282 	str	r1, [r3, r2, lsl #5]
34819d3c:	e3a01000 	mov	r1, #0
34819d40:	ebffff62 	bl	34819ad0 <s3c_udc_set_halt>

	spin_lock_irqsave(&ep->dev->lock, flags);
	s3c_udc_ep_activate(ep);
34819d44:	e1a00004 	mov	r0, r4
34819d48:	ebffff88 	bl	34819b70 <s3c_udc_ep_activate>
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
34819d4c:	e3a00000 	mov	r0, #0
34819d50:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (ep->bmAttributes != desc->bmAttributes
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {

		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
34819d54:	e3e00015 	mvn	r0, #21
34819d58:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
34819d5c:	e3e00021 	mvn	r0, #33	; 0x21
34819d60:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
34819d64:	e3e0006b 	mvn	r0, #107	; 0x6b
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
}
34819d68:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34819d6c:	348215b4 	.word	0x348215b4
34819d70:	3482bb78 	.word	0x3482bb78

34819d74 <s3c_ep0_setup>:

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
34819d74:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_ep *ep = &dev->ep[0];
34819d78:	e2806058 	add	r6, r0, #88	; 0x58

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34819d7c:	e59f5298 	ldr	r5, [pc, #664]	; 3481a01c <s3c_ep0_setup+0x2a8>
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
34819d80:	e3e01046 	mvn	r1, #70	; 0x46

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
34819d84:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
34819d88:	e1a00006 	mov	r0, r6
34819d8c:	ebfffc76 	bl	34818f6c <nuke>

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34819d90:	e5951018 	ldr	r1, [r5, #24]
34819d94:	e1a00006 	mov	r0, r6
34819d98:	e3a02008 	mov	r2, #8
34819d9c:	ebfffeca 	bl	348198cc <s3c_fifo_read>
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
34819da0:	e5951018 	ldr	r1, [r5, #24]
34819da4:	e5d13001 	ldrb	r3, [r1, #1]
34819da8:	e35300fe 	cmp	r3, #254	; 0xfe
34819dac:	1a000005 	bne	34819dc8 <s3c_ep0_setup+0x54>
	    usb_ctrl->wLength != 1) {
34819db0:	e5d13006 	ldrb	r3, [r1, #6]
34819db4:	e5d12007 	ldrb	r2, [r1, #7]
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
34819db8:	e1833402 	orr	r3, r3, r2, lsl #8
34819dbc:	e3530001 	cmp	r3, #1
34819dc0:	0a000006 	beq	34819de0 <s3c_ep0_setup+0x6c>
34819dc4:	ea00008a 	b	34819ff4 <s3c_ep0_setup+0x280>

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819dc8:	e35300ff 	cmp	r3, #255	; 0xff
34819dcc:	1a000003 	bne	34819de0 <s3c_ep0_setup+0x6c>
		 usb_ctrl->wLength != 0) {
34819dd0:	e5d13006 	ldrb	r3, [r1, #6]
34819dd4:	e5d12007 	ldrb	r2, [r1, #7]

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819dd8:	e1932402 	orrs	r2, r3, r2, lsl #8
34819ddc:	1a000084 	bne	34819ff4 <s3c_ep0_setup+0x280>

		return;
	}

	/* Set direction of EP0 */
	if (likely(usb_ctrl->bRequestType & USB_DIR_IN)) {
34819de0:	e1d130d0 	ldrsb	r3, [r1]
34819de4:	e3530000 	cmp	r3, #0
34819de8:	e5d4308d 	ldrb	r3, [r4, #141]	; 0x8d
		ep->bEndpointAddress |= USB_DIR_IN;
34819dec:	b1e03c83 	mvnlt	r3, r3, lsl #25
34819df0:	b1e03ca3 	mvnlt	r3, r3, lsr #25
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
34819df4:	a203307f 	andge	r3, r3, #127	; 0x7f
34819df8:	e5c4308d 	strb	r3, [r4, #141]	; 0x8d
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
34819dfc:	e5d13000 	ldrb	r3, [r1]
		== USB_TYPE_STANDARD;
34819e00:	e3130060 	tst	r3, #96	; 0x60
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
34819e04:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
		== USB_TYPE_STANDARD;
34819e08:	13a02000 	movne	r2, #0
34819e0c:	03a02001 	moveq	r2, #1
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
34819e10:	e7c13092 	bfi	r3, r2, #1, #1
		== USB_TYPE_STANDARD;

	dev->req_pending = 1;
34819e14:	e6ef3073 	uxtb	r3, r3
34819e18:	e3833001 	orr	r3, r3, #1
34819e1c:	e5c43159 	strb	r3, [r4, #345]	; 0x159

	/* Handle some SETUP packets ourselves */
	if (dev->req_std) {
34819e20:	e2033002 	and	r3, r3, #2
34819e24:	e6ef3073 	uxtb	r3, r3
34819e28:	e3530000 	cmp	r3, #0
34819e2c:	0a000066 	beq	34819fcc <s3c_ep0_setup+0x258>
		switch (usb_ctrl->bRequest) {
34819e30:	e5d13001 	ldrb	r3, [r1, #1]
34819e34:	e353000b 	cmp	r3, #11
34819e38:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
34819e3c:	ea000062 	b	34819fcc <s3c_ep0_setup+0x258>
34819e40:	34819eb8 	.word	0x34819eb8
34819e44:	34819ecc 	.word	0x34819ecc
34819e48:	34819fcc 	.word	0x34819fcc
34819e4c:	34819f54 	.word	0x34819f54
34819e50:	34819fcc 	.word	0x34819fcc
34819e54:	34819e70 	.word	0x34819e70
34819e58:	34819fcc 	.word	0x34819fcc
34819e5c:	34819fcc 	.word	0x34819fcc
34819e60:	34819fcc 	.word	0x34819fcc
34819e64:	34819e8c 	.word	0x34819e8c
34819e68:	34819fcc 	.word	0x34819fcc
34819e6c:	34819ea4 	.word	0x34819ea4
		case USB_REQ_SET_ADDRESS:
		debug_cond(DEBUG_SETUP != 0,
			   "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
34819e70:	e5d13000 	ldrb	r3, [r1]
34819e74:	e3530000 	cmp	r3, #0
34819e78:	1a000053 	bne	34819fcc <s3c_ep0_setup+0x258>
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34819e7c:	e5d11002 	ldrb	r1, [r1, #2]
34819e80:	e1a00004 	mov	r0, r4

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819e84:	e8bd4070 	pop	{r4, r5, r6, lr}
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34819e88:	eafffd15 	b	348192e4 <udc_set_address>
				   "=====================================\n");
			debug_cond(DEBUG_SETUP != 0,
				   "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_DEVICE)
34819e8c:	e5d13000 	ldrb	r3, [r1]
34819e90:	e3530000 	cmp	r3, #0
				reset_available = 1;
34819e94:	059f3184 	ldreq	r3, [pc, #388]	; 3481a020 <s3c_ep0_setup+0x2ac>
34819e98:	03a02001 	moveq	r2, #1
34819e9c:	0583200c 	streq	r2, [r3, #12]
34819ea0:	ea000049 	b	34819fcc <s3c_ep0_setup+0x258>
		case USB_REQ_SET_INTERFACE:
			debug_cond(DEBUG_SETUP != 0,
				   "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_INTERFACE)
34819ea4:	e5d13000 	ldrb	r3, [r1]
34819ea8:	e3530001 	cmp	r3, #1
				reset_available = 1;
34819eac:	059f216c 	ldreq	r2, [pc, #364]	; 3481a020 <s3c_ep0_setup+0x2ac>
34819eb0:	0582300c 	streq	r3, [r2, #12]
34819eb4:	ea000044 	b	34819fcc <s3c_ep0_setup+0x258>
				   "%s: *** USB_REQ_GET_CONFIGURATION\n",
				   __func__);
			break;

		case USB_REQ_GET_STATUS:
			if (!s3c_udc_get_status(dev, usb_ctrl))
34819eb8:	e1a00004 	mov	r0, r4
34819ebc:	ebfffe8c 	bl	348198f4 <s3c_udc_get_status>
34819ec0:	e3500000 	cmp	r0, #0
34819ec4:	1a000040 	bne	34819fcc <s3c_ep0_setup+0x258>
34819ec8:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
34819ecc:	e5d15004 	ldrb	r5, [r1, #4]
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819ed0:	e5d12006 	ldrb	r2, [r1, #6]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
34819ed4:	e205507f 	and	r5, r5, #127	; 0x7f
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819ed8:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
34819edc:	e0845305 	add	r5, r4, r5, lsl #6
34819ee0:	e2855058 	add	r5, r5, #88	; 0x58
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819ee4:	e192c40c 	orrs	ip, r2, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819ee8:	e5d53035 	ldrb	r3, [r5, #53]	; 0x35

	dev = ep->dev;
34819eec:	e5950018 	ldr	r0, [r5, #24]
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819ef0:	1a000035 	bne	34819fcc <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819ef4:	e5d12000 	ldrb	r2, [r1]
34819ef8:	e212201f 	ands	r2, r2, #31
				   "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
			/** @todo Add CLEAR_FEATURE for TEST modes. */
			break;
		}

		s3c_udc_ep0_zlp(dev);
34819efc:	02800054 	addeq	r0, r0, #84	; 0x54
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819f00:	0a00002f 	beq	34819fc4 <s3c_ep0_setup+0x250>
34819f04:	e3520002 	cmp	r2, #2
34819f08:	18bd8070 	popne	{r4, r5, r6, pc}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE:USB_RECIP_ENDPOINT, wValue = %d\n",
			   usb_ctrl->wValue);

		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
34819f0c:	e5d12002 	ldrb	r2, [r1, #2]
34819f10:	e5d16003 	ldrb	r6, [r1, #3]
34819f14:	e1926406 	orrs	r6, r2, r6, lsl #8
34819f18:	18bd8070 	popne	{r4, r5, r6, pc}
			if (ep_num == 0) {
34819f1c:	e213400f 	ands	r4, r3, #15
34819f20:	0a000021 	beq	34819fac <s3c_ep0_setup+0x238>
				s3c_udc_ep0_set_stall(ep);
				return 0;
			}

			s3c_udc_ep0_zlp(dev);
34819f24:	e2800054 	add	r0, r0, #84	; 0x54
34819f28:	ebfffc85 	bl	34819144 <s3c_udc_ep0_zlp.clone.2>

			s3c_udc_ep_clear_stall(ep);
34819f2c:	e1a00005 	mov	r0, r5
34819f30:	ebfffec7 	bl	34819a54 <s3c_udc_ep_clear_stall>
			s3c_udc_ep_activate(ep);
34819f34:	e1a00005 	mov	r0, r5
34819f38:	ebffff0c 	bl	34819b70 <s3c_udc_ep_activate>
			ep->stopped = 0;

			clear_feature_num = ep_num;
34819f3c:	e59f30d8 	ldr	r3, [pc, #216]	; 3481a01c <s3c_ep0_setup+0x2a8>
			clear_feature_flag = 1;
34819f40:	e3a02001 	mov	r2, #1

			s3c_udc_ep0_zlp(dev);

			s3c_udc_ep_clear_stall(ep);
			s3c_udc_ep_activate(ep);
			ep->stopped = 0;
34819f44:	e5c56034 	strb	r6, [r5, #52]	; 0x34

			clear_feature_num = ep_num;
34819f48:	e5c3401c 	strb	r4, [r3, #28]
			clear_feature_flag = 1;
34819f4c:	e5832020 	str	r2, [r3, #32]
34819f50:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
34819f54:	e5d10004 	ldrb	r0, [r1, #4]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819f58:	e5d13006 	ldrb	r3, [r1, #6]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819f5c:	e200007f 	and	r0, r0, #127	; 0x7f

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819f60:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819f64:	e0840300 	add	r0, r4, r0, lsl #6
34819f68:	e2800058 	add	r0, r0, #88	; 0x58

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819f6c:	e193c40c 	orrs	ip, r3, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819f70:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	dev = ep->dev;
34819f74:	e5905018 	ldr	r5, [r0, #24]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819f78:	1a000013 	bne	34819fcc <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819f7c:	e5d13000 	ldrb	r3, [r1]
34819f80:	e213301f 	ands	r3, r3, #31
34819f84:	0a00000d 	beq	34819fc0 <s3c_ep0_setup+0x24c>
34819f88:	e3530002 	cmp	r3, #2
34819f8c:	1a00000e 	bne	34819fcc <s3c_ep0_setup+0x258>
		break;

	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
34819f90:	e5d13002 	ldrb	r3, [r1, #2]
34819f94:	e5d11003 	ldrb	r1, [r1, #3]
34819f98:	e1931401 	orrs	r1, r3, r1, lsl #8
34819f9c:	1a000007 	bne	34819fc0 <s3c_ep0_setup+0x24c>
			if (ep_num == 0) {
34819fa0:	e312000f 	tst	r2, #15
34819fa4:	1a000002 	bne	34819fb4 <s3c_ep0_setup+0x240>
				s3c_udc_ep0_set_stall(ep);
34819fa8:	e1a00005 	mov	r0, r5

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819fac:	e8bd4070 	pop	{r4, r5, r6, lr}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
			if (ep_num == 0) {
				s3c_udc_ep0_set_stall(ep);
34819fb0:	eafffd4b 	b	348194e4 <s3c_udc_ep0_set_stall.clone.3>
				return 0;
			}
			ep->stopped = 1;
34819fb4:	e3a03001 	mov	r3, #1
34819fb8:	e5c03034 	strb	r3, [r0, #52]	; 0x34
			s3c_udc_ep_set_stall(ep);
34819fbc:	ebfffe8c 	bl	348199f4 <s3c_udc_ep_set_stall>
		}

		s3c_udc_ep0_zlp(dev);
34819fc0:	e2850054 	add	r0, r5, #84	; 0x54

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819fc4:	e8bd4070 	pop	{r4, r5, r6, lr}
			}
			ep->stopped = 1;
			s3c_udc_ep_set_stall(ep);
		}

		s3c_udc_ep0_zlp(dev);
34819fc8:	eafffc5d 	b	34819144 <s3c_udc_ep0_zlp.clone.2>
			break;
		}
	}


	if (likely(dev->driver)) {
34819fcc:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819fd0:	e3530000 	cmp	r3, #0
34819fd4:	08bd8070 	popeq	{r4, r5, r6, pc}
		debug_cond(DEBUG_SETUP != 0,
			   "%s:usb_ctrlreq will be passed to fsg_setup()\n",
			    __func__);

		spin_unlock(&dev->lock);
		i = dev->driver->setup(&dev->gadget, usb_ctrl);
34819fd8:	e59f203c 	ldr	r2, [pc, #60]	; 3481a01c <s3c_ep0_setup+0x2a8>
34819fdc:	e593300c 	ldr	r3, [r3, #12]
34819fe0:	e1a00004 	mov	r0, r4
34819fe4:	e5921018 	ldr	r1, [r2, #24]
34819fe8:	e12fff33 	blx	r3
		spin_lock(&dev->lock);

		if (i < 0) {
34819fec:	e3500000 	cmp	r0, #0
34819ff0:	aa000004 	bge	3481a008 <s3c_ep0_setup+0x294>
			/* setup processing failed, force stall */
			s3c_udc_ep0_set_stall(ep);
34819ff4:	e5940070 	ldr	r0, [r4, #112]	; 0x70
34819ff8:	ebfffd39 	bl	348194e4 <s3c_udc_ep0_set_stall.clone.3>
			dev->ep0state = WAIT_FOR_SETUP;
34819ffc:	e3a03000 	mov	r3, #0
3481a000:	e5843054 	str	r3, [r4, #84]	; 0x54
3481a004:	e8bd8070 	pop	{r4, r5, r6, pc}
				   "\tdev->driver->setup failed (%d),"
				    " bRequest = %d\n",
				i, usb_ctrl->bRequest);


		} else if (dev->req_pending) {
3481a008:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
3481a00c:	e3130001 	tst	r3, #1
			dev->req_pending = 0;
3481a010:	17c0301f 	bfcne	r3, #0, #1
3481a014:	15c43159 	strbne	r3, [r4, #345]	; 0x159
3481a018:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a01c:	3482bb78 	.word	0x3482bb78
3481a020:	34829268 	.word	0x34829268

3481a024 <usb_gadget_register_driver>:
/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
3481a024:	e59f3094 	ldr	r3, [pc, #148]	; 3481a0c0 <usb_gadget_register_driver+0x9c>
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
3481a028:	e3500000 	cmp	r0, #0

/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
3481a02c:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_udc *dev = the_controller;
3481a030:	e5935008 	ldr	r5, [r3, #8]
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
3481a034:	0a00001e 	beq	3481a0b4 <usb_gadget_register_driver+0x90>
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
3481a038:	e5903000 	ldr	r3, [r0]
3481a03c:	e2433002 	sub	r3, r3, #2
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
3481a040:	e3530001 	cmp	r3, #1
3481a044:	8a00001a 	bhi	3481a0b4 <usb_gadget_register_driver+0x90>
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
3481a048:	e5903004 	ldr	r3, [r0, #4]
3481a04c:	e3530000 	cmp	r3, #0
3481a050:	0a000017 	beq	3481a0b4 <usb_gadget_register_driver+0x90>
3481a054:	e5902010 	ldr	r2, [r0, #16]
3481a058:	e3520000 	cmp	r2, #0
3481a05c:	0a000014 	beq	3481a0b4 <usb_gadget_register_driver+0x90>
3481a060:	e590200c 	ldr	r2, [r0, #12]
3481a064:	e3520000 	cmp	r2, #0
3481a068:	0a000011 	beq	3481a0b4 <usb_gadget_register_driver+0x90>
		return -EINVAL;
	if (!dev)
3481a06c:	e3550000 	cmp	r5, #0
		return -ENODEV;
3481a070:	03e04012 	mvneq	r4, #18
	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
3481a074:	0a00000f 	beq	3481a0b8 <usb_gadget_register_driver+0x94>
		return -ENODEV;
	if (dev->driver)
3481a078:	e5956024 	ldr	r6, [r5, #36]	; 0x24
3481a07c:	e3560000 	cmp	r6, #0
		return -EBUSY;
3481a080:	13e0400f 	mvnne	r4, #15
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
		return -ENODEV;
	if (dev->driver)
3481a084:	1a00000b 	bne	3481a0b8 <usb_gadget_register_driver+0x94>
		return -EBUSY;

	spin_lock_irqsave(&dev->lock, flags);
	/* first hook up the driver ... */
	dev->driver = driver;
3481a088:	e5850024 	str	r0, [r5, #36]	; 0x24
	if (retval) { /* TODO */
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
3481a08c:	e1a00005 	mov	r0, r5
3481a090:	e12fff33 	blx	r3
	if (retval) {
3481a094:	e2504000 	subs	r4, r0, #0
		debug_cond(DEBUG_SETUP != 0,
			   "%s: bind to driver --> error %d\n",
			    dev->gadget.name, retval);
		dev->driver = 0;
3481a098:	15856024 	strne	r6, [r5, #36]	; 0x24
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
	if (retval) {
3481a09c:	1a000005 	bne	3481a0b8 <usb_gadget_register_driver+0x94>
 */
static int udc_enable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	otg_phy_init(dev);
3481a0a0:	e1a00005 	mov	r0, r5
3481a0a4:	ebfffca3 	bl	34819338 <otg_phy_init>
	reconfig_usbd();
3481a0a8:	ebfffb1c 	bl	34818d20 <reconfig_usbd>

	debug_cond(DEBUG_SETUP != 0,
		   "S3C USB 2.0 OTG Controller Core Initialized : 0x%x\n",
		    readl(&reg->gintmsk));

	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a0ac:	e5854010 	str	r4, [r5, #16]

	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
3481a0b0:	ea000000 	b	3481a0b8 <usb_gadget_register_driver+0x94>

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
3481a0b4:	e3e04015 	mvn	r4, #21
	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
}
3481a0b8:	e1a00004 	mov	r0, r4
3481a0bc:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a0c0:	3482bb78 	.word	0x3482bb78

3481a0c4 <usb_gadget_unregister_driver>:
/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
3481a0c4:	e59f3144 	ldr	r3, [pc, #324]	; 3481a210 <usb_gadget_unregister_driver+0x14c>

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
3481a0c8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_udc *dev = the_controller;
3481a0cc:	e5934008 	ldr	r4, [r3, #8]

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
3481a0d0:	e1a07000 	mov	r7, r0
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
3481a0d4:	e3540000 	cmp	r4, #0
		return -ENODEV;
3481a0d8:	03e00012 	mvneq	r0, #18
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
3481a0dc:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -ENODEV;
	if (!driver || driver != dev->driver)
3481a0e0:	e3570000 	cmp	r7, #0
		return -EINVAL;
3481a0e4:	03e00015 	mvneq	r0, #21
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
3481a0e8:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a0ec:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a0f0:	e1570003 	cmp	r7, r3
3481a0f4:	1a000043 	bne	3481a208 <usb_gadget_unregister_driver+0x144>
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a0f8:	e5949010 	ldr	r9, [r4, #16]
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
3481a0fc:	e3a06000 	mov	r6, #0
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a100:	e1590006 	cmp	r9, r6
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
3481a104:	e5846024 	str	r6, [r4, #36]	; 0x24
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a108:	11a09007 	movne	r9, r7
3481a10c:	01a09006 	moveq	r9, r6
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a110:	e5846010 	str	r6, [r4, #16]
3481a114:	e1a05004 	mov	r5, r4
3481a118:	e1a0a004 	mov	sl, r4

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
3481a11c:	e3a0b001 	mov	fp, #1
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
3481a120:	e0840306 	add	r0, r4, r6, lsl #6
		ep->stopped = 1;
3481a124:	e5cab08c 	strb	fp, [sl, #140]	; 0x8c
		nuke(ep, -ESHUTDOWN);
3481a128:	e2800058 	add	r0, r0, #88	; 0x58
3481a12c:	e3e0106b 	mvn	r1, #107	; 0x6b
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a130:	e2866001 	add	r6, r6, #1
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
3481a134:	ebfffb8c 	bl	34818f6c <nuke>
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a138:	e3560004 	cmp	r6, #4
3481a13c:	e28aa040 	add	sl, sl, #64	; 0x40
3481a140:	1afffff6 	bne	3481a120 <usb_gadget_unregister_driver+0x5c>
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
	}

	/* report disconnect; the driver is already quiesced */
	if (driver) {
3481a144:	e3590000 	cmp	r9, #0
3481a148:	0a000002 	beq	3481a158 <usb_gadget_unregister_driver+0x94>
		spin_unlock(&dev->lock);
		driver->disconnect(&dev->gadget);
3481a14c:	e5993010 	ldr	r3, [r9, #16]
3481a150:	e1a00004 	mov	r0, r4
3481a154:	e12fff33 	blx	r3

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a158:	e5943004 	ldr	r3, [r4, #4]
	unsigned int i;

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
3481a15c:	e2842008 	add	r2, r4, #8
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a160:	e283100c 	add	r1, r3, #12
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a164:	e5842008 	str	r2, [r4, #8]
	list->prev = list;
3481a168:	e584200c 	str	r2, [r4, #12]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a16c:	e583100c 	str	r1, [r3, #12]
	list->prev = list;
3481a170:	e5831010 	str	r1, [r3, #16]
	dev->ep0state = WAIT_FOR_SETUP;
3481a174:	e3a03000 	mov	r3, #0
3481a178:	e5843054 	str	r3, [r4, #84]	; 0x54
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a17c:	e1a06003 	mov	r6, r3
3481a180:	ea000009 	b	3481a1ac <usb_gadget_unregister_driver+0xe8>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
3481a184:	e3530000 	cmp	r3, #0
3481a188:	0a000006 	beq	3481a1a8 <usb_gadget_unregister_driver+0xe4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3481a18c:	e594100c 	ldr	r1, [r4, #12]
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
3481a190:	e0840303 	add	r0, r4, r3, lsl #6
3481a194:	e2800064 	add	r0, r0, #100	; 0x64
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481a198:	e584000c 	str	r0, [r4, #12]
	new->next = next;
3481a19c:	e58520a4 	str	r2, [r5, #164]	; 0xa4
	new->prev = prev;
3481a1a0:	e58510a8 	str	r1, [r5, #168]	; 0xa8
	prev->next = new;
3481a1a4:	e5810000 	str	r0, [r1]
3481a1a8:	e2855040 	add	r5, r5, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a1ac:	e0841303 	add	r1, r4, r3, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a1b0:	e2833001 	add	r3, r3, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a1b4:	e2811078 	add	r1, r1, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a1b8:	e3530004 	cmp	r3, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a1bc:	e5856074 	str	r6, [r5, #116]	; 0x74
		ep->stopped = 0;
3481a1c0:	e5c5608c 	strb	r6, [r5, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a1c4:	e5851078 	str	r1, [r5, #120]	; 0x78
	list->prev = list;
3481a1c8:	e585107c 	str	r1, [r5, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
3481a1cc:	e5856080 	str	r6, [r5, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a1d0:	1affffeb 	bne	3481a184 <usb_gadget_unregister_driver+0xc0>
	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
	stop_activity(dev, driver);
	spin_unlock_irqrestore(&dev->lock, flags);

	driver->unbind(&dev->gadget);
3481a1d4:	e5973008 	ldr	r3, [r7, #8]
3481a1d8:	e1a00004 	mov	r0, r4
3481a1dc:	e12fff33 	blx	r3
 */
static void udc_disable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);
3481a1e0:	e1a00004 	mov	r0, r4
3481a1e4:	e1a01006 	mov	r1, r6
3481a1e8:	ebfffc3d 	bl	348192e4 <udc_set_address>

	dev->ep0state = WAIT_FOR_SETUP;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
	dev->usb_address = 0;

	otg_phy_off(dev);
3481a1ec:	e1a00004 	mov	r0, r4
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);

	dev->ep0state = WAIT_FOR_SETUP;
3481a1f0:	e5846054 	str	r6, [r4, #84]	; 0x54
	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a1f4:	e5846010 	str	r6, [r4, #16]
	dev->usb_address = 0;
3481a1f8:	e5c46158 	strb	r6, [r4, #344]	; 0x158

	otg_phy_off(dev);
3481a1fc:	ebfffc80 	bl	34819404 <otg_phy_off>
	driver->unbind(&dev->gadget);

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
3481a200:	e1a00006 	mov	r0, r6
3481a204:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;
3481a208:	e3e00015 	mvn	r0, #21

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
}
3481a20c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a210:	3482bb78 	.word	0x3482bb78

3481a214 <s3c_udc_probe>:

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
3481a214:	e59f3108 	ldr	r3, [pc, #264]	; 3481a324 <s3c_udc_probe+0x110>
3481a218:	e5902004 	ldr	r2, [r0, #4]
/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
{
3481a21c:	e92d4070 	push	{r4, r5, r6, lr}

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
3481a220:	e5832010 	str	r2, [r3, #16]
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
3481a224:	e5902008 	ldr	r2, [r0, #8]
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
3481a228:	e59f60f8 	ldr	r6, [pc, #248]	; 3481a328 <s3c_udc_probe+0x114>

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
3481a22c:	e5832000 	str	r2, [r3]
	usb_phy_ctrl = pdata->usb_phy_ctrl;
3481a230:	e590200c 	ldr	r2, [r0, #12]
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;
3481a234:	e2864010 	add	r4, r6, #16

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
	usb_phy_ctrl = pdata->usb_phy_ctrl;
3481a238:	e583200c 	str	r2, [r3, #12]

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
3481a23c:	e5d62024 	ldrb	r2, [r6, #36]	; 0x24
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
3481a240:	e5860038 	str	r0, [r6, #56]	; 0x38
	usb_phy_ctrl = pdata->usb_phy_ctrl;

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
	dev->gadget.is_otg = 0;
3481a244:	e3822001 	orr	r2, r2, #1
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;
3481a248:	e20220e1 	and	r2, r2, #225	; 0xe1
3481a24c:	e7c5229f 	bfc	r2, #5, #1
3481a250:	e5c62024 	strb	r2, [r6, #36]	; 0x24

	the_controller = dev;
3481a254:	e2865038 	add	r5, r6, #56	; 0x38
3481a258:	e5834008 	str	r4, [r3, #8]

/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
3481a25c:	e286604c 	add	r6, r6, #76	; 0x4c
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
3481a260:	e3a01901 	mov	r1, #16384	; 0x4000
3481a264:	e3a00040 	mov	r0, #64	; 0x40
3481a268:	ebffc182 	bl	3480a878 <memalign>
3481a26c:	e5a50004 	str	r0, [r5, #4]!
					   DMA_BUFFER_SIZE);
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
3481a270:	e5850014 	str	r0, [r5, #20]
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
3481a274:	e2801901 	add	r1, r0, #16384	; 0x4000
3481a278:	ebff9b76 	bl	34801058 <invalidate_dcache_range>
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
3481a27c:	e1550006 	cmp	r5, r6
3481a280:	1afffff6 	bne	3481a260 <s3c_udc_probe+0x4c>
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
					(unsigned long) (dev->dma_buf[i]
							 + DMA_BUFFER_SIZE));
	}
	usb_ctrl = dev->dma_buf[0];
3481a284:	e59f309c 	ldr	r3, [pc, #156]	; 3481a328 <s3c_udc_probe+0x114>
3481a288:	e59f2094 	ldr	r2, [pc, #148]	; 3481a324 <s3c_udc_probe+0x110>
3481a28c:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
3481a290:	e5821018 	str	r1, [r2, #24]
	usb_ctrl_dma_addr = dev->dma_addr[0];
3481a294:	e5931050 	ldr	r1, [r3, #80]	; 0x50
3481a298:	e5821004 	str	r1, [r2, #4]

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a29c:	e5932014 	ldr	r2, [r3, #20]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a2a0:	e2831018 	add	r1, r3, #24
3481a2a4:	e282000c 	add	r0, r2, #12
3481a2a8:	e582000c 	str	r0, [r2, #12]
	list->prev = list;
3481a2ac:	e5820010 	str	r0, [r2, #16]
	dev->ep0state = WAIT_FOR_SETUP;
3481a2b0:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a2b4:	e5831018 	str	r1, [r3, #24]
3481a2b8:	e5832064 	str	r2, [r3, #100]	; 0x64
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a2bc:	e1a00002 	mov	r0, r2
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a2c0:	e2833010 	add	r3, r3, #16
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
3481a2c4:	e1a05001 	mov	r5, r1
3481a2c8:	ea000008 	b	3481a2f0 <s3c_udc_probe+0xdc>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
3481a2cc:	e3520000 	cmp	r2, #0
3481a2d0:	0a000005 	beq	3481a2ec <s3c_udc_probe+0xd8>
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
3481a2d4:	e083c302 	add	ip, r3, r2, lsl #6
3481a2d8:	e28cc064 	add	ip, ip, #100	; 0x64
3481a2dc:	e58450a4 	str	r5, [r4, #164]	; 0xa4
	new->prev = prev;
3481a2e0:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	prev->next = new;
3481a2e4:	e581c000 	str	ip, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481a2e8:	e1a0100c 	mov	r1, ip
	new->next = next;
	new->prev = prev;
	prev->next = new;
3481a2ec:	e2844040 	add	r4, r4, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a2f0:	e083c302 	add	ip, r3, r2, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a2f4:	e2822001 	add	r2, r2, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a2f8:	e28cc078 	add	ip, ip, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a2fc:	e3520004 	cmp	r2, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a300:	e5840074 	str	r0, [r4, #116]	; 0x74
		ep->stopped = 0;
3481a304:	e5c4008c 	strb	r0, [r4, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a308:	e584c078 	str	ip, [r4, #120]	; 0x78
	list->prev = list;
3481a30c:	e584c07c 	str	ip, [r4, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
3481a310:	e5840080 	str	r0, [r4, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a314:	1affffec 	bne	3481a2cc <s3c_udc_probe+0xb8>
3481a318:	e59f3008 	ldr	r3, [pc, #8]	; 3481a328 <s3c_udc_probe+0x114>
3481a31c:	e583101c 	str	r1, [r3, #28]
	usb_ctrl_dma_addr = dev->dma_addr[0];

	udc_reinit(dev);

	return retval;
}
3481a320:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a324:	3482bb78 	.word	0x3482bb78
3481a328:	34829268 	.word	0x34829268

3481a32c <usb_gadget_handle_interrupts>:

int usb_gadget_handle_interrupts()
{
3481a32c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u32 intr_status = readl(&reg->gintsts);
3481a330:	e59f3434 	ldr	r3, [pc, #1076]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a334:	e5932000 	ldr	r2, [r3]
3481a338:	e5922014 	ldr	r2, [r2, #20]
	u32 gintmsk = readl(&reg->gintmsk);
3481a33c:	e5931000 	ldr	r1, [r3]
3481a340:	e5910018 	ldr	r0, [r1, #24]

	if (intr_status & gintmsk)
3481a344:	e0100002 	ands	r0, r0, r2
3481a348:	0a000105 	beq	3481a764 <usb_gadget_handle_interrupts+0x438>
	u32 usb_status, gintmsk;
	unsigned long flags;

	spin_lock_irqsave(&dev->lock, flags);

	intr_status = readl(&reg->gintsts);
3481a34c:	e5932000 	ldr	r2, [r3]
		return s3c_udc_irq(1, (void *)the_controller);
3481a350:	e5934008 	ldr	r4, [r3, #8]
3481a354:	e5926014 	ldr	r6, [r2, #20]
		  "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x,"
		  "DAINT : 0x%x, DAINTMSK : 0x%x\n",
		  __func__, intr_status, state_names[dev->ep0state], gintmsk,
		  readl(&reg->daint), readl(&reg->daintmsk));

	if (!intr_status) {
3481a358:	e3560000 	cmp	r6, #0
3481a35c:	0a0000ff 	beq	3481a760 <usb_gadget_handle_interrupts+0x434>
		spin_unlock_irqrestore(&dev->lock, flags);
		return IRQ_HANDLED;
	}

	if (intr_status & INT_ENUMDONE) {
3481a360:	e3160a02 	tst	r6, #8192	; 0x2000
3481a364:	0a000009 	beq	3481a390 <usb_gadget_handle_interrupts+0x64>
		debug_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");

		writel(INT_ENUMDONE, &reg->gintsts);
3481a368:	e5933000 	ldr	r3, [r3]
3481a36c:	e3a02a02 	mov	r2, #8192	; 0x2000
3481a370:	e5832014 	str	r2, [r3, #20]
		usb_status = (readl(&reg->dsts) & 0x6);
3481a374:	e5933808 	ldr	r3, [r3, #2056]	; 0x808

		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
3481a378:	e3130006 	tst	r3, #6
			debug_cond(DEBUG_ISR,
				   "\t\tFull Speed Detection\n");
			set_max_pktsize(dev, USB_SPEED_FULL);
3481a37c:	11a00004 	movne	r0, r4
3481a380:	13a01002 	movne	r1, #2

		} else {
			debug_cond(DEBUG_ISR,
				"\t\tHigh Speed Detection : 0x%x\n",
				usb_status);
			set_max_pktsize(dev, USB_SPEED_HIGH);
3481a384:	01a00004 	moveq	r0, r4
3481a388:	03a01003 	moveq	r1, #3
3481a38c:	ebfffa35 	bl	34818c68 <set_max_pktsize>
		}
	}

	if (intr_status & INT_EARLY_SUSPEND) {
3481a390:	e3160b01 	tst	r6, #1024	; 0x400
3481a394:	0a000003 	beq	3481a3a8 <usb_gadget_handle_interrupts+0x7c>
		debug_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
		writel(INT_EARLY_SUSPEND, &reg->gintsts);
3481a398:	e59f33cc 	ldr	r3, [pc, #972]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a39c:	e3a02b01 	mov	r2, #1024	; 0x400
3481a3a0:	e5933000 	ldr	r3, [r3]
3481a3a4:	e5832014 	str	r2, [r3, #20]
	}

	if (intr_status & INT_SUSPEND) {
3481a3a8:	e3160b02 	tst	r6, #2048	; 0x800
3481a3ac:	0a000014 	beq	3481a404 <usb_gadget_handle_interrupts+0xd8>
		usb_status = readl(&reg->dsts);
		debug_cond(DEBUG_ISR,
			"\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
		writel(INT_SUSPEND, &reg->gintsts);
3481a3b0:	e59f33b4 	ldr	r3, [pc, #948]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a3b4:	e3a02b02 	mov	r2, #2048	; 0x800
3481a3b8:	e5933000 	ldr	r3, [r3]
3481a3bc:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
3481a3c0:	e5943010 	ldr	r3, [r4, #16]
3481a3c4:	e3530000 	cmp	r3, #0
3481a3c8:	0a00000d 	beq	3481a404 <usb_gadget_handle_interrupts+0xd8>
		    && dev->driver) {
3481a3cc:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a3d0:	e3530000 	cmp	r3, #0
3481a3d4:	0a00000a 	beq	3481a404 <usb_gadget_handle_interrupts+0xd8>
			if (dev->driver->suspend)
3481a3d8:	e5933014 	ldr	r3, [r3, #20]
3481a3dc:	e3530000 	cmp	r3, #0
3481a3e0:	0a000001 	beq	3481a3ec <usb_gadget_handle_interrupts+0xc0>
				dev->driver->suspend(&dev->gadget);
3481a3e4:	e1a00004 	mov	r0, r4
3481a3e8:	e12fff33 	blx	r3

			/* HACK to let gadget detect disconnected state */
			if (dev->driver->disconnect) {
3481a3ec:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a3f0:	e5933010 	ldr	r3, [r3, #16]
3481a3f4:	e3530000 	cmp	r3, #0
3481a3f8:	0a000001 	beq	3481a404 <usb_gadget_handle_interrupts+0xd8>
				spin_unlock_irqrestore(&dev->lock, flags);
				dev->driver->disconnect(&dev->gadget);
3481a3fc:	e1a00004 	mov	r0, r4
3481a400:	e12fff33 	blx	r3
				spin_lock_irqsave(&dev->lock, flags);
			}
		}
	}

	if (intr_status & INT_RESUME) {
3481a404:	e3560000 	cmp	r6, #0
3481a408:	aa00000e 	bge	3481a448 <usb_gadget_handle_interrupts+0x11c>
		debug_cond(DEBUG_ISR, "\tResume interrupt\n");
		writel(INT_RESUME, &reg->gintsts);
3481a40c:	e59f3358 	ldr	r3, [pc, #856]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a410:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
3481a414:	e5933000 	ldr	r3, [r3]
3481a418:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
3481a41c:	e5943010 	ldr	r3, [r4, #16]
3481a420:	e3530000 	cmp	r3, #0
3481a424:	0a000007 	beq	3481a448 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver
3481a428:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a42c:	e3530000 	cmp	r3, #0
3481a430:	0a000004 	beq	3481a448 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver->resume) {
3481a434:	e5933018 	ldr	r3, [r3, #24]
3481a438:	e3530000 	cmp	r3, #0
3481a43c:	0a000001 	beq	3481a448 <usb_gadget_handle_interrupts+0x11c>

			dev->driver->resume(&dev->gadget);
3481a440:	e1a00004 	mov	r0, r4
3481a444:	e12fff33 	blx	r3
		}
	}

	if (intr_status & INT_RESET) {
3481a448:	e3160a01 	tst	r6, #4096	; 0x1000
3481a44c:	0a000014 	beq	3481a4a4 <usb_gadget_handle_interrupts+0x178>
		usb_status = readl(&reg->gotgctl);
3481a450:	e59f3314 	ldr	r3, [pc, #788]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a454:	e5932000 	ldr	r2, [r3]
3481a458:	e5922000 	ldr	r2, [r2]
		debug_cond(DEBUG_ISR,
			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
		writel(INT_RESET, &reg->gintsts);
3481a45c:	e5933000 	ldr	r3, [r3]
3481a460:	e3a01a01 	mov	r1, #4096	; 0x1000
3481a464:	e5831014 	str	r1, [r3, #20]

		if ((usb_status & 0xc0000) == (0x3 << 18)) {
3481a468:	e2023703 	and	r3, r2, #786432	; 0xc0000
3481a46c:	e3530703 	cmp	r3, #786432	; 0xc0000
3481a470:	e59f52f8 	ldr	r5, [pc, #760]	; 3481a770 <usb_gadget_handle_interrupts+0x444>
3481a474:	1a000008 	bne	3481a49c <usb_gadget_handle_interrupts+0x170>
			if (reset_available) {
3481a478:	e595300c 	ldr	r3, [r5, #12]
3481a47c:	e3530000 	cmp	r3, #0
3481a480:	0a000005 	beq	3481a49c <usb_gadget_handle_interrupts+0x170>
				debug_cond(DEBUG_ISR,
					"\t\tOTG core got reset (%d)!!\n",
					reset_available);
				reconfig_usbd();
3481a484:	ebfffa25 	bl	34818d20 <reconfig_usbd>
				dev->ep0state = WAIT_FOR_SETUP;
3481a488:	e3a03000 	mov	r3, #0
3481a48c:	e5843054 	str	r3, [r4, #84]	; 0x54
				reset_available = 0;
3481a490:	e585300c 	str	r3, [r5, #12]
				s3c_udc_pre_setup();
3481a494:	ebfffc00 	bl	3481949c <s3c_udc_pre_setup>
3481a498:	ea000001 	b	3481a4a4 <usb_gadget_handle_interrupts+0x178>
			} else
				reset_available = 1;

		} else {
			reset_available = 1;
3481a49c:	e3a03001 	mov	r3, #1
3481a4a0:	e585300c 	str	r3, [r5, #12]
			debug_cond(DEBUG_ISR,
				   "\t\tRESET handling skipped\n");
		}
	}

	if (intr_status & INT_IN_EP)
3481a4a4:	e3160701 	tst	r6, #262144	; 0x40000
3481a4a8:	0a00007a 	beq	3481a698 <usb_gadget_handle_interrupts+0x36c>
static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
3481a4ac:	e59f72b8 	ldr	r7, [pc, #696]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a4b0:	e5973000 	ldr	r3, [r7]
3481a4b4:	e5939818 	ldr	r9, [r3, #2072]	; 0x818
}

static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
3481a4b8:	e3a05000 	mov	r5, #0

	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;
3481a4bc:	e6ff9079 	uxth	r9, r9
3481a4c0:	e58d6004 	str	r6, [sp, #4]
3481a4c4:	ea000070 	b	3481a68c <usb_gadget_handle_interrupts+0x360>

	while (ep_intr) {
		if (ep_intr & DAINT_IN_EP_INT(1)) {
3481a4c8:	e3190001 	tst	r9, #1
3481a4cc:	0a00006b 	beq	3481a680 <usb_gadget_handle_interrupts+0x354>
			ep_intr_status = readl(&reg->in_endp[ep_num].diepint);
3481a4d0:	e5973000 	ldr	r3, [r7]
3481a4d4:	e1a02285 	lsl	r2, r5, #5
3481a4d8:	e0833002 	add	r3, r3, r2
3481a4dc:	e5933908 	ldr	r3, [r3, #2312]	; 0x908
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
3481a4e0:	e2822c09 	add	r2, r2, #2304	; 0x900
3481a4e4:	e5971000 	ldr	r1, [r7]
3481a4e8:	e2822008 	add	r2, r2, #8

			if (ep_intr_status & TRANSFER_DONE) {
3481a4ec:	e3130001 	tst	r3, #1
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
3481a4f0:	e7813002 	str	r3, [r1, r2]

			if (ep_intr_status & TRANSFER_DONE) {
3481a4f4:	0a000061 	beq	3481a680 <usb_gadget_handle_interrupts+0x354>
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 last;

	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
3481a4f8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a4fc:	e3530008 	cmp	r3, #8
3481a500:	1a000003 	bne	3481a514 <usb_gadget_handle_interrupts+0x1e8>
		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
3481a504:	e3a00006 	mov	r0, #6
3481a508:	e5840054 	str	r0, [r4, #84]	; 0x54
		s3c_ep0_complete_out();
3481a50c:	ebfffab3 	bl	34818fe0 <s3c_ep0_complete_out>
3481a510:	ea00003a 	b	3481a600 <usb_gadget_handle_interrupts+0x2d4>
		return;
	}

	if (list_empty(&ep->queue)) {
3481a514:	e1a06305 	lsl	r6, r5, #6
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3481a518:	e0843006 	add	r3, r4, r6
3481a51c:	e286b078 	add	fp, r6, #120	; 0x78
3481a520:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3481a524:	e084b00b 	add	fp, r4, fp
3481a528:	e153000b 	cmp	r3, fp
3481a52c:	0a000033 	beq	3481a600 <usb_gadget_handle_interrupts+0x2d4>
		setdma_rx(ep, req);
}

static void complete_tx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a530:	e2866058 	add	r6, r6, #88	; 0x58
3481a534:	e0846006 	add	r6, r4, r6
			__func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
3481a538:	e2431028 	sub	r1, r3, #40	; 0x28

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a53c:	e513a004 	ldr	sl, [r3, #-4]
3481a540:	e5132024 	ldr	r2, [r3, #-36]	; 0x24

	req = list_entry(ep->queue.next, struct s3c_request, queue);

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
3481a544:	e0840305 	add	r0, r4, r5, lsl #6
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a548:	e5900084 	ldr	r0, [r0, #132]	; 0x84
3481a54c:	e06ac002 	rsb	ip, sl, r2
3481a550:	e15c0000 	cmp	ip, r0
3481a554:	908aa00c 	addls	sl, sl, ip
3481a558:	808aa000 	addhi	sl, sl, r0
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
3481a55c:	e3550000 	cmp	r5, #0

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a560:	e503a004 	str	sl, [r3, #-4]
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
3481a564:	1a000018 	bne	3481a5cc <usb_gadget_handle_interrupts+0x2a0>
		if (dev->ep0state == DATA_STATE_XMIT) {
3481a568:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a56c:	e3530001 	cmp	r3, #1
3481a570:	1a000005 	bne	3481a58c <usb_gadget_handle_interrupts+0x260>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, ep0stat =="
				"DATA_STATE_XMIT\n",
				__func__, ep_num);
			last = write_fifo_ep0(ep, req);
3481a574:	e1a00006 	mov	r0, r6
3481a578:	ebfffc31 	bl	34819644 <write_fifo_ep0>
			if (last)
3481a57c:	e3500000 	cmp	r0, #0
				dev->ep0state = WAIT_FOR_COMPLETE;
3481a580:	13a00005 	movne	r0, #5
3481a584:	15840054 	strne	r0, [r4, #84]	; 0x54
3481a588:	ea00001e 	b	3481a608 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
3481a58c:	e3530007 	cmp	r3, #7
3481a590:	1a000004 	bne	3481a5a8 <usb_gadget_handle_interrupts+0x27c>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
3481a594:	e1a00006 	mov	r0, r6
3481a598:	e1a02005 	mov	r2, r5
3481a59c:	ebfffa41 	bl	34818ea8 <done>
			dev->ep0state = WAIT_FOR_SETUP;
3481a5a0:	e5845054 	str	r5, [r4, #84]	; 0x54
3481a5a4:	ea000017 	b	3481a608 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
3481a5a8:	e3530005 	cmp	r3, #5
3481a5ac:	1a000015 	bne	3481a608 <usb_gadget_handle_interrupts+0x2dc>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
3481a5b0:	e1a00006 	mov	r0, r6
3481a5b4:	e1a02005 	mov	r2, r5
3481a5b8:	ebfffa3a 	bl	34818ea8 <done>
			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
3481a5bc:	e3a03006 	mov	r3, #6
3481a5c0:	e5843054 	str	r3, [r4, #84]	; 0x54
			s3c_ep0_complete_out();
3481a5c4:	ebfffa85 	bl	34818fe0 <s3c_ep0_complete_out>
3481a5c8:	ea00000e 	b	3481a608 <usb_gadget_handle_interrupts+0x2dc>
				__func__, ep_num);
		}
		return;
	}

	if (req->req.actual == req->req.length)
3481a5cc:	e15a0002 	cmp	sl, r2
3481a5d0:	1a000002 	bne	3481a5e0 <usb_gadget_handle_interrupts+0x2b4>
		done(ep, req, 0);
3481a5d4:	e1a00006 	mov	r0, r6
3481a5d8:	e3a02000 	mov	r2, #0
3481a5dc:	ebfffa31 	bl	34818ea8 <done>
3481a5e0:	e0843305 	add	r3, r4, r5, lsl #6
3481a5e4:	e5931078 	ldr	r1, [r3, #120]	; 0x78

	if (!list_empty(&ep->queue)) {
3481a5e8:	e151000b 	cmp	r1, fp
3481a5ec:	0a000023 	beq	3481a680 <usb_gadget_handle_interrupts+0x354>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request start...\n", __func__);
		setdma_tx(ep, req);
3481a5f0:	e1a00006 	mov	r0, r6
3481a5f4:	e2411028 	sub	r1, r1, #40	; 0x28
3481a5f8:	ebfffbc6 	bl	34819518 <setdma_tx>
3481a5fc:	ea00001f 	b	3481a680 <usb_gadget_handle_interrupts+0x354>
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);

			if (ep_intr_status & TRANSFER_DONE) {
				complete_tx(dev, ep_num);

				if (ep_num == 0) {
3481a600:	e3550000 	cmp	r5, #0
3481a604:	1a00001d 	bne	3481a680 <usb_gadget_handle_interrupts+0x354>
					if (dev->ep0state ==
3481a608:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a60c:	e3530007 	cmp	r3, #7
					    WAIT_FOR_IN_COMPLETE)
						dev->ep0state = WAIT_FOR_SETUP;
3481a610:	03a0a000 	moveq	sl, #0
3481a614:	0584a054 	streq	sl, [r4, #84]	; 0x54

					if (dev->ep0state == WAIT_FOR_SETUP)
3481a618:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a61c:	e3530000 	cmp	r3, #0
3481a620:	1a000000 	bne	3481a628 <usb_gadget_handle_interrupts+0x2fc>
						s3c_udc_pre_setup();
3481a624:	ebfffb9c 	bl	3481949c <s3c_udc_pre_setup>

					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
3481a628:	e5973020 	ldr	r3, [r7, #32]
3481a62c:	e3530001 	cmp	r3, #1
3481a630:	1a000012 	bne	3481a680 <usb_gadget_handle_interrupts+0x354>
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a634:	e5d7001c 	ldrb	r0, [r7, #28]
3481a638:	e1a00300 	lsl	r0, r0, #6
3481a63c:	e0843000 	add	r3, r4, r0
3481a640:	e5931078 	ldr	r1, [r3, #120]	; 0x78
	struct s3c_request *req;

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
3481a644:	e2802078 	add	r2, r0, #120	; 0x78
3481a648:	e0842002 	add	r2, r4, r2
3481a64c:	e1510002 	cmp	r1, r2
3481a650:	0a000008 	beq	3481a678 <usb_gadget_handle_interrupts+0x34c>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a654:	e1d338dd 	ldrsb	r3, [r3, #141]	; 0x8d
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a658:	e2800058 	add	r0, r0, #88	; 0x58
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a65c:	e3530000 	cmp	r3, #0
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a660:	e0840000 	add	r0, r4, r0

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
3481a664:	e2411028 	sub	r1, r1, #40	; 0x28
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a668:	aa000001 	bge	3481a674 <usb_gadget_handle_interrupts+0x348>
			setdma_tx(ep, req);
3481a66c:	ebfffba9 	bl	34819518 <setdma_tx>
3481a670:	ea000000 	b	3481a678 <usb_gadget_handle_interrupts+0x34c>
		else
			setdma_rx(ep, req);
3481a674:	ebfffa6b 	bl	34819028 <setdma_rx>
					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
						s3c_udc_check_tx_queue(dev,
							clear_feature_num);
						clear_feature_flag = 0;
3481a678:	e3a00000 	mov	r0, #0
3481a67c:	e5870020 	str	r0, [r7, #32]
					}
				}
			}
		}
		ep_num++;
3481a680:	e2855001 	add	r5, r5, #1
3481a684:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
3481a688:	e1a090a9 	lsr	r9, r9, #1
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;

	while (ep_intr) {
3481a68c:	e3590000 	cmp	r9, #0
3481a690:	1affff8c 	bne	3481a4c8 <usb_gadget_handle_interrupts+0x19c>
3481a694:	e59d6004 	ldr	r6, [sp, #4]
	}

	if (intr_status & INT_IN_EP)
		process_ep_in_intr(dev);

	if (intr_status & INT_OUT_EP)
3481a698:	e3160702 	tst	r6, #524288	; 0x80000
3481a69c:	0a00002f 	beq	3481a760 <usb_gadget_handle_interrupts+0x434>
static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
3481a6a0:	e59fa0c4 	ldr	sl, [pc, #196]	; 3481a76c <usb_gadget_handle_interrupts+0x440>
3481a6a4:	e59a3000 	ldr	r3, [sl]
3481a6a8:	e5936818 	ldr	r6, [r3, #2072]	; 0x818
}

static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
3481a6ac:	e3a05000 	mov	r5, #0
	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_OUT_EP != 0,
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
3481a6b0:	e1a06826 	lsr	r6, r6, #16
3481a6b4:	ea000027 	b	3481a758 <usb_gadget_handle_interrupts+0x42c>

	while (ep_intr) {
		if (ep_intr & 0x1) {
3481a6b8:	e3160001 	tst	r6, #1
3481a6bc:	0a000022 	beq	3481a74c <usb_gadget_handle_interrupts+0x420>
			ep_intr_status = readl(&reg->out_endp[ep_num].doepint);
3481a6c0:	e59a2000 	ldr	r2, [sl]
3481a6c4:	e1a03285 	lsl	r3, r5, #5
3481a6c8:	e0822003 	add	r2, r2, r3
3481a6cc:	e5927b08 	ldr	r7, [r2, #2824]	; 0xb08
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
3481a6d0:	e2833c0b 	add	r3, r3, #2816	; 0xb00
3481a6d4:	e59a2000 	ldr	r2, [sl]
3481a6d8:	e2833008 	add	r3, r3, #8

			if (ep_num == 0) {
3481a6dc:	e3550000 	cmp	r5, #0
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
3481a6e0:	e7827003 	str	r7, [r2, r3]
3481a6e4:	e2073001 	and	r3, r7, #1

			if (ep_num == 0) {
3481a6e8:	1a000012 	bne	3481a738 <usb_gadget_handle_interrupts+0x40c>
				if (ep_intr_status & TRANSFER_DONE) {
3481a6ec:	e3530000 	cmp	r3, #0
3481a6f0:	0a000008 	beq	3481a718 <usb_gadget_handle_interrupts+0x3ec>
					if (dev->ep0state !=
3481a6f4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a6f8:	e3530006 	cmp	r3, #6
3481a6fc:	0a000003 	beq	3481a710 <usb_gadget_handle_interrupts+0x3e4>
					    WAIT_FOR_OUT_COMPLETE)
						complete_rx(dev, ep_num);
3481a700:	e1a00004 	mov	r0, r4
3481a704:	e1a01005 	mov	r1, r5
3481a708:	ebfffaa1 	bl	34819194 <complete_rx>
3481a70c:	ea000001 	b	3481a718 <usb_gadget_handle_interrupts+0x3ec>
					else {
						dev->ep0state = WAIT_FOR_SETUP;
3481a710:	e5845054 	str	r5, [r4, #84]	; 0x54
						s3c_udc_pre_setup();
3481a714:	ebfffb60 	bl	3481949c <s3c_udc_pre_setup>
					}
				}

				if (ep_intr_status &
3481a718:	e3170008 	tst	r7, #8
3481a71c:	0a00000a 	beq	3481a74c <usb_gadget_handle_interrupts+0x420>
/*
 * handle ep0 interrupt
 */
static void s3c_handle_ep0(struct s3c_udc *dev)
{
	if (dev->ep0state == WAIT_FOR_SETUP) {
3481a720:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a724:	e3530000 	cmp	r3, #0
3481a728:	1a000007 	bne	3481a74c <usb_gadget_handle_interrupts+0x420>
		debug_cond(DEBUG_OUT_EP != 0,
			   "%s: WAIT_FOR_SETUP\n", __func__);
		s3c_ep0_setup(dev);
3481a72c:	e1a00004 	mov	r0, r4
3481a730:	ebfffd8f 	bl	34819d74 <s3c_ep0_setup>
3481a734:	ea000004 	b	3481a74c <usb_gadget_handle_interrupts+0x420>
					debug_cond(DEBUG_OUT_EP != 0,
						   "SETUP packet arrived\n");
					s3c_handle_ep0(dev);
				}
			} else {
				if (ep_intr_status & TRANSFER_DONE)
3481a738:	e3530000 	cmp	r3, #0
3481a73c:	0a000002 	beq	3481a74c <usb_gadget_handle_interrupts+0x420>
					complete_rx(dev, ep_num);
3481a740:	e1a00004 	mov	r0, r4
3481a744:	e1a01005 	mov	r1, r5
3481a748:	ebfffa91 	bl	34819194 <complete_rx>
			}
		}
		ep_num++;
3481a74c:	e2855001 	add	r5, r5, #1
3481a750:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
3481a754:	e1a060a6 	lsr	r6, r6, #1
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;

	while (ep_intr) {
3481a758:	e3560000 	cmp	r6, #0
3481a75c:	1affffd5 	bne	3481a6b8 <usb_gadget_handle_interrupts+0x38c>
3481a760:	e3a00001 	mov	r0, #1
	return 0;
}
3481a764:	e28dd010 	add	sp, sp, #16
3481a768:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a76c:	3482bb78 	.word	0x3482bb78
3481a770:	34829268 	.word	0x34829268

3481a774 <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481a774:	e1a03000 	mov	r3, r0
    int i;
    uint16_t cksum;

    cksum = 0;
3481a778:	e3a00000 	mov	r0, #0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481a77c:	e92d4010 	push	{r4, lr}
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a780:	e1a02000 	mov	r2, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a784:	e59fc028 	ldr	ip, [pc, #40]	; 3481a7b4 <cyg_crc16+0x40>
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a788:	ea000006 	b	3481a7a8 <cyg_crc16+0x34>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a78c:	e7d34002 	ldrb	r4, [r3, r2]
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a790:	e2822001 	add	r2, r2, #1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a794:	e0244420 	eor	r4, r4, r0, lsr #8
3481a798:	e1a04084 	lsl	r4, r4, #1
3481a79c:	e19c40b4 	ldrh	r4, [ip, r4]
3481a7a0:	e0240400 	eor	r0, r4, r0, lsl #8
3481a7a4:	e6ff0070 	uxth	r0, r0
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a7a8:	e1520001 	cmp	r2, r1
3481a7ac:	bafffff6 	blt	3481a78c <cyg_crc16+0x18>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
    }
    return cksum;
}
3481a7b0:	e8bd8010 	pop	{r4, pc}
3481a7b4:	348215f4 	.word	0x348215f4

3481a7b8 <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481a7b8:	e211c003 	ands	ip, r1, #3
3481a7bc:	13a0c001 	movne	ip, #1
3481a7c0:	e3520000 	cmp	r2, #0
3481a7c4:	03a0c000 	moveq	ip, #0
3481a7c8:	120cc001 	andne	ip, ip, #1
3481a7cc:	e35c0000 	cmp	ip, #0

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
3481a7d0:	e92d4070 	push	{r4, r5, r6, lr}
    const uint32_t *tab = crc_table;
    const uint32_t *b =(const uint32_t *)buf;
3481a7d4:	e1a03001 	mov	r3, r1
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481a7d8:	0a00000a 	beq	3481a808 <crc32_no_comp+0x50>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481a7dc:	e59f30b8 	ldr	r3, [pc, #184]	; 3481a89c <crc32_no_comp+0xe4>
3481a7e0:	e4d1c001 	ldrb	ip, [r1], #1
	 } while ((--len) && ((long)p)&3);
3481a7e4:	e2522001 	subs	r2, r2, #1
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481a7e8:	e020c00c 	eor	ip, r0, ip
3481a7ec:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481a7f0:	e793c10c 	ldr	ip, [r3, ip, lsl #2]
3481a7f4:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
3481a7f8:	0a000001 	beq	3481a804 <crc32_no_comp+0x4c>
3481a7fc:	e3110003 	tst	r1, #3
3481a800:	1afffff6 	bne	3481a7e0 <crc32_no_comp+0x28>
	 b = (uint32_t *)p;
3481a804:	e1a03001 	mov	r3, r1
    }

    rem_len = len & 3;
3481a808:	e2025003 	and	r5, r2, #3
    len = len >> 2;
3481a80c:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
3481a810:	e2431004 	sub	r1, r3, #4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
3481a814:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
3481a818:	e59fc07c 	ldr	ip, [pc, #124]	; 3481a89c <crc32_no_comp+0xe4>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a81c:	ea00000e 	b	3481a85c <crc32_no_comp+0xa4>
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481a820:	e4936004 	ldr	r6, [r3], #4
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a824:	e2444001 	sub	r4, r4, #1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481a828:	e0200006 	eor	r0, r0, r6
	 DO_CRC(0);
3481a82c:	e20060ff 	and	r6, r0, #255	; 0xff
3481a830:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a834:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a838:	e20060ff 	and	r6, r0, #255	; 0xff
3481a83c:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a840:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a844:	e20060ff 	and	r6, r0, #255	; 0xff
3481a848:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a84c:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a850:	e20060ff 	and	r6, r0, #255	; 0xff
3481a854:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a858:	e0260420 	eor	r0, r6, r0, lsr #8
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a85c:	e3540000 	cmp	r4, #0
3481a860:	1affffee 	bne	3481a820 <crc32_no_comp+0x68>
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481a864:	e3550000 	cmp	r5, #0
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a868:	e0812102 	add	r2, r1, r2, lsl #2
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481a86c:	08bd8070 	popeq	{r4, r5, r6, pc}
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a870:	e59f1024 	ldr	r1, [pc, #36]	; 3481a89c <crc32_no_comp+0xe4>
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
3481a874:	e2822003 	add	r2, r2, #3
3481a878:	e1a03005 	mov	r3, r5
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a87c:	e5f2c001 	ldrb	ip, [r2, #1]!
	 } while (--len);
3481a880:	e2533001 	subs	r3, r3, #1
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a884:	e020c00c 	eor	ip, r0, ip
3481a888:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481a88c:	e791c10c 	ldr	ip, [r1, ip, lsl #2]
3481a890:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while (--len);
3481a894:	1afffff8 	bne	3481a87c <crc32_no_comp+0xc4>
    }

    return le32_to_cpu(crc);
}
3481a898:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a89c:	348217f4 	.word	0x348217f4

3481a8a0 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
3481a8a0:	e92d4008 	push	{r3, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
3481a8a4:	e1e00000 	mvn	r0, r0
3481a8a8:	ebffffc2 	bl	3481a7b8 <crc32_no_comp>
}
3481a8ac:	e1e00000 	mvn	r0, r0
3481a8b0:	e8bd8008 	pop	{r3, pc}

3481a8b4 <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
3481a8b4:	eafffff9 	b	3481a8a0 <crc32>

3481a8b8 <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
3481a8b8:	e59f301c 	ldr	r3, [pc, #28]	; 3481a8dc <crc7+0x24>
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481a8bc:	ea000003 	b	3481a8d0 <crc7+0x18>
		crc = crc7_byte(crc, *buffer++);
3481a8c0:	e4d1c001 	ldrb	ip, [r1], #1
3481a8c4:	e2422001 	sub	r2, r2, #1
3481a8c8:	e02c0080 	eor	r0, ip, r0, lsl #1
3481a8cc:	e7d30000 	ldrb	r0, [r3, r0]
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481a8d0:	e3520000 	cmp	r2, #0
3481a8d4:	1afffff9 	bne	3481a8c0 <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
3481a8d8:	e12fff1e 	bx	lr
3481a8dc:	34821bf4 	.word	0x34821bf4

3481a8e0 <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
3481a8e0:	e92d4008 	push	{r3, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
3481a8e4:	e59f100c 	ldr	r1, [pc, #12]	; 3481a8f8 <display_options+0x18>
3481a8e8:	e59f000c 	ldr	r0, [pc, #12]	; 3481a8fc <display_options+0x1c>
3481a8ec:	ebffbc75 	bl	34809ac8 <printf>
#endif
	return 0;
}
3481a8f0:	e3a00000 	mov	r0, #0
3481a8f4:	e8bd8008 	pop	{r3, pc}
3481a8f8:	34820260 	.word	0x34820260
3481a8fc:	348228b5 	.word	0x348228b5

3481a900 <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
3481a900:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3481a904:	e1a04000 	mov	r4, r0
3481a908:	e1a05001 	mov	r5, r1
3481a90c:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481a910:	e3a0a000 	mov	sl, #0
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
	unsigned long long f;
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
3481a914:	e3a0603c 	mov	r6, #60	; 0x3c
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
		if (size >> d) {
3481a918:	e1a00004 	mov	r0, r4
3481a91c:	e1a01005 	mov	r1, r5
3481a920:	e1a02006 	mov	r2, r6
3481a924:	eb0015ba 	bl	34820014 <__lshrdi3>
3481a928:	e1901001 	orrs	r1, r0, r1
3481a92c:	0a000004 	beq	3481a944 <print_size+0x44>
			c = names[i];
3481a930:	e59f30e0 	ldr	r3, [pc, #224]	; 3481aa18 <print_size+0x118>
3481a934:	e7d3a00a 	ldrb	sl, [r3, sl]
			break;
		}
	}

	if (!c) {
3481a938:	e35a0000 	cmp	sl, #0
3481a93c:	1a00000b 	bne	3481a970 <print_size+0x70>
3481a940:	ea000003 	b	3481a954 <print_size+0x54>
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481a944:	e28aa001 	add	sl, sl, #1
3481a948:	e35a0006 	cmp	sl, #6
3481a94c:	1246600a 	subne	r6, r6, #10
3481a950:	1afffff0 	bne	3481a918 <print_size+0x18>
			break;
		}
	}

	if (!c) {
		printf("%llu Bytes%s", size, s);
3481a954:	e1a02004 	mov	r2, r4
3481a958:	e1a03005 	mov	r3, r5
3481a95c:	e59f00b8 	ldr	r0, [pc, #184]	; 3481aa1c <print_size+0x11c>
3481a960:	e58d9000 	str	r9, [sp]
3481a964:	ebffbc57 	bl	34809ac8 <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
3481a968:	e28dd00c 	add	sp, sp, #12
3481a96c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
	f = size & ((1ULL << d) - 1);
3481a970:	e1a02006 	mov	r2, r6
	if (!c) {
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
3481a974:	e1a07000 	mov	r7, r0
	f = size & ((1ULL << d) - 1);
3481a978:	e3a01000 	mov	r1, #0
3481a97c:	e3a00001 	mov	r0, #1
3481a980:	eb0015b1 	bl	3482004c <__ashldi3>
3481a984:	e3e02000 	mvn	r2, #0
3481a988:	e0922000 	adds	r2, r2, r0
3481a98c:	e3e03000 	mvn	r3, #0
3481a990:	e0a33001 	adc	r3, r3, r1
3481a994:	e0022004 	and	r2, r2, r4
3481a998:	e0033005 	and	r3, r3, r5

	/* If there's a remainder, deal with it */
	if (f) {
3481a99c:	e1924003 	orrs	r4, r2, r3
3481a9a0:	0a00000e 	beq	3481a9e0 <print_size+0xe0>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481a9a4:	e3a0100a 	mov	r1, #10
3481a9a8:	e0854192 	umull	r4, r5, r2, r1
3481a9ac:	e3a00001 	mov	r0, #1
3481a9b0:	e0255391 	mla	r5, r1, r3, r5
3481a9b4:	e2462001 	sub	r2, r6, #1
3481a9b8:	e3a01000 	mov	r1, #0
3481a9bc:	eb0015a2 	bl	3482004c <__ashldi3>
3481a9c0:	e0900004 	adds	r0, r0, r4
3481a9c4:	e0a11005 	adc	r1, r1, r5
3481a9c8:	e1a02006 	mov	r2, r6
3481a9cc:	eb001590 	bl	34820014 <__lshrdi3>

		if (m >= 10) {
3481a9d0:	e3500009 	cmp	r0, #9
	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481a9d4:	e1a04000 	mov	r4, r0

		if (m >= 10) {
			m -= 10;
			n += 1;
3481a9d8:	82877001 	addhi	r7, r7, #1
	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;

		if (m >= 10) {
			m -= 10;
3481a9dc:	8240400a 	subhi	r4, r0, #10
			n += 1;
		}
	}

	printf ("%lu", n);
3481a9e0:	e59f0038 	ldr	r0, [pc, #56]	; 3481aa20 <print_size+0x120>
3481a9e4:	e1a01007 	mov	r1, r7
3481a9e8:	ebffbc36 	bl	34809ac8 <printf>
	if (m) {
3481a9ec:	e3540000 	cmp	r4, #0
3481a9f0:	0a000002 	beq	3481aa00 <print_size+0x100>
		printf (".%ld", m);
3481a9f4:	e59f0028 	ldr	r0, [pc, #40]	; 3481aa24 <print_size+0x124>
3481a9f8:	e1a01004 	mov	r1, r4
3481a9fc:	ebffbc31 	bl	34809ac8 <printf>
	}
	printf (" %ciB%s", c, s);
3481aa00:	e59f0020 	ldr	r0, [pc, #32]	; 3481aa28 <print_size+0x128>
3481aa04:	e1a0100a 	mov	r1, sl
3481aa08:	e1a02009 	mov	r2, r9
}
3481aa0c:	e28dd00c 	add	sp, sp, #12
3481aa10:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
3481aa14:	eaffbc2b 	b	34809ac8 <printf>
3481aa18:	34821df4 	.word	0x34821df4
3481aa1c:	34827e10 	.word	0x34827e10
3481aa20:	34827e1d 	.word	0x34827e1d
3481aa24:	34827e21 	.word	0x34827e21
3481aa28:	34827e26 	.word	0x34827e26

3481aa2c <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481aa2c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481aa30:	e24dd050 	sub	sp, sp, #80	; 0x50
3481aa34:	e59d5070 	ldr	r5, [sp, #112]	; 0x70
3481aa38:	e1a07003 	mov	r7, r3
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481aa3c:	e0030592 	mul	r3, r2, r5
3481aa40:	e3530040 	cmp	r3, #64	; 0x40
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481aa44:	e1a0b000 	mov	fp, r0
3481aa48:	e1a09001 	mov	r9, r1
3481aa4c:	e1a04002 	mov	r4, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481aa50:	9a000003 	bls	3481aa64 <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
3481aa54:	e3a00040 	mov	r0, #64	; 0x40
3481aa58:	e1a01002 	mov	r1, r2
3481aa5c:	eb001459 	bl	3481fbc8 <__udivsi3>
3481aa60:	e1a05000 	mov	r5, r0
	if (linelen < 1)
3481aa64:	e3550000 	cmp	r5, #0
3481aa68:	1a00003c 	bne	3481ab60 <print_buffer+0x134>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
3481aa6c:	e3a00010 	mov	r0, #16
3481aa70:	e1a01004 	mov	r1, r4
3481aa74:	eb001453 	bl	3481fbc8 <__udivsi3>
3481aa78:	e1a05000 	mov	r5, r0
3481aa7c:	ea000037 	b	3481ab60 <print_buffer+0x134>

	while (count) {
		printf("%08lx:", addr);
3481aa80:	e59f00fc 	ldr	r0, [pc, #252]	; 3481ab84 <print_buffer+0x158>
3481aa84:	e1a0100b 	mov	r1, fp
3481aa88:	ebffbc0e 	bl	34809ac8 <printf>
3481aa8c:	e1550007 	cmp	r5, r7
3481aa90:	21a05007 	movcs	r5, r7
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481aa94:	e1a0a009 	mov	sl, r9
3481aa98:	e3a06000 	mov	r6, #0
3481aa9c:	ea000010 	b	3481aae4 <print_buffer+0xb8>
			uint32_t x;
			if (width == 4)
3481aaa0:	e3540004 	cmp	r4, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
3481aaa4:	059a2000 	ldreq	r2, [sl]
3481aaa8:	028d300c 	addeq	r3, sp, #12
3481aaac:	07832106 	streq	r2, [r3, r6, lsl #2]
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
3481aab0:	0a000006 	beq	3481aad0 <print_buffer+0xa4>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
3481aab4:	e3540002 	cmp	r4, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
3481aab8:	01da20b0 	ldrheq	r2, [sl]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481aabc:	15da2000 	ldrbne	r2, [sl]
3481aac0:	e28d300c 	add	r3, sp, #12
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481aac4:	01a01086 	lsleq	r1, r6, #1
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
3481aac8:	018320b1 	strheq	r2, [r3, r1]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481aacc:	17c32006 	strbne	r2, [r3, r6]
			printf(" %0*x", width * 2, x);
3481aad0:	e59f00b0 	ldr	r0, [pc, #176]	; 3481ab88 <print_buffer+0x15c>
3481aad4:	e59d1004 	ldr	r1, [sp, #4]
3481aad8:	ebffbbfa 	bl	34809ac8 <printf>
			data += width;
3481aadc:	e08aa004 	add	sl, sl, r4
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481aae0:	e2866001 	add	r6, r6, #1
3481aae4:	e1560005 	cmp	r6, r5
3481aae8:	3affffec 	bcc	3481aaa0 <print_buffer+0x74>
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481aaec:	e0060594 	mul	r6, r4, r5
3481aaf0:	e28d300c 	add	r3, sp, #12
3481aaf4:	e0899006 	add	r9, r9, r6
3481aaf8:	e0861003 	add	r1, r6, r3
3481aafc:	ea000008 	b	3481ab24 <print_buffer+0xf8>
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
3481ab00:	e4d32001 	ldrb	r2, [r3], #1
3481ab04:	e59fc080 	ldr	ip, [pc, #128]	; 3481ab8c <print_buffer+0x160>
3481ab08:	e7dc0002 	ldrb	r0, [ip, r2]
3481ab0c:	e3100097 	tst	r0, #151	; 0x97
3481ab10:	0a000001 	beq	3481ab1c <print_buffer+0xf0>
3481ab14:	e3120080 	tst	r2, #128	; 0x80
3481ab18:	0a000001 	beq	3481ab24 <print_buffer+0xf8>
				lb.uc[i] = '.';
3481ab1c:	e3a0202e 	mov	r2, #46	; 0x2e
3481ab20:	e5432001 	strb	r2, [r3, #-1]
			printf(" %0*x", width * 2, x);
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
3481ab24:	e1530001 	cmp	r3, r1
3481ab28:	1afffff4 	bne	3481ab00 <print_buffer+0xd4>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
				lb.uc[i] = '.';
		}
		lb.uc[i] = '\0';
3481ab2c:	e28dc050 	add	ip, sp, #80	; 0x50
3481ab30:	e08c3006 	add	r3, ip, r6
3481ab34:	e3a02000 	mov	r2, #0
3481ab38:	e5432044 	strb	r2, [r3, #-68]	; 0x44
		printf("    %s\n", lb.uc);
3481ab3c:	e28d100c 	add	r1, sp, #12
3481ab40:	e59f0048 	ldr	r0, [pc, #72]	; 3481ab90 <print_buffer+0x164>
3481ab44:	ebffbbdf 	bl	34809ac8 <printf>

		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
3481ab48:	ebffbc03 	bl	34809b5c <ctrlc>
3481ab4c:	e3500000 	cmp	r0, #0
3481ab50:	1a000008 	bne	3481ab78 <print_buffer+0x14c>
		}
		lb.uc[i] = '\0';
		printf("    %s\n", lb.uc);

		/* update references */
		addr += linelen * width;
3481ab54:	e08bb006 	add	fp, fp, r6
		count -= linelen;
3481ab58:	e0657007 	rsb	r7, r5, r7
3481ab5c:	ea000001 	b	3481ab68 <print_buffer+0x13c>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
			printf(" %0*x", width * 2, x);
3481ab60:	e1a03084 	lsl	r3, r4, #1
3481ab64:	e58d3004 	str	r3, [sp, #4]
	if (linelen*width > MAX_LINE_LENGTH_BYTES)
		linelen = MAX_LINE_LENGTH_BYTES / width;
	if (linelen < 1)
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;

	while (count) {
3481ab68:	e3570000 	cmp	r7, #0
3481ab6c:	1affffc3 	bne	3481aa80 <print_buffer+0x54>

		if (ctrlc())
			return -1;
	}

	return 0;
3481ab70:	e1a00007 	mov	r0, r7
3481ab74:	ea000000 	b	3481ab7c <print_buffer+0x150>
		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
			return -1;
3481ab78:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
3481ab7c:	e28dd050 	add	sp, sp, #80	; 0x50
3481ab80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ab84:	34823dc8 	.word	0x34823dc8
3481ab88:	34827e2e 	.word	0x34827e2e
3481ab8c:	34821cf4 	.word	0x34821cf4
3481ab90:	34827e34 	.word	0x34827e34

3481ab94 <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481ab94:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
3481ab98:	e1c060d0 	ldrd	r6, [r0]
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481ab9c:	e1510007 	cmp	r1, r7
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481aba0:	e1a09000 	mov	r9, r0
3481aba4:	e1a0a001 	mov	sl, r1
	uint64_t rem = *n;
	uint64_t b = base;
3481aba8:	e1a04001 	mov	r4, r1
3481abac:	e3a05000 	mov	r5, #0
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481abb0:	8a000009 	bhi	3481abdc <__div64_32+0x48>
		high /= base;
3481abb4:	e1a00007 	mov	r0, r7
3481abb8:	eb001402 	bl	3481fbc8 <__udivsi3>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
3481abbc:	e003009a 	mul	r3, sl, r0

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481abc0:	e3a0c000 	mov	ip, #0
		rem -= (uint64_t) (high*base) << 32;
3481abc4:	e1a0200c 	mov	r2, ip

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481abc8:	e58d0004 	str	r0, [sp, #4]
3481abcc:	e58dc000 	str	ip, [sp]
		rem -= (uint64_t) (high*base) << 32;
3481abd0:	e0566002 	subs	r6, r6, r2
3481abd4:	e0c77003 	sbc	r7, r7, r3
3481abd8:	ea000002 	b	3481abe8 <__div64_32+0x54>
	uint64_t b = base;
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
3481abdc:	e3a02000 	mov	r2, #0
3481abe0:	e3a03000 	mov	r3, #0
3481abe4:	e1cd20f0 	strd	r2, [sp]
3481abe8:	e3a00001 	mov	r0, #1
3481abec:	e3a01000 	mov	r1, #0
3481abf0:	ea000003 	b	3481ac04 <__div64_32+0x70>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
		b = b+b;
3481abf4:	e0944004 	adds	r4, r4, r4
3481abf8:	e0a55005 	adc	r5, r5, r5
		d = d+d;
3481abfc:	e0900000 	adds	r0, r0, r0
3481ac00:	e0a11001 	adc	r1, r1, r1
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
3481ac04:	e1a0afc5 	asr	sl, r5, #31
3481ac08:	e1a0200a 	mov	r2, sl
3481ac0c:	e1a0300a 	mov	r3, sl
3481ac10:	e0522004 	subs	r2, r2, r4
3481ac14:	e0c33005 	sbc	r3, r3, r5
3481ac18:	e1570005 	cmp	r7, r5
3481ac1c:	e1a02fa3 	lsr	r2, r3, #31
3481ac20:	e1a0b00a 	mov	fp, sl
3481ac24:	e3a03001 	mov	r3, #1
3481ac28:	8a000003 	bhi	3481ac3c <__div64_32+0xa8>
3481ac2c:	1a000001 	bne	3481ac38 <__div64_32+0xa4>
3481ac30:	e1560004 	cmp	r6, r4
3481ac34:	8a000000 	bhi	3481ac3c <__div64_32+0xa8>
3481ac38:	e3a03000 	mov	r3, #0
3481ac3c:	e1120003 	tst	r2, r3
3481ac40:	1affffeb 	bne	3481abf4 <__div64_32+0x60>
3481ac44:	e1cd20d0 	ldrd	r2, [sp]
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
3481ac48:	e1550007 	cmp	r5, r7
3481ac4c:	8a000006 	bhi	3481ac6c <__div64_32+0xd8>
3481ac50:	1a000001 	bne	3481ac5c <__div64_32+0xc8>
3481ac54:	e1540006 	cmp	r4, r6
3481ac58:	8a000003 	bhi	3481ac6c <__div64_32+0xd8>
			rem -= b;
3481ac5c:	e0566004 	subs	r6, r6, r4
3481ac60:	e0c77005 	sbc	r7, r7, r5
			res += d;
3481ac64:	e0922000 	adds	r2, r2, r0
3481ac68:	e0a33001 	adc	r3, r3, r1
		}
		b >>= 1;
		d >>= 1;
3481ac6c:	e1b010a1 	lsrs	r1, r1, #1
3481ac70:	e1a00060 	rrx	r0, r0
	} while (d);
3481ac74:	e190c001 	orrs	ip, r0, r1
3481ac78:	0a000002 	beq	3481ac88 <__div64_32+0xf4>
	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
3481ac7c:	e1b050a5 	lsrs	r5, r5, #1
3481ac80:	e1a04064 	rrx	r4, r4
3481ac84:	eaffffef 	b	3481ac48 <__div64_32+0xb4>
		d >>= 1;
	} while (d);

	*n = res;
3481ac88:	e1c920f0 	strd	r2, [r9]
	return rem;
}
3481ac8c:	e1a00006 	mov	r0, r6
3481ac90:	e28dd010 	add	sp, sp, #16
3481ac94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481ac98 <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
3481ac98:	e1a00001 	mov	r0, r1
3481ac9c:	eaffbcc7 	b	34809fc0 <free>

3481aca0 <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
3481aca0:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
3481aca4:	e282000f 	add	r0, r2, #15

	p = malloc (size);
3481aca8:	e3c0000f 	bic	r0, r0, #15
3481acac:	eaffbd4c 	b	3480a1e4 <malloc>

3481acb0 <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481acb0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481acb4:	e1a04003 	mov	r4, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481acb8:	e59f30e4 	ldr	r3, [pc, #228]	; 3481ada4 <zunzip+0xf4>
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481acbc:	e24dd040 	sub	sp, sp, #64	; 0x40
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481acc0:	e58d3024 	str	r3, [sp, #36]	; 0x24
	s.zfree = gzfree;
3481acc4:	e59f30dc 	ldr	r3, [pc, #220]	; 3481ada8 <zunzip+0xf8>

	r = inflateInit2(&s, -MAX_WBITS);
3481acc8:	e28da004 	add	sl, sp, #4
{
	z_stream s;
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;
3481accc:	e58d3028 	str	r3, [sp, #40]	; 0x28
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481acd0:	e1a05000 	mov	r5, r0
3481acd4:	e1a07001 	mov	r7, r1
3481acd8:	e1a09002 	mov	r9, r2
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481acdc:	e3e0100e 	mvn	r1, #14
3481ace0:	e1a0000a 	mov	r0, sl
3481ace4:	e59f20c0 	ldr	r2, [pc, #192]	; 3481adac <zunzip+0xfc>
3481ace8:	e3a0303c 	mov	r3, #60	; 0x3c
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481acec:	e59db060 	ldr	fp, [sp, #96]	; 0x60
3481acf0:	e59d6064 	ldr	r6, [sp, #100]	; 0x64
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481acf4:	eb000cf1 	bl	3481e0c0 <inflateInit2_>
	if (r != Z_OK) {
3481acf8:	e2501000 	subs	r1, r0, #0
3481acfc:	0a000002 	beq	3481ad0c <zunzip+0x5c>
		printf ("Error: inflateInit2() returned %d\n", r);
3481ad00:	e59f00a8 	ldr	r0, [pc, #168]	; 3481adb0 <zunzip+0x100>
3481ad04:	ebffbb6f 	bl	34809ac8 <printf>
3481ad08:	ea000013 	b	3481ad5c <zunzip+0xac>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
3481ad0c:	e5943000 	ldr	r3, [r4]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481ad10:	e0899006 	add	r9, r9, r6
	s.avail_in = *lenp - offset;
3481ad14:	e0663003 	rsb	r3, r6, r3
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481ad18:	e58d9004 	str	r9, [sp, #4]
	s.avail_in = *lenp - offset;
3481ad1c:	e58d3008 	str	r3, [sp, #8]
	s.next_out = dst;
3481ad20:	e58d5010 	str	r5, [sp, #16]
	s.avail_out = dstlen;
3481ad24:	e58d7014 	str	r7, [sp, #20]
	do {
		r = inflate(&s, Z_FINISH);
3481ad28:	e3a01004 	mov	r1, #4
3481ad2c:	e1a0000a 	mov	r0, sl
3481ad30:	eb000dfd 	bl	3481e52c <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481ad34:	e3500001 	cmp	r0, #1
3481ad38:	13700005 	cmnne	r0, #5
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
	s.next_out = dst;
	s.avail_out = dstlen;
	do {
		r = inflate(&s, Z_FINISH);
3481ad3c:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481ad40:	0a000007 	beq	3481ad64 <zunzip+0xb4>
3481ad44:	e35b0001 	cmp	fp, #1
3481ad48:	1a000005 	bne	3481ad64 <zunzip+0xb4>
			printf("Error: inflate() returned %d\n", r);
3481ad4c:	e59f0060 	ldr	r0, [pc, #96]	; 3481adb4 <zunzip+0x104>
3481ad50:	ebffbb5c 	bl	34809ac8 <printf>
			inflateEnd(&s);
3481ad54:	e1a0000a 	mov	r0, sl
3481ad58:	eb000d1e 	bl	3481e1d8 <inflateEnd>
			return -1;
3481ad5c:	e3e00000 	mvn	r0, #0
3481ad60:	ea00000d 	b	3481ad9c <zunzip+0xec>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481ad64:	e59d3010 	ldr	r3, [sp, #16]
3481ad68:	e5942000 	ldr	r2, [r4]
3481ad6c:	e0630005 	rsb	r0, r3, r5
3481ad70:	e0802002 	add	r2, r0, r2
3481ad74:	e0662002 	rsb	r2, r6, r2
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
3481ad78:	e3710005 	cmn	r1, #5
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
			printf("Error: inflate() returned %d\n", r);
			inflateEnd(&s);
			return -1;
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481ad7c:	e58d2008 	str	r2, [sp, #8]
		s.avail_out = dstlen;
3481ad80:	e58d7014 	str	r7, [sp, #20]
	} while (r == Z_BUF_ERROR);
3481ad84:	0affffe7 	beq	3481ad28 <zunzip+0x78>
	*lenp = s.next_out - (unsigned char *) dst;
3481ad88:	e0655003 	rsb	r5, r5, r3
3481ad8c:	e5845000 	str	r5, [r4]
	inflateEnd(&s);
3481ad90:	e28d0004 	add	r0, sp, #4
3481ad94:	eb000d0f 	bl	3481e1d8 <inflateEnd>

	return 0;
3481ad98:	e3a00000 	mov	r0, #0
}
3481ad9c:	e28dd040 	add	sp, sp, #64	; 0x40
3481ada0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ada4:	3481aca0 	.word	0x3481aca0
3481ada8:	3481ac98 	.word	0x3481ac98
3481adac:	34827e3c 	.word	0x34827e3c
3481adb0:	34827e42 	.word	0x34827e42
3481adb4:	34827e65 	.word	0x34827e65

3481adb8 <gunzip>:
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481adb8:	e5d2c002 	ldrb	ip, [r2, #2]
{
	free (addr);
}

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
3481adbc:	e92d4013 	push	{r0, r1, r4, lr}
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481adc0:	e35c0008 	cmp	ip, #8
{
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
3481adc4:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481adc8:	1a000001 	bne	3481add4 <gunzip+0x1c>
3481adcc:	e31e00e0 	tst	lr, #224	; 0xe0
3481add0:	0a000001 	beq	3481addc <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
3481add4:	e59f0080 	ldr	r0, [pc, #128]	; 3481ae5c <gunzip+0xa4>
3481add8:	ea000017 	b	3481ae3c <gunzip+0x84>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
3481addc:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
3481ade0:	15d2c00a 	ldrbne	ip, [r2, #10]
3481ade4:	15d2400b 	ldrbne	r4, [r2, #11]
3481ade8:	128cc00c 	addne	ip, ip, #12
3481adec:	108cc404 	addne	ip, ip, r4, lsl #8
int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
	int i, flags;

	/* skip header */
	i = 10;
3481adf0:	03a0c00a 	moveq	ip, #10
		puts ("Error: Bad gzipped data\n");
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
3481adf4:	e31e0008 	tst	lr, #8
3481adf8:	0a000003 	beq	3481ae0c <gunzip+0x54>
		while (src[i++] != 0)
3481adfc:	e7d2400c 	ldrb	r4, [r2, ip]
3481ae00:	e28cc001 	add	ip, ip, #1
3481ae04:	e3540000 	cmp	r4, #0
3481ae08:	1afffffb 	bne	3481adfc <gunzip+0x44>
			;
	if ((flags & COMMENT) != 0)
3481ae0c:	e31e0010 	tst	lr, #16
3481ae10:	0a000003 	beq	3481ae24 <gunzip+0x6c>
		while (src[i++] != 0)
3481ae14:	e7d2400c 	ldrb	r4, [r2, ip]
3481ae18:	e28cc001 	add	ip, ip, #1
3481ae1c:	e3540000 	cmp	r4, #0
3481ae20:	1afffffb 	bne	3481ae14 <gunzip+0x5c>
			;
	if ((flags & HEAD_CRC) != 0)
3481ae24:	e31e0002 	tst	lr, #2
		i += 2;
	if (i >= *lenp) {
3481ae28:	e593e000 	ldr	lr, [r3]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
3481ae2c:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
3481ae30:	e15c000e 	cmp	ip, lr
3481ae34:	3a000003 	bcc	3481ae48 <gunzip+0x90>
		puts ("Error: gunzip out of data in header\n");
3481ae38:	e59f0020 	ldr	r0, [pc, #32]	; 3481ae60 <gunzip+0xa8>
3481ae3c:	ebffbb17 	bl	34809aa0 <puts>
		return (-1);
3481ae40:	e3e00000 	mvn	r0, #0
3481ae44:	ea000003 	b	3481ae58 <gunzip+0xa0>
	}

	return zunzip(dst, dstlen, src, lenp, 1, i);
3481ae48:	e3a0e001 	mov	lr, #1
3481ae4c:	e58de000 	str	lr, [sp]
3481ae50:	e58dc004 	str	ip, [sp, #4]
3481ae54:	ebffff95 	bl	3481acb0 <zunzip>
}
3481ae58:	e8bd801c 	pop	{r2, r3, r4, pc}
3481ae5c:	34827e83 	.word	0x34827e83
3481ae60:	34827e9c 	.word	0x34827e9c

3481ae64 <drop_var_from_set>:
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481ae64:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481ae68:	e251a000 	subs	sl, r1, #0
3481ae6c:	13a05000 	movne	r5, #0
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481ae70:	e1a04000 	mov	r4, r0
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481ae74:	11a07002 	movne	r7, r2
3481ae78:	11a06005 	movne	r6, r5
3481ae7c:	1a000009 	bne	3481aea8 <drop_var_from_set+0x44>
3481ae80:	ea00000b 	b	3481aeb4 <drop_var_from_set+0x50>
		return 1;

	for (i = 0; i < nvars; i++) {
		if (vars[i] == NULL)
3481ae84:	e4971004 	ldr	r1, [r7], #4
3481ae88:	e3510000 	cmp	r1, #0
3481ae8c:	0a000004 	beq	3481aea4 <drop_var_from_set+0x40>
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
3481ae90:	e1a00004 	mov	r0, r4
3481ae94:	eb00050b 	bl	3481c2c8 <strcmp>
3481ae98:	e3500000 	cmp	r0, #0
			vars[i] = NULL;
3481ae9c:	05070004 	streq	r0, [r7, #-4]
			res = 1;
3481aea0:	03a05001 	moveq	r5, #1

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;

	for (i = 0; i < nvars; i++) {
3481aea4:	e2866001 	add	r6, r6, #1
3481aea8:	e156000a 	cmp	r6, sl
3481aeac:	bafffff4 	blt	3481ae84 <drop_var_from_set+0x20>
3481aeb0:	ea000000 	b	3481aeb8 <drop_var_from_set+0x54>
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;
3481aeb4:	e3a05001 	mov	r5, #1
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
3481aeb8:	e1a00005 	mov	r0, r5
3481aebc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481aec0 <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
3481aec0:	e5902000 	ldr	r2, [r0]
3481aec4:	e5913000 	ldr	r3, [r1]
3481aec8:	e5920000 	ldr	r0, [r2]
3481aecc:	e5931000 	ldr	r1, [r3]
3481aed0:	ea0004fc 	b	3481c2c8 <strcmp>

3481aed4 <hcreate_r>:
 * The contents of the table is zeroed, especially the field used
 * becomes zero.
 */

int hcreate_r(size_t nel, struct hsearch_data *htab)
{
3481aed4:	e92d4070 	push	{r4, r5, r6, lr}
	/* Test for correct arguments.  */
	if (htab == NULL) {
3481aed8:	e2516000 	subs	r6, r1, #0
3481aedc:	1a000004 	bne	3481aef4 <hcreate_r+0x20>
		__set_errno(EINVAL);
3481aee0:	e59f3094 	ldr	r3, [pc, #148]	; 3481af7c <hcreate_r+0xa8>
3481aee4:	e3a02016 	mov	r2, #22
3481aee8:	e5832000 	str	r2, [r3]
		return 0;
3481aeec:	e1a00006 	mov	r0, r6
3481aef0:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481aef4:	e5963000 	ldr	r3, [r6]
3481aef8:	e3530000 	cmp	r3, #0
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
3481aefc:	03804001 	orreq	r4, r0, #1
		__set_errno(EINVAL);
		return 0;
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481af00:	1a00001b 	bne	3481af74 <hcreate_r+0xa0>
3481af04:	ea000000 	b	3481af0c <hcreate_r+0x38>
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;
3481af08:	e2844002 	add	r4, r4, #2
 * b)  the number is small because the table must fit in the core
 * */
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;
3481af0c:	e3a05003 	mov	r5, #3
3481af10:	ea000000 	b	3481af18 <hcreate_r+0x44>

	while (div * div < number && number % div != 0)
		div += 2;
3481af14:	e2855002 	add	r5, r5, #2
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;

	while (div * div < number && number % div != 0)
3481af18:	e0030595 	mul	r3, r5, r5
3481af1c:	e1530004 	cmp	r3, r4
3481af20:	2a000004 	bcs	3481af38 <hcreate_r+0x64>
3481af24:	e1a00004 	mov	r0, r4
3481af28:	e1a01005 	mov	r1, r5
3481af2c:	eb0013a0 	bl	3481fdb4 <__aeabi_uidivmod>
3481af30:	e3510000 	cmp	r1, #0
3481af34:	1afffff6 	bne	3481af14 <hcreate_r+0x40>
		div += 2;

	return number % div != 0;
3481af38:	e1a00004 	mov	r0, r4
3481af3c:	e1a01005 	mov	r1, r5
3481af40:	eb00139b 	bl	3481fdb4 <__aeabi_uidivmod>
	if (htab->table != NULL)
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
3481af44:	e3510000 	cmp	r1, #0
3481af48:	0affffee 	beq	3481af08 <hcreate_r+0x34>
		nel += 2;

	htab->size = nel;
	htab->filled = 0;
3481af4c:	e3a03000 	mov	r3, #0
	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;

	htab->size = nel;
3481af50:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
3481af54:	e5863008 	str	r3, [r6, #8]

	/* allocate memory and zero out */
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
3481af58:	e2840001 	add	r0, r4, #1
3481af5c:	e3a0100c 	mov	r1, #12
3481af60:	ebffbe0c 	bl	3480a798 <calloc>
3481af64:	e5860000 	str	r0, [r6]
int hcreate_r(size_t nel, struct hsearch_data *htab)
{
	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
		return 0;
3481af68:	e2500000 	subs	r0, r0, #0
3481af6c:	13a00001 	movne	r0, #1
3481af70:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
		return 0;
3481af74:	e3a00000 	mov	r0, #0
	if (htab->table == NULL)
		return 0;

	/* everything went alright */
	return 1;
}
3481af78:	e8bd8070 	pop	{r4, r5, r6, pc}
3481af7c:	3482bba0 	.word	0x3482bba0

3481af80 <hdestroy_r>:
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481af80:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481af84:	e2504000 	subs	r4, r0, #0
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481af88:	e1a0a001 	mov	sl, r1
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481af8c:	13a0600c 	movne	r6, #12
3481af90:	13a07001 	movne	r7, #1
3481af94:	1a000017 	bne	3481aff8 <hdestroy_r+0x78>
		__set_errno(EINVAL);
3481af98:	e59f3078 	ldr	r3, [pc, #120]	; 3481b018 <hdestroy_r+0x98>
3481af9c:	e3a02016 	mov	r2, #22
3481afa0:	e5832000 	str	r2, [r3]
		return;
3481afa4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
		if (htab->table[i].used > 0) {
3481afa8:	e5943000 	ldr	r3, [r4]
3481afac:	e0835006 	add	r5, r3, r6
3481afb0:	e7933006 	ldr	r3, [r3, r6]
3481afb4:	e3530000 	cmp	r3, #0
3481afb8:	da00000c 	ble	3481aff0 <hdestroy_r+0x70>
			ENTRY *ep = &htab->table[i].entry;
			if (do_apply && htab->apply != NULL) {
3481afbc:	e35a0000 	cmp	sl, #0
3481afc0:	0a000006 	beq	3481afe0 <hdestroy_r+0x60>
3481afc4:	e594c00c 	ldr	ip, [r4, #12]
3481afc8:	e35c0000 	cmp	ip, #0
3481afcc:	0a000003 	beq	3481afe0 <hdestroy_r+0x60>
				/* deletion is always forced */
				htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481afd0:	e9950003 	ldmib	r5, {r0, r1}
3481afd4:	e3a02000 	mov	r2, #0
3481afd8:	e3a03002 	mov	r3, #2
3481afdc:	e12fff3c 	blx	ip
			}
			free((void *)ep->key);
3481afe0:	e5950004 	ldr	r0, [r5, #4]
3481afe4:	ebffbbf5 	bl	34809fc0 <free>
			free(ep->data);
3481afe8:	e5950008 	ldr	r0, [r5, #8]
3481afec:	ebffbbf3 	bl	34809fc0 <free>
		__set_errno(EINVAL);
		return;
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
3481aff0:	e2877001 	add	r7, r7, #1
3481aff4:	e286600c 	add	r6, r6, #12
3481aff8:	e5943004 	ldr	r3, [r4, #4]
3481affc:	e1570003 	cmp	r7, r3
3481b000:	9affffe8 	bls	3481afa8 <hdestroy_r+0x28>
			}
			free((void *)ep->key);
			free(ep->data);
		}
	}
	free(htab->table);
3481b004:	e5940000 	ldr	r0, [r4]
3481b008:	ebffbbec 	bl	34809fc0 <free>

	/* the sign for an existing table is an value != NULL in htable */
	htab->table = NULL;
3481b00c:	e3a03000 	mov	r3, #0
3481b010:	e5843000 	str	r3, [r4]
3481b014:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481b018:	3482bba0 	.word	0x3482bba0

3481b01c <hstrstr_r>:
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b01c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b020:	e2817001 	add	r7, r1, #1
3481b024:	e3a0600c 	mov	r6, #12
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b028:	e1a04000 	mov	r4, r0
3481b02c:	e1a05002 	mov	r5, r2
3481b030:	e1a0a003 	mov	sl, r3
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b034:	e0060796 	mul	r6, r6, r7
3481b038:	ea000018 	b	3481b0a0 <hstrstr_r+0x84>
		if (htab->table[idx].used <= 0)
3481b03c:	e59a3000 	ldr	r3, [sl]
3481b040:	e0832006 	add	r2, r3, r6
3481b044:	e7933006 	ldr	r3, [r3, r6]
3481b048:	e3530000 	cmp	r3, #0
3481b04c:	da000011 	ble	3481b098 <hstrstr_r+0x7c>
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481b050:	e5920004 	ldr	r0, [r2, #4]
3481b054:	e1a01004 	mov	r1, r4
3481b058:	eb0005dd 	bl	3481c7d4 <strstr>
3481b05c:	e3500000 	cmp	r0, #0
3481b060:	1a000006 	bne	3481b080 <hstrstr_r+0x64>
		    strstr(htab->table[idx].entry.data, match)) {
3481b064:	e59a3000 	ldr	r3, [sl]
3481b068:	e1a01004 	mov	r1, r4
3481b06c:	e0833006 	add	r3, r3, r6
3481b070:	e5930008 	ldr	r0, [r3, #8]
3481b074:	eb0005d6 	bl	3481c7d4 <strstr>
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481b078:	e3500000 	cmp	r0, #0
3481b07c:	0a000005 	beq	3481b098 <hstrstr_r+0x7c>
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481b080:	e59a3000 	ldr	r3, [sl]
			return idx;
3481b084:	e1a00007 	mov	r0, r7
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481b088:	e0836006 	add	r6, r3, r6
3481b08c:	e2866004 	add	r6, r6, #4
3481b090:	e5856000 	str	r6, [r5]
			return idx;
3481b094:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b098:	e2877001 	add	r7, r7, #1
3481b09c:	e286600c 	add	r6, r6, #12
3481b0a0:	e59a3004 	ldr	r3, [sl, #4]
3481b0a4:	e1570003 	cmp	r7, r3
3481b0a8:	3affffe3 	bcc	3481b03c <hstrstr_r+0x20>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b0ac:	e59f3010 	ldr	r3, [pc, #16]	; 3481b0c4 <hstrstr_r+0xa8>
3481b0b0:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481b0b4:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b0b8:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b0bc:	e5850000 	str	r0, [r5]
	return 0;
}
3481b0c0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481b0c4:	3482bba0 	.word	0x3482bba0

3481b0c8 <hmatch_r>:

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
3481b0c8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3481b0cc:	e1a05001 	mov	r5, r1
3481b0d0:	e1a09000 	mov	r9, r0
3481b0d4:	e1a04002 	mov	r4, r2
3481b0d8:	e1a07003 	mov	r7, r3
	unsigned int idx;
	size_t key_len = strlen(match);
3481b0dc:	eb0004ad 	bl	3481c398 <strlen>

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b0e0:	e2855001 	add	r5, r5, #1
3481b0e4:	e3a0600c 	mov	r6, #12

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);
3481b0e8:	e1a0a000 	mov	sl, r0

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b0ec:	e0060596 	mul	r6, r6, r5
3481b0f0:	ea000012 	b	3481b140 <hmatch_r+0x78>
		if (htab->table[idx].used <= 0)
3481b0f4:	e5972000 	ldr	r2, [r7]
3481b0f8:	e0823006 	add	r3, r2, r6
3481b0fc:	e7922006 	ldr	r2, [r2, r6]
3481b100:	e3520000 	cmp	r2, #0
3481b104:	da00000b 	ble	3481b138 <hmatch_r+0x70>
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
3481b108:	e1a00009 	mov	r0, r9
3481b10c:	e5931004 	ldr	r1, [r3, #4]
3481b110:	e1a0200a 	mov	r2, sl
3481b114:	eb000477 	bl	3481c2f8 <strncmp>
3481b118:	e3500000 	cmp	r0, #0
3481b11c:	1a000005 	bne	3481b138 <hmatch_r+0x70>
			*retval = &htab->table[idx].entry;
3481b120:	e5973000 	ldr	r3, [r7]
			return idx;
3481b124:	e1a00005 	mov	r0, r5

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
			*retval = &htab->table[idx].entry;
3481b128:	e0836006 	add	r6, r3, r6
3481b12c:	e2866004 	add	r6, r6, #4
3481b130:	e5846000 	str	r6, [r4]
			return idx;
3481b134:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b138:	e2855001 	add	r5, r5, #1
3481b13c:	e286600c 	add	r6, r6, #12
3481b140:	e5973004 	ldr	r3, [r7, #4]
3481b144:	e1550003 	cmp	r5, r3
3481b148:	3affffe9 	bcc	3481b0f4 <hmatch_r+0x2c>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b14c:	e59f3010 	ldr	r3, [pc, #16]	; 3481b164 <hmatch_r+0x9c>
3481b150:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481b154:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b158:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b15c:	e5840000 	str	r0, [r4]
	return 0;
}
3481b160:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3481b164:	3482bba0 	.word	0x3482bba0

3481b168 <hsearch_r>:

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b168:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b16c:	e24dd018 	sub	sp, sp, #24
3481b170:	e28dc010 	add	ip, sp, #16
3481b174:	e88c0003 	stm	ip, {r0, r1}
3481b178:	e58d2008 	str	r2, [sp, #8]
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481b17c:	e59d2014 	ldr	r2, [sp, #20]
	return 0;
}

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b180:	e1a07003 	mov	r7, r3
3481b184:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481b188:	e1a0b000 	mov	fp, r0
3481b18c:	e58d2004 	str	r2, [sp, #4]
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
3481b190:	eb000480 	bl	3481c398 <strlen>
3481b194:	e1a0a000 	mov	sl, r0
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481b198:	ea000002 	b	3481b1a8 <hsearch_r+0x40>
3481b19c:	e24aa001 	sub	sl, sl, #1
		hval <<= 4;
		hval += item.key[count];
3481b1a0:	e7db300a 	ldrb	r3, [fp, sl]
3481b1a4:	e0830200 	add	r0, r3, r0, lsl #4
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481b1a8:	e35a0000 	cmp	sl, #0
3481b1ac:	1afffffa 	bne	3481b19c <hsearch_r+0x34>

	/*
	 * First hash function:
	 * simply take the modul but prevent zero.
	 */
	hval %= htab->size;
3481b1b0:	e5941004 	ldr	r1, [r4, #4]
3481b1b4:	eb0012fe 	bl	3481fdb4 <__aeabi_uidivmod>
	if (hval == 0)
		++hval;
3481b1b8:	e3510000 	cmp	r1, #0
3481b1bc:	11a06001 	movne	r6, r1
3481b1c0:	03a06001 	moveq	r6, #1

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481b1c4:	e3a0300c 	mov	r3, #12
3481b1c8:	e0090693 	mul	r9, r3, r6
3481b1cc:	e5942000 	ldr	r2, [r4]
3481b1d0:	e7925009 	ldr	r5, [r2, r9]
3481b1d4:	e0823009 	add	r3, r2, r9
3481b1d8:	e3550000 	cmp	r5, #0
3481b1dc:	01a05006 	moveq	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b1e0:	058da00c 	streq	sl, [sp, #12]
		++hval;

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481b1e4:	0a000067 	beq	3481b388 <hsearch_r+0x220>
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b1e8:	e3750001 	cmn	r5, #1
3481b1ec:	01a02006 	moveq	r2, r6
3481b1f0:	13a02000 	movne	r2, #0

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481b1f4:	e1550006 	cmp	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b1f8:	e58d200c 	str	r2, [sp, #12]

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481b1fc:	1a000023 	bne	3481b290 <hsearch_r+0x128>
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481b200:	e1a0000b 	mov	r0, fp
3481b204:	e5931004 	ldr	r1, [r3, #4]
3481b208:	eb00042e 	bl	3481c2c8 <strcmp>
3481b20c:	e3500000 	cmp	r0, #0
3481b210:	1a00001e 	bne	3481b290 <hsearch_r+0x128>
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
3481b214:	e59d3008 	ldr	r3, [sp, #8]
3481b218:	e3530001 	cmp	r3, #1
3481b21c:	1a000016 	bne	3481b27c <hsearch_r+0x114>
3481b220:	e59d2004 	ldr	r2, [sp, #4]
3481b224:	e3520000 	cmp	r2, #0
3481b228:	0a000013 	beq	3481b27c <hsearch_r+0x114>
				free(htab->table[idx].entry.data);
3481b22c:	e5943000 	ldr	r3, [r4]
3481b230:	e0833009 	add	r3, r3, r9
3481b234:	e5930008 	ldr	r0, [r3, #8]
3481b238:	ebffbb60 	bl	34809fc0 <free>
				htab->table[idx].entry.data =
					strdup(item.data);
3481b23c:	e59d0004 	ldr	r0, [sp, #4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481b240:	e5946000 	ldr	r6, [r4]
					strdup(item.data);
3481b244:	eb000488 	bl	3481c46c <strdup>
				if (!htab->table[idx].entry.data) {
3481b248:	e5943000 	ldr	r3, [r4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481b24c:	e0866009 	add	r6, r6, r9
3481b250:	e5860008 	str	r0, [r6, #8]
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
3481b254:	e0833009 	add	r3, r3, r9
3481b258:	e5933008 	ldr	r3, [r3, #8]
3481b25c:	e3530000 	cmp	r3, #0
3481b260:	1a000005 	bne	3481b27c <hsearch_r+0x114>
					__set_errno(ENOMEM);
3481b264:	e59f31dc 	ldr	r3, [pc, #476]	; 3481b448 <hsearch_r+0x2e0>
3481b268:	e3a0200c 	mov	r2, #12
3481b26c:	e5832000 	str	r2, [r3]
					*retval = NULL;
					return 0;
3481b270:	e1a0500a 	mov	r5, sl
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
					__set_errno(ENOMEM);
					*retval = NULL;
3481b274:	e587a000 	str	sl, [r7]
					return 0;
3481b278:	ea00006f 	b	3481b43c <hsearch_r+0x2d4>
				}
			}
			/* return found entry */
			*retval = &htab->table[idx].entry;
3481b27c:	e5943000 	ldr	r3, [r4]
3481b280:	e0839009 	add	r9, r3, r9
3481b284:	e2899004 	add	r9, r9, #4
3481b288:	e5879000 	str	r9, [r7]
			return idx;
3481b28c:	ea00006a 	b	3481b43c <hsearch_r+0x2d4>

		/*
		 * Second hash function:
		 * as suggested in [Knuth]
		 */
		hval2 = 1 + hval % (htab->size - 2);
3481b290:	e5941004 	ldr	r1, [r4, #4]
3481b294:	e1a00006 	mov	r0, r6
3481b298:	e2411002 	sub	r1, r1, #2
3481b29c:	eb0012c4 	bl	3481fdb4 <__aeabi_uidivmod>
3481b2a0:	e1a05006 	mov	r5, r6
3481b2a4:	e2819001 	add	r9, r1, #1
			 */
			if (idx == hval)
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481b2a8:	e3a0c00c 	mov	ip, #12
		do {
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
3481b2ac:	e1550009 	cmp	r5, r9
				idx = htab->size + idx - hval2;
3481b2b0:	95943004 	ldrls	r3, [r4, #4]
			else
				idx -= hval2;
3481b2b4:	80695005 	rsbhi	r5, r9, r5
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
				idx = htab->size + idx - hval2;
3481b2b8:	90693003 	rsbls	r3, r9, r3
3481b2bc:	90855003 	addls	r5, r5, r3

			/*
			 * If we visited all entries leave the loop
			 * unsuccessfully.
			 */
			if (idx == hval)
3481b2c0:	e1550006 	cmp	r5, r6
3481b2c4:	0a00002f 	beq	3481b388 <hsearch_r+0x220>
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481b2c8:	e00a059c 	mul	sl, ip, r5
3481b2cc:	e5942000 	ldr	r2, [r4]
3481b2d0:	e082300a 	add	r3, r2, sl
3481b2d4:	e792200a 	ldr	r2, [r2, sl]
3481b2d8:	e1520006 	cmp	r2, r6
3481b2dc:	1a000025 	bne	3481b378 <hsearch_r+0x210>
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481b2e0:	e5931004 	ldr	r1, [r3, #4]
3481b2e4:	e1a0000b 	mov	r0, fp
3481b2e8:	e58dc000 	str	ip, [sp]
3481b2ec:	eb0003f5 	bl	3481c2c8 <strcmp>
3481b2f0:	e3500000 	cmp	r0, #0
3481b2f4:	e59dc000 	ldr	ip, [sp]
3481b2f8:	1a00001e 	bne	3481b378 <hsearch_r+0x210>
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
3481b2fc:	e59d3008 	ldr	r3, [sp, #8]
3481b300:	e3530001 	cmp	r3, #1
3481b304:	1a000016 	bne	3481b364 <hsearch_r+0x1fc>
3481b308:	e59d2004 	ldr	r2, [sp, #4]
3481b30c:	e3520000 	cmp	r2, #0
3481b310:	0a000013 	beq	3481b364 <hsearch_r+0x1fc>
					free(htab->table[idx].entry.data);
3481b314:	e5943000 	ldr	r3, [r4]
3481b318:	e083300a 	add	r3, r3, sl
3481b31c:	e5930008 	ldr	r0, [r3, #8]
3481b320:	ebffbb26 	bl	34809fc0 <free>
					htab->table[idx].entry.data =
						strdup(item.data);
3481b324:	e59d0004 	ldr	r0, [sp, #4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481b328:	e5946000 	ldr	r6, [r4]
						strdup(item.data);
3481b32c:	eb00044e 	bl	3481c46c <strdup>
					if (!htab->table[idx].entry.data) {
3481b330:	e5943000 	ldr	r3, [r4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481b334:	e086600a 	add	r6, r6, sl
3481b338:	e5860008 	str	r0, [r6, #8]
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
3481b33c:	e083300a 	add	r3, r3, sl
3481b340:	e5933008 	ldr	r3, [r3, #8]
3481b344:	e3530000 	cmp	r3, #0
3481b348:	1a000005 	bne	3481b364 <hsearch_r+0x1fc>
						__set_errno(ENOMEM);
3481b34c:	e59f20f4 	ldr	r2, [pc, #244]	; 3481b448 <hsearch_r+0x2e0>
3481b350:	e3a0100c 	mov	r1, #12
3481b354:	e5821000 	str	r1, [r2]
						*retval = NULL;
						return 0;
3481b358:	e1a05003 	mov	r5, r3
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
						__set_errno(ENOMEM);
						*retval = NULL;
3481b35c:	e5873000 	str	r3, [r7]
						return 0;
3481b360:	ea000035 	b	3481b43c <hsearch_r+0x2d4>
					}
				}
				/* return found entry */
				*retval = &htab->table[idx].entry;
3481b364:	e5943000 	ldr	r3, [r4]
3481b368:	e083a00a 	add	sl, r3, sl
3481b36c:	e28aa004 	add	sl, sl, #4
3481b370:	e587a000 	str	sl, [r7]
				return idx;
3481b374:	ea000030 	b	3481b43c <hsearch_r+0x2d4>
			}
		}
		while (htab->table[idx].used);
3481b378:	e5943000 	ldr	r3, [r4]
3481b37c:	e793300a 	ldr	r3, [r3, sl]
3481b380:	e3530000 	cmp	r3, #0
3481b384:	1affffc8 	bne	3481b2ac <hsearch_r+0x144>
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481b388:	e59d3008 	ldr	r3, [sp, #8]
3481b38c:	e3530001 	cmp	r3, #1
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481b390:	13a02003 	movne	r2, #3
		}
		while (htab->table[idx].used);
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481b394:	1a000024 	bne	3481b42c <hsearch_r+0x2c4>
		/*
		 * If table is full and another entry should be
		 * entered return with error.
		 */
		if (htab->filled == htab->size) {
3481b398:	e5942008 	ldr	r2, [r4, #8]
3481b39c:	e5943004 	ldr	r3, [r4, #4]
3481b3a0:	e1520003 	cmp	r2, r3
3481b3a4:	0a000017 	beq	3481b408 <hsearch_r+0x2a0>

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481b3a8:	e59d200c 	ldr	r2, [sp, #12]
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b3ac:	e3a0300c 	mov	r3, #12

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481b3b0:	e3520000 	cmp	r2, #0
3481b3b4:	11a05002 	movne	r5, r2
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b3b8:	e0050593 	mul	r5, r3, r5
3481b3bc:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.key = strdup(item.key);
3481b3c0:	e1a0000b 	mov	r0, fp
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b3c4:	e7836005 	str	r6, [r3, r5]
3481b3c8:	e083a005 	add	sl, r3, r5
		htab->table[idx].entry.key = strdup(item.key);
3481b3cc:	eb000426 	bl	3481c46c <strdup>
3481b3d0:	e58a0004 	str	r0, [sl, #4]
		htab->table[idx].entry.data = strdup(item.data);
3481b3d4:	e59d0004 	ldr	r0, [sp, #4]
3481b3d8:	e5946000 	ldr	r6, [r4]
3481b3dc:	eb000422 	bl	3481c46c <strdup>
		if (!htab->table[idx].entry.key ||
3481b3e0:	e5943000 	ldr	r3, [r4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481b3e4:	e0866005 	add	r6, r6, r5
		if (!htab->table[idx].entry.key ||
3481b3e8:	e0835005 	add	r5, r3, r5
3481b3ec:	e5953004 	ldr	r3, [r5, #4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481b3f0:	e5860008 	str	r0, [r6, #8]
		if (!htab->table[idx].entry.key ||
3481b3f4:	e3530000 	cmp	r3, #0
3481b3f8:	0a000002 	beq	3481b408 <hsearch_r+0x2a0>
3481b3fc:	e5953008 	ldr	r3, [r5, #8]
3481b400:	e3530000 	cmp	r3, #0
3481b404:	1a000001 	bne	3481b410 <hsearch_r+0x2a8>
		    !htab->table[idx].entry.data) {
			__set_errno(ENOMEM);
3481b408:	e3a0200c 	mov	r2, #12
3481b40c:	ea000006 	b	3481b42c <hsearch_r+0x2c4>
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481b410:	e5943008 	ldr	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481b414:	e2855004 	add	r5, r5, #4
			__set_errno(ENOMEM);
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481b418:	e2833001 	add	r3, r3, #1
3481b41c:	e5843008 	str	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481b420:	e5875000 	str	r5, [r7]
		return 1;
3481b424:	e59d5008 	ldr	r5, [sp, #8]
3481b428:	ea000003 	b	3481b43c <hsearch_r+0x2d4>
	}

	__set_errno(ESRCH);
3481b42c:	e59f3014 	ldr	r3, [pc, #20]	; 3481b448 <hsearch_r+0x2e0>
	*retval = NULL;
3481b430:	e3a05000 	mov	r5, #0
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481b434:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b438:	e5875000 	str	r5, [r7]
	return 0;
}
3481b43c:	e1a00005 	mov	r0, r5
3481b440:	e28dd018 	add	sp, sp, #24
3481b444:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b448:	3482bba0 	.word	0x3482bba0

3481b44c <hdelete_r>:
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481b44c:	e92d4070 	push	{r4, r5, r6, lr}
3481b450:	e24dd018 	sub	sp, sp, #24
	ENTRY e, *ep;
	int idx;

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;
3481b454:	e58d000c 	str	r0, [sp, #12]

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481b458:	e58d1000 	str	r1, [sp]
3481b45c:	e28d300c 	add	r3, sp, #12
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481b460:	e1a04001 	mov	r4, r1
3481b464:	e1a06002 	mov	r6, r2

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481b468:	e8930003 	ldm	r3, {r0, r1}
3481b46c:	e3a02000 	mov	r2, #0
3481b470:	e28d3014 	add	r3, sp, #20
3481b474:	ebffff3b 	bl	3481b168 <hsearch_r>
3481b478:	e2505000 	subs	r5, r0, #0
		__set_errno(ESRCH);
3481b47c:	059f3078 	ldreq	r3, [pc, #120]	; 3481b4fc <hdelete_r+0xb0>
3481b480:	03a02003 	moveq	r2, #3
3481b484:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
3481b488:	01a00005 	moveq	r0, r5
3481b48c:	0a000018 	beq	3481b4f4 <hdelete_r+0xa8>
	}

	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	if (do_apply && htab->apply != NULL)
3481b490:	e3560000 	cmp	r6, #0
3481b494:	0a000007 	beq	3481b4b8 <hdelete_r+0x6c>
3481b498:	e594c00c 	ldr	ip, [r4, #12]
3481b49c:	e35c0000 	cmp	ip, #0
3481b4a0:	0a000004 	beq	3481b4b8 <hdelete_r+0x6c>
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481b4a4:	e59d3014 	ldr	r3, [sp, #20]
3481b4a8:	e3a02000 	mov	r2, #0
3481b4ac:	e8930003 	ldm	r3, {r0, r1}
3481b4b0:	e3a03002 	mov	r3, #2
3481b4b4:	e12fff3c 	blx	ip
	free((void *)ep->key);
3481b4b8:	e59d3014 	ldr	r3, [sp, #20]
3481b4bc:	e5930000 	ldr	r0, [r3]
3481b4c0:	ebffbabe 	bl	34809fc0 <free>
	free(ep->data);
3481b4c4:	e59d3014 	ldr	r3, [sp, #20]
3481b4c8:	e5930004 	ldr	r0, [r3, #4]
3481b4cc:	ebffbabb 	bl	34809fc0 <free>
	htab->table[idx].used = -1;
3481b4d0:	e3a0200c 	mov	r2, #12
3481b4d4:	e0050592 	mul	r5, r2, r5
3481b4d8:	e5943000 	ldr	r3, [r4]
3481b4dc:	e3e02000 	mvn	r2, #0
3481b4e0:	e7832005 	str	r2, [r3, r5]

	--htab->filled;
3481b4e4:	e5943008 	ldr	r3, [r4, #8]

	return 1;
3481b4e8:	e3a00001 	mov	r0, #1
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
	free((void *)ep->key);
	free(ep->data);
	htab->table[idx].used = -1;

	--htab->filled;
3481b4ec:	e0833002 	add	r3, r3, r2
3481b4f0:	e5843008 	str	r3, [r4, #8]

	return 1;
}
3481b4f4:	e28dd018 	add	sp, sp, #24
3481b4f8:	e8bd8070 	pop	{r4, r5, r6, pc}
3481b4fc:	3482bba0 	.word	0x3482bba0

3481b500 <hexport_r>:
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481b500:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b504:	e28db01c 	add	fp, sp, #28
3481b508:	e24dd018 	sub	sp, sp, #24
3481b50c:	e1a04003 	mov	r4, r3
	ENTRY *list[htab->size];
3481b510:	e5903004 	ldr	r3, [r0, #4]
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481b514:	e3520000 	cmp	r2, #0

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
	ENTRY *list[htab->size];
3481b518:	e1a03103 	lsl	r3, r3, #2
3481b51c:	e283300e 	add	r3, r3, #14
3481b520:	e3c33007 	bic	r3, r3, #7
3481b524:	e04dd003 	sub	sp, sp, r3
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481b528:	e1a05000 	mov	r5, r0
3481b52c:	e1a07001 	mov	r7, r1
	ENTRY *list[htab->size];
3481b530:	e50bd028 	str	sp, [fp, #-40]	; 0x28
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481b534:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
3481b538:	0a000006 	beq	3481b558 <hexport_r+0x58>
3481b53c:	e3a06000 	mov	r6, #0
3481b540:	e3a02001 	mov	r2, #1
3481b544:	e3a0900c 	mov	r9, #12
3481b548:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481b54c:	e50b6020 	str	r6, [fp, #-32]
3481b550:	e50b4030 	str	r4, [fp, #-48]	; 0x30
3481b554:	ea000041 	b	3481b660 <hexport_r+0x160>
		__set_errno(EINVAL);
3481b558:	e3a02016 	mov	r2, #22
3481b55c:	ea000054 	b	3481b6b4 <hexport_r+0x1b4>
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
3481b560:	e5953000 	ldr	r3, [r5]
3481b564:	e0834009 	add	r4, r3, r9
3481b568:	e7933009 	ldr	r3, [r3, r9]
3481b56c:	e3530000 	cmp	r3, #0
3481b570:	da000036 	ble	3481b650 <hexport_r+0x150>
3481b574:	e59b3008 	ldr	r3, [fp, #8]
3481b578:	e1a02006 	mov	r2, r6
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481b57c:	e3a0a000 	mov	sl, #0
3481b580:	e1a06003 	mov	r6, r3
3481b584:	ea000007 	b	3481b5a8 <hexport_r+0xa8>
				if (strcmp(argv[arg], ep->key) == 0) {
3481b588:	e4960004 	ldr	r0, [r6], #4
3481b58c:	e5941004 	ldr	r1, [r4, #4]
3481b590:	e50b2034 	str	r2, [fp, #-52]	; 0x34
3481b594:	eb00034b 	bl	3481c2c8 <strcmp>
3481b598:	e3500000 	cmp	r0, #0
3481b59c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481b5a0:	0a000006 	beq	3481b5c0 <hexport_r+0xc0>

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481b5a4:	e28aa001 	add	sl, sl, #1
3481b5a8:	e59b3004 	ldr	r3, [fp, #4]
3481b5ac:	e15a0003 	cmp	sl, r3
3481b5b0:	bafffff4 	blt	3481b588 <hexport_r+0x88>
3481b5b4:	e1a06002 	mov	r6, r2
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;
3481b5b8:	e3a03000 	mov	r3, #0
3481b5bc:	ea000001 	b	3481b5c8 <hexport_r+0xc8>
3481b5c0:	e1a06002 	mov	r6, r2

			for (arg = 0; arg < argc; ++arg) {
				if (strcmp(argv[arg], ep->key) == 0) {
					found = 1;
3481b5c4:	e3a03001 	mov	r3, #1
					break;
				}
			}
			if ((argc > 0) && (found == 0))
3481b5c8:	e59b2004 	ldr	r2, [fp, #4]
3481b5cc:	e2233001 	eor	r3, r3, #1
3481b5d0:	e3520000 	cmp	r2, #0
3481b5d4:	d3a03000 	movle	r3, #0
3481b5d8:	c2033001 	andgt	r3, r3, #1
3481b5dc:	e3530000 	cmp	r3, #0
3481b5e0:	1a00001a 	bne	3481b650 <hexport_r+0x150>
				continue;

			list[n++] = ep;
3481b5e4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
3481b5e8:	e2843004 	add	r3, r4, #4
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481b5ec:	e7823106 	str	r3, [r2, r6, lsl #2]

			totlen += strlen(ep->key) + 2;
3481b5f0:	e5940004 	ldr	r0, [r4, #4]
3481b5f4:	eb000367 	bl	3481c398 <strlen>
3481b5f8:	e51b3020 	ldr	r3, [fp, #-32]

			if (sep == '\0') {
3481b5fc:	e3570000 	cmp	r7, #0
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;
3481b600:	e283a002 	add	sl, r3, #2
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481b604:	e2866001 	add	r6, r6, #1

			totlen += strlen(ep->key) + 2;
3481b608:	e08aa000 	add	sl, sl, r0

			if (sep == '\0') {
				totlen += strlen(ep->data);
3481b60c:	15942008 	ldrne	r2, [r4, #8]

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;

			if (sep == '\0') {
3481b610:	1a000009 	bne	3481b63c <hexport_r+0x13c>
				totlen += strlen(ep->data);
3481b614:	e5940008 	ldr	r0, [r4, #8]
3481b618:	eb00035e 	bl	3481c398 <strlen>
3481b61c:	e08aa000 	add	sl, sl, r0
3481b620:	ea000008 	b	3481b648 <hexport_r+0x148>
				char *s = ep->data;

				while (*s) {
					++totlen;
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481b624:	e1530007 	cmp	r3, r7
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
					++totlen;
3481b628:	e28aa001 	add	sl, sl, #1
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481b62c:	0a000001 	beq	3481b638 <hexport_r+0x138>
3481b630:	e353005c 	cmp	r3, #92	; 0x5c
3481b634:	1a000000 	bne	3481b63c <hexport_r+0x13c>
						++totlen;
3481b638:	e28aa001 	add	sl, sl, #1
			if (sep == '\0') {
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
3481b63c:	e4d23001 	ldrb	r3, [r2], #1
3481b640:	e3530000 	cmp	r3, #0
3481b644:	1afffff6 	bne	3481b624 <hexport_r+0x124>
					if ((*s == sep) || (*s == '\\'))
						++totlen;
					++s;
				}
			}
			totlen += 2;	/* for '=' and 'sep' char */
3481b648:	e28aa002 	add	sl, sl, #2
3481b64c:	e50ba020 	str	sl, [fp, #-32]
	/*
	 * Pass 1:
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
3481b650:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481b654:	e289900c 	add	r9, r9, #12
3481b658:	e2822001 	add	r2, r2, #1
3481b65c:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481b660:	e5953004 	ldr	r3, [r5, #4]
3481b664:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481b668:	e1520003 	cmp	r2, r3
3481b66c:	9affffbb 	bls	3481b560 <hexport_r+0x60>
		       i, list[i], list[i]->key, list[i]->data);
	}
#endif

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);
3481b670:	e3a02004 	mov	r2, #4
3481b674:	e59f3124 	ldr	r3, [pc, #292]	; 3481b7a0 <hexport_r+0x2a0>
3481b678:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
3481b67c:	e1a01006 	mov	r1, r6
3481b680:	e51b4030 	ldr	r4, [fp, #-48]	; 0x30
3481b684:	eb0002a0 	bl	3481c10c <qsort>
3481b688:	e51b3020 	ldr	r3, [fp, #-32]

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481b68c:	e3540000 	cmp	r4, #0
3481b690:	e2832001 	add	r2, r3, #1
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
			return (-1);
		}
	} else {
		size = totlen + 1;
3481b694:	01a04002 	moveq	r4, r2

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481b698:	0a000009 	beq	3481b6c4 <hexport_r+0x1c4>
		if (size < totlen + 1) {	/* provided buffer too small */
3481b69c:	e1540002 	cmp	r4, r2
3481b6a0:	2a000007 	bcs	3481b6c4 <hexport_r+0x1c4>
			printf("Env export buffer too small: %zu, "
3481b6a4:	e59f00f8 	ldr	r0, [pc, #248]	; 3481b7a4 <hexport_r+0x2a4>
3481b6a8:	e1a01004 	mov	r1, r4
3481b6ac:	ebffb905 	bl	34809ac8 <printf>
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481b6b0:	e3a0200c 	mov	r2, #12
3481b6b4:	e59f30ec 	ldr	r3, [pc, #236]	; 3481b7a8 <hexport_r+0x2a8>
			return (-1);
3481b6b8:	e3e00000 	mvn	r0, #0
	/* Check if the user supplied buffer size is sufficient */
	if (size) {
		if (size < totlen + 1) {	/* provided buffer too small */
			printf("Env export buffer too small: %zu, "
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481b6bc:	e5832000 	str	r2, [r3]
3481b6c0:	ea000034 	b	3481b798 <hexport_r+0x298>
	} else {
		size = totlen + 1;
	}

	/* Check if the user provided a buffer */
	if (*resp) {
3481b6c4:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3481b6c8:	e5925000 	ldr	r5, [r2]
3481b6cc:	e3550000 	cmp	r5, #0
3481b6d0:	0a000008 	beq	3481b6f8 <hexport_r+0x1f8>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
3481b6d4:	e1a00005 	mov	r0, r5
3481b6d8:	e3a01000 	mov	r1, #0
3481b6dc:	e1a02004 	mov	r2, r4
3481b6e0:	eb0003cc 	bl	3481c618 <memset>
3481b6e4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
		if (res == NULL) {
3481b6e8:	e3a03000 	mov	r3, #0
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481b6ec:	e3a0a03d 	mov	sl, #61	; 0x3d

		s = list[i]->data;

		while (*s) {
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
3481b6f0:	e3a0905c 	mov	r9, #92	; 0x5c
3481b6f4:	ea000022 	b	3481b784 <hexport_r+0x284>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481b6f8:	e3a00001 	mov	r0, #1
3481b6fc:	e1a01004 	mov	r1, r4
3481b700:	ebffbc24 	bl	3480a798 <calloc>
3481b704:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
		if (res == NULL) {
3481b708:	e3500000 	cmp	r0, #0
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481b70c:	e5830000 	str	r0, [r3]
		if (res == NULL) {
3481b710:	11a05000 	movne	r5, r0
3481b714:	1afffff2 	bne	3481b6e4 <hexport_r+0x1e4>
3481b718:	eaffffe4 	b	3481b6b0 <hexport_r+0x1b0>
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
3481b71c:	e4921004 	ldr	r1, [r2], #4
3481b720:	e5911000 	ldr	r1, [r1]
		while (*s)
3481b724:	ea000001 	b	3481b730 <hexport_r+0x230>
			*p++ = *s++;
3481b728:	e5c50000 	strb	r0, [r5]
3481b72c:	e1a0500c 	mov	r5, ip
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
		while (*s)
3481b730:	e4d10001 	ldrb	r0, [r1], #1
3481b734:	e285c001 	add	ip, r5, #1
3481b738:	e3500000 	cmp	r0, #0
3481b73c:	1afffff9 	bne	3481b728 <hexport_r+0x228>
			*p++ = *s++;
		*p++ = '=';
3481b740:	e5c5a000 	strb	sl, [r5]

		s = list[i]->data;
3481b744:	e5121004 	ldr	r1, [r2, #-4]
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481b748:	e1a0500c 	mov	r5, ip
3481b74c:	e5911004 	ldr	r1, [r1, #4]

		s = list[i]->data;

		while (*s) {
3481b750:	ea000006 	b	3481b770 <hexport_r+0x270>
			if ((*s == sep) || (*s == '\\'))
3481b754:	e1500007 	cmp	r0, r7
3481b758:	0a000001 	beq	3481b764 <hexport_r+0x264>
3481b75c:	e350005c 	cmp	r0, #92	; 0x5c
3481b760:	1a000000 	bne	3481b768 <hexport_r+0x268>
				*p++ = '\\';	/* escape */
3481b764:	e4c59001 	strb	r9, [r5], #1
			*p++ = *s++;
3481b768:	e5510001 	ldrb	r0, [r1, #-1]
3481b76c:	e4c50001 	strb	r0, [r5], #1
			*p++ = *s++;
		*p++ = '=';

		s = list[i]->data;

		while (*s) {
3481b770:	e4d10001 	ldrb	r0, [r1], #1
3481b774:	e3500000 	cmp	r0, #0
3481b778:	1afffff5 	bne	3481b754 <hexport_r+0x254>
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
3481b77c:	e4c57001 	strb	r7, [r5], #1
	}
	/*
	 * Pass 2:
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
3481b780:	e2833001 	add	r3, r3, #1
3481b784:	e1530006 	cmp	r3, r6
3481b788:	baffffe3 	blt	3481b71c <hexport_r+0x21c>
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
	}
	*p = '\0';		/* terminate result */
3481b78c:	e3a03000 	mov	r3, #0
3481b790:	e5c53000 	strb	r3, [r5]

	return size;
3481b794:	e1a00004 	mov	r0, r4
}
3481b798:	e24bd01c 	sub	sp, fp, #28
3481b79c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b7a0:	3481aec0 	.word	0x3481aec0
3481b7a4:	34827ec1 	.word	0x34827ec1
3481b7a8:	3482bba0 	.word	0x3482bba0

3481b7ac <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b7ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b7b0:	e28db01c 	add	fp, sp, #28
3481b7b4:	e24dd028 	sub	sp, sp, #40	; 0x28
3481b7b8:	e1a06002 	mov	r6, r2
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b7bc:	e59b2008 	ldr	r2, [fp, #8]
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b7c0:	e1a0a003 	mov	sl, r3
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b7c4:	e1a05102 	lsl	r5, r2, #2
3481b7c8:	e285300e 	add	r3, r5, #14
3481b7cc:	e3c33007 	bic	r3, r3, #7
3481b7d0:	e04dd003 	sub	sp, sp, r3
3481b7d4:	e28d3008 	add	r3, sp, #8
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481b7d8:	e2504000 	subs	r4, r0, #0
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b7dc:	e1a07001 	mov	r7, r1
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b7e0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
3481b7e4:	059f3318 	ldreq	r3, [pc, #792]	; 3481bb04 <himport_r+0x358>
3481b7e8:	03a02016 	moveq	r2, #22
3481b7ec:	05832000 	streq	r2, [r3]
		return 0;
3481b7f0:	01a00004 	moveq	r0, r4
3481b7f4:	0a0000c0 	beq	3481bafc <himport_r+0x350>
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
3481b7f8:	e1a00006 	mov	r0, r6
3481b7fc:	ebffba78 	bl	3480a1e4 <malloc>
3481b800:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
3481b804:	059f32f8 	ldreq	r3, [pc, #760]	; 3481bb04 <himport_r+0x358>
3481b808:	03a0200c 	moveq	r2, #12
3481b80c:	05832000 	streq	r2, [r3]
		return 0;
3481b810:	01a00009 	moveq	r0, r9
3481b814:	0a0000b8 	beq	3481bafc <himport_r+0x350>
	}
	memcpy(data, env, size);
3481b818:	e1a02006 	mov	r2, r6
3481b81c:	e1a01007 	mov	r1, r7
3481b820:	eb0003a0 	bl	3481c6a8 <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
3481b824:	e59b2008 	ldr	r2, [fp, #8]
3481b828:	e3520000 	cmp	r2, #0
3481b82c:	0a000003 	beq	3481b840 <himport_r+0x94>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
3481b830:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
3481b834:	e59b100c 	ldr	r1, [fp, #12]
3481b838:	e1a02005 	mov	r2, r5
3481b83c:	eb000399 	bl	3481c6a8 <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
3481b840:	e59b3004 	ldr	r3, [fp, #4]
3481b844:	e3130001 	tst	r3, #1
3481b848:	1a000005 	bne	3481b864 <himport_r+0xb8>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
3481b84c:	e5943000 	ldr	r3, [r4]
3481b850:	e3530000 	cmp	r3, #0
3481b854:	0a000002 	beq	3481b864 <himport_r+0xb8>
			hdestroy_r(htab, do_apply);
3481b858:	e1a00004 	mov	r0, r4
3481b85c:	e59b1010 	ldr	r1, [fp, #16]
3481b860:	ebfffdc6 	bl	3481af80 <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
3481b864:	e5943000 	ldr	r3, [r4]
3481b868:	e3530000 	cmp	r3, #0
3481b86c:	0a000003 	beq	3481b880 <himport_r+0xd4>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481b870:	e0896006 	add	r6, r9, r6
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b874:	e1a05009 	mov	r5, r9
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481b878:	e50b6034 	str	r6, [fp, #-52]	; 0x34
3481b87c:	ea00000c 	b	3481b8b4 <himport_r+0x108>
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
3481b880:	e1a001a6 	lsr	r0, r6, #3
3481b884:	e2800040 	add	r0, r0, #64	; 0x40
		if (nent > CONFIG_ENV_MAX_ENTRIES)
			nent = CONFIG_ENV_MAX_ENTRIES;

		debug("Create Hash Table: N=%d\n", nent);

		if (hcreate_r(nent, htab) == 0) {
3481b888:	e3500c02 	cmp	r0, #512	; 0x200
3481b88c:	a3a00c02 	movge	r0, #512	; 0x200
3481b890:	e1a01004 	mov	r1, r4
3481b894:	ebfffd8e 	bl	3481aed4 <hcreate_r>
3481b898:	e2505000 	subs	r5, r0, #0
3481b89c:	1afffff3 	bne	3481b870 <himport_r+0xc4>
			free(data);
3481b8a0:	e1a00009 	mov	r0, r9
3481b8a4:	ebffb9c5 	bl	34809fc0 <free>
			return 0;
3481b8a8:	e1a00005 	mov	r0, r5
3481b8ac:	ea000092 	b	3481bafc <himport_r+0x350>
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b8b0:	e1a05006 	mov	r5, r6
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481b8b4:	e5d53000 	ldrb	r3, [r5]
3481b8b8:	e3530020 	cmp	r3, #32
3481b8bc:	13530009 	cmpne	r3, #9
			++dp;
3481b8c0:	02856001 	addeq	r6, r5, #1
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481b8c4:	0afffff9 	beq	3481b8b0 <himport_r+0x104>
			++dp;

		/* skip comment lines */
		if (*dp == '#') {
3481b8c8:	e3530023 	cmp	r3, #35	; 0x23
3481b8cc:	11a02005 	movne	r2, r5
3481b8d0:	1a000007 	bne	3481b8f4 <himport_r+0x148>
3481b8d4:	e1a06005 	mov	r6, r5
			while (*dp && (*dp != sep))
3481b8d8:	e4d53001 	ldrb	r3, [r5], #1
3481b8dc:	e3530000 	cmp	r3, #0
3481b8e0:	0a000001 	beq	3481b8ec <himport_r+0x140>
3481b8e4:	e153000a 	cmp	r3, sl
3481b8e8:	1afffff9 	bne	3481b8d4 <himport_r+0x128>
				++dp;
			++dp;
3481b8ec:	e2866001 	add	r6, r6, #1
			continue;
3481b8f0:	ea000066 	b	3481ba90 <himport_r+0x2e4>
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b8f4:	e5d23000 	ldrb	r3, [r2]
		/* skip comment lines */
		if (*dp == '#') {
			while (*dp && (*dp != sep))
				++dp;
			++dp;
			continue;
3481b8f8:	e1a06002 	mov	r6, r2
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b8fc:	e3530000 	cmp	r3, #0
3481b900:	1353003d 	cmpne	r3, #61	; 0x3d
3481b904:	e2822001 	add	r2, r2, #1
3481b908:	1a000002 	bne	3481b918 <himport_r+0x16c>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481b90c:	e3530000 	cmp	r3, #0
3481b910:	0a00000e 	beq	3481b950 <himport_r+0x1a4>
3481b914:	ea000001 	b	3481b920 <himport_r+0x174>
			++dp;
			continue;
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b918:	e153000a 	cmp	r3, sl
3481b91c:	1afffff4 	bne	3481b8f4 <himport_r+0x148>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481b920:	e5d62001 	ldrb	r2, [r6, #1]
3481b924:	e2867001 	add	r7, r6, #1
3481b928:	e3520000 	cmp	r2, #0
3481b92c:	0a000003 	beq	3481b940 <himport_r+0x194>
3481b930:	e153000a 	cmp	r3, sl
3481b934:	0a000001 	beq	3481b940 <himport_r+0x194>
		    *dp == sep || *(dp + 1) == sep) {
3481b938:	e152000a 	cmp	r2, sl
3481b93c:	1a000010 	bne	3481b984 <himport_r+0x1d8>
			if (*dp == '=')
3481b940:	e353003d 	cmp	r3, #61	; 0x3d
				*dp++ = '\0';
3481b944:	03a02000 	moveq	r2, #0
3481b948:	05c62000 	strbeq	r2, [r6]
3481b94c:	01a06007 	moveq	r6, r7
			*dp++ = '\0';	/* terminate name */
3481b950:	e3a03000 	mov	r3, #0
3481b954:	e4c63001 	strb	r3, [r6], #1

			debug("DELETE CANDIDATE: \"%s\"\n", name);
			if (!drop_var_from_set(name, nvars, localvars))
3481b958:	e1a00005 	mov	r0, r5
3481b95c:	e59b1008 	ldr	r1, [fp, #8]
3481b960:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481b964:	ebfffd3e 	bl	3481ae64 <drop_var_from_set>
3481b968:	e3500000 	cmp	r0, #0
3481b96c:	0a000047 	beq	3481ba90 <himport_r+0x2e4>
				continue;

			if (hdelete_r(name, htab, do_apply) == 0)
3481b970:	e1a00005 	mov	r0, r5
3481b974:	e1a01004 	mov	r1, r4
3481b978:	e59b2010 	ldr	r2, [fp, #16]
3481b97c:	ebfffeb2 	bl	3481b44c <hdelete_r>
				debug("DELETE ERROR ##############################\n");

			continue;
3481b980:	ea000042 	b	3481ba90 <himport_r+0x2e4>
		}
		*dp++ = '\0';	/* terminate name */
3481b984:	e3a02000 	mov	r2, #0
3481b988:	e5c62000 	strb	r2, [r6]

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481b98c:	e1a03007 	mov	r3, r7
3481b990:	e1a06007 	mov	r6, r7
3481b994:	ea000006 	b	3481b9b4 <himport_r+0x208>
			if ((*dp == '\\') && *(dp + 1))
3481b998:	e352005c 	cmp	r2, #92	; 0x5c
3481b99c:	1a000002 	bne	3481b9ac <himport_r+0x200>
3481b9a0:	e5d62001 	ldrb	r2, [r6, #1]
3481b9a4:	e3520000 	cmp	r2, #0
3481b9a8:	12866001 	addne	r6, r6, #1
				++dp;
			*sp++ = *dp;
3481b9ac:	e4d62001 	ldrb	r2, [r6], #1
3481b9b0:	e4c32001 	strb	r2, [r3], #1
			continue;
		}
		*dp++ = '\0';	/* terminate name */

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481b9b4:	e5d62000 	ldrb	r2, [r6]
3481b9b8:	e3520000 	cmp	r2, #0
3481b9bc:	0a000001 	beq	3481b9c8 <himport_r+0x21c>
3481b9c0:	e152000a 	cmp	r2, sl
3481b9c4:	1afffff3 	bne	3481b998 <himport_r+0x1ec>
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
3481b9c8:	e3a02000 	mov	r2, #0
3481b9cc:	e5c32000 	strb	r2, [r3]
		++dp;

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481b9d0:	e1a00005 	mov	r0, r5
3481b9d4:	e59b1008 	ldr	r1, [fp, #8]
3481b9d8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481b9dc:	ebfffd20 	bl	3481ae64 <drop_var_from_set>
3481b9e0:	e3500000 	cmp	r0, #0
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
		++dp;
3481b9e4:	e2866001 	add	r6, r6, #1

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481b9e8:	0a000028 	beq	3481ba90 <himport_r+0x2e4>
		/* enter into hash table */
		e.key = name;
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b9ec:	e59b3010 	ldr	r3, [fp, #16]
		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
3481b9f0:	e50b5028 	str	r5, [fp, #-40]	; 0x28
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b9f4:	e3530000 	cmp	r3, #0
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
		e.data = value;
3481b9f8:	e50b7024 	str	r7, [fp, #-36]	; 0x24

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b9fc:	0a000012 	beq	3481ba4c <himport_r+0x2a0>
3481ba00:	e594300c 	ldr	r3, [r4, #12]
3481ba04:	e3530000 	cmp	r3, #0
3481ba08:	0a00000f 	beq	3481ba4c <himport_r+0x2a0>
				" for  %s\n", name);
			/*
			 * Search for variable in existing env, so to pass
			 * its previous value to the apply callback
			 */
			hsearch_r(e, FIND, &rv, htab);
3481ba0c:	e58d4000 	str	r4, [sp]
3481ba10:	e24b3028 	sub	r3, fp, #40	; 0x28
3481ba14:	e8930003 	ldm	r3, {r0, r1}
3481ba18:	e3a02000 	mov	r2, #0
3481ba1c:	e24b3020 	sub	r3, fp, #32
3481ba20:	ebfffdd0 	bl	3481b168 <hsearch_r>
			debug("previous value was %s\n", rv ? rv->data : "");
			if (htab->apply(name, rv ? rv->data : NULL,
3481ba24:	e51b1020 	ldr	r1, [fp, #-32]
3481ba28:	e594c00c 	ldr	ip, [r4, #12]
3481ba2c:	e3510000 	cmp	r1, #0
3481ba30:	15911004 	ldrne	r1, [r1, #4]
3481ba34:	e1a00005 	mov	r0, r5
3481ba38:	e1a02007 	mov	r2, r7
3481ba3c:	e59b3004 	ldr	r3, [fp, #4]
3481ba40:	e12fff3c 	blx	ip
3481ba44:	e3500000 	cmp	r0, #0
3481ba48:	1a000010 	bne	3481ba90 <himport_r+0x2e4>
					" variable %s, skipping it!\n", name);
				continue;
			}
		}

		hsearch_r(e, ENTER, &rv, htab);
3481ba4c:	e58d4000 	str	r4, [sp]
3481ba50:	e24b3028 	sub	r3, fp, #40	; 0x28
3481ba54:	e8930003 	ldm	r3, {r0, r1}
3481ba58:	e3a02001 	mov	r2, #1
3481ba5c:	e24b3020 	sub	r3, fp, #32
3481ba60:	ebfffdc0 	bl	3481b168 <hsearch_r>
		if (rv == NULL) {
3481ba64:	e51b3020 	ldr	r3, [fp, #-32]
3481ba68:	e3530000 	cmp	r3, #0
3481ba6c:	1a000007 	bne	3481ba90 <himport_r+0x2e4>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
3481ba70:	e59f0090 	ldr	r0, [pc, #144]	; 3481bb08 <himport_r+0x35c>
3481ba74:	e1a01005 	mov	r1, r5
3481ba78:	e1a02007 	mov	r2, r7
3481ba7c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
3481ba80:	ebffb810 	bl	34809ac8 <printf>
				name, value);
			return 0;
3481ba84:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
3481ba88:	e1a00003 	mov	r0, r3
3481ba8c:	ea00001a 	b	3481bafc <himport_r+0x350>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481ba90:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481ba94:	e1560002 	cmp	r6, r2
3481ba98:	2a000002 	bcs	3481baa8 <himport_r+0x2fc>
3481ba9c:	e5d63000 	ldrb	r3, [r6]
3481baa0:	e3530000 	cmp	r3, #0
3481baa4:	1affff81 	bne	3481b8b0 <himport_r+0x104>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481baa8:	e1a00009 	mov	r0, r9
3481baac:	ebffb943 	bl	34809fc0 <free>

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bab0:	e3a06000 	mov	r6, #0
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481bab4:	e51b5030 	ldr	r5, [fp, #-48]	; 0x30

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bab8:	ea00000b 	b	3481baec <himport_r+0x340>
		if (localvars[i] == NULL)
3481babc:	e4950004 	ldr	r0, [r5], #4
3481bac0:	e3500000 	cmp	r0, #0
3481bac4:	0a000007 	beq	3481bae8 <himport_r+0x33c>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, do_apply) == 0)
3481bac8:	e1a01004 	mov	r1, r4
3481bacc:	e59b2010 	ldr	r2, [fp, #16]
3481bad0:	ebfffe5d 	bl	3481b44c <hdelete_r>
3481bad4:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
3481bad8:	059f002c 	ldreq	r0, [pc, #44]	; 3481bb0c <himport_r+0x360>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
3481badc:	159f002c 	ldrne	r0, [pc, #44]	; 3481bb10 <himport_r+0x364>
3481bae0:	e5151004 	ldr	r1, [r5, #-4]
3481bae4:	ebffb7f7 	bl	34809ac8 <printf>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bae8:	e2866001 	add	r6, r6, #1
3481baec:	e59b3008 	ldr	r3, [fp, #8]
3481baf0:	e1560003 	cmp	r6, r3
3481baf4:	bafffff0 	blt	3481babc <himport_r+0x310>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
3481baf8:	e3a00001 	mov	r0, #1
}
3481bafc:	e24bd01c 	sub	sp, fp, #28
3481bb00:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481bb04:	3482bba0 	.word	0x3482bba0
3481bb08:	34827ef1 	.word	0x34827ef1
3481bb0c:	34827f22 	.word	0x34827f22
3481bb10:	34827f59 	.word	0x34827f59

3481bb14 <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481bb14:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481bb18:	e1a05001 	mov	r5, r1
3481bb1c:	e1a04000 	mov	r4, r0
  ldiv_t result;

  result.quot = numer / denom;
3481bb20:	e1a00001 	mov	r0, r1
3481bb24:	e1a01002 	mov	r1, r2
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481bb28:	e1a07002 	mov	r7, r2
  ldiv_t result;

  result.quot = numer / denom;
3481bb2c:	eb0010a8 	bl	3481fdd4 <__divsi3>
  result.rem = numer % denom;
3481bb30:	e1a01007 	mov	r1, r7
ldiv_t
ldiv (long int numer, long int denom)
{
  ldiv_t result;

  result.quot = numer / denom;
3481bb34:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
3481bb38:	e1a00005 	mov	r0, r5
3481bb3c:	eb00112c 	bl	3481fff4 <__aeabi_idivmod>
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
3481bb40:	e3550000 	cmp	r5, #0
3481bb44:	ba000002 	blt	3481bb54 <ldiv+0x40>
3481bb48:	e3510000 	cmp	r1, #0
    {
      ++result.quot;
3481bb4c:	b2866001 	addlt	r6, r6, #1
      result.rem -= denom;
3481bb50:	b0671001 	rsblt	r1, r7, r1
3481bb54:	e5846000 	str	r6, [r4]
3481bb58:	e5841004 	str	r1, [r4, #4]
    }

  return result;
}
3481bb5c:	e1a00004 	mov	r0, r4
3481bb60:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481bb64 <lmb_add_region>:
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481bb64:	e590c000 	ldr	ip, [r0]
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
3481bb68:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481bb6c:	e35c0001 	cmp	ip, #1
3481bb70:	1a000005 	bne	3481bb8c <lmb_add_region+0x28>
3481bb74:	e590500c 	ldr	r5, [r0, #12]
3481bb78:	e3550000 	cmp	r5, #0
		rgn->region[0].base = base;
3481bb7c:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
3481bb80:	0580200c 	streq	r2, [r0, #12]
		return 0;
3481bb84:	01a00005 	moveq	r0, r5
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481bb88:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3481bb8c:	e1a04000 	mov	r4, r0
static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
		return 1;
	else if (base1 == base2 + size2)
3481bb90:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bb94:	e0827001 	add	r7, r2, r1
3481bb98:	ea000019 	b	3481bc04 <lmb_add_region+0xa0>
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
		phys_addr_t rgnbase = rgn->region[i].base;
3481bb9c:	e5946008 	ldr	r6, [r4, #8]
		phys_size_t rgnsize = rgn->region[i].size;
3481bba0:	e594500c 	ldr	r5, [r4, #12]

		if ((rgnbase == base) && (rgnsize == size))
3481bba4:	e1550002 	cmp	r5, r2
3481bba8:	01560001 	cmpeq	r6, r1
3481bbac:	0a000054 	beq	3481bd04 <lmb_add_region+0x1a0>
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bbb0:	e1560007 	cmp	r6, r7
3481bbb4:	0a000005 	beq	3481bbd0 <lmb_add_region+0x6c>
		return 1;
	else if (base1 == base2 + size2)
3481bbb8:	e0856006 	add	r6, r5, r6
3481bbbc:	e1510006 	cmp	r1, r6
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bbc0:	e2844008 	add	r4, r4, #8
3481bbc4:	e2836001 	add	r6, r3, #1
		return 1;
	else if (base1 == base2 + size2)
3481bbc8:	1a000051 	bne	3481bd14 <lmb_add_region+0x1b0>
3481bbcc:	ea000007 	b	3481bbf0 <lmb_add_region+0x8c>
			/* Already have this region, so we're done */
			return 0;

		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
		if ( adjacent > 0 ) {
			rgn->region[i].base -= size;
3481bbd0:	e2834001 	add	r4, r3, #1
3481bbd4:	e0627007 	rsb	r7, r2, r7
3481bbd8:	e7807184 	str	r7, [r0, r4, lsl #3]
			rgn->region[i].size += size;
3481bbdc:	e0804184 	add	r4, r0, r4, lsl #3
3481bbe0:	e5945004 	ldr	r5, [r4, #4]
3481bbe4:	e0825005 	add	r5, r2, r5
3481bbe8:	e5845004 	str	r5, [r4, #4]
3481bbec:	ea000002 	b	3481bbfc <lmb_add_region+0x98>
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
			rgn->region[i].size += size;
3481bbf0:	e0806186 	add	r6, r0, r6, lsl #3
3481bbf4:	e0855002 	add	r5, r5, r2
3481bbf8:	e5865004 	str	r5, [r6, #4]
			coalesced++;
3481bbfc:	e3a05001 	mov	r5, #1
			break;
3481bc00:	ea000002 	b	3481bc10 <lmb_add_region+0xac>
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481bc04:	e153000c 	cmp	r3, ip
3481bc08:	3affffe3 	bcc	3481bb9c <lmb_add_region+0x38>
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
3481bc0c:	e3a05000 	mov	r5, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
3481bc10:	e24c4001 	sub	r4, ip, #1
3481bc14:	e1530004 	cmp	r3, r4
3481bc18:	2a00001e 	bcs	3481bc98 <lmb_add_region+0x134>
3481bc1c:	e2836001 	add	r6, r3, #1

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
3481bc20:	e080a186 	add	sl, r0, r6, lsl #3
}

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
3481bc24:	e7907186 	ldr	r7, [r0, r6, lsl #3]
	phys_size_t size1 = rgn->region[r1].size;
3481bc28:	e59ab004 	ldr	fp, [sl, #4]
	phys_addr_t base2 = rgn->region[r2].base;
3481bc2c:	e2866001 	add	r6, r6, #1
3481bc30:	e790a186 	ldr	sl, [r0, r6, lsl #3]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bc34:	e08b9007 	add	r9, fp, r7
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481bc38:	e0806186 	add	r6, r0, r6, lsl #3
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bc3c:	e15a0009 	cmp	sl, r9
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481bc40:	e5966004 	ldr	r6, [r6, #4]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bc44:	0a000002 	beq	3481bc54 <lmb_add_region+0xf0>
		return 1;
	else if (base1 == base2 + size2)
3481bc48:	e086a00a 	add	sl, r6, sl
3481bc4c:	e157000a 	cmp	r7, sl
3481bc50:	1a000010 	bne	3481bc98 <lmb_add_region+0x134>

/* Assumption: base addr of region 1 < base addr of region 2 */
static void lmb_coalesce_regions(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	rgn->region[r1].size += rgn->region[r2].size;
3481bc54:	e0802183 	add	r2, r0, r3, lsl #3
3481bc58:	e086600b 	add	r6, r6, fp
3481bc5c:	e582600c 	str	r6, [r2, #12]
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481bc60:	e2832003 	add	r2, r3, #3
3481bc64:	e0802182 	add	r2, r0, r2, lsl #3
3481bc68:	ea000003 	b	3481bc7c <lmb_add_region+0x118>
static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
		rgn->region[i].base = rgn->region[i + 1].base;
3481bc6c:	e5121008 	ldr	r1, [r2, #-8]
3481bc70:	e5021010 	str	r1, [r2, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481bc74:	e5121004 	ldr	r1, [r2, #-4]
3481bc78:	e502100c 	str	r1, [r2, #-12]
3481bc7c:	e2833001 	add	r3, r3, #1

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bc80:	e1530004 	cmp	r3, r4
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
3481bc84:	e2822008 	add	r2, r2, #8

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bc88:	3afffff7 	bcc	3481bc6c <lmb_add_region+0x108>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481bc8c:	e5804000 	str	r4, [r0]
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
3481bc90:	e2850001 	add	r0, r5, #1
3481bc94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
3481bc98:	e3550000 	cmp	r5, #0
3481bc9c:	13a00001 	movne	r0, #1
3481bca0:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481bca4:	e35c0007 	cmp	ip, #7
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481bca8:	928c3001 	addls	r3, ip, #1
3481bcac:	90803183 	addls	r3, r0, r3, lsl #3
		coalesced++;
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481bcb0:	9a00000b 	bls	3481bce4 <lmb_add_region+0x180>
3481bcb4:	ea000014 	b	3481bd0c <lmb_add_region+0x1a8>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
		if (base < rgn->region[i].base) {
3481bcb8:	e5335008 	ldr	r5, [r3, #-8]!
3481bcbc:	e1510005 	cmp	r1, r5
			rgn->region[i+1].base = rgn->region[i].base;
3481bcc0:	35835008 	strcc	r5, [r3, #8]
			rgn->region[i+1].size = rgn->region[i].size;
3481bcc4:	35935004 	ldrcc	r5, [r3, #4]
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481bcc8:	32444001 	subcc	r4, r4, #1
		if (base < rgn->region[i].base) {
			rgn->region[i+1].base = rgn->region[i].base;
			rgn->region[i+1].size = rgn->region[i].size;
3481bccc:	3583500c 	strcc	r5, [r3, #12]
		} else {
			rgn->region[i+1].base = base;
3481bcd0:	22844002 	addcs	r4, r4, #2
3481bcd4:	27801184 	strcs	r1, [r0, r4, lsl #3]
			rgn->region[i+1].size = size;
3481bcd8:	20804184 	addcs	r4, r0, r4, lsl #3
3481bcdc:	25842004 	strcs	r2, [r4, #4]
			break;
3481bce0:	2a000001 	bcs	3481bcec <lmb_add_region+0x188>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481bce4:	e3540000 	cmp	r4, #0
3481bce8:	aafffff2 	bge	3481bcb8 <lmb_add_region+0x154>
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481bcec:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
3481bcf0:	e28cc001 	add	ip, ip, #1
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481bcf4:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
3481bcf8:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
3481bcfc:	3580200c 	strcc	r2, [r0, #12]
	}

	rgn->cnt++;
3481bd00:	e580c000 	str	ip, [r0]
		phys_addr_t rgnbase = rgn->region[i].base;
		phys_size_t rgnsize = rgn->region[i].size;

		if ((rgnbase == base) && (rgnsize == size))
			/* Already have this region, so we're done */
			return 0;
3481bd04:	e3a00000 	mov	r0, #0
3481bd08:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;
3481bd0c:	e3e00000 	mvn	r0, #0
	}

	rgn->cnt++;

	return 0;
}
3481bd10:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481bd14:	e1a03006 	mov	r3, r6
3481bd18:	eaffffb9 	b	3481bc04 <lmb_add_region+0xa0>

3481bd1c <lmb_dump_all>:
			(long long unsigned)lmb->reserved.region[i].base);
		debug("		     .size = 0x%llx\n",
			(long long unsigned)lmb->reserved.region[i].size);
	}
#endif /* DEBUG */
}
3481bd1c:	e12fff1e 	bx	lr

3481bd20 <lmb_init>:
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481bd20:	e3a03000 	mov	r3, #0
	lmb->memory.region[0].size = 0;
	lmb->memory.cnt = 1;
3481bd24:	e3a02001 	mov	r2, #1
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481bd28:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
3481bd2c:	e580300c 	str	r3, [r0, #12]
	lmb->memory.cnt = 1;
3481bd30:	e880000c 	stm	r0, {r2, r3}
	lmb->memory.size = 0;

	/* Ditto. */
	lmb->reserved.region[0].base = 0;
3481bd34:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
3481bd38:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
3481bd3c:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
3481bd40:	e5803054 	str	r3, [r0, #84]	; 0x54
}
3481bd44:	e12fff1e 	bx	lr

3481bd48 <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
3481bd48:	eaffff85 	b	3481bb64 <lmb_add_region>

3481bd4c <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
3481bd4c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481bd50:	e3a04000 	mov	r4, #0

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
3481bd54:	e082c001 	add	ip, r2, r1
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481bd58:	e5907050 	ldr	r7, [r0, #80]	; 0x50
3481bd5c:	e1a06000 	mov	r6, r0
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */
3481bd60:	e1a03004 	mov	r3, r4
3481bd64:	e1a05004 	mov	r5, r4

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481bd68:	ea000007 	b	3481bd8c <lmb_free+0x40>
		rgnbegin = rgn->region[i].base;
3481bd6c:	e5965058 	ldr	r5, [r6, #88]	; 0x58
		rgnend = rgnbegin + rgn->region[i].size;
3481bd70:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
3481bd74:	e2866008 	add	r6, r6, #8
3481bd78:	e0853003 	add	r3, r5, r3

		if ((rgnbegin <= base) && (end <= rgnend))
3481bd7c:	e15c0003 	cmp	ip, r3
3481bd80:	91550001 	cmpls	r5, r1
3481bd84:	9a000003 	bls	3481bd98 <lmb_free+0x4c>
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481bd88:	e2844001 	add	r4, r4, #1
3481bd8c:	e1540007 	cmp	r4, r7
3481bd90:	e1a0a004 	mov	sl, r4
3481bd94:	3afffff4 	bcc	3481bd6c <lmb_free+0x20>
		if ((rgnbegin <= base) && (end <= rgnend))
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
3481bd98:	e1540007 	cmp	r4, r7
3481bd9c:	0a000032 	beq	3481be6c <lmb_free+0x120>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
3481bda0:	e1550001 	cmp	r5, r1
3481bda4:	13a05000 	movne	r5, #0
3481bda8:	03a05001 	moveq	r5, #1
3481bdac:	e153000c 	cmp	r3, ip
3481bdb0:	13a06000 	movne	r6, #0
3481bdb4:	03a06001 	moveq	r6, #1
3481bdb8:	e0169005 	ands	r9, r6, r5
3481bdbc:	0a00000e 	beq	3481bdfc <lmb_free+0xb0>
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
3481bdc0:	e284400c 	add	r4, r4, #12
3481bdc4:	e0804184 	add	r4, r0, r4, lsl #3

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bdc8:	e2477001 	sub	r7, r7, #1
3481bdcc:	ea000004 	b	3481bde4 <lmb_free+0x98>
		rgn->region[i].base = rgn->region[i + 1].base;
3481bdd0:	e5143008 	ldr	r3, [r4, #-8]
3481bdd4:	e28aa001 	add	sl, sl, #1
3481bdd8:	e5043010 	str	r3, [r4, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481bddc:	e5143004 	ldr	r3, [r4, #-4]
3481bde0:	e504300c 	str	r3, [r4, #-12]

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bde4:	e15a0007 	cmp	sl, r7
3481bde8:	e2844008 	add	r4, r4, #8
3481bdec:	3afffff7 	bcc	3481bdd0 <lmb_free+0x84>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481bdf0:	e5807050 	str	r7, [r0, #80]	; 0x50
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
		lmb_remove_region(rgn, i);
		return 0;
3481bdf4:	e3a00000 	mov	r0, #0
3481bdf8:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
3481bdfc:	e3550000 	cmp	r5, #0
3481be00:	0a000007 	beq	3481be24 <lmb_free+0xd8>
		rgn->region[i].base = end;
3481be04:	e284400b 	add	r4, r4, #11
3481be08:	e780c184 	str	ip, [r0, r4, lsl #3]
		rgn->region[i].size -= size;
3481be0c:	e0800184 	add	r0, r0, r4, lsl #3
3481be10:	e5903004 	ldr	r3, [r0, #4]
3481be14:	e0622003 	rsb	r2, r2, r3
3481be18:	e5802004 	str	r2, [r0, #4]
		return 0;
3481be1c:	e1a00009 	mov	r0, r9
3481be20:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
3481be24:	e3560000 	cmp	r6, #0
3481be28:	e284400b 	add	r4, r4, #11
3481be2c:	0a000005 	beq	3481be48 <lmb_free+0xfc>
		rgn->region[i].size -= size;
3481be30:	e0804184 	add	r4, r0, r4, lsl #3
3481be34:	e5943004 	ldr	r3, [r4, #4]
		return 0;
3481be38:	e1a00005 	mov	r0, r5
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
		rgn->region[i].size -= size;
3481be3c:	e0622003 	rsb	r2, r2, r3
3481be40:	e5842004 	str	r2, [r4, #4]
		return 0;
3481be44:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481be48:	e0802184 	add	r2, r0, r4, lsl #3
3481be4c:	e7904184 	ldr	r4, [r0, r4, lsl #3]
	return lmb_add_region(rgn, end, rgnend - end);
3481be50:	e2800050 	add	r0, r0, #80	; 0x50

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481be54:	e0641001 	rsb	r1, r4, r1
3481be58:	e5821004 	str	r1, [r2, #4]
	return lmb_add_region(rgn, end, rgnend - end);
3481be5c:	e1a0100c 	mov	r1, ip
3481be60:	e06c2003 	rsb	r2, ip, r3
}
3481be64:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
3481be68:	eaffff3d 	b	3481bb64 <lmb_add_region>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
		return -1;
3481be6c:	e3e00000 	mvn	r0, #0
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
}
3481be70:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3481be74 <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
3481be74:	e2800050 	add	r0, r0, #80	; 0x50
3481be78:	eaffff39 	b	3481bb64 <lmb_add_region>

3481be7c <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
3481be7c:	e92d4030 	push	{r4, r5, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481be80:	e590c000 	ldr	ip, [r0]
3481be84:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481be88:	e0822001 	add	r2, r2, r1
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481be8c:	ea000008 	b	3481beb4 <lmb_overlaps_region+0x38>
		phys_addr_t rgnbase = rgn->region[i].base;
3481be90:	e5904008 	ldr	r4, [r0, #8]
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481be94:	e590500c 	ldr	r5, [r0, #12]
3481be98:	e0845005 	add	r5, r4, r5
3481be9c:	e1510005 	cmp	r1, r5
3481bea0:	2a000007 	bcs	3481bec4 <lmb_overlaps_region+0x48>
3481bea4:	e1540002 	cmp	r4, r2
3481bea8:	2a000005 	bcs	3481bec4 <lmb_overlaps_region+0x48>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481beac:	e1a00003 	mov	r0, r3
3481beb0:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481beb4:	e153000c 	cmp	r3, ip
3481beb8:	3afffff4 	bcc	3481be90 <lmb_overlaps_region+0x14>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481bebc:	e3e00000 	mvn	r0, #0
}
3481bec0:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481bec4:	e2833001 	add	r3, r3, #1
3481bec8:	e2800008 	add	r0, r0, #8
3481becc:	eafffff8 	b	3481beb4 <lmb_overlaps_region+0x38>

3481bed0 <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481bed0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481bed4:	e5907000 	ldr	r7, [r0]
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481bed8:	e1a09003 	mov	r9, r3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481bedc:	e2803050 	add	r3, r0, #80	; 0x50
3481bee0:	e58d300c 	str	r3, [sp, #12]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481bee4:	e2623000 	rsb	r3, r2, #0
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481bee8:	e1a0c002 	mov	ip, r2
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481beec:	e247b001 	sub	fp, r7, #1
3481bef0:	e1a02003 	mov	r2, r3
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481bef4:	e2877001 	add	r7, r7, #1
{
3481bef8:	e1a04001 	mov	r4, r1
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481befc:	e0807187 	add	r7, r0, r7, lsl #3
3481bf00:	e1a03000 	mov	r3, r0
3481bf04:	e1a05002 	mov	r5, r2
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481bf08:	ea000036 	b	3481bfe8 <__lmb_alloc_base+0x118>
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;
3481bf0c:	e5176004 	ldr	r6, [r7, #-4]
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
		phys_addr_t lmbbase = lmb->memory.region[i].base;
3481bf10:	e517a008 	ldr	sl, [r7, #-8]
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
3481bf14:	e1560004 	cmp	r6, r4
3481bf18:	3a000030 	bcc	3481bfe0 <__lmb_alloc_base+0x110>
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481bf1c:	e3590000 	cmp	r9, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
3481bf20:	0086600a 	addeq	r6, r6, sl
3481bf24:	00646006 	rsbeq	r6, r4, r6
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481bf28:	0a000005 	beq	3481bf44 <__lmb_alloc_base+0x74>
			base = lmb_align_down(lmbbase + lmbsize - size, align);
		else if (lmbbase < max_addr) {
3481bf2c:	e15a0009 	cmp	sl, r9
3481bf30:	2a00002a 	bcs	3481bfe0 <__lmb_alloc_base+0x110>
			base = min(lmbbase + lmbsize, max_addr);
3481bf34:	e086600a 	add	r6, r6, sl
			base = lmb_align_down(base - size, align);
3481bf38:	e1590006 	cmp	r9, r6
3481bf3c:	90646009 	rsbls	r6, r4, r9
3481bf40:	80646006 	rsbhi	r6, r4, r6
3481bf44:	e58db008 	str	fp, [sp, #8]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481bf48:	e0066005 	and	r6, r6, r5
3481bf4c:	e1a0b007 	mov	fp, r7
3481bf50:	e1a07003 	mov	r7, r3
3481bf54:	ea000017 	b	3481bfb8 <__lmb_alloc_base+0xe8>
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481bf58:	e59d000c 	ldr	r0, [sp, #12]
3481bf5c:	e1a01006 	mov	r1, r6
3481bf60:	e1a02004 	mov	r2, r4
3481bf64:	e58dc004 	str	ip, [sp, #4]
3481bf68:	ebffffc3 	bl	3481be7c <lmb_overlaps_region>
			if (j < 0) {
3481bf6c:	e3500000 	cmp	r0, #0
3481bf70:	e59dc004 	ldr	ip, [sp, #4]
3481bf74:	aa000009 	bge	3481bfa0 <__lmb_alloc_base+0xd0>
	return addr & ~(size - 1);
}

static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
3481bf78:	e2444001 	sub	r4, r4, #1
3481bf7c:	e26c2000 	rsb	r2, ip, #0
3481bf80:	e084c00c 	add	ip, r4, ip

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
			if (j < 0) {
				/* This area isn't reserved, take it */
				if (lmb_add_region(&lmb->reserved, base,
3481bf84:	e1a01006 	mov	r1, r6
3481bf88:	e59d000c 	ldr	r0, [sp, #12]
3481bf8c:	e002200c 	and	r2, r2, ip
3481bf90:	ebfffef3 	bl	3481bb64 <lmb_add_region>
							lmb_align_up(size,
								align)) < 0)
					return 0;
3481bf94:	e3500000 	cmp	r0, #0
3481bf98:	b3a06000 	movlt	r6, #0
3481bf9c:	ea000014 	b	3481bff4 <__lmb_alloc_base+0x124>
				return base;
			}
			res_base = lmb->reserved.region[j].base;
3481bfa0:	e280000b 	add	r0, r0, #11
3481bfa4:	e7976180 	ldr	r6, [r7, r0, lsl #3]
			if (res_base < size)
3481bfa8:	e1560004 	cmp	r6, r4
3481bfac:	3a000008 	bcc	3481bfd4 <__lmb_alloc_base+0x104>
				break;
			base = lmb_align_down(res_base - size, align);
3481bfb0:	e0646006 	rsb	r6, r4, r6
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481bfb4:	e0056006 	and	r6, r5, r6
			base = min(lmbbase + lmbsize, max_addr);
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
3481bfb8:	e15a0006 	cmp	sl, r6
3481bfbc:	83a02000 	movhi	r2, #0
3481bfc0:	93a02001 	movls	r2, #1
3481bfc4:	e3560000 	cmp	r6, #0
3481bfc8:	03a02000 	moveq	r2, #0
3481bfcc:	e3520000 	cmp	r2, #0
3481bfd0:	1affffe0 	bne	3481bf58 <__lmb_alloc_base+0x88>
3481bfd4:	e1a03007 	mov	r3, r7
3481bfd8:	e1a0700b 	mov	r7, fp
3481bfdc:	e59db008 	ldr	fp, [sp, #8]
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481bfe0:	e24bb001 	sub	fp, fp, #1
3481bfe4:	e2477008 	sub	r7, r7, #8
3481bfe8:	e35b0000 	cmp	fp, #0
3481bfec:	aaffffc6 	bge	3481bf0c <__lmb_alloc_base+0x3c>
			if (res_base < size)
				break;
			base = lmb_align_down(res_base - size, align);
		}
	}
	return 0;
3481bff0:	e3a06000 	mov	r6, #0
}
3481bff4:	e1a00006 	mov	r0, r6
3481bff8:	e28dd010 	add	sp, sp, #16
3481bffc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481c000 <lmb_alloc_base>:
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
}

phys_addr_t lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481c000:	e92d4070 	push	{r4, r5, r6, lr}
3481c004:	e1a05001 	mov	r5, r1
3481c008:	e1a04003 	mov	r4, r3
	phys_addr_t alloc;

	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
3481c00c:	ebffffaf 	bl	3481bed0 <__lmb_alloc_base>

	if (alloc == 0)
3481c010:	e2506000 	subs	r6, r0, #0
3481c014:	1a000003 	bne	3481c028 <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
3481c018:	e59f0010 	ldr	r0, [pc, #16]	; 3481c030 <lmb_alloc_base+0x30>
3481c01c:	e1a01005 	mov	r1, r5
3481c020:	e1a02004 	mov	r2, r4
3481c024:	ebffb6a7 	bl	34809ac8 <printf>
		      (ulong)size, (ulong)max_addr);

	return alloc;
}
3481c028:	e1a00006 	mov	r0, r6
3481c02c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c030:	34827f8a 	.word	0x34827f8a

3481c034 <lmb_alloc>:
	return (i < rgn->cnt) ? i : -1;
}

phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
3481c034:	e3a03000 	mov	r3, #0
3481c038:	eafffff0 	b	3481c000 <lmb_alloc_base>

3481c03c <lmb_is_reserved>:
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
3481c03c:	e92d4010 	push	{r4, lr}
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481c040:	e590c050 	ldr	ip, [r0, #80]	; 0x50
3481c044:	e3a03000 	mov	r3, #0
3481c048:	ea00000d 	b	3481c084 <lmb_is_reserved+0x48>
		}
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
3481c04c:	e1a04000 	mov	r4, r0
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
3481c050:	e5902058 	ldr	r2, [r0, #88]	; 0x58
3481c054:	e594405c 	ldr	r4, [r4, #92]	; 0x5c
3481c058:	e2800008 	add	r0, r0, #8
3481c05c:	e0824004 	add	r4, r2, r4
3481c060:	e2444001 	sub	r4, r4, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
3481c064:	e1510004 	cmp	r1, r4
3481c068:	83a04000 	movhi	r4, #0
3481c06c:	93a04001 	movls	r4, #1
3481c070:	e1510002 	cmp	r1, r2
3481c074:	33a04000 	movcc	r4, #0
3481c078:	e3540000 	cmp	r4, #0
3481c07c:	1a000004 	bne	3481c094 <lmb_is_reserved+0x58>

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481c080:	e2833001 	add	r3, r3, #1
3481c084:	e153000c 	cmp	r3, ip
3481c088:	3affffef 	bcc	3481c04c <lmb_is_reserved+0x10>
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
	}
	return 0;
3481c08c:	e3a00000 	mov	r0, #0
3481c090:	e8bd8010 	pop	{r4, pc}

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
3481c094:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3481c098:	e8bd8010 	pop	{r4, pc}

3481c09c <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific board_lmb_reserve() */
}
3481c09c:	e12fff1e 	bx	lr

3481c0a0 <__arch_lmb_reserve>:
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific arch_lmb_reserve() */
}
3481c0a0:	e12fff1e 	bx	lr

3481c0a4 <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
3481c0a4:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481c0a8:	e2504000 	subs	r4, r0, #0
		return(0);
3481c0ac:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481c0b0:	0a000014 	beq	3481c108 <string_to_ip+0x64>
3481c0b4:	e3a06004 	mov	r6, #4
3481c0b8:	e3a05000 	mov	r5, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
3481c0bc:	e08d7006 	add	r7, sp, r6
3481c0c0:	e3540000 	cmp	r4, #0
3481c0c4:	01a00004 	moveq	r0, r4
3481c0c8:	0a000003 	beq	3481c0dc <string_to_ip+0x38>
3481c0cc:	e1a00004 	mov	r0, r4
3481c0d0:	e1a01007 	mov	r1, r7
3481c0d4:	e3a0200a 	mov	r2, #10
3481c0d8:	eb000441 	bl	3481d1e4 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
3481c0dc:	e20000ff 	and	r0, r0, #255	; 0xff
		if (s) {
3481c0e0:	e3540000 	cmp	r4, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
3481c0e4:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
3481c0e8:	0a000003 	beq	3481c0fc <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
3481c0ec:	e59d4004 	ldr	r4, [sp, #4]
3481c0f0:	e5d43000 	ldrb	r3, [r4]
3481c0f4:	e3530000 	cmp	r3, #0
3481c0f8:	12844001 	addne	r4, r4, #1
	int i;

	if (s == NULL)
		return(0);

	for (addr=0, i=0; i<4; ++i) {
3481c0fc:	e2566001 	subs	r6, r6, #1
3481c100:	1affffee 	bne	3481c0c0 <string_to_ip+0x1c>
3481c104:	e6bf0f35 	rev	r0, r5
			s = (*e) ? e+1 : e;
		}
	}

	return (htonl(addr));
}
3481c108:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481c10c <qsort>:

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481c10c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481c110:	e3520000 	cmp	r2, #0
3481c114:	13510001 	cmpne	r1, #1

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481c118:	e58d0008 	str	r0, [sp, #8]
3481c11c:	e1a06001 	mov	r6, r1
3481c120:	e58d300c 	str	r3, [sp, #12]
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481c124:	e1a04002 	mov	r4, r2
3481c128:	9a000031 	bls	3481c1f4 <qsort+0xe8>
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481c12c:	e2410001 	sub	r0, r1, #1
3481c130:	e3a01003 	mov	r1, #3
3481c134:	eb000ea3 	bl	3481fbc8 <__udivsi3>
3481c138:	e3a05000 	mov	r5, #0

	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
3481c13c:	e0855085 	add	r5, r5, r5, lsl #1
3481c140:	e2855001 	add	r5, r5, #1
		} while (wgap < (nel-1)/3);
3481c144:	e1550000 	cmp	r5, r0
3481c148:	3afffffb 	bcc	3481c13c <qsort+0x30>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481c14c:	e0060496 	mul	r6, r6, r4
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
3481c150:	e0050594 	mul	r5, r4, r5
		nel *= width;			/* Convert nel to 'wnel' */
3481c154:	e58d6004 	str	r6, [sp, #4]

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481c158:	e2653000 	rsb	r3, r5, #0
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481c15c:	e0859004 	add	r9, r5, r4
	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481c160:	e3a07000 	mov	r7, #0

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481c164:	e1a0b003 	mov	fp, r3
3481c168:	e59d2008 	ldr	r2, [sp, #8]
3481c16c:	e1a03007 	mov	r3, r7
3481c170:	e0826007 	add	r6, r2, r7
3481c174:	e086a005 	add	sl, r6, r5
					register char *b;

					j -= wgap;
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
3481c178:	e58d3000 	str	r3, [sp]
3481c17c:	e1a00006 	mov	r0, r6
3481c180:	e1a0100a 	mov	r1, sl
3481c184:	e59d200c 	ldr	r2, [sp, #12]
3481c188:	e12fff32 	blx	r2
3481c18c:	e3500000 	cmp	r0, #0
3481c190:	e59d3000 	ldr	r3, [sp]
3481c194:	da00000b 	ble	3481c1c8 <qsort+0xbc>
3481c198:	e3a02000 	mov	r2, #0
						break;
					}
					k = width;
					do {
						tmp = *a;
3481c19c:	e7d61002 	ldrb	r1, [r6, r2]
						*a++ = *b;
3481c1a0:	e7da0002 	ldrb	r0, [sl, r2]
3481c1a4:	e7c60002 	strb	r0, [r6, r2]
						*b++ = tmp;
3481c1a8:	e7ca1002 	strb	r1, [sl, r2]
3481c1ac:	e2822001 	add	r2, r2, #1
					} while (--k);
3481c1b0:	e1540002 	cmp	r4, r2
3481c1b4:	1afffff8 	bne	3481c19c <qsort+0x90>
3481c1b8:	e087700b 	add	r7, r7, fp
				} while (j >= wgap);
3481c1bc:	e1770005 	cmn	r7, r5
					k = width;
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
3481c1c0:	e086600b 	add	r6, r6, fp
				} while (j >= wgap);
3481c1c4:	3affffea 	bcc	3481c174 <qsort+0x68>
3481c1c8:	e0899004 	add	r9, r9, r4
				i += width;
			} while (i < nel);
3481c1cc:	e59d2004 	ldr	r2, [sp, #4]
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
3481c1d0:	e0837004 	add	r7, r3, r4
				i += width;
			} while (i < nel);
3481c1d4:	e0643009 	rsb	r3, r4, r9
3481c1d8:	e1530002 	cmp	r3, r2
3481c1dc:	3affffe1 	bcc	3481c168 <qsort+0x5c>
			wgap = (wgap - width)/3;
3481c1e0:	e0640005 	rsb	r0, r4, r5
3481c1e4:	e3a01003 	mov	r1, #3
3481c1e8:	eb000e76 	bl	3481fbc8 <__udivsi3>
		} while (wgap);
3481c1ec:	e2505000 	subs	r5, r0, #0
3481c1f0:	1affffd8 	bne	3481c158 <qsort+0x4c>
	}
}
3481c1f4:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3481c1f8 <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
3481c1f8:	e5900000 	ldr	r0, [r0]
3481c1fc:	e5911000 	ldr	r1, [r1]
3481c200:	ea000030 	b	3481c2c8 <strcmp>

3481c204 <strcpy>:
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
3481c204:	e3a03000 	mov	r3, #0
3481c208:	e7d12003 	ldrb	r2, [r1, r3]
3481c20c:	e3520000 	cmp	r2, #0
3481c210:	e7c02003 	strb	r2, [r0, r3]
3481c214:	e2833001 	add	r3, r3, #1
3481c218:	1afffffa 	bne	3481c208 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
3481c21c:	e12fff1e 	bx	lr

3481c220 <strncpy>:
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
3481c220:	e3a03000 	mov	r3, #0
3481c224:	e3520000 	cmp	r2, #0
3481c228:	012fff1e 	bxeq	lr
3481c22c:	e7d1c003 	ldrb	ip, [r1, r3]
3481c230:	e2422001 	sub	r2, r2, #1
3481c234:	e35c0000 	cmp	ip, #0
3481c238:	e7c0c003 	strb	ip, [r0, r3]
3481c23c:	e2833001 	add	r3, r3, #1
3481c240:	1afffff7 	bne	3481c224 <strncpy+0x4>
		/* nothing */;

	return tmp;
}
3481c244:	e12fff1e 	bx	lr

3481c248 <strcat>:
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
3481c248:	e1a0c000 	mov	ip, r0
3481c24c:	e5dc3000 	ldrb	r3, [ip]
3481c250:	e1a0200c 	mov	r2, ip
3481c254:	e3530000 	cmp	r3, #0
3481c258:	e28cc001 	add	ip, ip, #1
3481c25c:	1afffffa 	bne	3481c24c <strcat+0x4>
		dest++;
	while ((*dest++ = *src++) != '\0')
3481c260:	e7d1c003 	ldrb	ip, [r1, r3]
3481c264:	e35c0000 	cmp	ip, #0
3481c268:	e7c2c003 	strb	ip, [r2, r3]
3481c26c:	e2833001 	add	r3, r3, #1
3481c270:	1afffffa 	bne	3481c260 <strcat+0x18>
		;

	return tmp;
}
3481c274:	e12fff1e 	bx	lr

3481c278 <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
3481c278:	e3520000 	cmp	r2, #0
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
3481c27c:	e92d4010 	push	{r4, lr}
	char *tmp = dest;

	if (count) {
3481c280:	08bd8010 	popeq	{r4, pc}
3481c284:	e1a04000 	mov	r4, r0
3481c288:	e1a0c004 	mov	ip, r4
		while (*dest)
3481c28c:	e4d43001 	ldrb	r3, [r4], #1
3481c290:	e3530000 	cmp	r3, #0
3481c294:	1afffffb 	bne	3481c288 <strncat+0x10>
3481c298:	ea000005 	b	3481c2b4 <strncat+0x3c>
3481c29c:	e2833001 	add	r3, r3, #1
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
3481c2a0:	e1520003 	cmp	r2, r3
3481c2a4:	1a000002 	bne	3481c2b4 <strncat+0x3c>
				*dest = '\0';
3481c2a8:	e3a03000 	mov	r3, #0
3481c2ac:	e5cc3000 	strb	r3, [ip]
				break;
3481c2b0:	e8bd8010 	pop	{r4, pc}
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
3481c2b4:	e7d14003 	ldrb	r4, [r1, r3]
3481c2b8:	e3540000 	cmp	r4, #0
3481c2bc:	e4cc4001 	strb	r4, [ip], #1
3481c2c0:	1afffff5 	bne	3481c29c <strncat+0x24>
			}
		}
	}

	return tmp;
}
3481c2c4:	e8bd8010 	pop	{r4, pc}

3481c2c8 <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
3481c2c8:	e3a03000 	mov	r3, #0
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481c2cc:	e7d0c003 	ldrb	ip, [r0, r3]
3481c2d0:	e7d12003 	ldrb	r2, [r1, r3]
3481c2d4:	e062200c 	rsb	r2, r2, ip
3481c2d8:	e6ef2072 	uxtb	r2, r2
3481c2dc:	e3520000 	cmp	r2, #0
3481c2e0:	1a000002 	bne	3481c2f0 <strcmp+0x28>
3481c2e4:	e35c0000 	cmp	ip, #0
3481c2e8:	e2833001 	add	r3, r3, #1
3481c2ec:	1afffff6 	bne	3481c2cc <strcmp+0x4>
			break;
	}

	return __res;
}
3481c2f0:	e6af0072 	sxtb	r0, r2
3481c2f4:	e12fff1e 	bx	lr

3481c2f8 <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
3481c2f8:	e92d4010 	push	{r4, lr}
	register signed char __res = 0;

	while (count) {
3481c2fc:	e3a03000 	mov	r3, #0
3481c300:	ea000009 	b	3481c32c <strncmp+0x34>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481c304:	e7d04003 	ldrb	r4, [r0, r3]
3481c308:	e7d1c003 	ldrb	ip, [r1, r3]
3481c30c:	e06cc004 	rsb	ip, ip, r4
3481c310:	e6efc07c 	uxtb	ip, ip
3481c314:	e35c0000 	cmp	ip, #0
3481c318:	1a000006 	bne	3481c338 <strncmp+0x40>
3481c31c:	e3540000 	cmp	r4, #0
3481c320:	e2833001 	add	r3, r3, #1
3481c324:	0a000003 	beq	3481c338 <strncmp+0x40>
			break;
		count--;
3481c328:	e2422001 	sub	r2, r2, #1
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
3481c32c:	e3520000 	cmp	r2, #0
3481c330:	1afffff3 	bne	3481c304 <strncmp+0xc>
3481c334:	e1a0c002 	mov	ip, r2
			break;
		count--;
	}

	return __res;
}
3481c338:	e6af007c 	sxtb	r0, ip
3481c33c:	e8bd8010 	pop	{r4, pc}

3481c340 <strchr>:
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
		if (*s == '\0')
			return NULL;
3481c340:	e1a03000 	mov	r3, r0
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c344:	e6ef1071 	uxtb	r1, r1
3481c348:	ea000001 	b	3481c354 <strchr+0x14>
		if (*s == '\0')
3481c34c:	e3520000 	cmp	r2, #0
3481c350:	0a000005 	beq	3481c36c <strchr+0x2c>
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c354:	e5d32000 	ldrb	r2, [r3]
		if (*s == '\0')
3481c358:	e1a00003 	mov	r0, r3
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c35c:	e1520001 	cmp	r2, r1
3481c360:	e2833001 	add	r3, r3, #1
3481c364:	1afffff8 	bne	3481c34c <strchr+0xc>
3481c368:	e12fff1e 	bx	lr
		if (*s == '\0')
			return NULL;
3481c36c:	e1a00002 	mov	r0, r2
	return (char *) s;
}
3481c370:	e12fff1e 	bx	lr

3481c374 <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
3481c374:	e59f2018 	ldr	r2, [pc, #24]	; 3481c394 <skip_spaces+0x20>
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
3481c378:	e1a03000 	mov	r3, r0
	while (isspace(*str))
3481c37c:	e1a00003 	mov	r0, r3
3481c380:	e4d31001 	ldrb	r1, [r3], #1
3481c384:	e7d21001 	ldrb	r1, [r2, r1]
3481c388:	e3110020 	tst	r1, #32
3481c38c:	1afffffa 	bne	3481c37c <skip_spaces+0x8>
		++str;
	return (char *)str;
}
3481c390:	e12fff1e 	bx	lr
3481c394:	34821cf4 	.word	0x34821cf4

3481c398 <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
3481c398:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
3481c39c:	e1a02003 	mov	r2, r3
3481c3a0:	e4d31001 	ldrb	r1, [r3], #1
3481c3a4:	e3510000 	cmp	r1, #0
3481c3a8:	1afffffb 	bne	3481c39c <strlen+0x4>
		/* nothing */;
	return sc - s;
}
3481c3ac:	e0600002 	rsb	r0, r0, r2
3481c3b0:	e12fff1e 	bx	lr

3481c3b4 <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
3481c3b4:	e92d4010 	push	{r4, lr}
	size_t size;
	char *end;

	s = skip_spaces(s);
3481c3b8:	ebffffed 	bl	3481c374 <skip_spaces>
3481c3bc:	e1a04000 	mov	r4, r0
	size = strlen(s);
3481c3c0:	ebfffff4 	bl	3481c398 <strlen>
	if (!size)
3481c3c4:	e2503000 	subs	r3, r0, #0
3481c3c8:	0a00000b 	beq	3481c3fc <strim+0x48>
		return s;

	end = s + size - 1;
3481c3cc:	e2433001 	sub	r3, r3, #1
	while (end >= s && isspace(*end))
3481c3d0:	e59f102c 	ldr	r1, [pc, #44]	; 3481c404 <strim+0x50>
	s = skip_spaces(s);
	size = strlen(s);
	if (!size)
		return s;

	end = s + size - 1;
3481c3d4:	e0843003 	add	r3, r4, r3
	while (end >= s && isspace(*end))
3481c3d8:	e1530004 	cmp	r3, r4
3481c3dc:	e1a02003 	mov	r2, r3
3481c3e0:	3a000003 	bcc	3481c3f4 <strim+0x40>
3481c3e4:	e4530001 	ldrb	r0, [r3], #-1
3481c3e8:	e7d10000 	ldrb	r0, [r1, r0]
3481c3ec:	e3100020 	tst	r0, #32
3481c3f0:	1afffff8 	bne	3481c3d8 <strim+0x24>
		end--;
	*(end + 1) = '\0';
3481c3f4:	e3a03000 	mov	r3, #0
3481c3f8:	e5c23001 	strb	r3, [r2, #1]

	return s;
}
3481c3fc:	e1a00004 	mov	r0, r4
3481c400:	e8bd8010 	pop	{r4, pc}
3481c404:	34821cf4 	.word	0x34821cf4

3481c408 <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
3481c408:	e92d4038 	push	{r3, r4, r5, lr}
3481c40c:	e1a04000 	mov	r4, r0
3481c410:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
3481c414:	ebffffdf 	bl	3481c398 <strlen>
       do {
	   if (*p == (char)c)
3481c418:	e6ef5075 	uxtb	r5, r5
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481c41c:	e0843000 	add	r3, r4, r0
       do {
	   if (*p == (char)c)
3481c420:	e5d32000 	ldrb	r2, [r3]
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481c424:	e1a00003 	mov	r0, r3
       do {
	   if (*p == (char)c)
3481c428:	e1520005 	cmp	r2, r5
3481c42c:	e2433001 	sub	r3, r3, #1
3481c430:	08bd8038 	popeq	{r3, r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
3481c434:	e1540003 	cmp	r4, r3
3481c438:	9afffff8 	bls	3481c420 <strrchr+0x18>
       return NULL;
3481c43c:	e3a00000 	mov	r0, #0
}
3481c440:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c444 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
3481c444:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3481c448:	e3510000 	cmp	r1, #0
3481c44c:	e1a02003 	mov	r2, r3
3481c450:	0a000003 	beq	3481c464 <strnlen+0x20>
3481c454:	e4d3c001 	ldrb	ip, [r3], #1
3481c458:	e2411001 	sub	r1, r1, #1
3481c45c:	e35c0000 	cmp	ip, #0
3481c460:	1afffff8 	bne	3481c448 <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
3481c464:	e0600002 	rsb	r0, r0, r2
3481c468:	e12fff1e 	bx	lr

3481c46c <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
3481c46c:	e92d4038 	push	{r3, r4, r5, lr}
	char *new;

	if ((s == NULL)	||
3481c470:	e2505000 	subs	r5, r0, #0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
3481c474:	01a04005 	moveq	r4, r5
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481c478:	0a000006 	beq	3481c498 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
3481c47c:	ebffffc5 	bl	3481c398 <strlen>
3481c480:	e2800001 	add	r0, r0, #1
3481c484:	ebffb756 	bl	3480a1e4 <malloc>
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481c488:	e2504000 	subs	r4, r0, #0
3481c48c:	0a000001 	beq	3481c498 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
3481c490:	e1a01005 	mov	r1, r5
3481c494:	ebffff5a 	bl	3481c204 <strcpy>
	return new;
}
3481c498:	e1a00004 	mov	r0, r4
3481c49c:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c4a0 <strspn>:
 *	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
3481c4a0:	e1a03000 	mov	r3, r0
3481c4a4:	e92d4010 	push	{r4, lr}
	const char *p;
	const char *a;
	size_t count = 0;
3481c4a8:	e3a00000 	mov	r0, #0

	for (p = s; *p != '\0'; ++p) {
3481c4ac:	ea000006 	b	3481c4cc <strspn+0x2c>
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
3481c4b0:	e15c0004 	cmp	ip, r4
				break;
		}
		if (*a == '\0')
			return count;
		++count;
3481c4b4:	02800001 	addeq	r0, r0, #1
3481c4b8:	0a000003 	beq	3481c4cc <strspn+0x2c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
3481c4bc:	e4d24001 	ldrb	r4, [r2], #1
3481c4c0:	e3540000 	cmp	r4, #0
3481c4c4:	1afffff9 	bne	3481c4b0 <strspn+0x10>
3481c4c8:	e8bd8010 	pop	{r4, pc}
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
3481c4cc:	e7d3c000 	ldrb	ip, [r3, r0]
3481c4d0:	e35c0000 	cmp	ip, #0
3481c4d4:	08bd8010 	popeq	{r4, pc}
3481c4d8:	e1a02001 	mov	r2, r1
3481c4dc:	eafffff6 	b	3481c4bc <strspn+0x1c>

3481c4e0 <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
3481c4e0:	e92d4010 	push	{r4, lr}
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481c4e4:	e1a02000 	mov	r2, r0
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481c4e8:	ea000004 	b	3481c500 <strpbrk+0x20>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
3481c4ec:	e1530004 	cmp	r3, r4
3481c4f0:	08bd8010 	popeq	{r4, pc}
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3481c4f4:	e4dc4001 	ldrb	r4, [ip], #1
3481c4f8:	e3540000 	cmp	r4, #0
3481c4fc:	1afffffa 	bne	3481c4ec <strpbrk+0xc>
3481c500:	e1a00002 	mov	r0, r2
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481c504:	e4d23001 	ldrb	r3, [r2], #1
3481c508:	e3530000 	cmp	r3, #0
3481c50c:	11a0c001 	movne	ip, r1
3481c510:	1afffff7 	bne	3481c4f4 <strpbrk+0x14>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481c514:	e1a00003 	mov	r0, r3
}
3481c518:	e8bd8010 	pop	{r4, pc}

3481c51c <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481c51c:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481c520:	e2504000 	subs	r4, r0, #0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481c524:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481c528:	1a000003 	bne	3481c53c <strtok+0x20>
3481c52c:	e59f3060 	ldr	r3, [pc, #96]	; 3481c594 <strtok+0x78>
3481c530:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
3481c534:	e3540000 	cmp	r4, #0
3481c538:	0a000013 	beq	3481c58c <strtok+0x70>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
3481c53c:	e1a00004 	mov	r0, r4
3481c540:	e1a01005 	mov	r1, r5
3481c544:	ebffffd5 	bl	3481c4a0 <strspn>
	if (*sbegin == '\0') {
3481c548:	e7f43000 	ldrb	r3, [r4, r0]!
3481c54c:	e3530000 	cmp	r3, #0
		___strtok = NULL;
3481c550:	059f203c 	ldreq	r2, [pc, #60]	; 3481c594 <strtok+0x78>
		return( NULL );
3481c554:	01a04003 	moveq	r4, r3
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
3481c558:	05823000 	streq	r3, [r2]
		return( NULL );
3481c55c:	0a00000a 	beq	3481c58c <strtok+0x70>
	}
	send = strpbrk( sbegin, ct);
3481c560:	e1a00004 	mov	r0, r4
3481c564:	e1a01005 	mov	r1, r5
3481c568:	ebffffdc 	bl	3481c4e0 <strpbrk>
	if (send && *send != '\0')
3481c56c:	e3500000 	cmp	r0, #0
3481c570:	0a000003 	beq	3481c584 <strtok+0x68>
3481c574:	e5d03000 	ldrb	r3, [r0]
3481c578:	e3530000 	cmp	r3, #0
		*send++ = '\0';
3481c57c:	13a03000 	movne	r3, #0
3481c580:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
3481c584:	e59f3008 	ldr	r3, [pc, #8]	; 3481c594 <strtok+0x78>
3481c588:	e5830000 	str	r0, [r3]
	return (sbegin);
}
3481c58c:	e1a00004 	mov	r0, r4
3481c590:	e8bd8038 	pop	{r3, r4, r5, pc}
3481c594:	3482bba4 	.word	0x3482bba4

3481c598 <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481c598:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin = *s, *end;
3481c59c:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481c5a0:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
3481c5a4:	e3540000 	cmp	r4, #0
3481c5a8:	0a000005 	beq	3481c5c4 <strsep+0x2c>
		return NULL;

	end = strpbrk(sbegin, ct);
3481c5ac:	e1a00004 	mov	r0, r4
3481c5b0:	ebffffca 	bl	3481c4e0 <strpbrk>
	if (end)
3481c5b4:	e3500000 	cmp	r0, #0
		*end++ = '\0';
3481c5b8:	13a03000 	movne	r3, #0
3481c5bc:	14c03001 	strbne	r3, [r0], #1
	*s = end;
3481c5c0:	e5850000 	str	r0, [r5]

	return sbegin;
}
3481c5c4:	e1a00004 	mov	r0, r4
3481c5c8:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c5cc <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
3481c5cc:	e3500000 	cmp	r0, #0
3481c5d0:	012fff1e 	bxeq	lr
3481c5d4:	e5d03000 	ldrb	r3, [r0]
3481c5d8:	e3530000 	cmp	r3, #0
3481c5dc:	11a03000 	movne	r3, r0
3481c5e0:	1a000002 	bne	3481c5f0 <strswab+0x24>
3481c5e4:	ea000009 	b	3481c610 <strswab+0x44>

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
		char  tmp;

		tmp = *p;
		*p  = *q;
3481c5e8:	e5432002 	strb	r2, [r3, #-2]
		*q  = tmp;
3481c5ec:	e5431001 	strb	r1, [r3, #-1]

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
3481c5f0:	e5d31000 	ldrb	r1, [r3]
3481c5f4:	e3510000 	cmp	r1, #0
3481c5f8:	012fff1e 	bxeq	lr
3481c5fc:	e5d32001 	ldrb	r2, [r3, #1]
3481c600:	e2833002 	add	r3, r3, #2
3481c604:	e3520000 	cmp	r2, #0
3481c608:	1afffff6 	bne	3481c5e8 <strswab+0x1c>
3481c60c:	e12fff1e 	bx	lr
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
3481c610:	e1a00003 	mov	r0, r3
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
3481c614:	e12fff1e 	bx	lr

3481c618 <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481c618:	e210c003 	ands	ip, r0, #3
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
3481c61c:	e92d4010 	push	{r4, lr}
	unsigned long *sl = (unsigned long *) s;
3481c620:	e1a03000 	mov	r3, r0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481c624:	1a000012 	bne	3481c674 <memset+0x5c>
3481c628:	e1a0300c 	mov	r3, ip
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
3481c62c:	e20140ff 	and	r4, r1, #255	; 0xff
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481c630:	e2833001 	add	r3, r3, #1
3481c634:	e3530004 	cmp	r3, #4
			cl <<= 8;
			cl |= c & 0xff;
3481c638:	e184c40c 	orr	ip, r4, ip, lsl #8
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481c63c:	1afffffb 	bne	3481c630 <memset+0x18>
3481c640:	e1a04000 	mov	r4, r0
3481c644:	e1a03002 	mov	r3, r2
3481c648:	ea000001 	b	3481c654 <memset+0x3c>
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
			*sl++ = cl;
3481c64c:	e484c004 	str	ip, [r4], #4
			count -= sizeof(*sl);
3481c650:	e2433004 	sub	r3, r3, #4
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481c654:	e3530003 	cmp	r3, #3
3481c658:	8afffffb 	bhi	3481c64c <memset+0x34>
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481c65c:	e3c23003 	bic	r3, r2, #3
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481c660:	e0803003 	add	r3, r0, r3
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481c664:	e2022003 	and	r2, r2, #3
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481c668:	ea000001 	b	3481c674 <memset+0x5c>
		*s8++ = c;
3481c66c:	e4c31001 	strb	r1, [r3], #1
3481c670:	e2422001 	sub	r2, r2, #1
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481c674:	e3520000 	cmp	r2, #0
3481c678:	1afffffb 	bne	3481c66c <memset+0x54>
		*s8++ = c;

	return s;
}
3481c67c:	e8bd8010 	pop	{r4, pc}

3481c680 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
3481c680:	e1a03000 	mov	r3, r0
	char *tmp = dest;

	while (count--)
3481c684:	e3a00000 	mov	r0, #0
3481c688:	ea000002 	b	3481c698 <bcopy+0x18>
		*tmp++ = *src++;
3481c68c:	e7d3c000 	ldrb	ip, [r3, r0]
3481c690:	e7c1c000 	strb	ip, [r1, r0]
3481c694:	e2800001 	add	r0, r0, #1
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
3481c698:	e2522001 	subs	r2, r2, #1
3481c69c:	2afffffa 	bcs	3481c68c <bcopy+0xc>
		*tmp++ = *src++;

	return dest;
}
3481c6a0:	e1a00001 	mov	r0, r1
3481c6a4:	e12fff1e 	bx	lr

3481c6a8 <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481c6a8:	e1510000 	cmp	r1, r0
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
3481c6ac:	e92d4010 	push	{r4, lr}
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481c6b0:	08bd8010 	popeq	{r4, pc}
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481c6b4:	e1813000 	orr	r3, r1, r0
3481c6b8:	e2133003 	ands	r3, r3, #3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
3481c6bc:	e1a0c000 	mov	ip, r0
3481c6c0:	e1a04001 	mov	r4, r1

	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481c6c4:	01a0c002 	moveq	ip, r2
3481c6c8:	0a000004 	beq	3481c6e0 <memcpy+0x38>
3481c6cc:	ea000009 	b	3481c6f8 <memcpy+0x50>
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481c6d0:	e7914003 	ldr	r4, [r1, r3]
			count -= sizeof(*dl);
3481c6d4:	e24cc004 	sub	ip, ip, #4
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481c6d8:	e7804003 	str	r4, [r0, r3]
			count -= sizeof(*dl);
3481c6dc:	e2833004 	add	r3, r3, #4
	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
3481c6e0:	e35c0003 	cmp	ip, #3
3481c6e4:	8afffff9 	bhi	3481c6d0 <memcpy+0x28>
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
3481c6e8:	e3c24003 	bic	r4, r2, #3
3481c6ec:	e080c004 	add	ip, r0, r4
3481c6f0:	e2022003 	and	r2, r2, #3
3481c6f4:	e0814004 	add	r4, r1, r4
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481c6f8:	e3a03000 	mov	r3, #0
3481c6fc:	ea000003 	b	3481c710 <memcpy+0x68>
		*d8++ = *s8++;
3481c700:	e7d41003 	ldrb	r1, [r4, r3]
3481c704:	e2422001 	sub	r2, r2, #1
3481c708:	e7cc1003 	strb	r1, [ip, r3]
3481c70c:	e2833001 	add	r3, r3, #1
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481c710:	e3520000 	cmp	r2, #0
3481c714:	1afffff9 	bne	3481c700 <memcpy+0x58>
		*d8++ = *s8++;

	return dest;
}
3481c718:	e8bd8010 	pop	{r4, pc}

3481c71c <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
3481c71c:	e1510000 	cmp	r1, r0
3481c720:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
3481c724:	e1500001 	cmp	r0, r1
3481c728:	93a03000 	movls	r3, #0
3481c72c:	9a000004 	bls	3481c744 <memmove+0x28>
3481c730:	ea000006 	b	3481c750 <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
3481c734:	e7d1c003 	ldrb	ip, [r1, r3]
3481c738:	e2422001 	sub	r2, r2, #1
3481c73c:	e7c0c003 	strb	ip, [r0, r3]
3481c740:	e2833001 	add	r3, r3, #1
		return dest;

	if (dest <= src) {
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
3481c744:	e3520000 	cmp	r2, #0
3481c748:	1afffff9 	bne	3481c734 <memmove+0x18>
3481c74c:	e12fff1e 	bx	lr
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
3481c750:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
3481c754:	e0803002 	add	r3, r0, r2
		s = (char *) src + count;
		while (count--)
3481c758:	ea000002 	b	3481c768 <memmove+0x4c>
			*--tmp = *--s;
3481c75c:	e571c001 	ldrb	ip, [r1, #-1]!
3481c760:	e2422001 	sub	r2, r2, #1
3481c764:	e563c001 	strb	ip, [r3, #-1]!
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
3481c768:	e3520000 	cmp	r2, #0
3481c76c:	1afffffa 	bne	3481c75c <memmove+0x40>
			*--tmp = *--s;
		}

	return dest;
}
3481c770:	e12fff1e 	bx	lr

3481c774 <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
3481c774:	e92d4010 	push	{r4, lr}
3481c778:	e1a03000 	mov	r3, r0
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481c77c:	e3a0c000 	mov	ip, #0
3481c780:	ea000005 	b	3481c79c <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
3481c784:	e7d3400c 	ldrb	r4, [r3, ip]
3481c788:	e7d1000c 	ldrb	r0, [r1, ip]
3481c78c:	e28cc001 	add	ip, ip, #1
3481c790:	e0540000 	subs	r0, r4, r0
3481c794:	18bd8010 	popne	{r4, pc}
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481c798:	e2422001 	sub	r2, r2, #1
3481c79c:	e3520000 	cmp	r2, #0
3481c7a0:	1afffff7 	bne	3481c784 <memcmp+0x10>
3481c7a4:	e1a00002 	mov	r0, r2
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
3481c7a8:	e8bd8010 	pop	{r4, pc}

3481c7ac <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
3481c7ac:	e1a03000 	mov	r3, r0
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c7b0:	ea000003 	b	3481c7c4 <memscan+0x18>
		if (*p == c)
3481c7b4:	e4d3c001 	ldrb	ip, [r3], #1
3481c7b8:	e15c0001 	cmp	ip, r1
3481c7bc:	012fff1e 	bxeq	lr
			return (void *) p;
		p++;
		size--;
3481c7c0:	e2422001 	sub	r2, r2, #1
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c7c4:	e3520000 	cmp	r2, #0
		if (*p == c)
			return (void *) p;
		p++;
		size--;
3481c7c8:	e1a00003 	mov	r0, r3
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c7cc:	1afffff8 	bne	3481c7b4 <memscan+0x8>
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
3481c7d0:	e12fff1e 	bx	lr

3481c7d4 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481c7d4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481c7d8:	e1a04000 	mov	r4, r0
	int l1, l2;

	l2 = strlen(s2);
3481c7dc:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481c7e0:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
3481c7e4:	ebfffeeb 	bl	3481c398 <strlen>
	if (!l2)
3481c7e8:	e2506000 	subs	r6, r0, #0
3481c7ec:	0a00000e 	beq	3481c82c <strstr+0x58>
		return (char *) s1;
	l1 = strlen(s1);
3481c7f0:	e1a00004 	mov	r0, r4
3481c7f4:	ebfffee7 	bl	3481c398 <strlen>
3481c7f8:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
3481c7fc:	ea000007 	b	3481c820 <strstr+0x4c>
		l1--;
		if (!memcmp(s1,s2,l2))
3481c800:	e1a00004 	mov	r0, r4
3481c804:	e1a01007 	mov	r1, r7
3481c808:	e1a02006 	mov	r2, r6
3481c80c:	ebffffd8 	bl	3481c774 <memcmp>
3481c810:	e3500000 	cmp	r0, #0
3481c814:	0a000004 	beq	3481c82c <strstr+0x58>
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
3481c818:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
3481c81c:	e2844001 	add	r4, r4, #1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
3481c820:	e1550006 	cmp	r5, r6
3481c824:	aafffff5 	bge	3481c800 <strstr+0x2c>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
3481c828:	e3a04000 	mov	r4, #0
}
3481c82c:	e1a00004 	mov	r0, r4
3481c830:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481c834 <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
3481c834:	e6ef1071 	uxtb	r1, r1
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c838:	ea000003 	b	3481c84c <memchr+0x18>
		if ((unsigned char)c == *p++) {
3481c83c:	e4d0c001 	ldrb	ip, [r0], #1
3481c840:	e2422001 	sub	r2, r2, #1
3481c844:	e151000c 	cmp	r1, ip
3481c848:	0a000004 	beq	3481c860 <memchr+0x2c>
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c84c:	e3520000 	cmp	r2, #0
		if ((unsigned char)c == *p++) {
3481c850:	e1a03000 	mov	r3, r0
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c854:	1afffff8 	bne	3481c83c <memchr+0x8>
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
3481c858:	e1a00002 	mov	r0, r2
3481c85c:	e12fff1e 	bx	lr
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
3481c860:	e1a00003 	mov	r0, r3
		}
	}
	return NULL;
}
3481c864:	e12fff1e 	bx	lr

3481c868 <strmhz>:
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481c868:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481c86c:	e2815f7d 	add	r5, r1, #500	; 0x1f4
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481c870:	e1a04000 	mov	r4, r0
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481c874:	e59f1048 	ldr	r1, [pc, #72]	; 3481c8c4 <strmhz+0x5c>
3481c878:	e1a00005 	mov	r0, r5
3481c87c:	eb000cd1 	bl	3481fbc8 <__udivsi3>
3481c880:	e1a06000 	mov	r6, r0
	l = sprintf (buf, "%ld", n);
3481c884:	e1a02006 	mov	r2, r6
3481c888:	e59f1038 	ldr	r1, [pc, #56]	; 3481c8c8 <strmhz+0x60>
3481c88c:	e1a00004 	mov	r0, r4
3481c890:	eb0002f9 	bl	3481d47c <sprintf>
3481c894:	e1a07000 	mov	r7, r0

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
3481c898:	e59f002c 	ldr	r0, [pc, #44]	; 3481c8cc <strmhz+0x64>
3481c89c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481c8a0:	e0205690 	mla	r0, r0, r6, r5
3481c8a4:	eb000cc7 	bl	3481fbc8 <__udivsi3>
	if (m != 0)
3481c8a8:	e2502000 	subs	r2, r0, #0
3481c8ac:	0a000002 	beq	3481c8bc <strmhz+0x54>
		sprintf (buf + l, ".%03ld", m);
3481c8b0:	e0840007 	add	r0, r4, r7
3481c8b4:	e59f1014 	ldr	r1, [pc, #20]	; 3481c8d0 <strmhz+0x68>
3481c8b8:	eb0002ef 	bl	3481d47c <sprintf>
	return (buf);
}
3481c8bc:	e1a00004 	mov	r0, r4
3481c8c0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481c8c4:	000f4240 	.word	0x000f4240
3481c8c8:	34827e22 	.word	0x34827e22
3481c8cc:	fff0bdc0 	.word	0xfff0bdc0
3481c8d0:	34827fbe 	.word	0x34827fbe

3481c8d4 <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481c8d4:	e92d4070 	push	{r4, r5, r6, lr}
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481c8d8:	e59f6020 	ldr	r6, [pc, #32]	; 3481c900 <udelay+0x2c>
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481c8dc:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481c8e0:	e1540006 	cmp	r4, r6
3481c8e4:	31a05004 	movcc	r5, r4
3481c8e8:	21a05006 	movcs	r5, r6
		__udelay (kv);
3481c8ec:	e1a00005 	mov	r0, r5
3481c8f0:	ebff9286 	bl	34801310 <__udelay>
		usec -= kv;
	} while(usec);
3481c8f4:	e0544005 	subs	r4, r4, r5
3481c8f8:	1afffff8 	bne	3481c8e0 <udelay+0xc>
}
3481c8fc:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c900:	00989680 	.word	0x00989680

3481c904 <mdelay>:

void mdelay(unsigned long msec)
{
3481c904:	e92d4010 	push	{r4, lr}
3481c908:	e1a04000 	mov	r4, r0
	while (msec--)
3481c90c:	ea000002 	b	3481c91c <mdelay+0x18>
		udelay(1000);
3481c910:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3481c914:	ebffffee 	bl	3481c8d4 <udelay>
3481c918:	e2444001 	sub	r4, r4, #1
	} while(usec);
}

void mdelay(unsigned long msec)
{
	while (msec--)
3481c91c:	e3540000 	cmp	r4, #0
3481c920:	1afffffa 	bne	3481c910 <mdelay+0xc>
		udelay(1000);
}
3481c924:	e8bd8010 	pop	{r4, pc}

3481c928 <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
3481c928:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3481c92c:	e28d5008 	add	r5, sp, #8
3481c930:	e16520f8 	strd	r2, [r5, #-8]!
3481c934:	e1a04000 	mov	r4, r0
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481c938:	e3a090cd 	mov	r9, #205	; 0xcd
	d0 = d0 - 10*q;
3481c93c:	e3a0a00a 	mov	sl, #10
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
3481c940:	e89d0840 	ldm	sp, {r6, fp}
3481c944:	e35b0000 	cmp	fp, #0
3481c948:	1a00003b 	bne	3481ca3c <put_dec+0x114>
3481c94c:	e59f0198 	ldr	r0, [pc, #408]	; 3481caec <put_dec+0x1c4>
3481c950:	e1560000 	cmp	r6, r0
3481c954:	8a00002f 	bhi	3481ca18 <put_dec+0xf0>
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481c958:	e7e37256 	ubfx	r7, r6, #4, #4
	d2 = (q>>8) & 0xf;
3481c95c:	e7e31456 	ubfx	r1, r6, #8, #4
	d3 = (q>>12);
3481c960:	e1a03626 	lsr	r3, r6, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481c964:	e0870001 	add	r0, r7, r1
3481c968:	e206200f 	and	r2, r6, #15
3481c96c:	e0800003 	add	r0, r0, r3
3481c970:	e3a06006 	mov	r6, #6
3481c974:	e0262096 	mla	r6, r6, r0, r2
	q = (d0 * 0xcd) >> 11;
3481c978:	e3a0c0cd 	mov	ip, #205	; 0xcd
3481c97c:	e005069c 	mul	r5, ip, r6
	d0 = d0 - 10*q;
3481c980:	e3a0200a 	mov	r2, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481c984:	e1a055a5 	lsr	r5, r5, #11
	d0 = d0 - 10*q;
3481c988:	e0666592 	mls	r6, r2, r5, r6
	*buf++ = d0 + '0'; /* least significant digit */
3481c98c:	e1a00004 	mov	r0, r4
3481c990:	e2866030 	add	r6, r6, #48	; 0x30
3481c994:	e4c06001 	strb	r6, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
3481c998:	e0836183 	add	r6, r3, r3, lsl #3
3481c99c:	e0866007 	add	r6, r6, r7
3481c9a0:	e081a101 	add	sl, r1, r1, lsl #2
3481c9a4:	e086600a 	add	r6, r6, sl
	if (d1 != 0) {
3481c9a8:	e0965005 	adds	r5, r6, r5
3481c9ac:	0a000018 	beq	3481ca14 <put_dec+0xec>
		q = (d1 * 0xcd) >> 11;
3481c9b0:	e006059c 	mul	r6, ip, r5
3481c9b4:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481c9b8:	e0655692 	mls	r5, r2, r6, r5
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
3481c9bc:	e0861081 	add	r1, r6, r1, lsl #1
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481c9c0:	e2855030 	add	r5, r5, #48	; 0x30
3481c9c4:	e5c45001 	strb	r5, [r4, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481c9c8:	e1914003 	orrs	r4, r1, r3
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481c9cc:	e2800001 	add	r0, r0, #1

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481c9d0:	0a00000f 	beq	3481ca14 <put_dec+0xec>
			q = (d2 * 0xd) >> 7;
3481c9d4:	e3a0400d 	mov	r4, #13
3481c9d8:	e0040194 	mul	r4, r4, r1
3481c9dc:	e1a043a4 	lsr	r4, r4, #7
			d2 = d2 - 10*q;
3481c9e0:	e0611492 	mls	r1, r2, r4, r1
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
3481c9e4:	e0943103 	adds	r3, r4, r3, lsl #2

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0'; /* next digit */
3481c9e8:	e2811030 	add	r1, r1, #48	; 0x30
3481c9ec:	e4c01001 	strb	r1, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
3481c9f0:	0a000007 	beq	3481ca14 <put_dec+0xec>
				q = (d3 * 0xcd) >> 11;
3481c9f4:	e001039c 	mul	r1, ip, r3
3481c9f8:	e1a015a1 	lsr	r1, r1, #11
				d3 = d3 - 10*q;
3481c9fc:	e0633192 	mls	r3, r2, r1, r3
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
3481ca00:	e3510000 	cmp	r1, #0

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
3481ca04:	e2833030 	add	r3, r3, #48	; 0x30
3481ca08:	e4c03001 	strb	r3, [r0], #1
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
3481ca0c:	12811030 	addne	r1, r1, #48	; 0x30
3481ca10:	14c01001 	strbne	r1, [r0], #1
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
}
3481ca14:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
3481ca18:	e1a00006 	mov	r0, r6
3481ca1c:	e59f10cc 	ldr	r1, [pc, #204]	; 3481caf0 <put_dec+0x1c8>
3481ca20:	eb000ce3 	bl	3481fdb4 <__aeabi_uidivmod>
3481ca24:	e1a00006 	mov	r0, r6
3481ca28:	e1a07001 	mov	r7, r1
3481ca2c:	e59f10bc 	ldr	r1, [pc, #188]	; 3481caf0 <put_dec+0x1c8>
3481ca30:	eb000c64 	bl	3481fbc8 <__udivsi3>
3481ca34:	e88d0801 	stm	sp, {r0, fp}
3481ca38:	ea000003 	b	3481ca4c <put_dec+0x124>
3481ca3c:	e1a0000d 	mov	r0, sp
3481ca40:	e59f10a8 	ldr	r1, [pc, #168]	; 3481caf0 <put_dec+0x1c8>
3481ca44:	ebfff852 	bl	3481ab94 <__div64_32>
3481ca48:	e1a07000 	mov	r7, r0
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
3481ca4c:	e7e32457 	ubfx	r2, r7, #8, #4
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481ca50:	e7e30257 	ubfx	r0, r7, #4, #4
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);
3481ca54:	e1a03627 	lsr	r3, r7, #12
	 * (x * 0x34) >> 9:    110100 - same
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481ca58:	e0801002 	add	r1, r0, r2
3481ca5c:	e0811003 	add	r1, r1, r3
3481ca60:	e3a0c006 	mov	ip, #6
3481ca64:	e207700f 	and	r7, r7, #15
3481ca68:	e027719c 	mla	r7, ip, r1, r7
	q = (d0 * 0xcd) >> 11;
3481ca6c:	e0010799 	mul	r1, r9, r7
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481ca70:	e083c183 	add	ip, r3, r3, lsl #3
3481ca74:	e08c0000 	add	r0, ip, r0
3481ca78:	e082c102 	add	ip, r2, r2, lsl #2
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481ca7c:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481ca80:	e080000c 	add	r0, r0, ip
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
3481ca84:	e067719a 	mls	r7, sl, r1, r7
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481ca88:	e0801001 	add	r1, r0, r1
		q = (d1 * 0xcd) >> 11;
3481ca8c:	e0060199 	mul	r6, r9, r1
3481ca90:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481ca94:	e061169a 	mls	r1, sl, r6, r1
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
3481ca98:	e0862082 	add	r2, r6, r2, lsl #1
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481ca9c:	e2811030 	add	r1, r1, #48	; 0x30

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481caa0:	e3a0000d 	mov	r0, #13
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481caa4:	e5c41001 	strb	r1, [r4, #1]

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481caa8:	e0010290 	mul	r1, r0, r2
3481caac:	e1a013a1 	lsr	r1, r1, #7
			d2 = d2 - 10*q;
3481cab0:	e062219a 	mls	r2, sl, r1, r2
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
3481cab4:	e0813103 	add	r3, r1, r3, lsl #2
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
3481cab8:	e2822030 	add	r2, r2, #48	; 0x30
3481cabc:	e5c42002 	strb	r2, [r4, #2]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
3481cac0:	e0020399 	mul	r2, r9, r3
3481cac4:	e1a025a2 	lsr	r2, r2, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
3481cac8:	e063329a 	mls	r3, sl, r2, r3
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481cacc:	e2877030 	add	r7, r7, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481cad0:	e2833030 	add	r3, r3, #48	; 0x30
					*buf++ = q + '0';
3481cad4:	e2822030 	add	r2, r2, #48	; 0x30
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481cad8:	e5c47000 	strb	r7, [r4]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481cadc:	e5c43003 	strb	r3, [r4, #3]
					*buf++ = q + '0';
3481cae0:	e5c42004 	strb	r2, [r4, #4]
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
3481cae4:	e2844005 	add	r4, r4, #5
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
3481cae8:	eaffff94 	b	3481c940 <put_dec+0x18>
3481caec:	0001869f 	.word	0x0001869f
3481caf0:	000186a0 	.word	0x000186a0

3481caf4 <string.clone.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481caf4:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == 0)
		s = "<NULL>";
3481caf8:	e3510000 	cmp	r1, #0
3481cafc:	e59f607c 	ldr	r6, [pc, #124]	; 3481cb80 <string.clone.0+0x8c>
3481cb00:	11a06001 	movne	r6, r1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cb04:	e1a04000 	mov	r4, r0
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481cb08:	e1a01003 	mov	r1, r3
3481cb0c:	e1a00006 	mov	r0, r6
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cb10:	e1a05002 	mov	r5, r2
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481cb14:	ebfffe4a 	bl	3481c444 <strnlen>

	if (!(flags & LEFT))
3481cb18:	e59d3010 	ldr	r3, [sp, #16]
3481cb1c:	e3130010 	tst	r3, #16
3481cb20:	1a000007 	bne	3481cb44 <string.clone.0+0x50>
3481cb24:	ea000001 	b	3481cb30 <string.clone.0+0x3c>
		while (len < field_width--)
			ADDCH(buf, ' ');
3481cb28:	e4c43001 	strb	r3, [r4], #1
3481cb2c:	ea000000 	b	3481cb34 <string.clone.0+0x40>
3481cb30:	e3a03020 	mov	r3, #32
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481cb34:	e2455001 	sub	r5, r5, #1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cb38:	e2852001 	add	r2, r5, #1
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481cb3c:	e1500002 	cmp	r0, r2
3481cb40:	bafffff8 	blt	3481cb28 <string.clone.0+0x34>
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481cb44:	e3a03000 	mov	r3, #0
3481cb48:	ea000002 	b	3481cb58 <string.clone.0+0x64>
		ADDCH(buf, *s++);
3481cb4c:	e7d62003 	ldrb	r2, [r6, r3]
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481cb50:	e2833001 	add	r3, r3, #1
		ADDCH(buf, *s++);
3481cb54:	e4c42001 	strb	r2, [r4], #1
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481cb58:	e1530000 	cmp	r3, r0
3481cb5c:	bafffffa 	blt	3481cb4c <string.clone.0+0x58>
		ADDCH(buf, *s++);
	while (len < field_width--)
		ADDCH(buf, ' ');
3481cb60:	e3a03020 	mov	r3, #32
3481cb64:	ea000001 	b	3481cb70 <string.clone.0+0x7c>
3481cb68:	e4c43001 	strb	r3, [r4], #1
3481cb6c:	e2455001 	sub	r5, r5, #1
	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
		ADDCH(buf, *s++);
	while (len < field_width--)
3481cb70:	e1500005 	cmp	r0, r5
3481cb74:	bafffffb 	blt	3481cb68 <string.clone.0+0x74>
		ADDCH(buf, ' ');
	return buf;
}
3481cb78:	e1a00004 	mov	r0, r4
3481cb7c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481cb80:	34827fc5 	.word	0x34827fc5

3481cb84 <number.clone.1>:
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481cb84:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481cb88:	e24dd058 	sub	sp, sp, #88	; 0x58
3481cb8c:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
3481cb90:	e59d9078 	ldr	r9, [sp, #120]	; 0x78
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481cb94:	e2051020 	and	r1, r5, #32
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481cb98:	e259b00a 	subs	fp, r9, #10
3481cb9c:	13a0b001 	movne	fp, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
3481cba0:	e3150010 	tst	r5, #16
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481cba4:	e00bb325 	and	fp, fp, r5, lsr #6

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
		type &= ~ZEROPAD;
3481cba8:	13c55001 	bicne	r5, r5, #1
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481cbac:	e6ef1071 	uxtb	r1, r1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481cbb0:	e215a002 	ands	sl, r5, #2
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481cbb4:	e1a04000 	mov	r4, r0
3481cbb8:	e59d607c 	ldr	r6, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481cbbc:	e58d1004 	str	r1, [sp, #4]
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481cbc0:	0a00000f 	beq	3481cc04 <number.clone.1+0x80>
		if ((signed NUM_TYPE) num < 0) {
3481cbc4:	e3530000 	cmp	r3, #0
3481cbc8:	ba000002 	blt	3481cbd8 <number.clone.1+0x54>
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
3481cbcc:	e3150004 	tst	r5, #4
3481cbd0:	0a000008 	beq	3481cbf8 <number.clone.1+0x74>
3481cbd4:	ea000004 	b	3481cbec <number.clone.1+0x68>
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
3481cbd8:	e2722000 	rsbs	r2, r2, #0
3481cbdc:	e2e33000 	rsc	r3, r3, #0
			size--;
3481cbe0:	e2466001 	sub	r6, r6, #1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
3481cbe4:	e3a0a02d 	mov	sl, #45	; 0x2d
3481cbe8:	ea000005 	b	3481cc04 <number.clone.1+0x80>
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
3481cbec:	e2466001 	sub	r6, r6, #1
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
3481cbf0:	e3a0a02b 	mov	sl, #43	; 0x2b
3481cbf4:	ea000002 	b	3481cc04 <number.clone.1+0x80>
			size--;
		} else if (type & SPACE) {
3481cbf8:	e215a008 	ands	sl, r5, #8
			sign = ' ';
			size--;
3481cbfc:	12466001 	subne	r6, r6, #1
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
			sign = ' ';
3481cc00:	13a0a020 	movne	sl, #32
			size--;
		}
	}
	if (need_pfx) {
3481cc04:	e35b0000 	cmp	fp, #0
3481cc08:	0a000002 	beq	3481cc18 <number.clone.1+0x94>
		size--;
3481cc0c:	e2466001 	sub	r6, r6, #1
		if (base == 16)
3481cc10:	e3590010 	cmp	r9, #16
			size--;
3481cc14:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481cc18:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
3481cc1c:	03a03030 	moveq	r3, #48	; 0x30
3481cc20:	05cd3014 	strbeq	r3, [sp, #20]
3481cc24:	03a07001 	moveq	r7, #1
			size--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481cc28:	0a000023 	beq	3481ccbc <number.clone.1+0x138>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
3481cc2c:	e359000a 	cmp	r9, #10
3481cc30:	0a00001d 	beq	3481ccac <number.clone.1+0x128>
		int mask = base - 1;
		int shift = 3;
3481cc34:	e3590010 	cmp	r9, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481cc38:	e2491001 	sub	r1, r9, #1
		int shift = 3;
3481cc3c:	03a0c004 	moveq	ip, #4
3481cc40:	13a0c003 	movne	ip, #3
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481cc44:	e58d1008 	str	r1, [sp, #8]
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cc48:	e58db00c 	str	fp, [sp, #12]
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
3481cc4c:	e3a07000 	mov	r7, #0
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cc50:	e1a0b00a 	mov	fp, sl
3481cc54:	e1a00002 	mov	r0, r2
3481cc58:	e1a0a004 	mov	sl, r4
3481cc5c:	e1a01003 	mov	r1, r3
3481cc60:	e1a0400c 	mov	r4, ip
3481cc64:	e59d3008 	ldr	r3, [sp, #8]
3481cc68:	e6ef2070 	uxtb	r2, r0
3481cc6c:	e0022003 	and	r2, r2, r3
3481cc70:	e59f311c 	ldr	r3, [pc, #284]	; 3481cd94 <number.clone.1+0x210>
3481cc74:	e7d3c002 	ldrb	ip, [r3, r2]
3481cc78:	e59d3004 	ldr	r3, [sp, #4]
3481cc7c:	e28d2014 	add	r2, sp, #20
3481cc80:	e183c00c 	orr	ip, r3, ip
3481cc84:	e7c2c007 	strb	ip, [r2, r7]
			num >>= shift;
3481cc88:	e1a02004 	mov	r2, r4
3481cc8c:	eb000ce0 	bl	34820014 <__lshrdi3>
		} while (num);
3481cc90:	e1903001 	orrs	r3, r0, r1
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cc94:	e2877001 	add	r7, r7, #1
			num >>= shift;
		} while (num);
3481cc98:	1afffff1 	bne	3481cc64 <number.clone.1+0xe0>
3481cc9c:	e1a0400a 	mov	r4, sl
3481cca0:	e1a0a00b 	mov	sl, fp
3481cca4:	e59db00c 	ldr	fp, [sp, #12]
3481cca8:	ea000003 	b	3481ccbc <number.clone.1+0x138>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
3481ccac:	e28d7014 	add	r7, sp, #20
3481ccb0:	e1a00007 	mov	r0, r7
3481ccb4:	ebffff1b 	bl	3481c928 <put_dec>
3481ccb8:	e0677000 	rsb	r7, r7, r0
3481ccbc:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
3481ccc0:	e1570003 	cmp	r7, r3
3481ccc4:	a1a03007 	movge	r3, r7
3481ccc8:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
3481cccc:	e3150011 	tst	r5, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
3481ccd0:	e0636006 	rsb	r6, r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
3481ccd4:	1a000005 	bne	3481ccf0 <number.clone.1+0x16c>
3481ccd8:	ea000001 	b	3481cce4 <number.clone.1+0x160>
		while (--size >= 0)
			ADDCH(buf, ' ');
3481ccdc:	e4c42001 	strb	r2, [r4], #1
3481cce0:	ea000000 	b	3481cce8 <number.clone.1+0x164>
3481cce4:	e3a02020 	mov	r2, #32
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
		while (--size >= 0)
3481cce8:	e2566001 	subs	r6, r6, #1
3481ccec:	5afffffa 	bpl	3481ccdc <number.clone.1+0x158>
			ADDCH(buf, ' ');
	}
	/* sign */
	if (sign)
3481ccf0:	e35a0000 	cmp	sl, #0
		ADDCH(buf, sign);
3481ccf4:	14c4a001 	strbne	sl, [r4], #1
	/* "0x" / "0" prefix */
	if (need_pfx) {
3481ccf8:	e35b0000 	cmp	fp, #0
3481ccfc:	0a000005 	beq	3481cd18 <number.clone.1+0x194>
		ADDCH(buf, '0');
3481cd00:	e3a02030 	mov	r2, #48	; 0x30
3481cd04:	e4c42001 	strb	r2, [r4], #1
		if (base == 16)
3481cd08:	e3590010 	cmp	r9, #16
			ADDCH(buf, 'X' | locase);
3481cd0c:	059d1004 	ldreq	r1, [sp, #4]
3481cd10:	03812058 	orreq	r2, r1, #88	; 0x58
3481cd14:	04c42001 	strbeq	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
3481cd18:	e3150010 	tst	r5, #16
3481cd1c:	1a000009 	bne	3481cd48 <number.clone.1+0x1c4>
		char c = (type & ZEROPAD) ? '0' : ' ';
3481cd20:	e3150001 	tst	r5, #1
3481cd24:	03a02020 	moveq	r2, #32
3481cd28:	13a02030 	movne	r2, #48	; 0x30
3481cd2c:	ea000000 	b	3481cd34 <number.clone.1+0x1b0>

		while (--size >= 0)
			ADDCH(buf, c);
3481cd30:	e4c42001 	strb	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
		char c = (type & ZEROPAD) ? '0' : ' ';

		while (--size >= 0)
3481cd34:	e2566001 	subs	r6, r6, #1
3481cd38:	5afffffc 	bpl	3481cd30 <number.clone.1+0x1ac>
3481cd3c:	ea000001 	b	3481cd48 <number.clone.1+0x1c4>
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
3481cd40:	e4c42001 	strb	r2, [r4], #1
3481cd44:	ea000000 	b	3481cd4c <number.clone.1+0x1c8>
3481cd48:	e3a02030 	mov	r2, #48	; 0x30

		while (--size >= 0)
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
3481cd4c:	e2433001 	sub	r3, r3, #1
3481cd50:	e1570003 	cmp	r7, r3
3481cd54:	dafffff9 	ble	3481cd40 <number.clone.1+0x1bc>
3481cd58:	ea000002 	b	3481cd68 <number.clone.1+0x1e4>
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
3481cd5c:	e28d3014 	add	r3, sp, #20
3481cd60:	e7d33007 	ldrb	r3, [r3, r7]
3481cd64:	e4c43001 	strb	r3, [r4], #1
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
3481cd68:	e2577001 	subs	r7, r7, #1
3481cd6c:	5afffffa 	bpl	3481cd5c <number.clone.1+0x1d8>
3481cd70:	ea000001 	b	3481cd7c <number.clone.1+0x1f8>
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
		ADDCH(buf, ' ');
3481cd74:	e4c43001 	strb	r3, [r4], #1
3481cd78:	ea000000 	b	3481cd80 <number.clone.1+0x1fc>
3481cd7c:	e3a03020 	mov	r3, #32
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
3481cd80:	e2566001 	subs	r6, r6, #1
3481cd84:	5afffffa 	bpl	3481cd74 <number.clone.1+0x1f0>
		ADDCH(buf, ' ');
	return buf;
}
3481cd88:	e1a00004 	mov	r0, r4
3481cd8c:	e28dd058 	add	sp, sp, #88	; 0x58
3481cd90:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481cd94:	34821dfc 	.word	0x34821dfc

3481cd98 <vsnprintf_internal.clone.3>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481cd98:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481cd9c:	e1a0a000 	mov	sl, r0
3481cda0:	e1a06001 	mov	r6, r1
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481cda4:	e3a0900a 	mov	r9, #10

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
3481cda8:	e3a0b020 	mov	fp, #32
3481cdac:	ea000103 	b	3481d1c0 <vsnprintf_internal.clone.3+0x428>
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
3481cdb0:	e3530025 	cmp	r3, #37	; 0x25
3481cdb4:	1a0000cc 	bne	3481d0ec <vsnprintf_internal.clone.3+0x354>
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481cdb8:	e286c001 	add	ip, r6, #1
3481cdbc:	e3a01000 	mov	r1, #0
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
			ADDCH(str, *fmt);
3481cdc0:	e1a0600c 	mov	r6, ip

		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
3481cdc4:	e4dc3001 	ldrb	r3, [ip], #1
3481cdc8:	e353002b 	cmp	r3, #43	; 0x2b
3481cdcc:	0a00000c 	beq	3481ce04 <vsnprintf_internal.clone.3+0x6c>
3481cdd0:	8a000004 	bhi	3481cde8 <vsnprintf_internal.clone.3+0x50>
3481cdd4:	e3530020 	cmp	r3, #32
3481cdd8:	0a00000b 	beq	3481ce0c <vsnprintf_internal.clone.3+0x74>
3481cddc:	e3530023 	cmp	r3, #35	; 0x23
3481cde0:	1a00000f 	bne	3481ce24 <vsnprintf_internal.clone.3+0x8c>
3481cde4:	ea00000a 	b	3481ce14 <vsnprintf_internal.clone.3+0x7c>
3481cde8:	e353002d 	cmp	r3, #45	; 0x2d
3481cdec:	0a000002 	beq	3481cdfc <vsnprintf_internal.clone.3+0x64>
3481cdf0:	e3530030 	cmp	r3, #48	; 0x30
3481cdf4:	1a00000a 	bne	3481ce24 <vsnprintf_internal.clone.3+0x8c>
3481cdf8:	ea000007 	b	3481ce1c <vsnprintf_internal.clone.3+0x84>
				case '-': flags |= LEFT; goto repeat;
3481cdfc:	e3811010 	orr	r1, r1, #16
3481ce00:	eaffffee 	b	3481cdc0 <vsnprintf_internal.clone.3+0x28>
				case '+': flags |= PLUS; goto repeat;
3481ce04:	e3811004 	orr	r1, r1, #4
3481ce08:	eaffffec 	b	3481cdc0 <vsnprintf_internal.clone.3+0x28>
				case ' ': flags |= SPACE; goto repeat;
3481ce0c:	e3811008 	orr	r1, r1, #8
3481ce10:	eaffffea 	b	3481cdc0 <vsnprintf_internal.clone.3+0x28>
				case '#': flags |= SPECIAL; goto repeat;
3481ce14:	e3811040 	orr	r1, r1, #64	; 0x40
3481ce18:	eaffffe8 	b	3481cdc0 <vsnprintf_internal.clone.3+0x28>
				case '0': flags |= ZEROPAD; goto repeat;
3481ce1c:	e3811001 	orr	r1, r1, #1
3481ce20:	eaffffe6 	b	3481cdc0 <vsnprintf_internal.clone.3+0x28>
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
3481ce24:	e243c030 	sub	ip, r3, #48	; 0x30
3481ce28:	e6efc07c 	uxtb	ip, ip
3481ce2c:	e35c0009 	cmp	ip, #9
3481ce30:	91a03006 	movls	r3, r6
3481ce34:	93a0c000 	movls	ip, #0
3481ce38:	9a000001 	bls	3481ce44 <vsnprintf_internal.clone.3+0xac>
3481ce3c:	ea000007 	b	3481ce60 <vsnprintf_internal.clone.3+0xc8>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481ce40:	e02c4c99 	mla	ip, r9, ip, r4
3481ce44:	e1a06003 	mov	r6, r3

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481ce48:	e4d34001 	ldrb	r4, [r3], #1
3481ce4c:	e2444030 	sub	r4, r4, #48	; 0x30
3481ce50:	e6ef5074 	uxtb	r5, r4
3481ce54:	e3550009 	cmp	r5, #9
3481ce58:	9afffff8 	bls	3481ce40 <vsnprintf_internal.clone.3+0xa8>
3481ce5c:	ea000009 	b	3481ce88 <vsnprintf_internal.clone.3+0xf0>

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481ce60:	e353002a 	cmp	r3, #42	; 0x2a
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
3481ce64:	13e0c000 	mvnne	ip, #0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481ce68:	1a000006 	bne	3481ce88 <vsnprintf_internal.clone.3+0xf0>
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481ce6c:	e592c000 	ldr	ip, [r2]
3481ce70:	e2823004 	add	r3, r2, #4
			if (field_width < 0) {
3481ce74:	e35c0000 	cmp	ip, #0
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
3481ce78:	e2866001 	add	r6, r6, #1
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
3481ce7c:	b26cc000 	rsblt	ip, ip, #0
				flags |= LEFT;
3481ce80:	b3811010 	orrlt	r1, r1, #16
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481ce84:	e1a02003 	mov	r2, r3
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
3481ce88:	e5d63000 	ldrb	r3, [r6]
3481ce8c:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481ce90:	13e03000 	mvnne	r3, #0
		if (*fmt == '.') {
3481ce94:	1a00001c 	bne	3481cf0c <vsnprintf_internal.clone.3+0x174>
			++fmt;
			if (is_digit(*fmt))
3481ce98:	e5f63001 	ldrb	r3, [r6, #1]!
3481ce9c:	e2434030 	sub	r4, r3, #48	; 0x30
3481cea0:	e6ef4074 	uxtb	r4, r4
3481cea4:	e3540009 	cmp	r4, #9
3481cea8:	91a07006 	movls	r7, r6
3481ceac:	93a03000 	movls	r3, #0
3481ceb0:	9a000001 	bls	3481cebc <vsnprintf_internal.clone.3+0x124>
3481ceb4:	ea000009 	b	3481cee0 <vsnprintf_internal.clone.3+0x148>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481ceb8:	e0235399 	mla	r3, r9, r3, r5

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481cebc:	e5d75000 	ldrb	r5, [r7]
		i = i*10 + *((*s)++) - '0';
3481cec0:	e1a06007 	mov	r6, r7

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481cec4:	e2455030 	sub	r5, r5, #48	; 0x30
3481cec8:	e6ef4075 	uxtb	r4, r5
3481cecc:	e3540009 	cmp	r4, #9
3481ced0:	e2877001 	add	r7, r7, #1
3481ced4:	9afffff7 	bls	3481ceb8 <vsnprintf_internal.clone.3+0x120>
3481ced8:	e1a04002 	mov	r4, r2
3481cedc:	ea000006 	b	3481cefc <vsnprintf_internal.clone.3+0x164>
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
3481cee0:	e353002a 	cmp	r3, #42	; 0x2a
3481cee4:	1a000007 	bne	3481cf08 <vsnprintf_internal.clone.3+0x170>
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481cee8:	e5923000 	ldr	r3, [r2]
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
3481ceec:	e2866001 	add	r6, r6, #1
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
3481cef0:	e3530000 	cmp	r3, #0
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481cef4:	e2824004 	add	r4, r2, #4
			}
			if (precision < 0)
3481cef8:	ba000001 	blt	3481cf04 <vsnprintf_internal.clone.3+0x16c>
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481cefc:	e1a02004 	mov	r2, r4
3481cf00:	ea000001 	b	3481cf0c <vsnprintf_internal.clone.3+0x174>
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481cf04:	e1a02004 	mov	r2, r4
			}
			if (precision < 0)
				precision = 0;
3481cf08:	e3a03000 	mov	r3, #0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
3481cf0c:	e5d64000 	ldrb	r4, [r6]
3481cf10:	e3540068 	cmp	r4, #104	; 0x68
3481cf14:	1354006c 	cmpne	r4, #108	; 0x6c
3481cf18:	0a000008 	beq	3481cf40 <vsnprintf_internal.clone.3+0x1a8>
3481cf1c:	e354004c 	cmp	r4, #76	; 0x4c
3481cf20:	0a000006 	beq	3481cf40 <vsnprintf_internal.clone.3+0x1a8>
3481cf24:	e354005a 	cmp	r4, #90	; 0x5a
3481cf28:	0a000004 	beq	3481cf40 <vsnprintf_internal.clone.3+0x1a8>
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481cf2c:	e354007a 	cmp	r4, #122	; 0x7a
3481cf30:	0a000002 	beq	3481cf40 <vsnprintf_internal.clone.3+0x1a8>
3481cf34:	e3540074 	cmp	r4, #116	; 0x74
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
3481cf38:	13e04000 	mvnne	r4, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481cf3c:	1a000006 	bne	3481cf5c <vsnprintf_internal.clone.3+0x1c4>
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
3481cf40:	e354006c 	cmp	r4, #108	; 0x6c
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
3481cf44:	e2866001 	add	r6, r6, #1
			if (qualifier == 'l' && *fmt == 'l') {
3481cf48:	1a000003 	bne	3481cf5c <vsnprintf_internal.clone.3+0x1c4>
3481cf4c:	e5d65000 	ldrb	r5, [r6]
3481cf50:	e355006c 	cmp	r5, #108	; 0x6c
				qualifier = 'L';
				++fmt;
3481cf54:	02866001 	addeq	r6, r6, #1
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
				qualifier = 'L';
3481cf58:	03a0404c 	moveq	r4, #76	; 0x4c
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481cf5c:	e5d65000 	ldrb	r5, [r6]
3481cf60:	e355006e 	cmp	r5, #110	; 0x6e
3481cf64:	0a00004f 	beq	3481d0a8 <vsnprintf_internal.clone.3+0x310>
3481cf68:	8a00000d 	bhi	3481cfa4 <vsnprintf_internal.clone.3+0x20c>
3481cf6c:	e3550063 	cmp	r5, #99	; 0x63
3481cf70:	0a000018 	beq	3481cfd8 <vsnprintf_internal.clone.3+0x240>
3481cf74:	8a000005 	bhi	3481cf90 <vsnprintf_internal.clone.3+0x1f8>
3481cf78:	e3550025 	cmp	r5, #37	; 0x25
				*ip = (str - buf);
			}
			continue;

		case '%':
			ADDCH(str, '%');
3481cf7c:	04c05001 	strbeq	r5, [r0], #1
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481cf80:	0a00008d 	beq	3481d1bc <vsnprintf_internal.clone.3+0x424>
3481cf84:	e3550058 	cmp	r5, #88	; 0x58
3481cf88:	1a000051 	bne	3481d0d4 <vsnprintf_internal.clone.3+0x33c>
3481cf8c:	ea00005a 	b	3481d0fc <vsnprintf_internal.clone.3+0x364>
3481cf90:	e3550064 	cmp	r5, #100	; 0x64
3481cf94:	0a00004c 	beq	3481d0cc <vsnprintf_internal.clone.3+0x334>
3481cf98:	e3550069 	cmp	r5, #105	; 0x69
3481cf9c:	1a00004c 	bne	3481d0d4 <vsnprintf_internal.clone.3+0x33c>
3481cfa0:	ea000049 	b	3481d0cc <vsnprintf_internal.clone.3+0x334>
3481cfa4:	e3550073 	cmp	r5, #115	; 0x73
3481cfa8:	0a00001b 	beq	3481d01c <vsnprintf_internal.clone.3+0x284>
3481cfac:	8a000004 	bhi	3481cfc4 <vsnprintf_internal.clone.3+0x22c>
3481cfb0:	e355006f 	cmp	r5, #111	; 0x6f
3481cfb4:	0a000040 	beq	3481d0bc <vsnprintf_internal.clone.3+0x324>
3481cfb8:	e3550070 	cmp	r5, #112	; 0x70
3481cfbc:	1a000044 	bne	3481d0d4 <vsnprintf_internal.clone.3+0x33c>
3481cfc0:	ea00001b 	b	3481d034 <vsnprintf_internal.clone.3+0x29c>
3481cfc4:	e3550075 	cmp	r5, #117	; 0x75
3481cfc8:	0a000049 	beq	3481d0f4 <vsnprintf_internal.clone.3+0x35c>
3481cfcc:	e3550078 	cmp	r5, #120	; 0x78
3481cfd0:	1a00003f 	bne	3481d0d4 <vsnprintf_internal.clone.3+0x33c>
3481cfd4:	ea00003a 	b	3481d0c4 <vsnprintf_internal.clone.3+0x32c>
		case 'c':
			if (!(flags & LEFT)) {
3481cfd8:	e3110010 	tst	r1, #16
3481cfdc:	1a000004 	bne	3481cff4 <vsnprintf_internal.clone.3+0x25c>
3481cfe0:	ea000000 	b	3481cfe8 <vsnprintf_internal.clone.3+0x250>
				while (--field_width > 0)
					ADDCH(str, ' ');
3481cfe4:	e4c0b001 	strb	fp, [r0], #1
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
3481cfe8:	e24cc001 	sub	ip, ip, #1
3481cfec:	e35c0000 	cmp	ip, #0
3481cff0:	cafffffb 	bgt	3481cfe4 <vsnprintf_internal.clone.3+0x24c>
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481cff4:	e2823004 	add	r3, r2, #4
3481cff8:	e5922000 	ldr	r2, [r2]
3481cffc:	ea000000 	b	3481d004 <vsnprintf_internal.clone.3+0x26c>
			while (--field_width > 0)
				ADDCH(str, ' ');
3481d000:	e1a0200b 	mov	r2, fp
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481d004:	e24cc001 	sub	ip, ip, #1
3481d008:	e35c0000 	cmp	ip, #0
				ADDCH(str, ' ');
3481d00c:	e4c02001 	strb	r2, [r0], #1
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481d010:	cafffffa 	bgt	3481d000 <vsnprintf_internal.clone.3+0x268>
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481d014:	e1a02003 	mov	r2, r3
3481d018:	ea000067 	b	3481d1bc <vsnprintf_internal.clone.3+0x424>
			while (--field_width > 0)
				ADDCH(str, ' ');
			continue;

		case 's':
			str = string(str, end, va_arg(args, char *),
3481d01c:	e58d1000 	str	r1, [sp]
3481d020:	e2824004 	add	r4, r2, #4
3481d024:	e5921000 	ldr	r1, [r2]
3481d028:	e1a0200c 	mov	r2, ip
3481d02c:	ebfffeb0 	bl	3481caf4 <string.clone.0>
3481d030:	ea00001a 	b	3481d0a0 <vsnprintf_internal.clone.3+0x308>
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481d034:	e2824004 	add	r4, r2, #4
3481d038:	e5922000 	ldr	r2, [r2]
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
		int field_width, int precision, int flags)
{
	if (!ptr)
3481d03c:	e3520000 	cmp	r2, #0
3481d040:	1a000004 	bne	3481d058 <vsnprintf_internal.clone.3+0x2c0>
		return string(buf, end, "(null)", field_width, precision,
3481d044:	e58d1000 	str	r1, [sp]
3481d048:	e1a0200c 	mov	r2, ip
3481d04c:	e59f1188 	ldr	r1, [pc, #392]	; 3481d1dc <vsnprintf_internal.clone.3+0x444>
3481d050:	ebfffea7 	bl	3481caf4 <string.clone.0>
3481d054:	ea000009 	b	3481d080 <vsnprintf_internal.clone.3+0x2e8>
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
3481d058:	e37c0001 	cmn	ip, #1
					       precision, flags);
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
3481d05c:	e381e020 	orr	lr, r1, #32
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
3481d060:	028cc009 	addeq	ip, ip, #9
		flags |= ZEROPAD;
3481d064:	0381e021 	orreq	lr, r1, #33	; 0x21
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481d068:	e58d3008 	str	r3, [sp, #8]
3481d06c:	e3a01010 	mov	r1, #16
3481d070:	e3a03000 	mov	r3, #0
3481d074:	e88d1002 	stm	sp, {r1, ip}
3481d078:	e58de00c 	str	lr, [sp, #12]
3481d07c:	ebfffec0 	bl	3481cb84 <number.clone.1>
3481d080:	e1a03006 	mov	r3, r6
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481d084:	e5d32001 	ldrb	r2, [r3, #1]
3481d088:	e59f1150 	ldr	r1, [pc, #336]	; 3481d1e0 <vsnprintf_internal.clone.3+0x448>
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481d08c:	e1a06003 	mov	r6, r3
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481d090:	e7d12002 	ldrb	r2, [r1, r2]
3481d094:	e2833001 	add	r3, r3, #1
3481d098:	e3120007 	tst	r2, #7
3481d09c:	1afffff8 	bne	3481d084 <vsnprintf_internal.clone.3+0x2ec>
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481d0a0:	e1a02004 	mov	r2, r4
3481d0a4:	ea000044 	b	3481d1bc <vsnprintf_internal.clone.3+0x424>
3481d0a8:	e2827004 	add	r7, r2, #4
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
				*ip = (str - buf);
3481d0ac:	e5922000 	ldr	r2, [r2]
3481d0b0:	e06a3000 	rsb	r3, sl, r0
3481d0b4:	e5823000 	str	r3, [r2]
3481d0b8:	ea00003e 	b	3481d1b8 <vsnprintf_internal.clone.3+0x420>
			ADDCH(str, '%');
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
3481d0bc:	e3a0e008 	mov	lr, #8
3481d0c0:	ea00000e 	b	3481d100 <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
3481d0c4:	e3811020 	orr	r1, r1, #32
3481d0c8:	ea00000b 	b	3481d0fc <vsnprintf_internal.clone.3+0x364>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
3481d0cc:	e3811002 	orr	r1, r1, #2
3481d0d0:	ea000007 	b	3481d0f4 <vsnprintf_internal.clone.3+0x35c>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
3481d0d4:	e3a03025 	mov	r3, #37	; 0x25
3481d0d8:	e4c03001 	strb	r3, [r0], #1
			if (*fmt)
3481d0dc:	e5d63000 	ldrb	r3, [r6]
3481d0e0:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
			else
				--fmt;
3481d0e4:	02466001 	subeq	r6, r6, #1
		case 'u':
			break;

		default:
			ADDCH(str, '%');
			if (*fmt)
3481d0e8:	0a000033 	beq	3481d1bc <vsnprintf_internal.clone.3+0x424>
				ADDCH(str, *fmt);
3481d0ec:	e4c03001 	strb	r3, [r0], #1
3481d0f0:	ea000031 	b	3481d1bc <vsnprintf_internal.clone.3+0x424>
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481d0f4:	e3a0e00a 	mov	lr, #10
3481d0f8:	ea000000 	b	3481d100 <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
		case 'X':
			base = 16;
3481d0fc:	e3a0e010 	mov	lr, #16
				ADDCH(str, *fmt);
			else
				--fmt;
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
3481d100:	e354004c 	cmp	r4, #76	; 0x4c
			num = va_arg(args, unsigned long long);
3481d104:	02822007 	addeq	r2, r2, #7
3481d108:	03c22007 	biceq	r2, r2, #7
3481d10c:	02827008 	addeq	r7, r2, #8
3481d110:	01c240d0 	ldrdeq	r4, [r2]
3481d114:	0a000020 	beq	3481d19c <vsnprintf_internal.clone.3+0x404>
		else if (qualifier == 'l') {
3481d118:	e354006c 	cmp	r4, #108	; 0x6c
3481d11c:	1a000005 	bne	3481d138 <vsnprintf_internal.clone.3+0x3a0>
			num = va_arg(args, unsigned long);
3481d120:	e5924000 	ldr	r4, [r2]
			if (flags & SIGN)
3481d124:	e3110002 	tst	r1, #2
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
3481d128:	e2827004 	add	r7, r2, #4
3481d12c:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d130:	0a000019 	beq	3481d19c <vsnprintf_internal.clone.3+0x404>
3481d134:	ea000017 	b	3481d198 <vsnprintf_internal.clone.3+0x400>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481d138:	e354005a 	cmp	r4, #90	; 0x5a
3481d13c:	1354007a 	cmpne	r4, #122	; 0x7a
			num = va_arg(args, size_t);
3481d140:	05924000 	ldreq	r4, [r2]
3481d144:	02827004 	addeq	r7, r2, #4
3481d148:	03a05000 	moveq	r5, #0
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481d14c:	0a000012 	beq	3481d19c <vsnprintf_internal.clone.3+0x404>
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481d150:	e3540074 	cmp	r4, #116	; 0x74
			num = va_arg(args, ptrdiff_t);
3481d154:	02827004 	addeq	r7, r2, #4
3481d158:	05924000 	ldreq	r4, [r2]
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481d15c:	0a00000d 	beq	3481d198 <vsnprintf_internal.clone.3+0x400>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
3481d160:	e3540068 	cmp	r4, #104	; 0x68
3481d164:	e2827004 	add	r7, r2, #4
3481d168:	e5924000 	ldr	r4, [r2]
3481d16c:	e2012002 	and	r2, r1, #2
3481d170:	1a000005 	bne	3481d18c <vsnprintf_internal.clone.3+0x3f4>
			num = (unsigned short) va_arg(args, int);
3481d174:	e6ff4074 	uxth	r4, r4
3481d178:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d17c:	e3520000 	cmp	r2, #0
				num = (signed short) num;
3481d180:	16bf4074 	sxthne	r4, r4
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
3481d184:	1a000003 	bne	3481d198 <vsnprintf_internal.clone.3+0x400>
3481d188:	ea000003 	b	3481d19c <vsnprintf_internal.clone.3+0x404>
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
3481d18c:	e3520000 	cmp	r2, #0
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
3481d190:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d194:	0a000000 	beq	3481d19c <vsnprintf_internal.clone.3+0x404>
				num = (signed int) num;
3481d198:	e1a05fc4 	asr	r5, r4, #31
		}
		str = number(str, end, num, base, field_width, precision,
3481d19c:	e58d3008 	str	r3, [sp, #8]
3481d1a0:	e1a02004 	mov	r2, r4
3481d1a4:	e1a03005 	mov	r3, r5
3481d1a8:	e58de000 	str	lr, [sp]
3481d1ac:	e58dc004 	str	ip, [sp, #4]
3481d1b0:	e58d100c 	str	r1, [sp, #12]
3481d1b4:	ebfffe72 	bl	3481cb84 <number.clone.1>
3481d1b8:	e1a02007 	mov	r2, r7
		size = end - buf;
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
3481d1bc:	e2866001 	add	r6, r6, #1
3481d1c0:	e5d63000 	ldrb	r3, [r6]
3481d1c4:	e3530000 	cmp	r3, #0
3481d1c8:	1afffef8 	bne	3481cdb0 <vsnprintf_internal.clone.3+0x18>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
3481d1cc:	e5c03000 	strb	r3, [r0]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
}
3481d1d0:	e06a0000 	rsb	r0, sl, r0
3481d1d4:	e28dd010 	add	sp, sp, #16
3481d1d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d1dc:	34827fcc 	.word	0x34827fcc
3481d1e0:	34821cf4 	.word	0x34821cf4

3481d1e4 <simple_strtoul>:
	*buf++ = hex_asc_lo(byte);
	return buf;
}

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
3481d1e4:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned long result = 0,value;

	if (*cp == '0') {
3481d1e8:	e5d03000 	ldrb	r3, [r0]
3481d1ec:	e3530030 	cmp	r3, #48	; 0x30
3481d1f0:	1a00000d 	bne	3481d22c <simple_strtoul+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481d1f4:	e5f03001 	ldrb	r3, [r0, #1]!
3481d1f8:	e3530078 	cmp	r3, #120	; 0x78
3481d1fc:	1a000007 	bne	3481d220 <simple_strtoul+0x3c>
3481d200:	e5d0c001 	ldrb	ip, [r0, #1]
3481d204:	e59f4080 	ldr	r4, [pc, #128]	; 3481d28c <simple_strtoul+0xa8>
3481d208:	e2803001 	add	r3, r0, #1
3481d20c:	e7d4c00c 	ldrb	ip, [r4, ip]
3481d210:	e31c0044 	tst	ip, #68	; 0x44
3481d214:	11a00003 	movne	r0, r3
			base = 16;
3481d218:	13a02010 	movne	r2, #16
{
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481d21c:	1a000004 	bne	3481d234 <simple_strtoul+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481d220:	e3520000 	cmp	r2, #0
3481d224:	03a02008 	moveq	r2, #8
3481d228:	ea000001 	b	3481d234 <simple_strtoul+0x50>
		}
	}
	if (!base) {
		base = 10;
3481d22c:	e3520000 	cmp	r2, #0
3481d230:	03a0200a 	moveq	r2, #10
		}
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
3481d234:	e1a0c000 	mov	ip, r0
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d238:	e59f604c 	ldr	r6, [pc, #76]	; 3481d28c <simple_strtoul+0xa8>
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
		base = 10;
3481d23c:	e3a00000 	mov	r0, #0
3481d240:	ea000000 	b	3481d248 <simple_strtoul+0x64>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
3481d244:	e0203092 	mla	r0, r2, r0, r3
3481d248:	e1a0500c 	mov	r5, ip
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d24c:	e4dc3001 	ldrb	r3, [ip], #1
3481d250:	e7d64003 	ldrb	r4, [r6, r3]
3481d254:	e3140044 	tst	r4, #68	; 0x44
3481d258:	0a000008 	beq	3481d280 <simple_strtoul+0x9c>
3481d25c:	e3140004 	tst	r4, #4
3481d260:	12433030 	subne	r3, r3, #48	; 0x30
3481d264:	1a000003 	bne	3481d278 <simple_strtoul+0x94>
3481d268:	e3140002 	tst	r4, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
3481d26c:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
3481d270:	16ef3073 	uxtbne	r3, r3
3481d274:	e2433037 	sub	r3, r3, #55	; 0x37
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d278:	e1530002 	cmp	r3, r2
3481d27c:	3afffff0 	bcc	3481d244 <simple_strtoul+0x60>
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}
	if (endp)
3481d280:	e3510000 	cmp	r1, #0
		*endp = (char *)cp;
3481d284:	15815000 	strne	r5, [r1]
	return result;
}
3481d288:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d28c:	34821cf4 	.word	0x34821cf4

3481d290 <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481d290:	e3a03000 	mov	r3, #0
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481d294:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481d298:	e5823000 	str	r3, [r2]
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481d29c:	e1a04000 	mov	r4, r0
3481d2a0:	e1a07001 	mov	r7, r1
3481d2a4:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
3481d2a8:	ebfffc3a 	bl	3481c398 <strlen>
	if (len == 0)
3481d2ac:	e2506000 	subs	r6, r0, #0
3481d2b0:	0a000012 	beq	3481d300 <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
3481d2b4:	e1a00004 	mov	r0, r4
3481d2b8:	e28d1004 	add	r1, sp, #4
3481d2bc:	e1a02007 	mov	r2, r7
3481d2c0:	ebffffc7 	bl	3481d1e4 <simple_strtoul>
	if (tail == cp)
3481d2c4:	e59d3004 	ldr	r3, [sp, #4]
3481d2c8:	e1530004 	cmp	r3, r4
3481d2cc:	0a00000b 	beq	3481d300 <strict_strtoul+0x70>
		return -EINVAL;

	if ((*tail == '\0') ||
3481d2d0:	e5d32000 	ldrb	r2, [r3]
3481d2d4:	e3520000 	cmp	r2, #0
3481d2d8:	0a000005 	beq	3481d2f4 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481d2dc:	e0643003 	rsb	r3, r4, r3
3481d2e0:	e2833001 	add	r3, r3, #1

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;

	if ((*tail == '\0') ||
3481d2e4:	e1560003 	cmp	r6, r3
3481d2e8:	1a000004 	bne	3481d300 <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481d2ec:	e352000a 	cmp	r2, #10
3481d2f0:	1a000002 	bne	3481d300 <strict_strtoul+0x70>
		*res = val;
3481d2f4:	e5850000 	str	r0, [r5]
		return 0;
3481d2f8:	e3a00000 	mov	r0, #0
3481d2fc:	ea000000 	b	3481d304 <strict_strtoul+0x74>
	}

	return -EINVAL;
3481d300:	e3e00015 	mvn	r0, #21
}
3481d304:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481d308 <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
3481d308:	e92d4010 	push	{r4, lr}
	if(*cp=='-')
3481d30c:	e5d0c000 	ldrb	ip, [r0]
3481d310:	e35c002d 	cmp	ip, #45	; 0x2d
3481d314:	1a000003 	bne	3481d328 <simple_strtol+0x20>
		return -simple_strtoul(cp+1,endp,base);
3481d318:	e2800001 	add	r0, r0, #1
3481d31c:	ebffffb0 	bl	3481d1e4 <simple_strtoul>
	return simple_strtoul(cp,endp,base);
}
3481d320:	e2600000 	rsb	r0, r0, #0
3481d324:	e8bd8010 	pop	{r4, pc}
3481d328:	e8bd4010 	pop	{r4, lr}

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
3481d32c:	eaffffac 	b	3481d1e4 <simple_strtoul>

3481d330 <ustrtoul>:
}

int ustrtoul(const char *cp, char **endp, unsigned int base)
{
3481d330:	e92d4010 	push	{r4, lr}
3481d334:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
3481d338:	ebffffa9 	bl	3481d1e4 <simple_strtoul>
	switch (**endp) {
3481d33c:	e5943000 	ldr	r3, [r4]
3481d340:	e5d32000 	ldrb	r2, [r3]
3481d344:	e352004b 	cmp	r2, #75	; 0x4b
3481d348:	0a00000a 	beq	3481d378 <ustrtoul+0x48>
3481d34c:	8a000002 	bhi	3481d35c <ustrtoul+0x2c>
3481d350:	e3520047 	cmp	r2, #71	; 0x47
3481d354:	18bd8010 	popne	{r4, pc}
3481d358:	ea000004 	b	3481d370 <ustrtoul+0x40>
3481d35c:	e352004d 	cmp	r2, #77	; 0x4d
3481d360:	0a000003 	beq	3481d374 <ustrtoul+0x44>
3481d364:	e352006b 	cmp	r2, #107	; 0x6b
3481d368:	18bd8010 	popne	{r4, pc}
3481d36c:	ea000001 	b	3481d378 <ustrtoul+0x48>
	case 'G' :
		result *= 1024;
3481d370:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'M':
		result *= 1024;
3481d374:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
		if ((*endp)[1] == 'i') {
3481d378:	e5d32001 	ldrb	r2, [r3, #1]
	case 'M':
		result *= 1024;
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
3481d37c:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
3481d380:	e3520069 	cmp	r2, #105	; 0x69
3481d384:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
3481d388:	e5d31002 	ldrb	r1, [r3, #2]
3481d38c:	e2832002 	add	r2, r3, #2
3481d390:	e3510042 	cmp	r1, #66	; 0x42
				(*endp) += 3;
3481d394:	02833003 	addeq	r3, r3, #3
3481d398:	05843000 	streq	r3, [r4]
			else
				(*endp) += 2;
3481d39c:	15842000 	strne	r2, [r4]
		}
	}
	return result;
}
3481d3a0:	e8bd8010 	pop	{r4, pc}

3481d3a4 <simple_strtoull>:

unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
{
3481d3a4:	e92d4cf0 	push	{r4, r5, r6, r7, sl, fp, lr}
	unsigned long long result = 0, value;

	if (*cp == '0') {
3481d3a8:	e5d03000 	ldrb	r3, [r0]
3481d3ac:	e3530030 	cmp	r3, #48	; 0x30
3481d3b0:	1a00000d 	bne	3481d3ec <simple_strtoull+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481d3b4:	e5f03001 	ldrb	r3, [r0, #1]!
3481d3b8:	e3530078 	cmp	r3, #120	; 0x78
3481d3bc:	1a000007 	bne	3481d3e0 <simple_strtoull+0x3c>
3481d3c0:	e5d0c001 	ldrb	ip, [r0, #1]
3481d3c4:	e59f40a8 	ldr	r4, [pc, #168]	; 3481d474 <simple_strtoull+0xd0>
3481d3c8:	e2803001 	add	r3, r0, #1
3481d3cc:	e7d4c00c 	ldrb	ip, [r4, ip]
3481d3d0:	e31c0044 	tst	ip, #68	; 0x44
3481d3d4:	11a00003 	movne	r0, r3
			base = 16;
3481d3d8:	13a02010 	movne	r2, #16
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481d3dc:	1a000004 	bne	3481d3f4 <simple_strtoull+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481d3e0:	e3520000 	cmp	r2, #0
3481d3e4:	03a02008 	moveq	r2, #8
3481d3e8:	ea000001 	b	3481d3f4 <simple_strtoull+0x50>
		}
	}
	if (!base) {
		base = 10;
3481d3ec:	e3520000 	cmp	r2, #0
3481d3f0:	03a0200a 	moveq	r2, #10
3481d3f4:	e3a04000 	mov	r4, #0
3481d3f8:	e3a05000 	mov	r5, #0
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d3fc:	e59fc070 	ldr	ip, [pc, #112]	; 3481d474 <simple_strtoull+0xd0>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481d400:	e3a03000 	mov	r3, #0
3481d404:	ea000003 	b	3481d418 <simple_strtoull+0x74>
		result = result * base + value;
3481d408:	e0876294 	umull	r6, r7, r4, r2
3481d40c:	e0277592 	mla	r7, r2, r5, r7
3481d410:	e09a4006 	adds	r4, sl, r6
3481d414:	e0ab5007 	adc	r5, fp, r7
3481d418:	e1a07000 	mov	r7, r0
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d41c:	e4d06001 	ldrb	r6, [r0], #1
3481d420:	e7dca006 	ldrb	sl, [ip, r6]
3481d424:	e31a0044 	tst	sl, #68	; 0x44
3481d428:	0a00000c 	beq	3481d460 <simple_strtoull+0xbc>
3481d42c:	e31a0004 	tst	sl, #4
3481d430:	12466030 	subne	r6, r6, #48	; 0x30
3481d434:	1a000003 	bne	3481d448 <simple_strtoull+0xa4>
3481d438:	e31a0002 	tst	sl, #2
3481d43c:	12466020 	subne	r6, r6, #32
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481d440:	16ef6076 	uxtbne	r6, r6
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d444:	e2466037 	sub	r6, r6, #55	; 0x37
3481d448:	e1a0a006 	mov	sl, r6
3481d44c:	e1a0bfca 	asr	fp, sl, #31
3481d450:	e153000b 	cmp	r3, fp
3481d454:	1a000001 	bne	3481d460 <simple_strtoull+0xbc>
3481d458:	e1520006 	cmp	r2, r6
3481d45c:	8affffe9 	bhi	3481d408 <simple_strtoull+0x64>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}
	if (endp)
3481d460:	e3510000 	cmp	r1, #0
		*endp = (char *) cp;
3481d464:	15817000 	strne	r7, [r1]
	return result;
}
3481d468:	e1a00004 	mov	r0, r4
3481d46c:	e1a01005 	mov	r1, r5
3481d470:	e8bd8cf0 	pop	{r4, r5, r6, r7, sl, fp, pc}
3481d474:	34821cf4 	.word	0x34821cf4

3481d478 <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d478:	eafffe46 	b	3481cd98 <vsnprintf_internal.clone.3>

3481d47c <sprintf>:
}

int sprintf(char * buf, const char *fmt, ...)
{
3481d47c:	e92d000e 	push	{r1, r2, r3}
3481d480:	e92d4003 	push	{r0, r1, lr}
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d484:	e59d100c 	ldr	r1, [sp, #12]
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
3481d488:	e28d2010 	add	r2, sp, #16
3481d48c:	e58d2004 	str	r2, [sp, #4]
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d490:	ebfffe40 	bl	3481cd98 <vsnprintf_internal.clone.3>

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
	va_end(args);
	return i;
}
3481d494:	e8bd400c 	pop	{r2, r3, lr}
3481d498:	e28dd00c 	add	sp, sp, #12
3481d49c:	e12fff1e 	bx	lr

3481d4a0 <panic>:

void panic(const char *fmt, ...)
{
3481d4a0:	e92d000f 	push	{r0, r1, r2, r3}
3481d4a4:	e92d4007 	push	{r0, r1, r2, lr}
	va_list	args;
	va_start(args, fmt);
	vprintf(fmt, args);
3481d4a8:	e59d0010 	ldr	r0, [sp, #16]
}

void panic(const char *fmt, ...)
{
	va_list	args;
	va_start(args, fmt);
3481d4ac:	e28d1014 	add	r1, sp, #20
3481d4b0:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
3481d4b4:	ebffb197 	bl	34809b18 <vprintf>
	putc('\n');
3481d4b8:	e3a0000a 	mov	r0, #10
3481d4bc:	ebffb16d 	bl	34809a78 <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
3481d4c0:	e59f0018 	ldr	r0, [pc, #24]	; 3481d4e0 <panic+0x40>
3481d4c4:	ebfffd02 	bl	3481c8d4 <udelay>
	do_reset (NULL, 0, 0, NULL);
3481d4c8:	e3a00000 	mov	r0, #0
3481d4cc:	e1a01000 	mov	r1, r0
3481d4d0:	e1a02000 	mov	r2, r0
3481d4d4:	e1a03000 	mov	r3, r0
3481d4d8:	ebff9327 	bl	3480217c <do_reset>
3481d4dc:	eafffffe 	b	3481d4dc <panic+0x3c>
3481d4e0:	000186a0 	.word	0x000186a0

3481d4e4 <__assert_fail>:
		;
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
3481d4e4:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
3481d4e8:	e58d0000 	str	r0, [sp]
3481d4ec:	e59f0000 	ldr	r0, [pc, #0]	; 3481d4f4 <__assert_fail+0x10>
3481d4f0:	ebffffea 	bl	3481d4a0 <panic>
3481d4f4:	34827fd3 	.word	0x34827fd3

3481d4f8 <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
3481d4f8:	e92d4070 	push	{r4, r5, r6, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481d4fc:	e59f4048 	ldr	r4, [pc, #72]	; 3481d54c <simple_itoa+0x54>
3481d500:	e3a03000 	mov	r3, #0
3481d504:	e5c43015 	strb	r3, [r4, #21]
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
	      assertion);
}

char *simple_itoa(ulong i)
{
3481d508:	e1a05000 	mov	r5, r0
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481d50c:	e2844014 	add	r4, r4, #20
3481d510:	ea000000 	b	3481d518 <simple_itoa+0x20>
	do {
		*p-- = '0' + i % 10;
3481d514:	e1a04006 	mov	r4, r6
3481d518:	e1a00005 	mov	r0, r5
3481d51c:	e3a0100a 	mov	r1, #10
3481d520:	eb000a23 	bl	3481fdb4 <__aeabi_uidivmod>
3481d524:	e1a06004 	mov	r6, r4
3481d528:	e2811030 	add	r1, r1, #48	; 0x30
3481d52c:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
3481d530:	e1a00005 	mov	r0, r5
3481d534:	e3a0100a 	mov	r1, #10
3481d538:	eb0009a2 	bl	3481fbc8 <__udivsi3>
	} while (i > 0);
3481d53c:	e2505000 	subs	r5, r0, #0
3481d540:	1afffff3 	bne	3481d514 <simple_itoa+0x1c>
	return p + 1;
}
3481d544:	e1a00004 	mov	r0, r4
3481d548:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d54c:	3482bba8 	.word	0x3482bba8

3481d550 <zcfree>:
void  zcfree (opaque, ptr, nb)
	voidpf opaque;
	voidpf ptr;
	unsigned nb;
{
	free(ptr);
3481d550:	e1a00001 	mov	r0, r1
3481d554:	eaffb299 	b	34809fc0 <free>

3481d558 <zcalloc>:
	unsigned items;
	unsigned size;
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
3481d558:	e0000291 	mul	r0, r1, r2
3481d55c:	eaffb320 	b	3480a1e4 <malloc>

3481d560 <inflate_fast>:
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481d560:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
3481d564:	e5903004 	ldr	r3, [r0, #4]
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481d568:	e5904000 	ldr	r4, [r0]
    last = in + (strm->avail_in - 5);
3481d56c:	e2432005 	sub	r2, r3, #5
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481d570:	e2444001 	sub	r4, r4, #1
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481d574:	e24dd048 	sub	sp, sp, #72	; 0x48

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481d578:	e0942002 	adds	r2, r4, r2
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
3481d57c:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481d580:	e58d201c 	str	r2, [sp, #28]
3481d584:	3a000005 	bcc	3481d5a0 <inflate_fast+0x40>
3481d588:	e3530005 	cmp	r3, #5
        /*
         * overflow detected, limit strm->avail_in to the
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
3481d58c:	81e03004 	mvnhi	r3, r4
3481d590:	85803004 	strhi	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
3481d594:	82433005 	subhi	r3, r3, #5
3481d598:	80843003 	addhi	r3, r4, r3
3481d59c:	858d301c 	strhi	r3, [sp, #28]
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481d5a0:	e595602c 	ldr	r6, [r5, #44]	; 0x2c
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481d5a4:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481d5a8:	e58d6038 	str	r6, [sp, #56]	; 0x38
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
3481d5ac:	e5956054 	ldr	r6, [r5, #84]	; 0x54
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481d5b0:	e58dc024 	str	ip, [sp, #36]	; 0x24
    lmask = (1U << state->lenbits) - 1;
3481d5b4:	e3a0c001 	mov	ip, #1
3481d5b8:	e1a0661c 	lsl	r6, ip, r6
3481d5bc:	e2466001 	sub	r6, r6, #1
3481d5c0:	e58d603c 	str	r6, [sp, #60]	; 0x3c
    dmask = (1U << state->distbits) - 1;
3481d5c4:	e5956058 	ldr	r6, [r5, #88]	; 0x58
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d5c8:	e5902010 	ldr	r2, [r0, #16]
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d5cc:	e1a0661c 	lsl	r6, ip, r6
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481d5d0:	e590300c 	ldr	r3, [r0, #12]
    beg = out - (start - strm->avail_out);
3481d5d4:	e0611002 	rsb	r1, r1, r2
    end = out + (strm->avail_out - 257);
3481d5d8:	e2422c01 	sub	r2, r2, #256	; 0x100
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481d5dc:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
3481d5e0:	e2422001 	sub	r2, r2, #1
3481d5e4:	e0832002 	add	r2, r3, r2
3481d5e8:	e58d2028 	str	r2, [sp, #40]	; 0x28
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481d5ec:	e5952028 	ldr	r2, [r5, #40]	; 0x28
    whave = state->whave;
    write = state->write;
    window = state->window;
3481d5f0:	e5959034 	ldr	r9, [r5, #52]	; 0x34
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481d5f4:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d5f8:	e2466001 	sub	r6, r6, #1
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
3481d5fc:	e5957030 	ldr	r7, [r5, #48]	; 0x30
    window = state->window;
3481d600:	e58d9030 	str	r9, [sp, #48]	; 0x30
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d604:	e58d6040 	str	r6, [sp, #64]	; 0x40
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d608:	e2496001 	sub	r6, r9, #1
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d60c:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d610:	e0831001 	add	r1, r3, r1
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
3481d614:	e595a04c 	ldr	sl, [r5, #76]	; 0x4c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d618:	e58d1034 	str	r1, [sp, #52]	; 0x34
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d61c:	e0879009 	add	r9, r7, r9
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
3481d620:	e5951038 	ldr	r1, [r5, #56]	; 0x38
    bits = state->bits;
3481d624:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
    lcode = state->lencode;
3481d628:	e58da020 	str	sl, [sp, #32]
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d62c:	e58d600c 	str	r6, [sp, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d630:	e58d9044 	str	r9, [sp, #68]	; 0x44
3481d634:	e58d5010 	str	r5, [sp, #16]
3481d638:	e58d0014 	str	r0, [sp, #20]
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
3481d63c:	e352000e 	cmp	r2, #14
3481d640:	8a000007 	bhi	3481d664 <inflate_fast+0x104>
            hold += (unsigned long)(PUP(in)) << bits;
3481d644:	e5d4c001 	ldrb	ip, [r4, #1]
3481d648:	e2840001 	add	r0, r4, #1
3481d64c:	e081121c 	add	r1, r1, ip, lsl r2
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
3481d650:	e2804001 	add	r4, r0, #1
3481d654:	e5d00001 	ldrb	r0, [r0, #1]
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
3481d658:	e2822008 	add	r2, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
3481d65c:	e0811210 	add	r1, r1, r0, lsl r2
            bits += 8;
3481d660:	e2822008 	add	r2, r2, #8
        }
        this = lcode[hold & lmask];
3481d664:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
3481d668:	e59d5020 	ldr	r5, [sp, #32]
3481d66c:	e001000a 	and	r0, r1, sl
3481d670:	e085c100 	add	ip, r5, r0, lsl #2
3481d674:	e7d56100 	ldrb	r6, [r5, r0, lsl #2]
3481d678:	e5dc0001 	ldrb	r0, [ip, #1]
3481d67c:	e1dcc0b2 	ldrh	ip, [ip, #2]
3481d680:	e1a0a005 	mov	sl, r5
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
3481d684:	e3560000 	cmp	r6, #0
            bits += 8;
        }
        this = lcode[hold & lmask];
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
3481d688:	e1a01031 	lsr	r1, r1, r0
        bits -= op;
3481d68c:	e0602002 	rsb	r2, r0, r2
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
3481d690:	05e3c001 	strbeq	ip, [r3, #1]!
3481d694:	0a0000ed 	beq	3481da50 <inflate_fast+0x4f0>
        }
        else if (op & 16) {                     /* length base */
3481d698:	e3160010 	tst	r6, #16
3481d69c:	0a0000d8 	beq	3481da04 <inflate_fast+0x4a4>
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
3481d6a0:	e216600f 	ands	r6, r6, #15
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
3481d6a4:	e1a0000c 	mov	r0, ip
            op &= 15;                           /* number of extra bits */
            if (op) {
3481d6a8:	0a00000a 	beq	3481d6d8 <inflate_fast+0x178>
                if (bits < op) {
3481d6ac:	e1520006 	cmp	r2, r6
                    hold += (unsigned long)(PUP(in)) << bits;
3481d6b0:	35f40001 	ldrbcc	r0, [r4, #1]!
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d6b4:	e3a09001 	mov	r9, #1
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
3481d6b8:	30811210 	addcc	r1, r1, r0, lsl r2
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d6bc:	e1a00619 	lsl	r0, r9, r6
3481d6c0:	e2400001 	sub	r0, r0, #1
3481d6c4:	e0010000 	and	r0, r1, r0
                hold >>= op;
3481d6c8:	e1a01631 	lsr	r1, r1, r6
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
3481d6cc:	32822008 	addcc	r2, r2, #8
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d6d0:	e08c0000 	add	r0, ip, r0
                hold >>= op;
                bits -= op;
3481d6d4:	e0662002 	rsb	r2, r6, r2
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
3481d6d8:	e352000e 	cmp	r2, #14
3481d6dc:	8a000007 	bhi	3481d700 <inflate_fast+0x1a0>
                hold += (unsigned long)(PUP(in)) << bits;
3481d6e0:	e284c001 	add	ip, r4, #1
3481d6e4:	e5d44001 	ldrb	r4, [r4, #1]
3481d6e8:	e0811214 	add	r1, r1, r4, lsl r2
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
3481d6ec:	e28c4001 	add	r4, ip, #1
3481d6f0:	e5dcc001 	ldrb	ip, [ip, #1]
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
3481d6f4:	e2822008 	add	r2, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
3481d6f8:	e081121c 	add	r1, r1, ip, lsl r2
                bits += 8;
3481d6fc:	e2822008 	add	r2, r2, #8
            }
            this = dcode[hold & dmask];
3481d700:	e59da040 	ldr	sl, [sp, #64]	; 0x40
3481d704:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
3481d708:	e001c00a 	and	ip, r1, sl
3481d70c:	e085610c 	add	r6, r5, ip, lsl #2
3481d710:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
3481d714:	e7d5c10c 	ldrb	ip, [r5, ip, lsl #2]
3481d718:	e5d65001 	ldrb	r5, [r6, #1]
3481d71c:	e1d660b2 	ldrh	r6, [r6, #2]
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481d720:	e31c0010 	tst	ip, #16
                bits += 8;
            }
            this = dcode[hold & dmask];
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
3481d724:	e1a01531 	lsr	r1, r1, r5
            bits -= op;
3481d728:	e0652002 	rsb	r2, r5, r2
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481d72c:	0a0000a1 	beq	3481d9b8 <inflate_fast+0x458>
                dist = (unsigned)(this.val);
                op &= 15;                       /* number of extra bits */
3481d730:	e20cc00f 	and	ip, ip, #15
                if (bits < op) {
3481d734:	e152000c 	cmp	r2, ip
3481d738:	2a000006 	bcs	3481d758 <inflate_fast+0x1f8>
                    hold += (unsigned long)(PUP(in)) << bits;
3481d73c:	e5f45001 	ldrb	r5, [r4, #1]!
3481d740:	e0811215 	add	r1, r1, r5, lsl r2
                    bits += 8;
3481d744:	e2822008 	add	r2, r2, #8
                    if (bits < op) {
3481d748:	e152000c 	cmp	r2, ip
                        hold += (unsigned long)(PUP(in)) << bits;
3481d74c:	35f45001 	ldrbcc	r5, [r4, #1]!
3481d750:	30811215 	addcc	r1, r1, r5, lsl r2
                        bits += 8;
3481d754:	32822008 	addcc	r2, r2, #8
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481d758:	e3a09001 	mov	r9, #1
3481d75c:	e1a05c19 	lsl	r5, r9, ip
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481d760:	e59da034 	ldr	sl, [sp, #52]	; 0x34
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481d764:	e2455001 	sub	r5, r5, #1
3481d768:	e0015005 	and	r5, r1, r5
3481d76c:	e0855006 	add	r5, r5, r6
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
3481d770:	e1a01c31 	lsr	r1, r1, ip
                bits -= op;
3481d774:	e06c2002 	rsb	r2, ip, r2
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481d778:	e06ac003 	rsb	ip, sl, r3
                if (dist > op) {                /* see if copy from window */
3481d77c:	e155000c 	cmp	r5, ip
3481d780:	9a000062 	bls	3481d910 <inflate_fast+0x3b0>
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
3481d784:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
3481d788:	e06cc005 	rsb	ip, ip, r5
                    if (op > whave) {
3481d78c:	e15c0006 	cmp	ip, r6
3481d790:	859d5010 	ldrhi	r5, [sp, #16]
3481d794:	859d0014 	ldrhi	r0, [sp, #20]
                        strm->msg = (char *)"invalid distance too far back";
3481d798:	859fc328 	ldrhi	ip, [pc, #808]	; 3481dac8 <inflate_fast+0x568>
3481d79c:	8a000094 	bhi	3481d9f4 <inflate_fast+0x494>
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
3481d7a0:	e3570000 	cmp	r7, #0
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d7a4:	e59da00c 	ldr	sl, [sp, #12]
                    if (write == 0) {           /* very common case */
3481d7a8:	1a000010 	bne	3481d7f0 <inflate_fast+0x290>
                        from += wsize - op;
3481d7ac:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
3481d7b0:	e59d600c 	ldr	r6, [sp, #12]
3481d7b4:	e06ca009 	rsb	sl, ip, r9
                        if (op < len) {         /* some from window */
3481d7b8:	e15c0000 	cmp	ip, r0
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
3481d7bc:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481d7c0:	2a000008 	bcs	3481d7e8 <inflate_fast+0x288>
                            len -= op;
3481d7c4:	e06c0000 	rsb	r0, ip, r0
3481d7c8:	e1a06003 	mov	r6, r3
3481d7cc:	e1a0b00c 	mov	fp, ip
3481d7d0:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481d7d4:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481d7d8:	e25bb001 	subs	fp, fp, #1
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d7dc:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481d7e0:	1afffffb 	bne	3481d7d4 <inflate_fast+0x274>
3481d7e4:	ea000033 	b	3481d8b8 <inflate_fast+0x358>
                            from = out - dist;  /* rest from output */
3481d7e8:	e1a0c003 	mov	ip, r3
3481d7ec:	ea00003b 	b	3481d8e0 <inflate_fast+0x380>
                        }
                    }
                    else if (write < op) {      /* wrap around window */
3481d7f0:	e157000c 	cmp	r7, ip
3481d7f4:	2a000022 	bcs	3481d884 <inflate_fast+0x324>
                        from += wsize + write - op;
3481d7f8:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
3481d7fc:	e59d600c 	ldr	r6, [sp, #12]
3481d800:	e06cb009 	rsb	fp, ip, r9
                        op -= write;
3481d804:	e067c00c 	rsb	ip, r7, ip
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d808:	e086b00b 	add	fp, r6, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481d80c:	e15c0000 	cmp	ip, r0
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d810:	21a0a00b 	movcs	sl, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481d814:	2afffff3 	bcs	3481d7e8 <inflate_fast+0x288>
                            len -= op;
3481d818:	e06c0000 	rsb	r0, ip, r0
3481d81c:	e58d3018 	str	r3, [sp, #24]
3481d820:	e1a0600c 	mov	r6, ip
3481d824:	e1a09004 	mov	r9, r4
3481d828:	e58d3004 	str	r3, [sp, #4]
                            do {
                                PUP(out) = PUP(from);
3481d82c:	e5fb4001 	ldrb	r4, [fp, #1]!
3481d830:	e59d3018 	ldr	r3, [sp, #24]
                            } while (--op);
3481d834:	e2566001 	subs	r6, r6, #1
                        from += wsize + write - op;
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d838:	e5e34001 	strb	r4, [r3, #1]!
3481d83c:	e58d3018 	str	r3, [sp, #24]
                            } while (--op);
3481d840:	1afffff9 	bne	3481d82c <inflate_fast+0x2cc>
3481d844:	e59d3004 	ldr	r3, [sp, #4]
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481d848:	e1570000 	cmp	r7, r0
3481d84c:	e1a04009 	mov	r4, r9
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
3481d850:	e083300c 	add	r3, r3, ip
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481d854:	2affffe3 	bcs	3481d7e8 <inflate_fast+0x288>
                                op = write;
                                len -= op;
3481d858:	e0670000 	rsb	r0, r7, r0
3481d85c:	e1a0c003 	mov	ip, r3
                                do {
                                    PUP(out) = PUP(from);
3481d860:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
3481d864:	e7d9a006 	ldrb	sl, [r9, r6]
3481d868:	e2866001 	add	r6, r6, #1
                                } while (--op);
3481d86c:	e1570006 	cmp	r7, r6
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
                                op = write;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
3481d870:	e5eca001 	strb	sl, [ip, #1]!
                                } while (--op);
3481d874:	1afffff9 	bne	3481d860 <inflate_fast+0x300>
3481d878:	e0833007 	add	r3, r3, r7
                                from = out - dist;      /* rest from output */
3481d87c:	e065a003 	rsb	sl, r5, r3
3481d880:	eaffffd8 	b	3481d7e8 <inflate_fast+0x288>
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481d884:	e59d600c 	ldr	r6, [sp, #12]
3481d888:	e06ca007 	rsb	sl, ip, r7
                        if (op < len) {         /* some from window */
3481d88c:	e15c0000 	cmp	ip, r0
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481d890:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481d894:	2affffd3 	bcs	3481d7e8 <inflate_fast+0x288>
                            len -= op;
3481d898:	e06c0000 	rsb	r0, ip, r0
3481d89c:	e1a06003 	mov	r6, r3
3481d8a0:	e1a0b00c 	mov	fp, ip
3481d8a4:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481d8a8:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481d8ac:	e25bb001 	subs	fp, fp, #1
                    else {                      /* contiguous in window */
                        from += write - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d8b0:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481d8b4:	1afffffb 	bne	3481d8a8 <inflate_fast+0x348>
3481d8b8:	e1a04009 	mov	r4, r9
3481d8bc:	e083300c 	add	r3, r3, ip
3481d8c0:	eaffffed 	b	3481d87c <inflate_fast+0x31c>
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481d8c4:	e5da3001 	ldrb	r3, [sl, #1]
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481d8c8:	e2400003 	sub	r0, r0, #3
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481d8cc:	e5cc3001 	strb	r3, [ip, #1]
                        PUP(out) = PUP(from);
3481d8d0:	e5da3002 	ldrb	r3, [sl, #2]
3481d8d4:	e5cc3002 	strb	r3, [ip, #2]
                        PUP(out) = PUP(from);
3481d8d8:	e5fa3003 	ldrb	r3, [sl, #3]!
3481d8dc:	e5ec3003 	strb	r3, [ip, #3]!
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481d8e0:	e3500002 	cmp	r0, #2
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481d8e4:	e1a0300c 	mov	r3, ip
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481d8e8:	8afffff5 	bhi	3481d8c4 <inflate_fast+0x364>
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
3481d8ec:	e3500000 	cmp	r0, #0
3481d8f0:	0a000056 	beq	3481da50 <inflate_fast+0x4f0>
                        PUP(out) = PUP(from);
3481d8f4:	e5da5001 	ldrb	r5, [sl, #1]
3481d8f8:	e28ac001 	add	ip, sl, #1
3481d8fc:	e5e35001 	strb	r5, [r3, #1]!
                        if (len > 1)
3481d900:	e3500002 	cmp	r0, #2
                            PUP(out) = PUP(from);
3481d904:	05dc0001 	ldrbeq	r0, [ip, #1]
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
3481d908:	0a000028 	beq	3481d9b0 <inflate_fast+0x450>
3481d90c:	ea00004f 	b	3481da50 <inflate_fast+0x4f0>
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
3481d910:	e3130001 	tst	r3, #1
                }
                else {
		    unsigned short *sout;
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
3481d914:	e0656003 	rsb	r6, r5, r3
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481d918:	05f6c001 	ldrbeq	ip, [r6, #1]!
			len--;
3481d91c:	02400001 	subeq	r0, r0, #1

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481d920:	05e3c001 	strbeq	ip, [r3, #1]!
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
3481d924:	e3550002 	cmp	r5, #2
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
3481d928:	e243c001 	sub	ip, r3, #1
		    if (dist > 2 ) {
3481d92c:	9a000010 	bls	3481d974 <inflate_fast+0x414>
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481d930:	e2469001 	sub	r9, r6, #1
			loops = len >> 1;
3481d934:	e1a030a0 	lsr	r3, r0, #1
3481d938:	e1a05006 	mov	r5, r6
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481d93c:	e58d9018 	str	r9, [sp, #24]
			loops = len >> 1;
3481d940:	e1a0a00c 	mov	sl, ip
3481d944:	e1a06003 	mov	r6, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
3481d948:	e5d5b002 	ldrb	fp, [r5, #2]
3481d94c:	e5d59001 	ldrb	r9, [r5, #1]
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481d950:	e2566001 	subs	r6, r6, #1
3481d954:	e189940b 	orr	r9, r9, fp, lsl #8
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
3481d958:	e1ea90b2 	strh	r9, [sl, #2]!
			while (--loops);
3481d95c:	e2855002 	add	r5, r5, #2
3481d960:	1afffff8 	bne	3481d948 <inflate_fast+0x3e8>
    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(strm, start)
3481d964:	e59da018 	ldr	sl, [sp, #24]
3481d968:	e08a6083 	add	r6, sl, r3, lsl #1

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481d96c:	e2866001 	add	r6, r6, #1
3481d970:	ea000009 	b	3481d99c <inflate_fast+0x43c>
			out = (unsigned char *)sout + OFF;
			from = (unsigned char *)sfrom + OFF;
		    } else { /* dist == 1 or dist == 2 */
			unsigned short pat16;

			pat16 = *(sout-2+2*OFF);
3481d974:	e153a0b1 	ldrh	sl, [r3, #-1]
			if (dist == 1)
3481d978:	e3550001 	cmp	r5, #1
#if defined(__BIG_ENDIAN)
			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
#elif defined(__LITTLE_ENDIAN)
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
3481d97c:	03ca30ff 	biceq	r3, sl, #255	; 0xff
3481d980:	0183a42a 	orreq	sl, r3, sl, lsr #8
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
3481d984:	e1a030a0 	lsr	r3, r0, #1
3481d988:	e1a0900c 	mov	r9, ip
3481d98c:	e1a05003 	mov	r5, r3
			do
			    PUP(sout) = pat16;
			while (--loops);
3481d990:	e2555001 	subs	r5, r5, #1
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
3481d994:	e1e9a0b2 	strh	sl, [r9, #2]!
			while (--loops);
3481d998:	1afffffc 	bne	3481d990 <inflate_fast+0x430>
			out = (unsigned char *)sout + OFF;
3481d99c:	e08c3083 	add	r3, ip, r3, lsl #1
		    }
		    if (len & 1)
3481d9a0:	e3100001 	tst	r0, #1
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
			while (--loops);
			out = (unsigned char *)sout + OFF;
3481d9a4:	e2833001 	add	r3, r3, #1
		    }
		    if (len & 1)
3481d9a8:	0a000028 	beq	3481da50 <inflate_fast+0x4f0>
			PUP(out) = PUP(from);
3481d9ac:	e5d60001 	ldrb	r0, [r6, #1]
3481d9b0:	e5e30001 	strb	r0, [r3, #1]!
3481d9b4:	ea000025 	b	3481da50 <inflate_fast+0x4f0>
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
3481d9b8:	e31c0040 	tst	ip, #64	; 0x40
3481d9bc:	1a000009 	bne	3481d9e8 <inflate_fast+0x488>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
3481d9c0:	e3a05001 	mov	r5, #1
3481d9c4:	e1a0cc15 	lsl	ip, r5, ip
3481d9c8:	e24cc001 	sub	ip, ip, #1
3481d9cc:	e00cc001 	and	ip, ip, r1
3481d9d0:	e08c6006 	add	r6, ip, r6
3481d9d4:	e089a106 	add	sl, r9, r6, lsl #2
3481d9d8:	e7d9c106 	ldrb	ip, [r9, r6, lsl #2]
3481d9dc:	e5da5001 	ldrb	r5, [sl, #1]
3481d9e0:	e1da60b2 	ldrh	r6, [sl, #2]
                goto dodist;
3481d9e4:	eaffff4d 	b	3481d720 <inflate_fast+0x1c0>
3481d9e8:	e59d5010 	ldr	r5, [sp, #16]
3481d9ec:	e59d0014 	ldr	r0, [sp, #20]
            }
            else {
                strm->msg = (char *)"invalid distance code";
3481d9f0:	e59fc0d4 	ldr	ip, [pc, #212]	; 3481dacc <inflate_fast+0x56c>
3481d9f4:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
3481d9f8:	e3a0c01b 	mov	ip, #27
3481d9fc:	e585c000 	str	ip, [r5]
                break;
3481da00:	ea000019 	b	3481da6c <inflate_fast+0x50c>
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
3481da04:	e3160040 	tst	r6, #64	; 0x40
3481da08:	1a000009 	bne	3481da34 <inflate_fast+0x4d4>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481da0c:	e3a09001 	mov	r9, #1
3481da10:	e1a06619 	lsl	r6, r9, r6
3481da14:	e2466001 	sub	r6, r6, #1
3481da18:	e0066001 	and	r6, r6, r1
3481da1c:	e086c00c 	add	ip, r6, ip
3481da20:	e08a510c 	add	r5, sl, ip, lsl #2
3481da24:	e7da610c 	ldrb	r6, [sl, ip, lsl #2]
3481da28:	e5d50001 	ldrb	r0, [r5, #1]
3481da2c:	e1d5c0b2 	ldrh	ip, [r5, #2]
            goto dolen;
3481da30:	eaffff13 	b	3481d684 <inflate_fast+0x124>
        }
        else if (op & 32) {                     /* end-of-block */
3481da34:	e3160020 	tst	r6, #32
3481da38:	e59d5010 	ldr	r5, [sp, #16]
3481da3c:	e59d0014 	ldr	r0, [sp, #20]
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
3481da40:	13a0c00b 	movne	ip, #11
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
3481da44:	059fc084 	ldreq	ip, [pc, #132]	; 3481dad0 <inflate_fast+0x570>
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
3481da48:	0affffe9 	beq	3481d9f4 <inflate_fast+0x494>
3481da4c:	eaffffea 	b	3481d9fc <inflate_fast+0x49c>
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
3481da50:	e59da028 	ldr	sl, [sp, #40]	; 0x28
3481da54:	e59dc01c 	ldr	ip, [sp, #28]
3481da58:	e153000a 	cmp	r3, sl
3481da5c:	3154000c 	cmpcc	r4, ip
3481da60:	3afffef5 	bcc	3481d63c <inflate_fast+0xdc>
3481da64:	e59d5010 	ldr	r5, [sp, #16]
3481da68:	e59d0014 	ldr	r0, [sp, #20]

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
3481da6c:	e1a0c1a2 	lsr	ip, r2, #3
    in -= len;
3481da70:	e06c4004 	rsb	r4, ip, r4
    bits -= len << 3;
3481da74:	e1a0c18c 	lsl	ip, ip, #3
3481da78:	e06c2002 	rsb	r2, ip, r2
    hold &= (1U << bits) - 1;
3481da7c:	e3e0c000 	mvn	ip, #0
3481da80:	e1c1121c 	bic	r1, r1, ip, lsl r2
3481da84:	e59d601c 	ldr	r6, [sp, #28]

    /* update state and return */
    strm->next_in = in + OFF;
3481da88:	e284c001 	add	ip, r4, #1
3481da8c:	e580c000 	str	ip, [r0]
3481da90:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    strm->next_out = out + OFF;
3481da94:	e283c001 	add	ip, r3, #1
3481da98:	e580c00c 	str	ip, [r0, #12]
3481da9c:	e286c005 	add	ip, r6, #5
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481daa0:	e064400c 	rsb	r4, r4, ip
3481daa4:	e289cc01 	add	ip, r9, #256	; 0x100
3481daa8:	e28cc001 	add	ip, ip, #1
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
3481daac:	e063300c 	rsb	r3, r3, ip
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481dab0:	e5804004 	str	r4, [r0, #4]
    strm->avail_out = (unsigned)(out < end ?
3481dab4:	e5803010 	str	r3, [r0, #16]
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
3481dab8:	e5851038 	str	r1, [r5, #56]	; 0x38
    state->bits = bits;
3481dabc:	e585203c 	str	r2, [r5, #60]	; 0x3c
    return;
}
3481dac0:	e28dd048 	add	sp, sp, #72	; 0x48
3481dac4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481dac8:	34827ff5 	.word	0x34827ff5
3481dacc:	34828013 	.word	0x34828013
3481dad0:	34828029 	.word	0x34828029

3481dad4 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481dad4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481dad8:	e24dd088 	sub	sp, sp, #136	; 0x88
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481dadc:	e28d4068 	add	r4, sp, #104	; 0x68
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481dae0:	e58d1030 	str	r1, [sp, #48]	; 0x30
3481dae4:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481dae8:	e28dc066 	add	ip, sp, #102	; 0x66
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481daec:	e1a05004 	mov	r5, r4
3481daf0:	e284701e 	add	r7, r4, #30
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
3481daf4:	e3a06000 	mov	r6, #0
3481daf8:	e1ec60b2 	strh	r6, [ip, #2]!
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
3481dafc:	e15c0007 	cmp	ip, r7
3481db00:	1afffffb 	bne	3481daf4 <inflate_table+0x20>
3481db04:	e59db030 	ldr	fp, [sp, #48]	; 0x30
3481db08:	e3a0c000 	mov	ip, #0
3481db0c:	e1a0600b 	mov	r6, fp
3481db10:	ea000006 	b	3481db30 <inflate_table+0x5c>
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;
3481db14:	e0d690b2 	ldrh	r9, [r6], #2
3481db18:	e28da088 	add	sl, sp, #136	; 0x88
3481db1c:	e08a9089 	add	r9, sl, r9, lsl #1
3481db20:	e159a2b0 	ldrh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481db24:	e28cc001 	add	ip, ip, #1
        count[lens[sym]]++;
3481db28:	e28aa001 	add	sl, sl, #1
3481db2c:	e149a2b0 	strh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481db30:	e15c0002 	cmp	ip, r2
3481db34:	3afffff6 	bcc	3481db14 <inflate_table+0x40>
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
3481db38:	e59d60a8 	ldr	r6, [sp, #168]	; 0xa8
3481db3c:	e28da088 	add	sl, sp, #136	; 0x88
3481db40:	e596c000 	ldr	ip, [r6]
    for (max = MAXBITS; max >= 1; max--)
3481db44:	e3a0600f 	mov	r6, #15
        if (count[max] != 0) break;
3481db48:	e17a90b2 	ldrh	r9, [sl, #-2]!
3481db4c:	e3590000 	cmp	r9, #0
3481db50:	0a000004 	beq	3481db68 <inflate_table+0x94>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
3481db54:	e3560000 	cmp	r6, #0
3481db58:	11a0a004 	movne	sl, r4
3481db5c:	13a04001 	movne	r4, #1
3481db60:	1a000013 	bne	3481dbb4 <inflate_table+0xe0>
3481db64:	ea000001 	b	3481db70 <inflate_table+0x9c>
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
3481db68:	e2566001 	subs	r6, r6, #1
3481db6c:	1afffff5 	bne	3481db48 <inflate_table+0x74>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481db70:	e5932000 	ldr	r2, [r3]
3481db74:	e3a01001 	mov	r1, #1
3481db78:	e2820004 	add	r0, r2, #4
3481db7c:	e3a0c040 	mov	ip, #64	; 0x40
3481db80:	e5c21001 	strb	r1, [r2, #1]
3481db84:	e5c2c000 	strb	ip, [r2]
3481db88:	e5c01001 	strb	r1, [r0, #1]
3481db8c:	e5c2c004 	strb	ip, [r2, #4]
3481db90:	e3a07000 	mov	r7, #0
        *(*table)++ = this;
        *bits = 1;
3481db94:	e59d90a8 	ldr	r9, [sp, #168]	; 0xa8
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481db98:	e1c270b2 	strh	r7, [r2, #2]
3481db9c:	e1c070b2 	strh	r7, [r0, #2]
        *(*table)++ = this;
3481dba0:	e2800004 	add	r0, r0, #4
3481dba4:	e5830000 	str	r0, [r3]
        *bits = 1;
3481dba8:	e5891000 	str	r1, [r9]
        return 0;     /* no symbols, but wait for decoding to report error */
3481dbac:	e3a00000 	mov	r0, #0
3481dbb0:	ea00011e 	b	3481e030 <inflate_table+0x55c>
    }
    for (min = 1; min <= MAXBITS; min++)
        if (count[min] != 0) break;
3481dbb4:	e1fa90b2 	ldrh	r9, [sl, #2]!
3481dbb8:	e3590000 	cmp	r9, #0
3481dbbc:	1a000004 	bne	3481dbd4 <inflate_table+0x100>
        *(*table)++ = this;             /* make a table to force an error */
        *(*table)++ = this;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min <= MAXBITS; min++)
3481dbc0:	e2844001 	add	r4, r4, #1
3481dbc4:	e3540010 	cmp	r4, #16
3481dbc8:	1afffff9 	bne	3481dbb4 <inflate_table+0xe0>
3481dbcc:	e1a0c004 	mov	ip, r4
3481dbd0:	ea000003 	b	3481dbe4 <inflate_table+0x110>
3481dbd4:	e156000c 	cmp	r6, ip
3481dbd8:	31a0c006 	movcc	ip, r6
        if (count[min] != 0) break;
    if (root < min) root = min;
3481dbdc:	e15c0004 	cmp	ip, r4
3481dbe0:	31a0c004 	movcc	ip, r4

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
3481dbe4:	e3a09001 	mov	r9, #1
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
3481dbe8:	e1a0a089 	lsl	sl, r9, #1
        left -= count[len];
3481dbec:	e1f590b2 	ldrh	r9, [r5, #2]!
        if (left < 0) return -1;        /* over-subscribed */
3481dbf0:	e05a9009 	subs	r9, sl, r9
3481dbf4:	4a00010a 	bmi	3481e024 <inflate_table+0x550>
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
3481dbf8:	e1550007 	cmp	r5, r7
3481dbfc:	1afffff9 	bne	3481dbe8 <inflate_table+0x114>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
3481dc00:	e3590000 	cmp	r9, #0
3481dc04:	0a000005 	beq	3481dc20 <inflate_table+0x14c>
3481dc08:	e2705001 	rsbs	r5, r0, #1
3481dc0c:	33a05000 	movcc	r5, #0
3481dc10:	e3560001 	cmp	r6, #1
3481dc14:	13855001 	orrne	r5, r5, #1
3481dc18:	e3550000 	cmp	r5, #0
3481dc1c:	1a000100 	bne	3481e024 <inflate_table+0x550>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
3481dc20:	e3a0a000 	mov	sl, #0
3481dc24:	e1cda4ba 	strh	sl, [sp, #74]	; 0x4a
3481dc28:	e28d7048 	add	r7, sp, #72	; 0x48
3481dc2c:	e3a05000 	mov	r5, #0
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481dc30:	e2855002 	add	r5, r5, #2
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
3481dc34:	e28da068 	add	sl, sp, #104	; 0x68
3481dc38:	e19a90b5 	ldrh	r9, [sl, r5]
3481dc3c:	e1d7a0b2 	ldrh	sl, [r7, #2]
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481dc40:	e355001c 	cmp	r5, #28
        offs[len + 1] = offs[len] + count[len];
3481dc44:	e089a00a 	add	sl, r9, sl
3481dc48:	e1c7a0b4 	strh	sl, [r7, #4]
3481dc4c:	e2877002 	add	r7, r7, #2
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481dc50:	1afffff6 	bne	3481dc30 <inflate_table+0x15c>
3481dc54:	e3a05000 	mov	r5, #0
3481dc58:	ea00000a 	b	3481dc88 <inflate_table+0x1b4>
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
3481dc5c:	e0db90b2 	ldrh	r9, [fp], #2
3481dc60:	e3590000 	cmp	r9, #0
3481dc64:	0a000006 	beq	3481dc84 <inflate_table+0x1b0>
3481dc68:	e28d7088 	add	r7, sp, #136	; 0x88
3481dc6c:	e0879089 	add	r9, r7, r9, lsl #1
3481dc70:	e15974b0 	ldrh	r7, [r9, #-64]	; 0xffffffc0
3481dc74:	e1a0a087 	lsl	sl, r7, #1
3481dc78:	e2877001 	add	r7, r7, #1
3481dc7c:	e18150ba 	strh	r5, [r1, sl]
3481dc80:	e14974b0 	strh	r7, [r9, #-64]	; 0xffffffc0
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
3481dc84:	e2855001 	add	r5, r5, #1
3481dc88:	e1550002 	cmp	r5, r2
3481dc8c:	3afffff2 	bcc	3481dc5c <inflate_table+0x188>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
3481dc90:	e3500000 	cmp	r0, #0
3481dc94:	0a00000f 	beq	3481dcd8 <inflate_table+0x204>
3481dc98:	e3500001 	cmp	r0, #1
3481dc9c:	1a000006 	bne	3481dcbc <inflate_table+0x1e8>
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481dca0:	e59fa390 	ldr	sl, [pc, #912]	; 3481e038 <inflate_table+0x564>
        end = 256;
3481dca4:	e3a09c01 	mov	r9, #256	; 0x100
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481dca8:	e28a2040 	add	r2, sl, #64	; 0x40
        extra = lext;
        extra -= 257;
        end = 256;
3481dcac:	e58d9020 	str	r9, [sp, #32]
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481dcb0:	e58da010 	str	sl, [sp, #16]
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481dcb4:	e58d201c 	str	r2, [sp, #28]
3481dcb8:	ea00000a 	b	3481dce8 <inflate_table+0x214>
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481dcbc:	e59f7378 	ldr	r7, [pc, #888]	; 3481e03c <inflate_table+0x568>
        end = -1;
3481dcc0:	e3e05000 	mvn	r5, #0
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481dcc4:	e2879040 	add	r9, r7, #64	; 0x40
        extra = dext;
        end = -1;
3481dcc8:	e58d5020 	str	r5, [sp, #32]
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481dccc:	e58d7010 	str	r7, [sp, #16]
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481dcd0:	e58d901c 	str	r9, [sp, #28]
3481dcd4:	ea000003 	b	3481dce8 <inflate_table+0x214>

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
3481dcd8:	e3a0a013 	mov	sl, #19
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
3481dcdc:	e58d1010 	str	r1, [sp, #16]
3481dce0:	e58d101c 	str	r1, [sp, #28]
        end = 19;
3481dce4:	e58da020 	str	sl, [sp, #32]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481dce8:	e3a0a001 	mov	sl, #1
3481dcec:	e1a02c1a 	lsl	r2, sl, ip
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dcf0:	e150000a 	cmp	r0, sl
3481dcf4:	13a00000 	movne	r0, #0
3481dcf8:	03a00001 	moveq	r0, #1

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
3481dcfc:	e5937000 	ldr	r7, [r3]
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481dd00:	e58d200c 	str	r2, [sp, #12]
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dd04:	e58d0038 	str	r0, [sp, #56]	; 0x38
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481dd08:	e2425001 	sub	r5, r2, #1

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dd0c:	e59d900c 	ldr	r9, [sp, #12]
3481dd10:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3481dd14:	e30005af 	movw	r0, #1455	; 0x5af
3481dd18:	e1590000 	cmp	r9, r0
3481dd1c:	93a02000 	movls	r2, #0
3481dd20:	82022001 	andhi	r2, r2, #1
3481dd24:	e3520000 	cmp	r2, #0
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481dd28:	e58d5034 	str	r5, [sp, #52]	; 0x34

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
        return 1;
3481dd2c:	11a0000a 	movne	r0, sl
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dd30:	1a0000be 	bne	3481e030 <inflate_table+0x55c>
3481dd34:	e58d1018 	str	r1, [sp, #24]
3481dd38:	e3e01000 	mvn	r1, #0
3481dd3c:	e58d1014 	str	r1, [sp, #20]
3481dd40:	e1a0500c 	mov	r5, ip
3481dd44:	e1a01002 	mov	r1, r2
3481dd48:	e1a0b006 	mov	fp, r6
3481dd4c:	ea000000 	b	3481dd54 <inflate_table+0x280>
3481dd50:	e58d0014 	str	r0, [sp, #20]

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481dd54:	e59d6018 	ldr	r6, [sp, #24]
3481dd58:	e59d9020 	ldr	r9, [sp, #32]
3481dd5c:	e0d6a0b2 	ldrh	sl, [r6], #2
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481dd60:	e0610004 	rsb	r0, r1, r4
        if ((int)(work[sym]) < end) {
3481dd64:	e15a0009 	cmp	sl, r9
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481dd68:	e6ef0070 	uxtb	r0, r0
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
3481dd6c:	b3a09000 	movlt	r9, #0
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481dd70:	e58d003c 	str	r0, [sp, #60]	; 0x3c
        if ((int)(work[sym]) < end) {
3481dd74:	e58d6018 	str	r6, [sp, #24]
            this.op = (unsigned char)0;
3481dd78:	b58d902c 	strlt	r9, [sp, #44]	; 0x2c

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481dd7c:	ba000008 	blt	3481dda4 <inflate_table+0x2d0>
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481dd80:	c59d0010 	ldrgt	r0, [sp, #16]
3481dd84:	c1a0a08a 	lslgt	sl, sl, #1
            this.val = base[work[sym]];
3481dd88:	c59d601c 	ldrgt	r6, [sp, #28]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481dd8c:	c7d0000a 	ldrbgt	r0, [r0, sl]
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481dd90:	d3a00060 	movle	r0, #96	; 0x60
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
3481dd94:	c196a0ba 	ldrhgt	sl, [r6, sl]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481dd98:	c58d002c 	strgt	r0, [sp, #44]	; 0x2c
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
3481dd9c:	d3a0a000 	movle	sl, #0
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481dda0:	d58d002c 	strle	r0, [sp, #44]	; 0x2c
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
3481dda4:	e3a09001 	mov	r9, #1
3481dda8:	e0616004 	rsb	r6, r1, r4
3481ddac:	e1a06619 	lsl	r6, r9, r6
        fill = 1U << curr;
3481ddb0:	e1a00519 	lsl	r0, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ddb4:	e2669000 	rsb	r9, r6, #0
3481ddb8:	e58d9040 	str	r9, [sp, #64]	; 0x40
3481ddbc:	e3e09003 	mvn	r9, #3
3481ddc0:	e0090699 	mul	r9, r9, r6
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
3481ddc4:	e58d0024 	str	r0, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ddc8:	e58d9044 	str	r9, [sp, #68]	; 0x44
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481ddcc:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ddd0:	e0660000 	rsb	r0, r6, r0
3481ddd4:	e58d0028 	str	r0, [sp, #40]	; 0x28
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481ddd8:	e0890132 	add	r0, r9, r2, lsr r1
3481dddc:	e0660000 	rsb	r0, r6, r0
3481dde0:	e0870100 	add	r0, r7, r0, lsl #2
3481dde4:	e1a0900c 	mov	r9, ip
3481dde8:	e58d3004 	str	r3, [sp, #4]
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ddec:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481ddf0:	e5c0c000 	strb	ip, [r0]
3481ddf4:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481ddf8:	e1c0a0b2 	strh	sl, [r0, #2]
3481ddfc:	e5c03001 	strb	r3, [r0, #1]
3481de00:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
3481de04:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3481de08:	e08cc003 	add	ip, ip, r3
3481de0c:	e58dc028 	str	ip, [sp, #40]	; 0x28
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481de10:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481de14:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
3481de18:	e080000c 	add	r0, r0, ip
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481de1c:	e083c006 	add	ip, r3, r6
3481de20:	e35c0000 	cmp	ip, #0
3481de24:	1afffff0 	bne	3481ddec <inflate_table+0x318>

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481de28:	e2440001 	sub	r0, r4, #1
3481de2c:	e3a06001 	mov	r6, #1
3481de30:	e1a0c009 	mov	ip, r9
3481de34:	e59d3004 	ldr	r3, [sp, #4]
3481de38:	e1a00016 	lsl	r0, r6, r0
        while (huff & incr)
3481de3c:	ea000000 	b	3481de44 <inflate_table+0x370>
            incr >>= 1;
3481de40:	e1a000a0 	lsr	r0, r0, #1
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481de44:	e1100002 	tst	r0, r2
3481de48:	1afffffc 	bne	3481de40 <inflate_table+0x36c>
            incr >>= 1;
        if (incr != 0) {
3481de4c:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481de50:	12406001 	subne	r6, r0, #1
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481de54:	e28d9088 	add	r9, sp, #136	; 0x88
        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
3481de58:	10062002 	andne	r2, r6, r2
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481de5c:	e0896084 	add	r6, r9, r4, lsl #1
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
3481de60:	10822000 	addne	r2, r2, r0
        }
        else
            huff = 0;
3481de64:	01a02000 	moveq	r2, r0

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481de68:	e15602b0 	ldrh	r0, [r6, #-32]	; 0xffffffe0
3481de6c:	e2400001 	sub	r0, r0, #1
3481de70:	e6ff0070 	uxth	r0, r0
3481de74:	e3500000 	cmp	r0, #0
3481de78:	e14602b0 	strh	r0, [r6, #-32]	; 0xffffffe0
3481de7c:	1a000006 	bne	3481de9c <inflate_table+0x3c8>
            if (len == max) break;
3481de80:	e154000b 	cmp	r4, fp
3481de84:	0a000058 	beq	3481dfec <inflate_table+0x518>
            len = lens[work[sym]];
3481de88:	e59da018 	ldr	sl, [sp, #24]
3481de8c:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3481de90:	e1da00b0 	ldrh	r0, [sl]
3481de94:	e1a00080 	lsl	r0, r0, #1
3481de98:	e19640b0 	ldrh	r4, [r6, r0]
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
3481de9c:	e154000c 	cmp	r4, ip
3481dea0:	959d0014 	ldrls	r0, [sp, #20]
3481dea4:	9affffa9 	bls	3481dd50 <inflate_table+0x27c>
3481dea8:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481deac:	e59da014 	ldr	sl, [sp, #20]
3481deb0:	e0020009 	and	r0, r2, r9
3481deb4:	e150000a 	cmp	r0, sl
3481deb8:	0affffa4 	beq	3481dd50 <inflate_table+0x27c>
            /* if first time, transition to sub-tables */
            if (drop == 0)
3481debc:	e3510000 	cmp	r1, #0
3481dec0:	01a0100c 	moveq	r1, ip

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
3481dec4:	e0615004 	rsb	r5, r1, r4
            left = (int)(1 << curr);
3481dec8:	e3a09001 	mov	r9, #1
3481decc:	e1a06519 	lsl	r6, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ded0:	e2419001 	sub	r9, r1, #1
3481ded4:	e28da068 	add	sl, sp, #104	; 0x68
3481ded8:	e0899005 	add	r9, r9, r5
3481dedc:	e08a9089 	add	r9, sl, r9, lsl #1
3481dee0:	e1a0a00c 	mov	sl, ip
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481dee4:	ea000005 	b	3481df00 <inflate_table+0x42c>
                left -= count[curr + drop];
3481dee8:	e1f9c0b2 	ldrh	ip, [r9, #2]!
3481deec:	e06c6006 	rsb	r6, ip, r6
                if (left <= 0) break;
3481def0:	e3560000 	cmp	r6, #0
3481def4:	da000004 	ble	3481df0c <inflate_table+0x438>
                curr++;
3481def8:	e2855001 	add	r5, r5, #1
                left <<= 1;
3481defc:	e1a06086 	lsl	r6, r6, #1
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481df00:	e085c001 	add	ip, r5, r1
3481df04:	e15c000b 	cmp	ip, fp
3481df08:	3afffff6 	bcc	3481dee8 <inflate_table+0x414>
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
3481df0c:	e59d600c 	ldr	r6, [sp, #12]
3481df10:	e3a09001 	mov	r9, #1
3481df14:	e0866519 	add	r6, r6, r9, lsl r5
3481df18:	e58d600c 	str	r6, [sp, #12]
3481df1c:	e1a0c00a 	mov	ip, sl
            if (type == LENS && used >= ENOUGH - MAXD)
3481df20:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
3481df24:	e59da00c 	ldr	sl, [sp, #12]
3481df28:	e30095af 	movw	r9, #1455	; 0x5af
3481df2c:	e15a0009 	cmp	sl, r9
3481df30:	93a06000 	movls	r6, #0
3481df34:	82066001 	andhi	r6, r6, #1
3481df38:	e3560000 	cmp	r6, #0
3481df3c:	1a00003a 	bne	3481e02c <inflate_table+0x558>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481df40:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481df44:	e59da024 	ldr	sl, [sp, #36]	; 0x24
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481df48:	e7c65100 	strb	r5, [r6, r0, lsl #2]
            (*table)[low].bits = (unsigned char)root;
3481df4c:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481df50:	e087710a 	add	r7, r7, sl, lsl #2
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481df54:	e1a0a100 	lsl	sl, r0, #2
            (*table)[low].bits = (unsigned char)root;
3481df58:	e086600a 	add	r6, r6, sl
3481df5c:	e5c6c001 	strb	ip, [r6, #1]
            (*table)[low].val = (unsigned short)(next - *table);
3481df60:	e5936000 	ldr	r6, [r3]
3481df64:	e086a00a 	add	sl, r6, sl
3481df68:	e0666007 	rsb	r6, r6, r7
3481df6c:	e1a06146 	asr	r6, r6, #2
3481df70:	e1ca60b2 	strh	r6, [sl, #2]
3481df74:	eaffff75 	b	3481dd50 <inflate_table+0x27c>
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
3481df78:	e3510000 	cmp	r1, #0
3481df7c:	0a000007 	beq	3481dfa0 <inflate_table+0x4cc>
3481df80:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481df84:	e0020009 	and	r0, r2, r9
3481df88:	e59d9014 	ldr	r9, [sp, #20]
3481df8c:	e1500009 	cmp	r0, r9
            drop = 0;
            len = root;
            next = *table;
3481df90:	15937000 	ldrne	r7, [r3]
            this.bits = (unsigned char)len;
3481df94:	11a0b00a 	movne	fp, sl
3481df98:	11a0400c 	movne	r4, ip
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
3481df9c:	13a01000 	movne	r1, #0
            next = *table;
            this.bits = (unsigned char)len;
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481dfa0:	e1a09132 	lsr	r9, r2, r1
3481dfa4:	e0870109 	add	r0, r7, r9, lsl #2
3481dfa8:	e7c76109 	strb	r6, [r7, r9, lsl #2]
3481dfac:	e3a09000 	mov	r9, #0
3481dfb0:	e5c0b001 	strb	fp, [r0, #1]
3481dfb4:	e1c090b2 	strh	r9, [r0, #2]

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481dfb8:	e2440001 	sub	r0, r4, #1
3481dfbc:	e1a00015 	lsl	r0, r5, r0
        while (huff & incr)
3481dfc0:	ea000000 	b	3481dfc8 <inflate_table+0x4f4>
            incr >>= 1;
3481dfc4:	e1a000a0 	lsr	r0, r0, #1
        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481dfc8:	e1100002 	tst	r0, r2
3481dfcc:	1afffffc 	bne	3481dfc4 <inflate_table+0x4f0>
            incr >>= 1;
        if (incr != 0) {
3481dfd0:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481dfd4:	12409001 	subne	r9, r0, #1
3481dfd8:	10092002 	andne	r2, r9, r2
            huff += incr;
3481dfdc:	10822000 	addne	r2, r2, r0
3481dfe0:	1a000005 	bne	3481dffc <inflate_table+0x528>
        }
        else
            huff = 0;
3481dfe4:	e1a02000 	mov	r2, r0
3481dfe8:	ea000005 	b	3481e004 <inflate_table+0x530>

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481dfec:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
3481dff0:	e6efa07c 	uxtb	sl, ip
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481dff4:	e3a06040 	mov	r6, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481dff8:	e3a05001 	mov	r5, #1
       drops back to the root table to fill in any remaining entries there.
     */
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
3481dffc:	e3520000 	cmp	r2, #0
3481e000:	1affffdc 	bne	3481df78 <inflate_table+0x4a4>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481e004:	e5931000 	ldr	r1, [r3]
3481e008:	e59da00c 	ldr	sl, [sp, #12]
    *bits = root;
3481e00c:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481e010:	e081110a 	add	r1, r1, sl, lsl #2
3481e014:	e5831000 	str	r1, [r3]
    *bits = root;
3481e018:	e580c000 	str	ip, [r0]
    return 0;
3481e01c:	e1a00002 	mov	r0, r2
3481e020:	ea000002 	b	3481e030 <inflate_table+0x55c>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */
3481e024:	e3e00000 	mvn	r0, #0
3481e028:	ea000000 	b	3481e030 <inflate_table+0x55c>
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;
3481e02c:	e3a00001 	mov	r0, #1

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
3481e030:	e28dd088 	add	sp, sp, #136	; 0x88
3481e034:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481e038:	34821c22 	.word	0x34821c22
3481e03c:	34821ea4 	.word	0x34821ea4

3481e040 <inflateReset>:
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481e040:	e3500000 	cmp	r0, #0
3481e044:	03e00001 	mvneq	r0, #1
3481e048:	012fff1e 	bxeq	lr
3481e04c:	e590301c 	ldr	r3, [r0, #28]
3481e050:	e3530000 	cmp	r3, #0
3481e054:	0a000017 	beq	3481e0b8 <inflateReset+0x78>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e058:	e3a02000 	mov	r2, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481e05c:	e3a01001 	mov	r1, #1
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e060:	e583201c 	str	r2, [r3, #28]
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481e064:	e5801034 	str	r1, [r0, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481e068:	e3a01902 	mov	r1, #32768	; 0x8000
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e06c:	e5802014 	str	r2, [r0, #20]
3481e070:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
3481e074:	e5802018 	str	r2, [r0, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481e078:	e5831014 	str	r1, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
3481e07c:	e2831e53 	add	r1, r3, #1328	; 0x530
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
3481e080:	e5832000 	str	r2, [r3]
    state->last = 0;
3481e084:	e5832004 	str	r2, [r3, #4]
    state->havedict = 0;
3481e088:	e583200c 	str	r2, [r3, #12]
    state->dmax = 32768U;
    state->head = Z_NULL;
3481e08c:	e5832020 	str	r2, [r3, #32]
    state->wsize = 0;
3481e090:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
3481e094:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->write = 0;
3481e098:	e5832030 	str	r2, [r3, #48]	; 0x30
    state->hold = 0;
3481e09c:	e5832038 	str	r2, [r3, #56]	; 0x38
    state->bits = 0;
3481e0a0:	e583203c 	str	r2, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
3481e0a4:	e583106c 	str	r1, [r3, #108]	; 0x6c
3481e0a8:	e5831050 	str	r1, [r3, #80]	; 0x50
3481e0ac:	e583104c 	str	r1, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
3481e0b0:	e1a00002 	mov	r0, r2
3481e0b4:	e12fff1e 	bx	lr
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481e0b8:	e3e00001 	mvn	r0, #1
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
3481e0bc:	e12fff1e 	bx	lr

3481e0c0 <inflateInit2_>:
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481e0c0:	e3520000 	cmp	r2, #0
int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
3481e0c4:	e92d4070 	push	{r4, r5, r6, lr}
3481e0c8:	e1a04000 	mov	r4, r0
3481e0cc:	e1a05001 	mov	r5, r1
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481e0d0:	0a000033 	beq	3481e1a4 <inflateInit2_+0xe4>
3481e0d4:	e5d22000 	ldrb	r2, [r2]
3481e0d8:	e3520031 	cmp	r2, #49	; 0x31
3481e0dc:	0353003c 	cmpeq	r3, #60	; 0x3c
3481e0e0:	03a03000 	moveq	r3, #0
3481e0e4:	13a03001 	movne	r3, #1
3481e0e8:	1a00002d 	bne	3481e1a4 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481e0ec:	e3500000 	cmp	r0, #0
3481e0f0:	0a00002d 	beq	3481e1ac <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
3481e0f4:	e5803018 	str	r3, [r0, #24]
    if (strm->zalloc == (alloc_func)0) {
3481e0f8:	e5903020 	ldr	r3, [r0, #32]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e0fc:	e3a01001 	mov	r1, #1
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
3481e100:	e3530000 	cmp	r3, #0
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
3481e104:	05803028 	streq	r3, [r0, #40]	; 0x28
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481e108:	059f20ac 	ldreq	r2, [pc, #172]	; 3481e1bc <inflateInit2_+0xfc>
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e10c:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481e110:	05802020 	streq	r2, [r0, #32]
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e114:	e3530000 	cmp	r3, #0
3481e118:	059f30a0 	ldreq	r3, [pc, #160]	; 3481e1c0 <inflateInit2_+0x100>
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e11c:	e3022530 	movw	r2, #9520	; 0x2530
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e120:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e124:	e5903020 	ldr	r3, [r0, #32]
3481e128:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481e12c:	e12fff33 	blx	r3
    if (state == Z_NULL) return Z_MEM_ERROR;
3481e130:	e2501000 	subs	r1, r0, #0
3481e134:	0a00001e 	beq	3481e1b4 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481e138:	e3550000 	cmp	r5, #0
        state->wrap = 0;
3481e13c:	b3a03000 	movlt	r3, #0
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
3481e140:	e584101c 	str	r1, [r4, #28]
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
3481e144:	b2655000 	rsblt	r5, r5, #0
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
        state->wrap = 0;
3481e148:	b5813008 	strlt	r3, [r1, #8]
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481e14c:	ba000004 	blt	3481e164 <inflateInit2_+0xa4>
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481e150:	e1a03245 	asr	r3, r5, #4
3481e154:	e2833001 	add	r3, r3, #1
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481e158:	e355002f 	cmp	r5, #47	; 0x2f
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481e15c:	e5813008 	str	r3, [r1, #8]
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481e160:	d205500f 	andle	r5, r5, #15
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
3481e164:	e2453008 	sub	r3, r5, #8
3481e168:	e3530007 	cmp	r3, #7
3481e16c:	9a000006 	bls	3481e18c <inflateInit2_+0xcc>
        ZFREE(strm, state);
3481e170:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e174:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e178:	e3a02000 	mov	r2, #0
3481e17c:	e12fff33 	blx	r3
        strm->state = Z_NULL;
3481e180:	e3a03000 	mov	r3, #0
3481e184:	e584301c 	str	r3, [r4, #28]
3481e188:	ea000007 	b	3481e1ac <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
3481e18c:	e3a03000 	mov	r3, #0
    return inflateReset(strm);
3481e190:	e1a00004 	mov	r0, r4
    if (windowBits < 8 || windowBits > 15) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
3481e194:	e5815024 	str	r5, [r1, #36]	; 0x24
    state->window = Z_NULL;
3481e198:	e5813034 	str	r3, [r1, #52]	; 0x34
    return inflateReset(strm);
}
3481e19c:	e8bd4070 	pop	{r4, r5, r6, lr}
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
3481e1a0:	eaffffa6 	b	3481e040 <inflateReset>
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
3481e1a4:	e3e00005 	mvn	r0, #5
3481e1a8:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481e1ac:	e3e00001 	mvn	r0, #1
3481e1b0:	e8bd8070 	pop	{r4, r5, r6, pc}
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
3481e1b4:	e3e00003 	mvn	r0, #3
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
}
3481e1b8:	e8bd8070 	pop	{r4, r5, r6, pc}
3481e1bc:	3481d558 	.word	0x3481d558
3481e1c0:	3481d550 	.word	0x3481d550

3481e1c4 <inflateInit_>:

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
3481e1c4:	e1a0c001 	mov	ip, r1
3481e1c8:	e1a03002 	mov	r3, r2
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
3481e1cc:	e3a0100f 	mov	r1, #15
3481e1d0:	e1a0200c 	mov	r2, ip
3481e1d4:	eaffffb9 	b	3481e0c0 <inflateInit2_>

3481e1d8 <inflateEnd>:
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
3481e1d8:	e92d4010 	push	{r4, lr}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
3481e1dc:	e2504000 	subs	r4, r0, #0
3481e1e0:	0a000013 	beq	3481e234 <inflateEnd+0x5c>
3481e1e4:	e594201c 	ldr	r2, [r4, #28]
3481e1e8:	e3520000 	cmp	r2, #0
3481e1ec:	0a000010 	beq	3481e234 <inflateEnd+0x5c>
3481e1f0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e1f4:	e3530000 	cmp	r3, #0
3481e1f8:	0a00000f 	beq	3481e23c <inflateEnd+0x64>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
3481e1fc:	e5921034 	ldr	r1, [r2, #52]	; 0x34
3481e200:	e3510000 	cmp	r1, #0
3481e204:	0a000002 	beq	3481e214 <inflateEnd+0x3c>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
3481e208:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e20c:	e3a02000 	mov	r2, #0
3481e210:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
3481e214:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e218:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e21c:	e594101c 	ldr	r1, [r4, #28]
3481e220:	e3a02000 	mov	r2, #0
3481e224:	e12fff33 	blx	r3
    strm->state = Z_NULL;
3481e228:	e3a00000 	mov	r0, #0
3481e22c:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
3481e230:	e8bd8010 	pop	{r4, pc}
int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
3481e234:	e3e00001 	mvn	r0, #1
3481e238:	e8bd8010 	pop	{r4, pc}
3481e23c:	e3e00001 	mvn	r0, #1
    }
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}
3481e240:	e8bd8010 	pop	{r4, pc}

3481e244 <adler32>:
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481e244:	e3520001 	cmp	r2, #1
/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
3481e248:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481e24c:	e1a04001 	mov	r4, r1
3481e250:	e1a07002 	mov	r7, r2
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
3481e254:	e1a06820 	lsr	r6, r0, #16
    adler &= 0xffff;
3481e258:	e6ff5070 	uxth	r5, r0

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481e25c:	1a00000b 	bne	3481e290 <adler32+0x4c>
        adler += buf[0];
3481e260:	e5d13000 	ldrb	r3, [r1]
3481e264:	e0835005 	add	r5, r3, r5
        if (adler >= BASE)
3481e268:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e26c:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481e270:	82455cff 	subhi	r5, r5, #65280	; 0xff00
3481e274:	824550f1 	subhi	r5, r5, #241	; 0xf1
        sum2 += adler;
3481e278:	e0856006 	add	r6, r5, r6
        if (sum2 >= BASE)
3481e27c:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e280:	e1560003 	cmp	r6, r3
            sum2 -= BASE;
3481e284:	82466cff 	subhi	r6, r6, #65280	; 0xff00
3481e288:	824660f1 	subhi	r6, r6, #241	; 0xf1
3481e28c:	ea0000a2 	b	3481e51c <adler32+0x2d8>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
3481e290:	e3510000 	cmp	r1, #0
3481e294:	0a0000a2 	beq	3481e524 <adler32+0x2e0>
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
3481e298:	e352000f 	cmp	r2, #15
3481e29c:	9a000004 	bls	3481e2b4 <adler32+0x70>
3481e2a0:	ea000050 	b	3481e3e8 <adler32+0x1a4>
        while (len--) {
            adler += *buf++;
3481e2a4:	e4d43001 	ldrb	r3, [r4], #1
            sum2 += adler;
3481e2a8:	e2477001 	sub	r7, r7, #1
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
3481e2ac:	e0855003 	add	r5, r5, r3
            sum2 += adler;
3481e2b0:	e0866005 	add	r6, r6, r5
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
3481e2b4:	e3570000 	cmp	r7, #0
3481e2b8:	1afffff9 	bne	3481e2a4 <adler32+0x60>
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
3481e2bc:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e2c0:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481e2c4:	82455cff 	subhi	r5, r5, #65280	; 0xff00
        MOD4(sum2);             /* only added so many BASE's */
3481e2c8:	e1a00006 	mov	r0, r6
3481e2cc:	e30f1ff1 	movw	r1, #65521	; 0xfff1
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
3481e2d0:	824550f1 	subhi	r5, r5, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
3481e2d4:	eb0006b6 	bl	3481fdb4 <__aeabi_uidivmod>
        return adler | (sum2 << 16);
3481e2d8:	e1850801 	orr	r0, r5, r1, lsl #16
3481e2dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
3481e2e0:	e2477d56 	sub	r7, r7, #5504	; 0x1580
3481e2e4:	e2477030 	sub	r7, r7, #48	; 0x30
3481e2e8:	e1a03004 	mov	r3, r4
        n = NMAX / 16;          /* NMAX is divisible by 16 */
3481e2ec:	e300215b 	movw	r2, #347	; 0x15b
        do {
            DO16(buf);          /* 16 sums unrolled */
3481e2f0:	e5d31000 	ldrb	r1, [r3]
            buf += 16;
        } while (--n);
3481e2f4:	e2522001 	subs	r2, r2, #1
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
3481e2f8:	e0855001 	add	r5, r5, r1
3481e2fc:	e5d31001 	ldrb	r1, [r3, #1]
3481e300:	e0856006 	add	r6, r5, r6
3481e304:	e0855001 	add	r5, r5, r1
3481e308:	e5d31002 	ldrb	r1, [r3, #2]
3481e30c:	e0866005 	add	r6, r6, r5
3481e310:	e0855001 	add	r5, r5, r1
3481e314:	e5d31003 	ldrb	r1, [r3, #3]
3481e318:	e0866005 	add	r6, r6, r5
3481e31c:	e0855001 	add	r5, r5, r1
3481e320:	e5d31004 	ldrb	r1, [r3, #4]
3481e324:	e0866005 	add	r6, r6, r5
3481e328:	e0855001 	add	r5, r5, r1
3481e32c:	e5d31005 	ldrb	r1, [r3, #5]
3481e330:	e0866005 	add	r6, r6, r5
3481e334:	e0855001 	add	r5, r5, r1
3481e338:	e5d31006 	ldrb	r1, [r3, #6]
3481e33c:	e0866005 	add	r6, r6, r5
3481e340:	e0855001 	add	r5, r5, r1
3481e344:	e5d31007 	ldrb	r1, [r3, #7]
3481e348:	e0866005 	add	r6, r6, r5
3481e34c:	e0855001 	add	r5, r5, r1
3481e350:	e5d31008 	ldrb	r1, [r3, #8]
3481e354:	e0866005 	add	r6, r6, r5
3481e358:	e0855001 	add	r5, r5, r1
3481e35c:	e5d31009 	ldrb	r1, [r3, #9]
3481e360:	e0866005 	add	r6, r6, r5
3481e364:	e0855001 	add	r5, r5, r1
3481e368:	e5d3100a 	ldrb	r1, [r3, #10]
3481e36c:	e0866005 	add	r6, r6, r5
3481e370:	e0855001 	add	r5, r5, r1
3481e374:	e5d3100b 	ldrb	r1, [r3, #11]
3481e378:	e0866005 	add	r6, r6, r5
3481e37c:	e0855001 	add	r5, r5, r1
3481e380:	e5d3100c 	ldrb	r1, [r3, #12]
3481e384:	e0866005 	add	r6, r6, r5
3481e388:	e0855001 	add	r5, r5, r1
3481e38c:	e5d3100d 	ldrb	r1, [r3, #13]
3481e390:	e0866005 	add	r6, r6, r5
3481e394:	e0855001 	add	r5, r5, r1
3481e398:	e5d3100e 	ldrb	r1, [r3, #14]
3481e39c:	e0866005 	add	r6, r6, r5
3481e3a0:	e0855001 	add	r5, r5, r1
3481e3a4:	e5d3100f 	ldrb	r1, [r3, #15]
3481e3a8:	e0866005 	add	r6, r6, r5
3481e3ac:	e0855001 	add	r5, r5, r1
3481e3b0:	e0866005 	add	r6, r6, r5
            buf += 16;
3481e3b4:	e2833010 	add	r3, r3, #16
        } while (--n);
3481e3b8:	1affffcc 	bne	3481e2f0 <adler32+0xac>
        MOD(adler);
3481e3bc:	e1a00005 	mov	r0, r5
3481e3c0:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e3c4:	eb00067a 	bl	3481fdb4 <__aeabi_uidivmod>
        MOD(sum2);
3481e3c8:	e1a00006 	mov	r0, r6
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
3481e3cc:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481e3d0:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e3d4:	eb000676 	bl	3481fdb4 <__aeabi_uidivmod>
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
3481e3d8:	e2844d56 	add	r4, r4, #5504	; 0x1580
3481e3dc:	e2844030 	add	r4, r4, #48	; 0x30
        MOD(adler);
        MOD(sum2);
3481e3e0:	e1a06001 	mov	r6, r1
3481e3e4:	ea000000 	b	3481e3ec <adler32+0x1a8>
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
3481e3e8:	e301a5af 	movw	sl, #5551	; 0x15af
3481e3ec:	e157000a 	cmp	r7, sl
3481e3f0:	8affffba 	bhi	3481e2e0 <adler32+0x9c>
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
3481e3f4:	e2573000 	subs	r3, r7, #0
3481e3f8:	11a02004 	movne	r2, r4
3481e3fc:	1a000031 	bne	3481e4c8 <adler32+0x284>
3481e400:	ea000045 	b	3481e51c <adler32+0x2d8>
        while (len >= 16) {
            len -= 16;
            DO16(buf);
3481e404:	e5521010 	ldrb	r1, [r2, #-16]
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
3481e408:	e2477010 	sub	r7, r7, #16
            DO16(buf);
3481e40c:	e0855001 	add	r5, r5, r1
3481e410:	e552100f 	ldrb	r1, [r2, #-15]
3481e414:	e0856006 	add	r6, r5, r6
3481e418:	e0855001 	add	r5, r5, r1
3481e41c:	e552100e 	ldrb	r1, [r2, #-14]
3481e420:	e0866005 	add	r6, r6, r5
3481e424:	e0855001 	add	r5, r5, r1
3481e428:	e552100d 	ldrb	r1, [r2, #-13]
3481e42c:	e0866005 	add	r6, r6, r5
3481e430:	e0855001 	add	r5, r5, r1
3481e434:	e552100c 	ldrb	r1, [r2, #-12]
3481e438:	e0866005 	add	r6, r6, r5
3481e43c:	e0855001 	add	r5, r5, r1
3481e440:	e552100b 	ldrb	r1, [r2, #-11]
3481e444:	e0866005 	add	r6, r6, r5
3481e448:	e0855001 	add	r5, r5, r1
3481e44c:	e552100a 	ldrb	r1, [r2, #-10]
3481e450:	e0866005 	add	r6, r6, r5
3481e454:	e0855001 	add	r5, r5, r1
3481e458:	e5521009 	ldrb	r1, [r2, #-9]
3481e45c:	e0866005 	add	r6, r6, r5
3481e460:	e0855001 	add	r5, r5, r1
3481e464:	e5521008 	ldrb	r1, [r2, #-8]
3481e468:	e0866005 	add	r6, r6, r5
3481e46c:	e0855001 	add	r5, r5, r1
3481e470:	e5521007 	ldrb	r1, [r2, #-7]
3481e474:	e0866005 	add	r6, r6, r5
3481e478:	e0855001 	add	r5, r5, r1
3481e47c:	e5521006 	ldrb	r1, [r2, #-6]
3481e480:	e0866005 	add	r6, r6, r5
3481e484:	e0855001 	add	r5, r5, r1
3481e488:	e5521005 	ldrb	r1, [r2, #-5]
3481e48c:	e0866005 	add	r6, r6, r5
3481e490:	e0855001 	add	r5, r5, r1
3481e494:	e5521004 	ldrb	r1, [r2, #-4]
3481e498:	e0866005 	add	r6, r6, r5
3481e49c:	e0855001 	add	r5, r5, r1
3481e4a0:	e5521003 	ldrb	r1, [r2, #-3]
3481e4a4:	e0866005 	add	r6, r6, r5
3481e4a8:	e0855001 	add	r5, r5, r1
3481e4ac:	e5521002 	ldrb	r1, [r2, #-2]
3481e4b0:	e0866005 	add	r6, r6, r5
3481e4b4:	e0855001 	add	r5, r5, r1
3481e4b8:	e5521001 	ldrb	r1, [r2, #-1]
3481e4bc:	e0866005 	add	r6, r6, r5
3481e4c0:	e0855001 	add	r5, r5, r1
3481e4c4:	e0866005 	add	r6, r6, r5
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e4c8:	e357000f 	cmp	r7, #15
            len -= 16;
            DO16(buf);
3481e4cc:	e2822010 	add	r2, r2, #16
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e4d0:	8affffcb 	bhi	3481e404 <adler32+0x1c0>
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
3481e4d4:	e3c3200f 	bic	r2, r3, #15
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e4d8:	e0844002 	add	r4, r4, r2
3481e4dc:	e203300f 	and	r3, r3, #15
3481e4e0:	ea000003 	b	3481e4f4 <adler32+0x2b0>
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481e4e4:	e4d42001 	ldrb	r2, [r4], #1
            sum2 += adler;
3481e4e8:	e2433001 	sub	r3, r3, #1
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481e4ec:	e0855002 	add	r5, r5, r2
            sum2 += adler;
3481e4f0:	e0866005 	add	r6, r6, r5
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
3481e4f4:	e3530000 	cmp	r3, #0
3481e4f8:	1afffff9 	bne	3481e4e4 <adler32+0x2a0>
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481e4fc:	e1a00005 	mov	r0, r5
3481e500:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e504:	eb00062a 	bl	3481fdb4 <__aeabi_uidivmod>
        MOD(sum2);
3481e508:	e1a00006 	mov	r0, r6
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481e50c:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481e510:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e514:	eb000626 	bl	3481fdb4 <__aeabi_uidivmod>
3481e518:	e1a06001 	mov	r6, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
3481e51c:	e1850806 	orr	r0, r5, r6, lsl #16
3481e520:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;
3481e524:	e3a00001 	mov	r0, #1
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}
3481e528:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481e52c <inflate>:
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481e52c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e530:	e250a000 	subs	sl, r0, #0
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481e534:	e24dd048 	sub	sp, sp, #72	; 0x48
3481e538:	e58d103c 	str	r1, [sp, #60]	; 0x3c
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481e53c:	03e01001 	mvneq	r1, #1
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e540:	0a00058b 	beq	3481fb74 <inflate+0x1648>
3481e544:	e59a401c 	ldr	r4, [sl, #28]
3481e548:	e3540000 	cmp	r4, #0
3481e54c:	0a00058a 	beq	3481fb7c <inflate+0x1650>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e550:	e59a9000 	ldr	r9, [sl]
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e554:	e3590000 	cmp	r9, #0
3481e558:	1a000003 	bne	3481e56c <inflate+0x40>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e55c:	e59a3004 	ldr	r3, [sl, #4]
3481e560:	e3530000 	cmp	r3, #0
        return Z_STREAM_ERROR;
3481e564:	13e03001 	mvnne	r3, #1
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e568:	1a000586 	bne	3481fb88 <inflate+0x165c>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e56c:	e5943000 	ldr	r3, [r4]
    LOAD();
3481e570:	e59a1004 	ldr	r1, [sl, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e574:	e353000b 	cmp	r3, #11
    LOAD();
3481e578:	e59a000c 	ldr	r0, [sl, #12]
3481e57c:	e59ab010 	ldr	fp, [sl, #16]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e580:	02833001 	addeq	r3, r3, #1
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
3481e584:	e3a02000 	mov	r2, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481e588:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481e58c:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e590:	05843000 	streq	r3, [r4]
    LOAD();
3481e594:	e58d0020 	str	r0, [sp, #32]
3481e598:	e58d1038 	str	r1, [sp, #56]	; 0x38
    in = have;
    out = left;
3481e59c:	e58db02c 	str	fp, [sp, #44]	; 0x2c
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481e5a0:	e1a07001 	mov	r7, r1
    in = have;
    out = left;
    ret = Z_OK;
3481e5a4:	e58d201c 	str	r2, [sp, #28]
    for (;;)
        switch (state->mode) {
3481e5a8:	e5943000 	ldr	r3, [r4]
3481e5ac:	e353001c 	cmp	r3, #28
3481e5b0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481e5b4:	ea000575 	b	3481fb90 <inflate+0x1664>
3481e5b8:	3481e64c 	.word	0x3481e64c
3481e5bc:	3481e644 	.word	0x3481e644
3481e5c0:	3481e828 	.word	0x3481e828
3481e5c4:	3481e8ac 	.word	0x3481e8ac
3481e5c8:	3481e92c 	.word	0x3481e92c
3481e5cc:	3481e9c4 	.word	0x3481e9c4
3481e5d0:	3481ea88 	.word	0x3481ea88
3481e5d4:	3481eb44 	.word	0x3481eb44
3481e5d8:	3481ebf8 	.word	0x3481ebf8
3481e5dc:	3481e63c 	.word	0x3481e63c
3481e5e0:	3481ecd4 	.word	0x3481ecd4
3481e5e4:	3481ed24 	.word	0x3481ed24
3481e5e8:	3481ed30 	.word	0x3481ed30
3481e5ec:	3481ede8 	.word	0x3481ede8
3481e5f0:	3481ee50 	.word	0x3481ee50
3481e5f4:	3481e634 	.word	0x3481e634
3481e5f8:	3481ef34 	.word	0x3481ef34
3481e5fc:	3481f028 	.word	0x3481f028
3481e600:	3481f2d0 	.word	0x3481f2d0
3481e604:	3481f470 	.word	0x3481f470
3481e608:	3481f4d4 	.word	0x3481f4d4
3481e60c:	3481f5fc 	.word	0x3481f5fc
3481e610:	3481f6d0 	.word	0x3481f6d0
3481e614:	3481f778 	.word	0x3481f778
3481e618:	3481f79c 	.word	0x3481f79c
3481e61c:	3481f898 	.word	0x3481f898
3481e620:	3481f924 	.word	0x3481f924
3481e624:	3481f918 	.word	0x3481f918
3481e628:	3481e62c 	.word	0x3481e62c
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
3481e62c:	e3e03003 	mvn	r3, #3
3481e630:	ea000554 	b	3481fb88 <inflate+0x165c>
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
3481e634:	e1a03009 	mov	r3, r9
3481e638:	ea000223 	b	3481eecc <inflate+0x9a0>
3481e63c:	e1a03009 	mov	r3, r9
3481e640:	ea000193 	b	3481ec94 <inflate+0x768>
3481e644:	e1a03009 	mov	r3, r9
3481e648:	ea000058 	b	3481e7b0 <inflate+0x284>
        case HEAD:
            if (state->wrap == 0) {
3481e64c:	e5943008 	ldr	r3, [r4, #8]
3481e650:	e3530000 	cmp	r3, #0
3481e654:	11a02009 	movne	r2, r9
                state->mode = TYPEDO;
3481e658:	03a0300c 	moveq	r3, #12
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
3481e65c:	1a000006 	bne	3481e67c <inflate+0x150>
3481e660:	ea0004a3 	b	3481f8f4 <inflate+0x13c8>
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
3481e664:	e3570000 	cmp	r7, #0
3481e668:	0a0004af 	beq	3481f92c <inflate+0x1400>
3481e66c:	e4d21001 	ldrb	r1, [r2], #1
3481e670:	e2477001 	sub	r7, r7, #1
3481e674:	e0866511 	add	r6, r6, r1, lsl r5
3481e678:	e2855008 	add	r5, r5, #8
3481e67c:	e355000f 	cmp	r5, #15
3481e680:	e1a09002 	mov	r9, r2
3481e684:	9afffff6 	bls	3481e664 <inflate+0x138>
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
3481e688:	e7e020d3 	ubfx	r2, r3, #1, #1
3481e68c:	e3081b1f 	movw	r1, #35615	; 0x8b1f
3481e690:	e1560001 	cmp	r6, r1
3481e694:	13a02000 	movne	r2, #0
3481e698:	02022001 	andeq	r2, r2, #1
3481e69c:	e3520000 	cmp	r2, #0
3481e6a0:	0a000010 	beq	3481e6e8 <inflate+0x1bc>
                state->check = crc32(0L, Z_NULL, 0);
3481e6a4:	e3a00000 	mov	r0, #0
3481e6a8:	e1a01000 	mov	r1, r0
3481e6ac:	e1a02000 	mov	r2, r0
3481e6b0:	ebfff07a 	bl	3481a8a0 <crc32>
                CRC2(state->check, hold);
3481e6b4:	e3a0301f 	mov	r3, #31
3481e6b8:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
3481e6bc:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
3481e6c0:	e3e03074 	mvn	r3, #116	; 0x74
3481e6c4:	e28d1044 	add	r1, sp, #68	; 0x44
3481e6c8:	e3a02002 	mov	r2, #2
3481e6cc:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481e6d0:	ebfff072 	bl	3481a8a0 <crc32>
                INITBITS();
                state->mode = FLAGS;
3481e6d4:	e3a0c001 	mov	ip, #1
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
3481e6d8:	e5840018 	str	r0, [r4, #24]
                INITBITS();
                state->mode = FLAGS;
3481e6dc:	e584c000 	str	ip, [r4]
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
3481e6e0:	e3a05000 	mov	r5, #0
3481e6e4:	ea000029 	b	3481e790 <inflate+0x264>
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
3481e6e8:	e5842010 	str	r2, [r4, #16]
            if (state->head != Z_NULL)
3481e6ec:	e5942020 	ldr	r2, [r4, #32]
3481e6f0:	e3520000 	cmp	r2, #0
                state->head->done = -1;
3481e6f4:	13e01000 	mvnne	r1, #0
3481e6f8:	15821030 	strne	r1, [r2, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481e6fc:	e3130001 	tst	r3, #1
3481e700:	0a000006 	beq	3481e720 <inflate+0x1f4>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
3481e704:	e1a03426 	lsr	r3, r6, #8
3481e708:	e1a00c06 	lsl	r0, r6, #24
3481e70c:	e0830820 	add	r0, r3, r0, lsr #16
3481e710:	e3a0101f 	mov	r1, #31
3481e714:	eb0005a6 	bl	3481fdb4 <__aeabi_uidivmod>
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481e718:	e2513000 	subs	r3, r1, #0
3481e71c:	0a000001 	beq	3481e728 <inflate+0x1fc>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
3481e720:	e59f3ee8 	ldr	r3, [pc, #3816]	; 3481f610 <inflate+0x10e4>
3481e724:	ea000470 	b	3481f8ec <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
3481e728:	e206200f 	and	r2, r6, #15
3481e72c:	e3520008 	cmp	r2, #8
3481e730:	1a000025 	bne	3481e7cc <inflate+0x2a0>
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481e734:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
3481e738:	e206000f 	and	r0, r6, #15
            if (len > state->wbits) {
3481e73c:	e5942024 	ldr	r2, [r4, #36]	; 0x24
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
3481e740:	e2800008 	add	r0, r0, #8
            if (len > state->wbits) {
3481e744:	e1500002 	cmp	r0, r2
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481e748:	82455004 	subhi	r5, r5, #4
            len = BITS(4) + 8;
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
3481e74c:	859f3ec0 	ldrhi	r3, [pc, #3776]	; 3481f614 <inflate+0x10e8>
3481e750:	8a000465 	bhi	3481f8ec <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481e754:	e3a02001 	mov	r2, #1
3481e758:	e1a00012 	lsl	r0, r2, r0
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e75c:	e1a02003 	mov	r2, r3
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481e760:	e5840014 	str	r0, [r4, #20]
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e764:	e1a00003 	mov	r0, r3
3481e768:	e58d3014 	str	r3, [sp, #20]
3481e76c:	ebfffeb4 	bl	3481e244 <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e770:	e3160c02 	tst	r6, #512	; 0x200
            INITBITS();
3481e774:	e59d3014 	ldr	r3, [sp, #20]
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e778:	03a0200b 	moveq	r2, #11
3481e77c:	13a02009 	movne	r2, #9
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e780:	e5840018 	str	r0, [r4, #24]
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
3481e784:	e1a05003 	mov	r5, r3
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e788:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e78c:	e5842000 	str	r2, [r4]
            INITBITS();
3481e790:	e1a06005 	mov	r6, r5
            break;
3481e794:	eaffff83 	b	3481e5a8 <inflate+0x7c>
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
3481e798:	e3570000 	cmp	r7, #0
3481e79c:	0a000462 	beq	3481f92c <inflate+0x1400>
3481e7a0:	e4d32001 	ldrb	r2, [r3], #1
3481e7a4:	e2477001 	sub	r7, r7, #1
3481e7a8:	e0866512 	add	r6, r6, r2, lsl r5
3481e7ac:	e2855008 	add	r5, r5, #8
3481e7b0:	e355000f 	cmp	r5, #15
3481e7b4:	e1a09003 	mov	r9, r3
3481e7b8:	9afffff6 	bls	3481e798 <inflate+0x26c>
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481e7bc:	e20630ff 	and	r3, r6, #255	; 0xff
3481e7c0:	e3530008 	cmp	r3, #8
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
3481e7c4:	e5846010 	str	r6, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481e7c8:	0a000001 	beq	3481e7d4 <inflate+0x2a8>
                strm->msg = (char *)"unknown compression method";
3481e7cc:	e59f3e44 	ldr	r3, [pc, #3652]	; 3481f618 <inflate+0x10ec>
3481e7d0:	ea000445 	b	3481f8ec <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481e7d4:	e3160a0e 	tst	r6, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
3481e7d8:	159f3e3c 	ldrne	r3, [pc, #3644]	; 3481f61c <inflate+0x10f0>
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481e7dc:	1a000442 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
3481e7e0:	e5943020 	ldr	r3, [r4, #32]
3481e7e4:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
3481e7e8:	17e02456 	ubfxne	r2, r6, #8, #1
3481e7ec:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481e7f0:	e3160c02 	tst	r6, #512	; 0x200
3481e7f4:	0a000007 	beq	3481e818 <inflate+0x2ec>
3481e7f8:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e7fc:	e1a06426 	lsr	r6, r6, #8
3481e800:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e804:	e5940018 	ldr	r0, [r4, #24]
3481e808:	e28d1044 	add	r1, sp, #68	; 0x44
3481e80c:	e3a02002 	mov	r2, #2
3481e810:	ebfff022 	bl	3481a8a0 <crc32>
3481e814:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = TIME;
3481e818:	e3a03002 	mov	r3, #2
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e81c:	e3a05000 	mov	r5, #0
            state->mode = TIME;
3481e820:	e5843000 	str	r3, [r4]
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e824:	e1a06005 	mov	r6, r5
            state->mode = TIME;
3481e828:	e1a03009 	mov	r3, r9
3481e82c:	ea000005 	b	3481e848 <inflate+0x31c>
        case TIME:
            NEEDBITS(32);
3481e830:	e3570000 	cmp	r7, #0
3481e834:	0a00043c 	beq	3481f92c <inflate+0x1400>
3481e838:	e4d32001 	ldrb	r2, [r3], #1
3481e83c:	e2477001 	sub	r7, r7, #1
3481e840:	e0866512 	add	r6, r6, r2, lsl r5
3481e844:	e2855008 	add	r5, r5, #8
3481e848:	e355001f 	cmp	r5, #31
3481e84c:	e1a09003 	mov	r9, r3
3481e850:	9afffff6 	bls	3481e830 <inflate+0x304>
            if (state->head != Z_NULL)
3481e854:	e5943020 	ldr	r3, [r4, #32]
3481e858:	e3530000 	cmp	r3, #0
                state->head->time = hold;
3481e85c:	15836004 	strne	r6, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
3481e860:	e5943010 	ldr	r3, [r4, #16]
3481e864:	e3130c02 	tst	r3, #512	; 0x200
3481e868:	0a00000b 	beq	3481e89c <inflate+0x370>
3481e86c:	e1a03426 	lsr	r3, r6, #8
3481e870:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e874:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481e878:	e1a03826 	lsr	r3, r6, #16
3481e87c:	e1a06c26 	lsr	r6, r6, #24
3481e880:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
3481e884:	e5cd6047 	strb	r6, [sp, #71]	; 0x47
3481e888:	e5940018 	ldr	r0, [r4, #24]
3481e88c:	e28d1044 	add	r1, sp, #68	; 0x44
3481e890:	e3a02004 	mov	r2, #4
3481e894:	ebfff001 	bl	3481a8a0 <crc32>
3481e898:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = OS;
3481e89c:	e3a03003 	mov	r3, #3
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481e8a0:	e3a05000 	mov	r5, #0
            state->mode = OS;
3481e8a4:	e5843000 	str	r3, [r4]
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481e8a8:	e1a06005 	mov	r6, r5
            state->mode = OS;
3481e8ac:	e1a03009 	mov	r3, r9
3481e8b0:	ea000005 	b	3481e8cc <inflate+0x3a0>
        case OS:
            NEEDBITS(16);
3481e8b4:	e3570000 	cmp	r7, #0
3481e8b8:	0a00041b 	beq	3481f92c <inflate+0x1400>
3481e8bc:	e4d32001 	ldrb	r2, [r3], #1
3481e8c0:	e2477001 	sub	r7, r7, #1
3481e8c4:	e0866512 	add	r6, r6, r2, lsl r5
3481e8c8:	e2855008 	add	r5, r5, #8
3481e8cc:	e355000f 	cmp	r5, #15
3481e8d0:	e1a09003 	mov	r9, r3
3481e8d4:	9afffff6 	bls	3481e8b4 <inflate+0x388>
            if (state->head != Z_NULL) {
3481e8d8:	e5943020 	ldr	r3, [r4, #32]
3481e8dc:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
3481e8e0:	120620ff 	andne	r2, r6, #255	; 0xff
3481e8e4:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
3481e8e8:	11a02426 	lsrne	r2, r6, #8
3481e8ec:	1583200c 	strne	r2, [r3, #12]
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481e8f0:	e5943010 	ldr	r3, [r4, #16]
3481e8f4:	e3130c02 	tst	r3, #512	; 0x200
3481e8f8:	0a000007 	beq	3481e91c <inflate+0x3f0>
3481e8fc:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e900:	e1a06426 	lsr	r6, r6, #8
3481e904:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e908:	e5940018 	ldr	r0, [r4, #24]
3481e90c:	e28d1044 	add	r1, sp, #68	; 0x44
3481e910:	e3a02002 	mov	r2, #2
3481e914:	ebffefe1 	bl	3481a8a0 <crc32>
3481e918:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = EXLEN;
3481e91c:	e3a03004 	mov	r3, #4
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e920:	e3a05000 	mov	r5, #0
            state->mode = EXLEN;
3481e924:	e5843000 	str	r3, [r4]
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e928:	e1a06005 	mov	r6, r5
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
3481e92c:	e5943010 	ldr	r3, [r4, #16]
3481e930:	e2132b01 	ands	r2, r3, #1024	; 0x400
3481e934:	11a02009 	movne	r2, r9
3481e938:	1a000006 	bne	3481e958 <inflate+0x42c>
3481e93c:	ea000019 	b	3481e9a8 <inflate+0x47c>
                NEEDBITS(16);
3481e940:	e3570000 	cmp	r7, #0
3481e944:	0a0003f8 	beq	3481f92c <inflate+0x1400>
3481e948:	e4d21001 	ldrb	r1, [r2], #1
3481e94c:	e2477001 	sub	r7, r7, #1
3481e950:	e0866511 	add	r6, r6, r1, lsl r5
3481e954:	e2855008 	add	r5, r5, #8
3481e958:	e355000f 	cmp	r5, #15
3481e95c:	e1a09002 	mov	r9, r2
3481e960:	9afffff6 	bls	3481e940 <inflate+0x414>
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
3481e964:	e5942020 	ldr	r2, [r4, #32]
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
3481e968:	e5846040 	str	r6, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
3481e96c:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
3481e970:	15826014 	strne	r6, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e974:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
3481e978:	01a06003 	moveq	r6, r3
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e97c:	0a00000d 	beq	3481e9b8 <inflate+0x48c>
3481e980:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e984:	e1a06426 	lsr	r6, r6, #8
3481e988:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e98c:	e5940018 	ldr	r0, [r4, #24]
3481e990:	e28d1044 	add	r1, sp, #68	; 0x44
3481e994:	e3a02002 	mov	r2, #2
3481e998:	ebffefc0 	bl	3481a8a0 <crc32>
                INITBITS();
3481e99c:	e3a06000 	mov	r6, #0
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e9a0:	e5840018 	str	r0, [r4, #24]
3481e9a4:	ea000003 	b	3481e9b8 <inflate+0x48c>
                INITBITS();
            }
            else if (state->head != Z_NULL)
3481e9a8:	e5943020 	ldr	r3, [r4, #32]
3481e9ac:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
3481e9b0:	15832010 	strne	r2, [r3, #16]
3481e9b4:	ea000000 	b	3481e9bc <inflate+0x490>
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
3481e9b8:	e1a05006 	mov	r5, r6
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
3481e9bc:	e3a03005 	mov	r3, #5
3481e9c0:	e5843000 	str	r3, [r4]
        case EXTRA:
            if (state->flags & 0x0400) {
3481e9c4:	e5943010 	ldr	r3, [r4, #16]
3481e9c8:	e3130b01 	tst	r3, #1024	; 0x400
3481e9cc:	0a000029 	beq	3481ea78 <inflate+0x54c>
                copy = state->length;
3481e9d0:	e5942040 	ldr	r2, [r4, #64]	; 0x40
3481e9d4:	e1570002 	cmp	r7, r2
3481e9d8:	31a03007 	movcc	r3, r7
3481e9dc:	21a03002 	movcs	r3, r2
                if (copy > have) copy = have;
                if (copy) {
3481e9e0:	e3530000 	cmp	r3, #0
3481e9e4:	0a000020 	beq	3481ea6c <inflate+0x540>
                    if (state->head != Z_NULL &&
3481e9e8:	e5941020 	ldr	r1, [r4, #32]
3481e9ec:	e3510000 	cmp	r1, #0
3481e9f0:	0a00000e 	beq	3481ea30 <inflate+0x504>
                        state->head->extra != Z_NULL) {
3481e9f4:	e5910010 	ldr	r0, [r1, #16]
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
3481e9f8:	e3500000 	cmp	r0, #0
3481e9fc:	0a00000b 	beq	3481ea30 <inflate+0x504>
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481ea00:	e591c014 	ldr	ip, [r1, #20]
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481ea04:	e5911018 	ldr	r1, [r1, #24]
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481ea08:	e062200c 	rsb	r2, r2, ip
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481ea0c:	e083c002 	add	ip, r3, r2
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
3481ea10:	e15c0001 	cmp	ip, r1
3481ea14:	e0800002 	add	r0, r0, r2
3481ea18:	80622001 	rsbhi	r2, r2, r1
3481ea1c:	91a02003 	movls	r2, r3
3481ea20:	e1a01009 	mov	r1, r9
3481ea24:	e58d3014 	str	r3, [sp, #20]
3481ea28:	ebfff71e 	bl	3481c6a8 <memcpy>
3481ea2c:	e59d3014 	ldr	r3, [sp, #20]
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
3481ea30:	e5942010 	ldr	r2, [r4, #16]
3481ea34:	e3120c02 	tst	r2, #512	; 0x200
3481ea38:	0a000006 	beq	3481ea58 <inflate+0x52c>
                        state->check = crc32(state->check, next, copy);
3481ea3c:	e5940018 	ldr	r0, [r4, #24]
3481ea40:	e1a02003 	mov	r2, r3
3481ea44:	e1a01009 	mov	r1, r9
3481ea48:	e58d3014 	str	r3, [sp, #20]
3481ea4c:	ebffef93 	bl	3481a8a0 <crc32>
3481ea50:	e59d3014 	ldr	r3, [sp, #20]
3481ea54:	e5840018 	str	r0, [r4, #24]
                    have -= copy;
                    next += copy;
                    state->length -= copy;
3481ea58:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
3481ea5c:	e0637007 	rsb	r7, r3, r7
                    next += copy;
3481ea60:	e0899003 	add	r9, r9, r3
                    state->length -= copy;
3481ea64:	e0633002 	rsb	r3, r3, r2
3481ea68:	e5843040 	str	r3, [r4, #64]	; 0x40
                }
                if (state->length) goto inf_leave;
3481ea6c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481ea70:	e3530000 	cmp	r3, #0
3481ea74:	1a0003ac 	bne	3481f92c <inflate+0x1400>
            }
            state->length = 0;
3481ea78:	e3a03000 	mov	r3, #0
3481ea7c:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
3481ea80:	e2833006 	add	r3, r3, #6
3481ea84:	e5843000 	str	r3, [r4]
        case NAME:
            if (state->flags & 0x0800) {
3481ea88:	e5942010 	ldr	r2, [r4, #16]
3481ea8c:	e2122b02 	ands	r2, r2, #2048	; 0x800
3481ea90:	0a000024 	beq	3481eb28 <inflate+0x5fc>
                if (have == 0) goto inf_leave;
3481ea94:	e3570000 	cmp	r7, #0
3481ea98:	0a0003a3 	beq	3481f92c <inflate+0x1400>
3481ea9c:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481eaa0:	e5941020 	ldr	r1, [r4, #32]
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481eaa4:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481eaa8:	e3510000 	cmp	r1, #0
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481eaac:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481eab0:	0a000008 	beq	3481ead8 <inflate+0x5ac>
                            state->head->name != Z_NULL &&
3481eab4:	e591001c 	ldr	r0, [r1, #28]
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481eab8:	e3500000 	cmp	r0, #0
3481eabc:	0a000005 	beq	3481ead8 <inflate+0x5ac>
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
3481eac0:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
3481eac4:	e5911020 	ldr	r1, [r1, #32]
3481eac8:	e1520001 	cmp	r2, r1
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
3481eacc:	37c0c002 	strbcc	ip, [r0, r2]
3481ead0:	32822001 	addcc	r2, r2, #1
3481ead4:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481ead8:	e35c0000 	cmp	ip, #0
3481eadc:	11530007 	cmpne	r3, r7
3481eae0:	3affffee 	bcc	3481eaa0 <inflate+0x574>
                if (state->flags & 0x0200)
3481eae4:	e5942010 	ldr	r2, [r4, #16]
3481eae8:	e3120c02 	tst	r2, #512	; 0x200
3481eaec:	0a000008 	beq	3481eb14 <inflate+0x5e8>
                    state->check = crc32(state->check, next, copy);
3481eaf0:	e5940018 	ldr	r0, [r4, #24]
3481eaf4:	e1a02003 	mov	r2, r3
3481eaf8:	e1a01009 	mov	r1, r9
3481eafc:	e58d3014 	str	r3, [sp, #20]
3481eb00:	e58dc018 	str	ip, [sp, #24]
3481eb04:	ebffef65 	bl	3481a8a0 <crc32>
3481eb08:	e59dc018 	ldr	ip, [sp, #24]
3481eb0c:	e59d3014 	ldr	r3, [sp, #20]
3481eb10:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481eb14:	e35c0000 	cmp	ip, #0
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481eb18:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481eb1c:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481eb20:	0a000003 	beq	3481eb34 <inflate+0x608>
3481eb24:	ea000380 	b	3481f92c <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481eb28:	e5943020 	ldr	r3, [r4, #32]
3481eb2c:	e3530000 	cmp	r3, #0
                state->head->name = Z_NULL;
3481eb30:	1583201c 	strne	r2, [r3, #28]
            state->length = 0;
3481eb34:	e3a0c000 	mov	ip, #0
            state->mode = COMMENT;
3481eb38:	e3a03007 	mov	r3, #7
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
3481eb3c:	e584c040 	str	ip, [r4, #64]	; 0x40
            state->mode = COMMENT;
3481eb40:	e5843000 	str	r3, [r4]
        case COMMENT:
            if (state->flags & 0x1000) {
3481eb44:	e5942010 	ldr	r2, [r4, #16]
3481eb48:	e2122a01 	ands	r2, r2, #4096	; 0x1000
3481eb4c:	0a000024 	beq	3481ebe4 <inflate+0x6b8>
                if (have == 0) goto inf_leave;
3481eb50:	e3570000 	cmp	r7, #0
3481eb54:	0a000374 	beq	3481f92c <inflate+0x1400>
3481eb58:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481eb5c:	e5941020 	ldr	r1, [r4, #32]
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481eb60:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481eb64:	e3510000 	cmp	r1, #0
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481eb68:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481eb6c:	0a000008 	beq	3481eb94 <inflate+0x668>
                            state->head->comment != Z_NULL &&
3481eb70:	e5910024 	ldr	r0, [r1, #36]	; 0x24
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481eb74:	e3500000 	cmp	r0, #0
3481eb78:	0a000005 	beq	3481eb94 <inflate+0x668>
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
3481eb7c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
3481eb80:	e5911028 	ldr	r1, [r1, #40]	; 0x28
3481eb84:	e1520001 	cmp	r2, r1
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
3481eb88:	37c0c002 	strbcc	ip, [r0, r2]
3481eb8c:	32822001 	addcc	r2, r2, #1
3481eb90:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481eb94:	e35c0000 	cmp	ip, #0
3481eb98:	11530007 	cmpne	r3, r7
3481eb9c:	3affffee 	bcc	3481eb5c <inflate+0x630>
                if (state->flags & 0x0200)
3481eba0:	e5942010 	ldr	r2, [r4, #16]
3481eba4:	e3120c02 	tst	r2, #512	; 0x200
3481eba8:	0a000008 	beq	3481ebd0 <inflate+0x6a4>
                    state->check = crc32(state->check, next, copy);
3481ebac:	e5940018 	ldr	r0, [r4, #24]
3481ebb0:	e1a02003 	mov	r2, r3
3481ebb4:	e1a01009 	mov	r1, r9
3481ebb8:	e58d3014 	str	r3, [sp, #20]
3481ebbc:	e58dc018 	str	ip, [sp, #24]
3481ebc0:	ebffef36 	bl	3481a8a0 <crc32>
3481ebc4:	e59dc018 	ldr	ip, [sp, #24]
3481ebc8:	e59d3014 	ldr	r3, [sp, #20]
3481ebcc:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481ebd0:	e35c0000 	cmp	ip, #0
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481ebd4:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481ebd8:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481ebdc:	0a000003 	beq	3481ebf0 <inflate+0x6c4>
3481ebe0:	ea000351 	b	3481f92c <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481ebe4:	e5943020 	ldr	r3, [r4, #32]
3481ebe8:	e3530000 	cmp	r3, #0
                state->head->comment = Z_NULL;
3481ebec:	15832024 	strne	r2, [r3, #36]	; 0x24
            state->mode = HCRC;
3481ebf0:	e3a03008 	mov	r3, #8
3481ebf4:	e5843000 	str	r3, [r4]
        case HCRC:
            if (state->flags & 0x0200) {
3481ebf8:	e5942010 	ldr	r2, [r4, #16]
3481ebfc:	e3120c02 	tst	r2, #512	; 0x200
3481ec00:	11a03009 	movne	r3, r9
3481ec04:	1a000006 	bne	3481ec24 <inflate+0x6f8>
3481ec08:	ea00000e 	b	3481ec48 <inflate+0x71c>
                NEEDBITS(16);
3481ec0c:	e3570000 	cmp	r7, #0
3481ec10:	0a000345 	beq	3481f92c <inflate+0x1400>
3481ec14:	e4d31001 	ldrb	r1, [r3], #1
3481ec18:	e2477001 	sub	r7, r7, #1
3481ec1c:	e0866511 	add	r6, r6, r1, lsl r5
3481ec20:	e2855008 	add	r5, r5, #8
3481ec24:	e355000f 	cmp	r5, #15
3481ec28:	e1a09003 	mov	r9, r3
3481ec2c:	9afffff6 	bls	3481ec0c <inflate+0x6e0>
                if (hold != (state->check & 0xffff)) {
3481ec30:	e1d431b8 	ldrh	r3, [r4, #24]
3481ec34:	e1560003 	cmp	r6, r3
                    strm->msg = (char *)"header crc mismatch";
3481ec38:	159f39e0 	ldrne	r3, [pc, #2528]	; 3481f620 <inflate+0x10f4>
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
3481ec3c:	1a00032a 	bne	3481f8ec <inflate+0x13c0>
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481ec40:	e3a05000 	mov	r5, #0
3481ec44:	e1a06005 	mov	r6, r5
            }
            if (state->head != Z_NULL) {
3481ec48:	e5943020 	ldr	r3, [r4, #32]
3481ec4c:	e3530000 	cmp	r3, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
3481ec50:	13a00001 	movne	r0, #1
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481ec54:	17e024d2 	ubfxne	r2, r2, #9, #1
                state->head->done = 1;
3481ec58:	15830030 	strne	r0, [r3, #48]	; 0x30
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481ec5c:	e3a00000 	mov	r0, #0
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481ec60:	1583202c 	strne	r2, [r3, #44]	; 0x2c
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481ec64:	e1a01000 	mov	r1, r0
3481ec68:	e1a02000 	mov	r2, r0
3481ec6c:	ebffef0b 	bl	3481a8a0 <crc32>
3481ec70:	e5840018 	str	r0, [r4, #24]
3481ec74:	e58a0034 	str	r0, [sl, #52]	; 0x34
3481ec78:	ea0001f3 	b	3481f44c <inflate+0xf20>
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
3481ec7c:	e3570000 	cmp	r7, #0
3481ec80:	0a000329 	beq	3481f92c <inflate+0x1400>
3481ec84:	e4d32001 	ldrb	r2, [r3], #1
3481ec88:	e2477001 	sub	r7, r7, #1
3481ec8c:	e0866512 	add	r6, r6, r2, lsl r5
3481ec90:	e2855008 	add	r5, r5, #8
3481ec94:	e355001f 	cmp	r5, #31
3481ec98:	e1a09003 	mov	r9, r3
3481ec9c:	9afffff6 	bls	3481ec7c <inflate+0x750>
            strm->adler = state->check = REVERSE(hold);
3481eca0:	e1a02c26 	lsr	r2, r6, #24
3481eca4:	e1a03426 	lsr	r3, r6, #8
3481eca8:	e0822c06 	add	r2, r2, r6, lsl #24
3481ecac:	e2033cff 	and	r3, r3, #65280	; 0xff00
3481ecb0:	e2066cff 	and	r6, r6, #65280	; 0xff00
3481ecb4:	e0823003 	add	r3, r2, r3
3481ecb8:	e0833406 	add	r3, r3, r6, lsl #8
3481ecbc:	e5843018 	str	r3, [r4, #24]
            INITBITS();
3481ecc0:	e3a06000 	mov	r6, #0
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
3481ecc4:	e58a3034 	str	r3, [sl, #52]	; 0x34
            INITBITS();
            state->mode = DICT;
3481ecc8:	e3a0300a 	mov	r3, #10
3481eccc:	e5843000 	str	r3, [r4]
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
3481ecd0:	e1a05006 	mov	r5, r6
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
3481ecd4:	e594300c 	ldr	r3, [r4, #12]
3481ecd8:	e3530000 	cmp	r3, #0
3481ecdc:	1a000008 	bne	3481ed04 <inflate+0x7d8>
                RESTORE();
3481ece0:	e59d1020 	ldr	r1, [sp, #32]
3481ece4:	e58ab010 	str	fp, [sl, #16]
3481ece8:	e58a100c 	str	r1, [sl, #12]
3481ecec:	e58a9000 	str	r9, [sl]
3481ecf0:	e58a7004 	str	r7, [sl, #4]
                return Z_NEED_DICT;
3481ecf4:	e3a02002 	mov	r2, #2
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
3481ecf8:	e5846038 	str	r6, [r4, #56]	; 0x38
3481ecfc:	e584503c 	str	r5, [r4, #60]	; 0x3c
3481ed00:	ea00039e 	b	3481fb80 <inflate+0x1654>
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ed04:	e3a00000 	mov	r0, #0
3481ed08:	e1a01000 	mov	r1, r0
3481ed0c:	e1a02000 	mov	r2, r0
3481ed10:	ebfffd4b 	bl	3481e244 <adler32>
            state->mode = TYPE;
3481ed14:	e3a0300b 	mov	r3, #11
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ed18:	e5840018 	str	r0, [r4, #24]
3481ed1c:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = TYPE;
3481ed20:	e5843000 	str	r3, [r4]
        case TYPE:
	    WATCHDOG_RESET();
            if (flush == Z_BLOCK) goto inf_leave;
3481ed24:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481ed28:	e3530005 	cmp	r3, #5
3481ed2c:	0a0002fe 	beq	3481f92c <inflate+0x1400>
        case TYPEDO:
            if (state->last) {
3481ed30:	e5943004 	ldr	r3, [r4, #4]
3481ed34:	e3530000 	cmp	r3, #0
3481ed38:	01a03009 	moveq	r3, r9
3481ed3c:	0a00000a 	beq	3481ed6c <inflate+0x840>
                BYTEBITS();
3481ed40:	e2053007 	and	r3, r5, #7
3481ed44:	e1a06336 	lsr	r6, r6, r3
3481ed48:	e3c55007 	bic	r5, r5, #7
                state->mode = CHECK;
3481ed4c:	e3a03018 	mov	r3, #24
3481ed50:	ea0002e7 	b	3481f8f4 <inflate+0x13c8>
                break;
            }
            NEEDBITS(3);
3481ed54:	e3570000 	cmp	r7, #0
3481ed58:	0a0002f3 	beq	3481f92c <inflate+0x1400>
3481ed5c:	e4d32001 	ldrb	r2, [r3], #1
3481ed60:	e2477001 	sub	r7, r7, #1
3481ed64:	e0866512 	add	r6, r6, r2, lsl r5
3481ed68:	e2855008 	add	r5, r5, #8
3481ed6c:	e3550002 	cmp	r5, #2
3481ed70:	e1a09003 	mov	r9, r3
3481ed74:	9afffff6 	bls	3481ed54 <inflate+0x828>
            state->last = BITS(1);
3481ed78:	e2063001 	and	r3, r6, #1
            DROPBITS(1);
3481ed7c:	e1a060a6 	lsr	r6, r6, #1
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
3481ed80:	e5843004 	str	r3, [r4, #4]
            DROPBITS(1);
            switch (BITS(2)) {
3481ed84:	e2063003 	and	r3, r6, #3
3481ed88:	e3530002 	cmp	r3, #2
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
3481ed8c:	03a0300f 	moveq	r3, #15
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
3481ed90:	0a000010 	beq	3481edd8 <inflate+0x8ac>
3481ed94:	e3530003 	cmp	r3, #3
3481ed98:	0a00000b 	beq	3481edcc <inflate+0x8a0>
3481ed9c:	e3530001 	cmp	r3, #1

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481eda0:	03a03009 	moveq	r3, #9
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481eda4:	059fc878 	ldreq	ip, [pc, #2168]	; 3481f624 <inflate+0x10f8>
    state->lenbits = 9;
    state->distcode = distfix;
3481eda8:	059f0878 	ldreq	r0, [pc, #2168]	; 3481f628 <inflate+0x10fc>

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481edac:	05843054 	streq	r3, [r4, #84]	; 0x54
    state->distcode = distfix;
    state->distbits = 5;
3481edb0:	03a03005 	moveq	r3, #5
3481edb4:	05843058 	streq	r3, [r4, #88]	; 0x58
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
3481edb8:	13a0300d 	movne	r3, #13
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481edbc:	0584c04c 	streq	ip, [r4, #76]	; 0x4c
    state->lenbits = 9;
    state->distcode = distfix;
3481edc0:	05840050 	streq	r0, [r4, #80]	; 0x50
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
3481edc4:	0283300d 	addeq	r3, r3, #13
3481edc8:	ea000002 	b	3481edd8 <inflate+0x8ac>
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
3481edcc:	e59f3858 	ldr	r3, [pc, #2136]	; 3481f62c <inflate+0x1100>
3481edd0:	e58a3018 	str	r3, [sl, #24]
                state->mode = BAD;
3481edd4:	e3a0301b 	mov	r3, #27
3481edd8:	e5843000 	str	r3, [r4]
            }
            DROPBITS(2);
3481eddc:	e1a06126 	lsr	r6, r6, #2
3481ede0:	e2455003 	sub	r5, r5, #3
            break;
3481ede4:	eafffdef 	b	3481e5a8 <inflate+0x7c>
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
3481ede8:	e2053007 	and	r3, r5, #7
3481edec:	e1a06336 	lsr	r6, r6, r3
3481edf0:	e3c55007 	bic	r5, r5, #7
3481edf4:	e1a03009 	mov	r3, r9
            NEEDBITS(32);
3481edf8:	ea000005 	b	3481ee14 <inflate+0x8e8>
3481edfc:	e3570000 	cmp	r7, #0
3481ee00:	0a0002c9 	beq	3481f92c <inflate+0x1400>
3481ee04:	e4d32001 	ldrb	r2, [r3], #1
3481ee08:	e2477001 	sub	r7, r7, #1
3481ee0c:	e0866512 	add	r6, r6, r2, lsl r5
3481ee10:	e2855008 	add	r5, r5, #8
3481ee14:	e355001f 	cmp	r5, #31
3481ee18:	e1a09003 	mov	r9, r3
3481ee1c:	9afffff6 	bls	3481edfc <inflate+0x8d0>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481ee20:	e1a02826 	lsr	r2, r6, #16
3481ee24:	e2222cff 	eor	r2, r2, #65280	; 0xff00
3481ee28:	e6ff3076 	uxth	r3, r6
3481ee2c:	e22220ff 	eor	r2, r2, #255	; 0xff
3481ee30:	e1530002 	cmp	r3, r2
                strm->msg = (char *)"invalid stored block lengths";
3481ee34:	159f37f4 	ldrne	r3, [pc, #2036]	; 3481f630 <inflate+0x1104>
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481ee38:	1a0002ab 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
3481ee3c:	e5843040 	str	r3, [r4, #64]	; 0x40
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481ee40:	e3a05000 	mov	r5, #0
            state->mode = COPY;
3481ee44:	e3a0300e 	mov	r3, #14
3481ee48:	e5843000 	str	r3, [r4]
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481ee4c:	e1a06005 	mov	r6, r5
            state->mode = COPY;
        case COPY:
            copy = state->length;
3481ee50:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
3481ee54:	e3530000 	cmp	r3, #0
3481ee58:	0a00017b 	beq	3481f44c <inflate+0xf20>
3481ee5c:	e15b0003 	cmp	fp, r3
3481ee60:	31a0300b 	movcc	r3, fp
3481ee64:	e1530007 	cmp	r3, r7
3481ee68:	21a03007 	movcs	r3, r7
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
3481ee6c:	e3530000 	cmp	r3, #0
3481ee70:	0a0002ad 	beq	3481f92c <inflate+0x1400>
                zmemcpy(put, next, copy);
3481ee74:	e1a01009 	mov	r1, r9
3481ee78:	e1a02003 	mov	r2, r3
3481ee7c:	e59d0020 	ldr	r0, [sp, #32]
3481ee80:	e58d3014 	str	r3, [sp, #20]
3481ee84:	ebfff607 	bl	3481c6a8 <memcpy>
                have -= copy;
3481ee88:	e59d3014 	ldr	r3, [sp, #20]
                next += copy;
                left -= copy;
                put += copy;
3481ee8c:	e59d1020 	ldr	r1, [sp, #32]
                state->length -= copy;
3481ee90:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481ee94:	e0811003 	add	r1, r1, r3
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
3481ee98:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481ee9c:	e0899003 	add	r9, r9, r3
                left -= copy;
3481eea0:	e063b00b 	rsb	fp, r3, fp
                put += copy;
                state->length -= copy;
3481eea4:	e0633002 	rsb	r3, r3, r2
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481eea8:	e58d1020 	str	r1, [sp, #32]
                state->length -= copy;
3481eeac:	e5843040 	str	r3, [r4, #64]	; 0x40
                break;
3481eeb0:	eafffdbc 	b	3481e5a8 <inflate+0x7c>
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
3481eeb4:	e3570000 	cmp	r7, #0
3481eeb8:	0a00029b 	beq	3481f92c <inflate+0x1400>
3481eebc:	e4d32001 	ldrb	r2, [r3], #1
3481eec0:	e2477001 	sub	r7, r7, #1
3481eec4:	e0866512 	add	r6, r6, r2, lsl r5
3481eec8:	e2855008 	add	r5, r5, #8
3481eecc:	e355000d 	cmp	r5, #13
3481eed0:	e1a09003 	mov	r9, r3
3481eed4:	9afffff6 	bls	3481eeb4 <inflate+0x988>
            state->nlen = BITS(5) + 257;
3481eed8:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481eedc:	e7e31556 	ubfx	r1, r6, #10, #4
3481eee0:	e2811004 	add	r1, r1, #4
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481eee4:	e2822c01 	add	r2, r2, #256	; 0x100
3481eee8:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481eeec:	e7e432d6 	ubfx	r3, r6, #5, #5
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481eef0:	e584105c 	str	r1, [r4, #92]	; 0x5c
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481eef4:	e300111e 	movw	r1, #286	; 0x11e
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481eef8:	e2833001 	add	r3, r3, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481eefc:	e1520001 	cmp	r2, r1
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481ef00:	e5842060 	str	r2, [r4, #96]	; 0x60
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481ef04:	e5843064 	str	r3, [r4, #100]	; 0x64
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
3481ef08:	e1a06726 	lsr	r6, r6, #14
3481ef0c:	e245500e 	sub	r5, r5, #14
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481ef10:	8a000001 	bhi	3481ef1c <inflate+0x9f0>
3481ef14:	e353001e 	cmp	r3, #30
3481ef18:	9a000001 	bls	3481ef24 <inflate+0x9f8>
                strm->msg = (char *)"too many length or distance symbols";
3481ef1c:	e59f3710 	ldr	r3, [pc, #1808]	; 3481f634 <inflate+0x1108>
3481ef20:	ea000271 	b	3481f8ec <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481ef24:	e3a02000 	mov	r2, #0
            state->mode = LENLENS;
3481ef28:	e3a03010 	mov	r3, #16
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481ef2c:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = LENLENS;
3481ef30:	e5843000 	str	r3, [r4]
        case LENLENS:
            while (state->have < state->ncode) {
3481ef34:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
3481ef38:	ea000013 	b	3481ef8c <inflate+0xa60>
                NEEDBITS(3);
3481ef3c:	e3570000 	cmp	r7, #0
3481ef40:	0a000279 	beq	3481f92c <inflate+0x1400>
3481ef44:	e4d10001 	ldrb	r0, [r1], #1
3481ef48:	e2477001 	sub	r7, r7, #1
3481ef4c:	e0866510 	add	r6, r6, r0, lsl r5
3481ef50:	e2855008 	add	r5, r5, #8
3481ef54:	e3550002 	cmp	r5, #2
3481ef58:	e1a09001 	mov	r9, r1
3481ef5c:	9afffff6 	bls	3481ef3c <inflate+0xa10>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481ef60:	e59fc6d0 	ldr	ip, [pc, #1744]	; 3481f638 <inflate+0x110c>
3481ef64:	e2060007 	and	r0, r6, #7
3481ef68:	e08c1083 	add	r1, ip, r3, lsl #1
3481ef6c:	e2811d26 	add	r1, r1, #2432	; 0x980
3481ef70:	e1d110b0 	ldrh	r1, [r1]
3481ef74:	e2833001 	add	r3, r3, #1
3481ef78:	e0841081 	add	r1, r4, r1, lsl #1
3481ef7c:	e1c107b0 	strh	r0, [r1, #112]	; 0x70
3481ef80:	e5843068 	str	r3, [r4, #104]	; 0x68
                DROPBITS(3);
3481ef84:	e1a061a6 	lsr	r6, r6, #3
3481ef88:	e2455003 	sub	r5, r5, #3
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
3481ef8c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481ef90:	e1530002 	cmp	r3, r2
3481ef94:	2a00000a 	bcs	3481efc4 <inflate+0xa98>
3481ef98:	e1a01009 	mov	r1, r9
3481ef9c:	eaffffec 	b	3481ef54 <inflate+0xa28>
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
3481efa0:	e59f0690 	ldr	r0, [pc, #1680]	; 3481f638 <inflate+0x110c>
3481efa4:	e3a01000 	mov	r1, #0
3481efa8:	e0802083 	add	r2, r0, r3, lsl #1
3481efac:	e2822d26 	add	r2, r2, #2432	; 0x980
3481efb0:	e1d220b0 	ldrh	r2, [r2]
3481efb4:	e2833001 	add	r3, r3, #1
3481efb8:	e0842082 	add	r2, r4, r2, lsl #1
3481efbc:	e1c217b0 	strh	r1, [r2, #112]	; 0x70
3481efc0:	e5843068 	str	r3, [r4, #104]	; 0x68
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
3481efc4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481efc8:	e3530012 	cmp	r3, #18
3481efcc:	9afffff3 	bls	3481efa0 <inflate+0xa74>
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
3481efd0:	e2843e53 	add	r3, r4, #1328	; 0x530
3481efd4:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481efd8:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
3481efdc:	e3a03007 	mov	r3, #7
3481efe0:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481efe4:	e2843054 	add	r3, r4, #84	; 0x54
3481efe8:	e58d3000 	str	r3, [sp]
3481efec:	e2843e2f 	add	r3, r4, #752	; 0x2f0
3481eff0:	e58d3004 	str	r3, [sp, #4]
3481eff4:	e3a00000 	mov	r0, #0
3481eff8:	e284306c 	add	r3, r4, #108	; 0x6c
3481effc:	e2841070 	add	r1, r4, #112	; 0x70
3481f000:	e3a02013 	mov	r2, #19
3481f004:	ebfffab2 	bl	3481dad4 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481f008:	e3500000 	cmp	r0, #0
3481f00c:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid code lengths set";
3481f010:	159f3624 	ldrne	r3, [pc, #1572]	; 3481f63c <inflate+0x1110>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481f014:	1a000234 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481f018:	e59d201c 	ldr	r2, [sp, #28]
            state->mode = CODELENS;
3481f01c:	e3a03011 	mov	r3, #17
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481f020:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = CODELENS;
3481f024:	e5843000 	str	r3, [r4]
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481f028:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481f02c:	e5943060 	ldr	r3, [r4, #96]	; 0x60
3481f030:	e0823003 	add	r3, r2, r3
3481f034:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481f038:	ea000075 	b	3481f214 <inflate+0xce8>
                for (;;) {
                    this = state->lencode[BITS(state->lenbits)];
3481f03c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481f040:	e3a00001 	mov	r0, #1
3481f044:	e1a03310 	lsl	r3, r0, r3
3481f048:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481f04c:	e2433001 	sub	r3, r3, #1
3481f050:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f054:	e1a02009 	mov	r2, r9
3481f058:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3481f05c:	e1a09002 	mov	r9, r2
3481f060:	e0060003 	and	r0, r6, r3
3481f064:	e08c0100 	add	r0, ip, r0, lsl #2
3481f068:	e5d03001 	ldrb	r3, [r0, #1]
3481f06c:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(this.bits) <= bits) break;
3481f070:	e1530005 	cmp	r3, r5
3481f074:	9a000006 	bls	3481f094 <inflate+0xb68>
                    PULLBYTE();
3481f078:	e3570000 	cmp	r7, #0
3481f07c:	0a00022a 	beq	3481f92c <inflate+0x1400>
3481f080:	e4d23001 	ldrb	r3, [r2], #1
3481f084:	e2477001 	sub	r7, r7, #1
3481f088:	e0866513 	add	r6, r6, r3, lsl r5
3481f08c:	e2855008 	add	r5, r5, #8
                }
3481f090:	eafffff0 	b	3481f058 <inflate+0xb2c>
                if (this.val < 16) {
3481f094:	e350000f 	cmp	r0, #15
3481f098:	8a000010 	bhi	3481f0e0 <inflate+0xbb4>
3481f09c:	ea000005 	b	3481f0b8 <inflate+0xb8c>
                    NEEDBITS(this.bits);
3481f0a0:	e3570000 	cmp	r7, #0
3481f0a4:	0a000220 	beq	3481f92c <inflate+0x1400>
3481f0a8:	e4d2c001 	ldrb	ip, [r2], #1
3481f0ac:	e2477001 	sub	r7, r7, #1
3481f0b0:	e086651c 	add	r6, r6, ip, lsl r5
3481f0b4:	e2855008 	add	r5, r5, #8
3481f0b8:	e1550003 	cmp	r5, r3
3481f0bc:	e1a09002 	mov	r9, r2
3481f0c0:	3afffff6 	bcc	3481f0a0 <inflate+0xb74>
                    DROPBITS(this.bits);
3481f0c4:	e1a06336 	lsr	r6, r6, r3
3481f0c8:	e0635005 	rsb	r5, r3, r5
                    state->lens[state->have++] = this.val;
3481f0cc:	e0843081 	add	r3, r4, r1, lsl #1
3481f0d0:	e2811001 	add	r1, r1, #1
3481f0d4:	e1c307b0 	strh	r0, [r3, #112]	; 0x70
3481f0d8:	e5841068 	str	r1, [r4, #104]	; 0x68
3481f0dc:	ea00004c 	b	3481f214 <inflate+0xce8>
                }
                else {
                    if (this.val == 16) {
3481f0e0:	e3500010 	cmp	r0, #16
                        NEEDBITS(this.bits + 2);
3481f0e4:	02830002 	addeq	r0, r3, #2
                    NEEDBITS(this.bits);
                    DROPBITS(this.bits);
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
3481f0e8:	1a000014 	bne	3481f140 <inflate+0xc14>
3481f0ec:	ea000005 	b	3481f108 <inflate+0xbdc>
                        NEEDBITS(this.bits + 2);
3481f0f0:	e3570000 	cmp	r7, #0
3481f0f4:	0a00020c 	beq	3481f92c <inflate+0x1400>
3481f0f8:	e4d2c001 	ldrb	ip, [r2], #1
3481f0fc:	e2477001 	sub	r7, r7, #1
3481f100:	e086651c 	add	r6, r6, ip, lsl r5
3481f104:	e2855008 	add	r5, r5, #8
3481f108:	e1550000 	cmp	r5, r0
3481f10c:	e1a09002 	mov	r9, r2
3481f110:	3afffff6 	bcc	3481f0f0 <inflate+0xbc4>
                        DROPBITS(this.bits);
                        if (state->have == 0) {
3481f114:	e3510000 	cmp	r1, #0
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
                        NEEDBITS(this.bits + 2);
                        DROPBITS(this.bits);
3481f118:	e1a06336 	lsr	r6, r6, r3
3481f11c:	e0635005 	rsb	r5, r3, r5
                        if (state->have == 0) {
3481f120:	0a00002f 	beq	3481f1e4 <inflate+0xcb8>
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
3481f124:	e2062003 	and	r2, r6, #3
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
3481f128:	e0843081 	add	r3, r4, r1, lsl #1
3481f12c:	e1d336be 	ldrh	r3, [r3, #110]	; 0x6e
                        copy = 3 + BITS(2);
3481f130:	e2822003 	add	r2, r2, #3
                        DROPBITS(2);
3481f134:	e1a06126 	lsr	r6, r6, #2
3481f138:	e2455002 	sub	r5, r5, #2
3481f13c:	ea000024 	b	3481f1d4 <inflate+0xca8>
                    }
                    else if (this.val == 17) {
3481f140:	e3500011 	cmp	r0, #17
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481f144:	12830007 	addne	r0, r3, #7
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
3481f148:	02830003 	addeq	r0, r3, #3
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
3481f14c:	1a000015 	bne	3481f1a8 <inflate+0xc7c>
3481f150:	ea000005 	b	3481f16c <inflate+0xc40>
                        NEEDBITS(this.bits + 3);
3481f154:	e3570000 	cmp	r7, #0
3481f158:	0a0001f3 	beq	3481f92c <inflate+0x1400>
3481f15c:	e4d2c001 	ldrb	ip, [r2], #1
3481f160:	e2477001 	sub	r7, r7, #1
3481f164:	e086651c 	add	r6, r6, ip, lsl r5
3481f168:	e2855008 	add	r5, r5, #8
3481f16c:	e1550000 	cmp	r5, r0
3481f170:	e1a09002 	mov	r9, r2
3481f174:	3afffff6 	bcc	3481f154 <inflate+0xc28>
                        DROPBITS(this.bits);
3481f178:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 3 + BITS(3);
3481f17c:	e2062007 	and	r2, r6, #7
3481f180:	e2822003 	add	r2, r2, #3
                        DROPBITS(3);
3481f184:	e1a061a6 	lsr	r6, r6, #3
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
                        DROPBITS(this.bits);
3481f188:	e3e00002 	mvn	r0, #2
3481f18c:	ea00000d 	b	3481f1c8 <inflate+0xc9c>
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481f190:	e3570000 	cmp	r7, #0
3481f194:	0a0001e4 	beq	3481f92c <inflate+0x1400>
3481f198:	e4d2c001 	ldrb	ip, [r2], #1
3481f19c:	e2477001 	sub	r7, r7, #1
3481f1a0:	e086651c 	add	r6, r6, ip, lsl r5
3481f1a4:	e2855008 	add	r5, r5, #8
3481f1a8:	e1550000 	cmp	r5, r0
3481f1ac:	e1a09002 	mov	r9, r2
3481f1b0:	3afffff6 	bcc	3481f190 <inflate+0xc64>
                        DROPBITS(this.bits);
3481f1b4:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 11 + BITS(7);
3481f1b8:	e206207f 	and	r2, r6, #127	; 0x7f
3481f1bc:	e282200b 	add	r2, r2, #11
                        DROPBITS(7);
3481f1c0:	e1a063a6 	lsr	r6, r6, #7
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
3481f1c4:	e3e00006 	mvn	r0, #6
3481f1c8:	e0630000 	rsb	r0, r3, r0
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
3481f1cc:	e0855000 	add	r5, r5, r0
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
                        len = 0;
3481f1d0:	e3a03000 	mov	r3, #0
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
3481f1d4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
3481f1d8:	e0821001 	add	r1, r2, r1
3481f1dc:	e151000c 	cmp	r1, ip
3481f1e0:	9a000004 	bls	3481f1f8 <inflate+0xccc>
                        strm->msg = (char *)"invalid bit length repeat";
3481f1e4:	e59f3454 	ldr	r3, [pc, #1108]	; 3481f640 <inflate+0x1114>
3481f1e8:	e58a3018 	str	r3, [sl, #24]
                        state->mode = BAD;
3481f1ec:	e3a0301b 	mov	r3, #27
3481f1f0:	e5843000 	str	r3, [r4]
                        break;
3481f1f4:	ea00000a 	b	3481f224 <inflate+0xcf8>
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
3481f1f8:	e5941068 	ldr	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481f1fc:	e2522001 	subs	r2, r2, #1
                        state->lens[state->have++] = (unsigned short)len;
3481f200:	e0840081 	add	r0, r4, r1, lsl #1
3481f204:	e2811001 	add	r1, r1, #1
3481f208:	e1c037b0 	strh	r3, [r0, #112]	; 0x70
3481f20c:	e5841068 	str	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481f210:	1afffff8 	bne	3481f1f8 <inflate+0xccc>
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481f214:	e5941068 	ldr	r1, [r4, #104]	; 0x68
3481f218:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3481f21c:	e1510000 	cmp	r1, r0
3481f220:	3affff85 	bcc	3481f03c <inflate+0xb10>
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;
3481f224:	e5943000 	ldr	r3, [r4]
3481f228:	e353001b 	cmp	r3, #27
3481f22c:	0afffcdd 	beq	3481e5a8 <inflate+0x7c>

            /* build code tables */
            state->next = state->codes;
3481f230:	e2843e53 	add	r3, r4, #1328	; 0x530
3481f234:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481f238:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
3481f23c:	e3a03009 	mov	r3, #9
3481f240:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481f244:	e284ce2f 	add	ip, r4, #752	; 0x2f0
3481f248:	e284106c 	add	r1, r4, #108	; 0x6c
3481f24c:	e2843054 	add	r3, r4, #84	; 0x54
3481f250:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481f254:	e88d1008 	stm	sp, {r3, ip}
3481f258:	e5942060 	ldr	r2, [r4, #96]	; 0x60
3481f25c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481f260:	e3a00001 	mov	r0, #1
3481f264:	e2841070 	add	r1, r4, #112	; 0x70
3481f268:	e58dc018 	str	ip, [sp, #24]
3481f26c:	ebfffa18 	bl	3481dad4 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481f270:	e3500000 	cmp	r0, #0
3481f274:	e58d001c 	str	r0, [sp, #28]
3481f278:	e59dc018 	ldr	ip, [sp, #24]
                strm->msg = (char *)"invalid literal/lengths set";
3481f27c:	159f33c0 	ldrne	r3, [pc, #960]	; 3481f644 <inflate+0x1118>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481f280:	1a000199 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481f284:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481f288:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481f28c:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
3481f290:	e3a03006 	mov	r3, #6
3481f294:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481f298:	e2843058 	add	r3, r4, #88	; 0x58
3481f29c:	e88d1008 	stm	sp, {r3, ip}
3481f2a0:	e3a00002 	mov	r0, #2
3481f2a4:	e2811038 	add	r1, r1, #56	; 0x38
3481f2a8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481f2ac:	e0214091 	mla	r1, r1, r0, r4
3481f2b0:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481f2b4:	ebfffa06 	bl	3481dad4 <inflate_table>
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481f2b8:	e3500000 	cmp	r0, #0
3481f2bc:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid distances set";
3481f2c0:	159f3380 	ldrne	r3, [pc, #896]	; 3481f648 <inflate+0x111c>
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481f2c4:	1a000188 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
3481f2c8:	e3a03012 	mov	r3, #18
3481f2cc:	e5843000 	str	r3, [r4]
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
3481f2d0:	e3003101 	movw	r3, #257	; 0x101
3481f2d4:	e3570005 	cmp	r7, #5
3481f2d8:	815b0003 	cmphi	fp, r3
3481f2dc:	9a000011 	bls	3481f328 <inflate+0xdfc>
                RESTORE();
3481f2e0:	e59d2020 	ldr	r2, [sp, #32]
3481f2e4:	e58ab010 	str	fp, [sl, #16]
3481f2e8:	e58a9000 	str	r9, [sl]
3481f2ec:	e58a7004 	str	r7, [sl, #4]
3481f2f0:	e58a200c 	str	r2, [sl, #12]
                inflate_fast(strm, out);
3481f2f4:	e1a0000a 	mov	r0, sl
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
                RESTORE();
3481f2f8:	e5846038 	str	r6, [r4, #56]	; 0x38
3481f2fc:	e584503c 	str	r5, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
3481f300:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481f304:	ebfff895 	bl	3481d560 <inflate_fast>
                LOAD();
3481f308:	e59a300c 	ldr	r3, [sl, #12]
3481f30c:	e59ab010 	ldr	fp, [sl, #16]
3481f310:	e58d3020 	str	r3, [sp, #32]
3481f314:	e59a9000 	ldr	r9, [sl]
3481f318:	e59a7004 	ldr	r7, [sl, #4]
3481f31c:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481f320:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
                break;
3481f324:	eafffc9f 	b	3481e5a8 <inflate+0x7c>
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481f328:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481f32c:	e3a00001 	mov	r0, #1
3481f330:	e1a03310 	lsl	r3, r0, r3
3481f334:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481f338:	e2433001 	sub	r3, r3, #1
3481f33c:	e58dc00c 	str	ip, [sp, #12]
3481f340:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f344:	e1a00009 	mov	r0, r9
3481f348:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481f34c:	e1a09000 	mov	r9, r0
3481f350:	e0063001 	and	r3, r6, r1
3481f354:	e08c1103 	add	r1, ip, r3, lsl #2
3481f358:	e5d12001 	ldrb	r2, [r1, #1]
3481f35c:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f360:	e1520005 	cmp	r2, r5
                inflate_fast(strm, out);
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481f364:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481f368:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f36c:	e1a01002 	mov	r1, r2
3481f370:	9a000006 	bls	3481f390 <inflate+0xe64>
                PULLBYTE();
3481f374:	e3570000 	cmp	r7, #0
3481f378:	0a00016b 	beq	3481f92c <inflate+0x1400>
3481f37c:	e4d03001 	ldrb	r3, [r0], #1
3481f380:	e2477001 	sub	r7, r7, #1
3481f384:	e0866513 	add	r6, r6, r3, lsl r5
3481f388:	e2855008 	add	r5, r5, #8
            }
3481f38c:	eaffffed 	b	3481f348 <inflate+0xe1c>
3481f390:	e58dc00c 	str	ip, [sp, #12]
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f394:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481f398:	e3530000 	cmp	r3, #0
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f39c:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481f3a0:	0a000020 	beq	3481f428 <inflate+0xefc>
3481f3a4:	e31300f0 	tst	r3, #240	; 0xf0
3481f3a8:	1a00001e 	bne	3481f428 <inflate+0xefc>
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481f3ac:	e0823003 	add	r3, r2, r3
3481f3b0:	e3a02001 	mov	r2, #1
3481f3b4:	e1a03312 	lsl	r3, r2, r3
3481f3b8:	e59dc00c 	ldr	ip, [sp, #12]
3481f3bc:	e2433001 	sub	r3, r3, #1
3481f3c0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3481f3c4:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f3c8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f3cc:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481f3d0:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f3d4:	e0823133 	add	r3, r2, r3, lsr r1
3481f3d8:	e08c0103 	add	r0, ip, r3, lsl #2
3481f3dc:	e5d02001 	ldrb	r2, [r0, #1]
3481f3e0:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481f3e4:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f3e8:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f3ec:	e0810002 	add	r0, r1, r2
3481f3f0:	e1500005 	cmp	r0, r5
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f3f4:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f3f8:	9a000008 	bls	3481f420 <inflate+0xef4>
                    PULLBYTE();
3481f3fc:	e3570000 	cmp	r7, #0
3481f400:	0a000149 	beq	3481f92c <inflate+0x1400>
3481f404:	e1a00009 	mov	r0, r9
3481f408:	e4d03001 	ldrb	r3, [r0], #1
3481f40c:	e2477001 	sub	r7, r7, #1
3481f410:	e0866513 	add	r6, r6, r3, lsl r5
3481f414:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f418:	e2855008 	add	r5, r5, #8
                }
3481f41c:	eaffffe9 	b	3481f3c8 <inflate+0xe9c>
                DROPBITS(last.bits);
3481f420:	e1a06136 	lsr	r6, r6, r1
3481f424:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
3481f428:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            if ((int)(this.op) == 0) {
3481f42c:	e3530000 	cmp	r3, #0
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481f430:	e1a06236 	lsr	r6, r6, r2
3481f434:	e0625005 	rsb	r5, r2, r5
            state->length = (unsigned)this.val;
3481f438:	e5841040 	str	r1, [r4, #64]	; 0x40
            if ((int)(this.op) == 0) {
                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
3481f43c:	02833017 	addeq	r3, r3, #23
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
            if ((int)(this.op) == 0) {
3481f440:	0a00012b 	beq	3481f8f4 <inflate+0x13c8>
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
                break;
            }
            if (this.op & 32) {
3481f444:	e3130020 	tst	r3, #32
3481f448:	0a000001 	beq	3481f454 <inflate+0xf28>
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
3481f44c:	e3a0300b 	mov	r3, #11
3481f450:	ea000127 	b	3481f8f4 <inflate+0x13c8>
                break;
            }
            if (this.op & 64) {
3481f454:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
3481f458:	159f31ec 	ldrne	r3, [pc, #492]	; 3481f64c <inflate+0x1120>
            if (this.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }
            if (this.op & 64) {
3481f45c:	1a000122 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(this.op) & 15;
3481f460:	e203300f 	and	r3, r3, #15
3481f464:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
3481f468:	e3a03013 	mov	r3, #19
3481f46c:	e5843000 	str	r3, [r4]
        case LENEXT:
            if (state->extra) {
3481f470:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481f474:	e3530000 	cmp	r3, #0
3481f478:	11a02009 	movne	r2, r9
3481f47c:	1a000006 	bne	3481f49c <inflate+0xf70>
3481f480:	ea000011 	b	3481f4cc <inflate+0xfa0>
                NEEDBITS(state->extra);
3481f484:	e3570000 	cmp	r7, #0
3481f488:	0a000127 	beq	3481f92c <inflate+0x1400>
3481f48c:	e4d21001 	ldrb	r1, [r2], #1
3481f490:	e2477001 	sub	r7, r7, #1
3481f494:	e0866511 	add	r6, r6, r1, lsl r5
3481f498:	e2855008 	add	r5, r5, #8
3481f49c:	e1550003 	cmp	r5, r3
3481f4a0:	e1a09002 	mov	r9, r2
3481f4a4:	3afffff6 	bcc	3481f484 <inflate+0xf58>
                state->length += BITS(state->extra);
3481f4a8:	e3a0c001 	mov	ip, #1
3481f4ac:	e1a0231c 	lsl	r2, ip, r3
3481f4b0:	e2422001 	sub	r2, r2, #1
3481f4b4:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481f4b8:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481f4bc:	e5941040 	ldr	r1, [r4, #64]	; 0x40
                DROPBITS(state->extra);
3481f4c0:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481f4c4:	e0812002 	add	r2, r1, r2
3481f4c8:	e5842040 	str	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
3481f4cc:	e3a03014 	mov	r3, #20
3481f4d0:	e5843000 	str	r3, [r4]
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481f4d4:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481f4d8:	e3a01001 	mov	r1, #1
3481f4dc:	e1a03311 	lsl	r3, r1, r3
3481f4e0:	e5940050 	ldr	r0, [r4, #80]	; 0x50
3481f4e4:	e2433001 	sub	r3, r3, #1
3481f4e8:	e58d000c 	str	r0, [sp, #12]
3481f4ec:	e59dc00c 	ldr	ip, [sp, #12]
3481f4f0:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f4f4:	e1a00009 	mov	r0, r9
3481f4f8:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3481f4fc:	e1a09000 	mov	r9, r0
3481f500:	e0063002 	and	r3, r6, r2
3481f504:	e08c1103 	add	r1, ip, r3, lsl #2
3481f508:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481f50c:	e5d13001 	ldrb	r3, [r1, #1]
3481f510:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f514:	e1530005 	cmp	r3, r5
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481f518:	e58d1024 	str	r1, [sp, #36]	; 0x24
                if ((unsigned)(this.bits) <= bits) break;
3481f51c:	e1a01003 	mov	r1, r3
3481f520:	9a000006 	bls	3481f540 <inflate+0x1014>
                PULLBYTE();
3481f524:	e3570000 	cmp	r7, #0
3481f528:	0a0000ff 	beq	3481f92c <inflate+0x1400>
3481f52c:	e4d03001 	ldrb	r3, [r0], #1
3481f530:	e2477001 	sub	r7, r7, #1
3481f534:	e0866513 	add	r6, r6, r3, lsl r5
3481f538:	e2855008 	add	r5, r5, #8
            }
3481f53c:	eaffffed 	b	3481f4f8 <inflate+0xfcc>
3481f540:	e58dc00c 	str	ip, [sp, #12]
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f544:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481f548:	e31200f0 	tst	r2, #240	; 0xf0
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f54c:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481f550:	1a00001e 	bne	3481f5d0 <inflate+0x10a4>
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481f554:	e0832002 	add	r2, r3, r2
3481f558:	e3a03001 	mov	r3, #1
3481f55c:	e1a02213 	lsl	r2, r3, r2
3481f560:	e59dc00c 	ldr	ip, [sp, #12]
3481f564:	e2422001 	sub	r2, r2, #1
3481f568:	e58d2030 	str	r2, [sp, #48]	; 0x30
3481f56c:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f570:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f574:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481f578:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f57c:	e0823133 	add	r3, r2, r3, lsr r1
3481f580:	e08c0103 	add	r0, ip, r3, lsl #2
3481f584:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481f588:	e5d03001 	ldrb	r3, [r0, #1]
3481f58c:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481f590:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f594:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f598:	e0810003 	add	r0, r1, r3
3481f59c:	e1500005 	cmp	r0, r5
3481f5a0:	9a000008 	bls	3481f5c8 <inflate+0x109c>
                    PULLBYTE();
3481f5a4:	e3570000 	cmp	r7, #0
3481f5a8:	0a0000df 	beq	3481f92c <inflate+0x1400>
3481f5ac:	e1a00009 	mov	r0, r9
3481f5b0:	e4d03001 	ldrb	r3, [r0], #1
3481f5b4:	e2477001 	sub	r7, r7, #1
3481f5b8:	e0866513 	add	r6, r6, r3, lsl r5
3481f5bc:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f5c0:	e2855008 	add	r5, r5, #8
                }
3481f5c4:	eaffffe9 	b	3481f570 <inflate+0x1044>
                DROPBITS(last.bits);
3481f5c8:	e1a06136 	lsr	r6, r6, r1
3481f5cc:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481f5d0:	e3120040 	tst	r2, #64	; 0x40
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481f5d4:	e1a06336 	lsr	r6, r6, r3
3481f5d8:	e0635005 	rsb	r5, r3, r5
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
3481f5dc:	159f306c 	ldrne	r3, [pc, #108]	; 3481f650 <inflate+0x1124>
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481f5e0:	1a0000c1 	bne	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481f5e4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            state->extra = (unsigned)(this.op) & 15;
3481f5e8:	e202200f 	and	r2, r2, #15
            state->mode = DISTEXT;
3481f5ec:	e3a03015 	mov	r3, #21
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481f5f0:	e5841044 	str	r1, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
3481f5f4:	e5842048 	str	r2, [r4, #72]	; 0x48
            state->mode = DISTEXT;
3481f5f8:	e5843000 	str	r3, [r4]
        case DISTEXT:
            if (state->extra) {
3481f5fc:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481f600:	e3530000 	cmp	r3, #0
3481f604:	11a02009 	movne	r2, r9
3481f608:	1a00001a 	bne	3481f678 <inflate+0x114c>
3481f60c:	ea000025 	b	3481f6a8 <inflate+0x117c>
3481f610:	34828045 	.word	0x34828045
3481f614:	34828077 	.word	0x34828077
3481f618:	3482805c 	.word	0x3482805c
3481f61c:	3482808b 	.word	0x3482808b
3481f620:	348280a4 	.word	0x348280a4
3481f624:	34821f24 	.word	0x34821f24
3481f628:	34822724 	.word	0x34822724
3481f62c:	348280b8 	.word	0x348280b8
3481f630:	348280cb 	.word	0x348280cb
3481f634:	348280e8 	.word	0x348280e8
3481f638:	34821e24 	.word	0x34821e24
3481f63c:	3482810c 	.word	0x3482810c
3481f640:	34828125 	.word	0x34828125
3481f644:	3482813f 	.word	0x3482813f
3481f648:	3482815b 	.word	0x3482815b
3481f64c:	34828029 	.word	0x34828029
3481f650:	34828013 	.word	0x34828013
3481f654:	34827ff5 	.word	0x34827ff5
3481f658:	34828171 	.word	0x34828171
3481f65c:	34828186 	.word	0x34828186
                NEEDBITS(state->extra);
3481f660:	e3570000 	cmp	r7, #0
3481f664:	0a0000b0 	beq	3481f92c <inflate+0x1400>
3481f668:	e4d21001 	ldrb	r1, [r2], #1
3481f66c:	e2477001 	sub	r7, r7, #1
3481f670:	e0866511 	add	r6, r6, r1, lsl r5
3481f674:	e2855008 	add	r5, r5, #8
3481f678:	e1550003 	cmp	r5, r3
3481f67c:	e1a09002 	mov	r9, r2
3481f680:	3afffff6 	bcc	3481f660 <inflate+0x1134>
                state->offset += BITS(state->extra);
3481f684:	e3a0c001 	mov	ip, #1
3481f688:	e1a0231c 	lsl	r2, ip, r3
3481f68c:	e2422001 	sub	r2, r2, #1
3481f690:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481f694:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481f698:	e5941044 	ldr	r1, [r4, #68]	; 0x44
                DROPBITS(state->extra);
3481f69c:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481f6a0:	e0812002 	add	r2, r1, r2
3481f6a4:	e5842044 	str	r2, [r4, #68]	; 0x44
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481f6a8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481f6ac:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3481f6b0:	e5942044 	ldr	r2, [r4, #68]	; 0x44
3481f6b4:	e0803003 	add	r3, r0, r3
3481f6b8:	e06b3003 	rsb	r3, fp, r3
3481f6bc:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
3481f6c0:	851f3074 	ldrhi	r3, [pc, #-116]	; 3481f654 <inflate+0x1128>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481f6c4:	8a000088 	bhi	3481f8ec <inflate+0x13c0>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
3481f6c8:	e3a03016 	mov	r3, #22
3481f6cc:	e5843000 	str	r3, [r4]
        case MATCH:
            if (left == 0) goto inf_leave;
3481f6d0:	e35b0000 	cmp	fp, #0
3481f6d4:	0a000094 	beq	3481f92c <inflate+0x1400>
            copy = out - left;
3481f6d8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481f6dc:	e06b2001 	rsb	r2, fp, r1
            if (state->offset > copy) {         /* copy from window */
3481f6e0:	e5941044 	ldr	r1, [r4, #68]	; 0x44
3481f6e4:	e1510002 	cmp	r1, r2
                else
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
3481f6e8:	959d2020 	ldrls	r2, [sp, #32]
3481f6ec:	90611002 	rsbls	r1, r1, r2
                copy = state->length;
3481f6f0:	95942040 	ldrls	r2, [r4, #64]	; 0x40
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
3481f6f4:	9a00000b 	bls	3481f728 <inflate+0x11fc>
                copy = state->offset - copy;
                if (copy > state->write) {
3481f6f8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
3481f6fc:	e0622001 	rsb	r2, r2, r1
                if (copy > state->write) {
3481f700:	e1520003 	cmp	r2, r3
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481f704:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
3481f708:	80632002 	rsbhi	r2, r3, r2
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->write - copy);
3481f70c:	90621003 	rsbls	r1, r2, r3
3481f710:	e5940034 	ldr	r0, [r4, #52]	; 0x34
                if (copy > state->length) copy = state->length;
3481f714:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481f718:	80621001 	rsbhi	r1, r2, r1
                }
                else
                    from = state->window + (state->write - copy);
3481f71c:	e0801001 	add	r1, r0, r1
                if (copy > state->length) copy = state->length;
3481f720:	e1520003 	cmp	r2, r3
3481f724:	21a02003 	movcs	r2, r3
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481f728:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
3481f72c:	e152000b 	cmp	r2, fp
3481f730:	21a0200b 	movcs	r2, fp
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481f734:	e0623003 	rsb	r3, r2, r3
3481f738:	e5843040 	str	r3, [r4, #64]	; 0x40
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
3481f73c:	e062b00b 	rsb	fp, r2, fp
            state->length -= copy;
3481f740:	e3a03000 	mov	r3, #0
            do {
                *put++ = *from++;
3481f744:	e7d10003 	ldrb	r0, [r1, r3]
3481f748:	e59dc020 	ldr	ip, [sp, #32]
3481f74c:	e7cc0003 	strb	r0, [ip, r3]
3481f750:	e2833001 	add	r3, r3, #1
            } while (--copy);
3481f754:	e1520003 	cmp	r2, r3
3481f758:	1afffff9 	bne	3481f744 <inflate+0x1218>
            if (state->length == 0) state->mode = LEN;
3481f75c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481f760:	e08cc002 	add	ip, ip, r2
            if (state->length == 0) state->mode = LEN;
3481f764:	e3530000 	cmp	r3, #0
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481f768:	e58dc020 	str	ip, [sp, #32]
            if (state->length == 0) state->mode = LEN;
3481f76c:	02833012 	addeq	r3, r3, #18
3481f770:	0a00005f 	beq	3481f8f4 <inflate+0x13c8>
3481f774:	eafffb8b 	b	3481e5a8 <inflate+0x7c>
            break;
        case LIT:
            if (left == 0) goto inf_leave;
3481f778:	e35b0000 	cmp	fp, #0
3481f77c:	0a00006a 	beq	3481f92c <inflate+0x1400>
            *put++ = (unsigned char)(state->length);
3481f780:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481f784:	e59d0020 	ldr	r0, [sp, #32]
            left--;
3481f788:	e24bb001 	sub	fp, fp, #1
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
3481f78c:	e4c03001 	strb	r3, [r0], #1
3481f790:	e58d0020 	str	r0, [sp, #32]
            left--;
            state->mode = LEN;
3481f794:	e3a03012 	mov	r3, #18
3481f798:	ea000055 	b	3481f8f4 <inflate+0x13c8>
            break;
        case CHECK:
            if (state->wrap) {
3481f79c:	e5943008 	ldr	r3, [r4, #8]
3481f7a0:	e3530000 	cmp	r3, #0
3481f7a4:	11a03009 	movne	r3, r9
3481f7a8:	1a000006 	bne	3481f7c8 <inflate+0x129c>
3481f7ac:	ea000037 	b	3481f890 <inflate+0x1364>
                NEEDBITS(32);
3481f7b0:	e3570000 	cmp	r7, #0
3481f7b4:	0a00005c 	beq	3481f92c <inflate+0x1400>
3481f7b8:	e4d32001 	ldrb	r2, [r3], #1
3481f7bc:	e2477001 	sub	r7, r7, #1
3481f7c0:	e0866512 	add	r6, r6, r2, lsl r5
3481f7c4:	e2855008 	add	r5, r5, #8
3481f7c8:	e355001f 	cmp	r5, #31
3481f7cc:	e1a09003 	mov	r9, r3
3481f7d0:	9afffff6 	bls	3481f7b0 <inflate+0x1284>
                out -= left;
3481f7d4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
                strm->total_out += out;
3481f7d8:	e59a3014 	ldr	r3, [sl, #20]
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
3481f7dc:	e06b2001 	rsb	r2, fp, r1
                strm->total_out += out;
3481f7e0:	e0833002 	add	r3, r3, r2
3481f7e4:	e58a3014 	str	r3, [sl, #20]
                state->total += out;
3481f7e8:	e594301c 	ldr	r3, [r4, #28]
                if (out)
3481f7ec:	e3520000 	cmp	r2, #0
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
3481f7f0:	e0833002 	add	r3, r3, r2
3481f7f4:	e584301c 	str	r3, [r4, #28]
                if (out)
3481f7f8:	0a00000e 	beq	3481f838 <inflate+0x130c>
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
3481f7fc:	e5943010 	ldr	r3, [r4, #16]
3481f800:	e2621000 	rsb	r1, r2, #0
3481f804:	e3530000 	cmp	r3, #0
3481f808:	0a000004 	beq	3481f820 <inflate+0x12f4>
3481f80c:	e59d3020 	ldr	r3, [sp, #32]
3481f810:	e5940018 	ldr	r0, [r4, #24]
3481f814:	e0831001 	add	r1, r3, r1
3481f818:	ebffec20 	bl	3481a8a0 <crc32>
3481f81c:	ea000003 	b	3481f830 <inflate+0x1304>
3481f820:	e59dc020 	ldr	ip, [sp, #32]
3481f824:	e5940018 	ldr	r0, [r4, #24]
3481f828:	e08c1001 	add	r1, ip, r1
3481f82c:	ebfffa84 	bl	3481e244 <adler32>
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
3481f830:	e5840018 	str	r0, [r4, #24]
3481f834:	e58a0034 	str	r0, [sl, #52]	; 0x34
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481f838:	e5943010 	ldr	r3, [r4, #16]
3481f83c:	e3530000 	cmp	r3, #0
#endif
                     REVERSE(hold)) != state->check) {
3481f840:	01a02426 	lsreq	r2, r6, #8
3481f844:	01a01c26 	lsreq	r1, r6, #24
3481f848:	02022cff 	andeq	r2, r2, #65280	; 0xff00
3481f84c:	00811c06 	addeq	r1, r1, r6, lsl #24
3481f850:	02063cff 	andeq	r3, r6, #65280	; 0xff00
3481f854:	00812002 	addeq	r2, r1, r2
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481f858:	00823403 	addeq	r3, r2, r3, lsl #8
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f85c:	e5942018 	ldr	r2, [r4, #24]
#ifdef GUNZIP
                     state->flags ? hold :
3481f860:	11a03006 	movne	r3, r6
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f864:	e1530002 	cmp	r3, r2
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481f868:	03a05000 	moveq	r5, #0
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f86c:	058db02c 	streq	fp, [sp, #44]	; 0x2c
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481f870:	01a06005 	moveq	r6, r5
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f874:	0a000005 	beq	3481f890 <inflate+0x1364>
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481f878:	e51f3228 	ldr	r3, [pc, #-552]	; 3481f658 <inflate+0x112c>
                    state->mode = BAD;
                    break;
3481f87c:	e58db02c 	str	fp, [sp, #44]	; 0x2c
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481f880:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481f884:	e3a0301b 	mov	r3, #27
3481f888:	e5843000 	str	r3, [r4]
                    break;
3481f88c:	eafffb45 	b	3481e5a8 <inflate+0x7c>
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
3481f890:	e3a03019 	mov	r3, #25
3481f894:	e5843000 	str	r3, [r4]
        case LENGTH:
            if (state->wrap && state->flags) {
3481f898:	e5943008 	ldr	r3, [r4, #8]
3481f89c:	e3530000 	cmp	r3, #0
3481f8a0:	0a000017 	beq	3481f904 <inflate+0x13d8>
3481f8a4:	e5943010 	ldr	r3, [r4, #16]
3481f8a8:	e3530000 	cmp	r3, #0
3481f8ac:	0a000014 	beq	3481f904 <inflate+0x13d8>
3481f8b0:	e1a03009 	mov	r3, r9
3481f8b4:	ea000005 	b	3481f8d0 <inflate+0x13a4>
                NEEDBITS(32);
3481f8b8:	e3570000 	cmp	r7, #0
3481f8bc:	0a00001a 	beq	3481f92c <inflate+0x1400>
3481f8c0:	e4d32001 	ldrb	r2, [r3], #1
3481f8c4:	e2477001 	sub	r7, r7, #1
3481f8c8:	e0866512 	add	r6, r6, r2, lsl r5
3481f8cc:	e2855008 	add	r5, r5, #8
3481f8d0:	e355001f 	cmp	r5, #31
3481f8d4:	e1a09003 	mov	r9, r3
3481f8d8:	9afffff6 	bls	3481f8b8 <inflate+0x138c>
                if (hold != (state->total & 0xffffffffUL)) {
3481f8dc:	e594301c 	ldr	r3, [r4, #28]
3481f8e0:	e1560003 	cmp	r6, r3
3481f8e4:	0a000004 	beq	3481f8fc <inflate+0x13d0>
                    strm->msg = (char *)"incorrect length check";
3481f8e8:	e51f3294 	ldr	r3, [pc, #-660]	; 3481f65c <inflate+0x1130>
3481f8ec:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481f8f0:	e3a0301b 	mov	r3, #27
3481f8f4:	e5843000 	str	r3, [r4]
3481f8f8:	eafffb2a 	b	3481e5a8 <inflate+0x7c>
                    break;
                }
                INITBITS();
3481f8fc:	e3a05000 	mov	r5, #0
3481f900:	e1a06005 	mov	r6, r5
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481f904:	e3a0301a 	mov	r3, #26
        case DONE:
            ret = Z_STREAM_END;
3481f908:	e3a00001 	mov	r0, #1
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481f90c:	e5843000 	str	r3, [r4]
        case DONE:
            ret = Z_STREAM_END;
3481f910:	e58d001c 	str	r0, [sp, #28]
3481f914:	ea000004 	b	3481f92c <inflate+0x1400>
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
3481f918:	e3e01002 	mvn	r1, #2
3481f91c:	e58d101c 	str	r1, [sp, #28]
3481f920:	ea000001 	b	3481f92c <inflate+0x1400>
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
3481f924:	e3a02001 	mov	r2, #1
3481f928:	e58d201c 	str	r2, [sp, #28]
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f92c:	e59d3020 	ldr	r3, [sp, #32]
3481f930:	e58ab010 	str	fp, [sl, #16]
3481f934:	e58a300c 	str	r3, [sl, #12]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f938:	e5943028 	ldr	r3, [r4, #40]	; 0x28
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f93c:	e58a9000 	str	r9, [sl]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f940:	e3530000 	cmp	r3, #0
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f944:	e58a7004 	str	r7, [sl, #4]
3481f948:	e5846038 	str	r6, [r4, #56]	; 0x38
3481f94c:	e584503c 	str	r5, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f950:	1a000005 	bne	3481f96c <inflate+0x1440>
3481f954:	e5943000 	ldr	r3, [r4]
3481f958:	e3530017 	cmp	r3, #23
3481f95c:	8a000048 	bhi	3481fa84 <inflate+0x1558>
3481f960:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481f964:	e15c000b 	cmp	ip, fp
3481f968:	0a000045 	beq	3481fa84 <inflate+0x1558>
unsigned out;
{
    struct inflate_state FAR *state;
    unsigned copy, dist;

    state = (struct inflate_state FAR *)strm->state;
3481f96c:	e59a501c 	ldr	r5, [sl, #28]

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
3481f970:	e5953034 	ldr	r3, [r5, #52]	; 0x34
3481f974:	e3530000 	cmp	r3, #0
3481f978:	1a000008 	bne	3481f9a0 <inflate+0x1474>
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
3481f97c:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481f980:	e3a02001 	mov	r2, #1
3481f984:	e59a3020 	ldr	r3, [sl, #32]
3481f988:	e59a0028 	ldr	r0, [sl, #40]	; 0x28
3481f98c:	e1a01112 	lsl	r1, r2, r1
3481f990:	e12fff33 	blx	r3
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481f994:	e3500000 	cmp	r0, #0

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
3481f998:	e5850034 	str	r0, [r5, #52]	; 0x34
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481f99c:	0a000034 	beq	3481fa74 <inflate+0x1548>
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
3481f9a0:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481f9a4:	e3530000 	cmp	r3, #0
3481f9a8:	1a000005 	bne	3481f9c4 <inflate+0x1498>
        state->wsize = 1U << state->wbits;
3481f9ac:	e5952024 	ldr	r2, [r5, #36]	; 0x24
3481f9b0:	e3a01001 	mov	r1, #1
3481f9b4:	e1a02211 	lsl	r2, r1, r2
        state->write = 0;
3481f9b8:	e5853030 	str	r3, [r5, #48]	; 0x30
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
3481f9bc:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
3481f9c0:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481f9c4:	e59a6010 	ldr	r6, [sl, #16]
3481f9c8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    if (copy >= state->wsize) {
3481f9cc:	e5952028 	ldr	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481f9d0:	e0666000 	rsb	r6, r6, r0
    if (copy >= state->wsize) {
3481f9d4:	e1560002 	cmp	r6, r2
3481f9d8:	e59a100c 	ldr	r1, [sl, #12]
3481f9dc:	3a000005 	bcc	3481f9f8 <inflate+0x14cc>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
3481f9e0:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481f9e4:	e0621001 	rsb	r1, r2, r1
3481f9e8:	ebfff32e 	bl	3481c6a8 <memcpy>
        state->write = 0;
3481f9ec:	e3a03000 	mov	r3, #0
3481f9f0:	e5853030 	str	r3, [r5, #48]	; 0x30
3481f9f4:	ea000010 	b	3481fa3c <inflate+0x1510>
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481f9f8:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481f9fc:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
        state->write = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481fa00:	e0637002 	rsb	r7, r3, r2
3481fa04:	e1560007 	cmp	r6, r7
3481fa08:	31a07006 	movcc	r7, r6
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481fa0c:	e0661001 	rsb	r1, r6, r1
3481fa10:	e0800003 	add	r0, r0, r3
3481fa14:	e1a02007 	mov	r2, r7
3481fa18:	ebfff322 	bl	3481c6a8 <memcpy>
        copy -= dist;
        if (copy) {
3481fa1c:	e0566007 	subs	r6, r6, r7
3481fa20:	0a000008 	beq	3481fa48 <inflate+0x151c>
            zmemcpy(state->window, strm->next_out - copy, copy);
3481fa24:	e59a100c 	ldr	r1, [sl, #12]
3481fa28:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481fa2c:	e0661001 	rsb	r1, r6, r1
3481fa30:	e1a02006 	mov	r2, r6
3481fa34:	ebfff31b 	bl	3481c6a8 <memcpy>
            state->write = copy;
3481fa38:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
3481fa3c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481fa40:	e585302c 	str	r3, [r5, #44]	; 0x2c
3481fa44:	ea00000e 	b	3481fa84 <inflate+0x1558>
        }
        else {
            state->write += dist;
3481fa48:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
3481fa4c:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481fa50:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
3481fa54:	e1530002 	cmp	r3, r2
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481fa58:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
            if (state->whave < state->wsize) state->whave += dist;
3481fa5c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
            if (state->write == state->wsize) state->write = 0;
3481fa60:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481fa64:	e1530002 	cmp	r3, r2
3481fa68:	30877003 	addcc	r7, r7, r3
3481fa6c:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
3481fa70:	ea000003 	b	3481fa84 <inflate+0x1558>
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
3481fa74:	e3a0301c 	mov	r3, #28
3481fa78:	e5843000 	str	r3, [r4]
            return Z_MEM_ERROR;
3481fa7c:	e3e01003 	mvn	r1, #3
3481fa80:	ea00003b 	b	3481fb74 <inflate+0x1648>
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
3481fa84:	e59a6010 	ldr	r6, [sl, #16]
3481fa88:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481fa8c:	e59a5004 	ldr	r5, [sl, #4]
3481fa90:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    out -= strm->avail_out;
3481fa94:	e0666003 	rsb	r6, r6, r3
    strm->total_in += in;
3481fa98:	e59a3008 	ldr	r3, [sl, #8]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481fa9c:	e0655002 	rsb	r5, r5, r2
    out -= strm->avail_out;
    strm->total_in += in;
3481faa0:	e0833005 	add	r3, r3, r5
3481faa4:	e58a3008 	str	r3, [sl, #8]
    strm->total_out += out;
3481faa8:	e59a3014 	ldr	r3, [sl, #20]
3481faac:	e0833006 	add	r3, r3, r6
3481fab0:	e58a3014 	str	r3, [sl, #20]
    state->total += out;
3481fab4:	e594301c 	ldr	r3, [r4, #28]
3481fab8:	e0833006 	add	r3, r3, r6
3481fabc:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
3481fac0:	e5943008 	ldr	r3, [r4, #8]
3481fac4:	e3560000 	cmp	r6, #0
3481fac8:	13530000 	cmpne	r3, #0
3481facc:	0a00000f 	beq	3481fb10 <inflate+0x15e4>
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
3481fad0:	e5943010 	ldr	r3, [r4, #16]
3481fad4:	e59a100c 	ldr	r1, [sl, #12]
3481fad8:	e3530000 	cmp	r3, #0
3481fadc:	e2663000 	rsb	r3, r6, #0
3481fae0:	0a000004 	beq	3481faf8 <inflate+0x15cc>
3481fae4:	e5940018 	ldr	r0, [r4, #24]
3481fae8:	e0811003 	add	r1, r1, r3
3481faec:	e1a02006 	mov	r2, r6
3481faf0:	ebffeb6a 	bl	3481a8a0 <crc32>
3481faf4:	ea000003 	b	3481fb08 <inflate+0x15dc>
3481faf8:	e5940018 	ldr	r0, [r4, #24]
3481fafc:	e0811003 	add	r1, r1, r3
3481fb00:	e1a02006 	mov	r2, r6
3481fb04:	ebfff9ce 	bl	3481e244 <adler32>
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
3481fb08:	e5840018 	str	r0, [r4, #24]
3481fb0c:	e58a0034 	str	r0, [sl, #52]	; 0x34
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fb10:	e5943004 	ldr	r3, [r4, #4]
3481fb14:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
3481fb18:	e3530000 	cmp	r3, #0
3481fb1c:	13a03040 	movne	r3, #64	; 0x40
3481fb20:	03a03000 	moveq	r3, #0
3481fb24:	e0833002 	add	r3, r3, r2
3481fb28:	e5942000 	ldr	r2, [r4]
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fb2c:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fb30:	e352000b 	cmp	r2, #11
3481fb34:	03a02080 	moveq	r2, #128	; 0x80
3481fb38:	13a02000 	movne	r2, #0
3481fb3c:	e0833002 	add	r3, r3, r2
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fb40:	e1966005 	orrs	r6, r6, r5
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fb44:	e58a302c 	str	r3, [sl, #44]	; 0x2c
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fb48:	13a03000 	movne	r3, #0
3481fb4c:	03a03001 	moveq	r3, #1
3481fb50:	e35c0004 	cmp	ip, #4
3481fb54:	03833001 	orreq	r3, r3, #1
3481fb58:	e3530000 	cmp	r3, #0
3481fb5c:	0a00000d 	beq	3481fb98 <inflate+0x166c>
        ret = Z_BUF_ERROR;
3481fb60:	e59d001c 	ldr	r0, [sp, #28]
3481fb64:	e3500000 	cmp	r0, #0
3481fb68:	03e00004 	mvneq	r0, #4
3481fb6c:	e58d001c 	str	r0, [sp, #28]
3481fb70:	ea000008 	b	3481fb98 <inflate+0x166c>
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481fb74:	e58d101c 	str	r1, [sp, #28]
3481fb78:	ea000006 	b	3481fb98 <inflate+0x166c>
3481fb7c:	e3e02001 	mvn	r2, #1
3481fb80:	e58d201c 	str	r2, [sp, #28]
3481fb84:	ea000003 	b	3481fb98 <inflate+0x166c>
3481fb88:	e58d301c 	str	r3, [sp, #28]
3481fb8c:	ea000001 	b	3481fb98 <inflate+0x166c>
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
3481fb90:	e3e0c001 	mvn	ip, #1
3481fb94:	e58dc01c 	str	ip, [sp, #28]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
3481fb98:	e59d001c 	ldr	r0, [sp, #28]
3481fb9c:	e28dd048 	add	sp, sp, #72	; 0x48
3481fba0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481fba4 <raise>:
 */

#include <common.h>

int raise (int signum)
{
3481fba4:	e1a01000 	mov	r1, r0
3481fba8:	e92d4008 	push	{r3, lr}
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
3481fbac:	e59f0008 	ldr	r0, [pc, #8]	; 3481fbbc <raise+0x18>
3481fbb0:	ebffa7c4 	bl	34809ac8 <printf>
#endif
	return 0;
}
3481fbb4:	e3a00000 	mov	r0, #0
3481fbb8:	e8bd8008 	pop	{r3, pc}
3481fbbc:	34828211 	.word	0x34828211

3481fbc0 <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
};
3481fbc0:	e12fff1e 	bx	lr

3481fbc4 <__aeabi_unwind_cpp_pr1>:

void __aeabi_unwind_cpp_pr1(void)
{
};
3481fbc4:	e12fff1e 	bx	lr

3481fbc8 <__udivsi3>:
3481fbc8:	e2512001 	subs	r2, r1, #1
3481fbcc:	012fff1e 	bxeq	lr
3481fbd0:	3a000074 	bcc	3481fda8 <__udivsi3+0x1e0>
3481fbd4:	e1500001 	cmp	r0, r1
3481fbd8:	9a00006b 	bls	3481fd8c <__udivsi3+0x1c4>
3481fbdc:	e1110002 	tst	r1, r2
3481fbe0:	0a00006c 	beq	3481fd98 <__udivsi3+0x1d0>
3481fbe4:	e16f3f10 	clz	r3, r0
3481fbe8:	e16f2f11 	clz	r2, r1
3481fbec:	e0423003 	sub	r3, r2, r3
3481fbf0:	e273301f 	rsbs	r3, r3, #31
3481fbf4:	10833083 	addne	r3, r3, r3, lsl #1
3481fbf8:	e3a02000 	mov	r2, #0
3481fbfc:	108ff103 	addne	pc, pc, r3, lsl #2
3481fc00:	e320f000 	nop	{0}
3481fc04:	e1500f81 	cmp	r0, r1, lsl #31
3481fc08:	e0a22002 	adc	r2, r2, r2
3481fc0c:	20400f81 	subcs	r0, r0, r1, lsl #31
3481fc10:	e1500f01 	cmp	r0, r1, lsl #30
3481fc14:	e0a22002 	adc	r2, r2, r2
3481fc18:	20400f01 	subcs	r0, r0, r1, lsl #30
3481fc1c:	e1500e81 	cmp	r0, r1, lsl #29
3481fc20:	e0a22002 	adc	r2, r2, r2
3481fc24:	20400e81 	subcs	r0, r0, r1, lsl #29
3481fc28:	e1500e01 	cmp	r0, r1, lsl #28
3481fc2c:	e0a22002 	adc	r2, r2, r2
3481fc30:	20400e01 	subcs	r0, r0, r1, lsl #28
3481fc34:	e1500d81 	cmp	r0, r1, lsl #27
3481fc38:	e0a22002 	adc	r2, r2, r2
3481fc3c:	20400d81 	subcs	r0, r0, r1, lsl #27
3481fc40:	e1500d01 	cmp	r0, r1, lsl #26
3481fc44:	e0a22002 	adc	r2, r2, r2
3481fc48:	20400d01 	subcs	r0, r0, r1, lsl #26
3481fc4c:	e1500c81 	cmp	r0, r1, lsl #25
3481fc50:	e0a22002 	adc	r2, r2, r2
3481fc54:	20400c81 	subcs	r0, r0, r1, lsl #25
3481fc58:	e1500c01 	cmp	r0, r1, lsl #24
3481fc5c:	e0a22002 	adc	r2, r2, r2
3481fc60:	20400c01 	subcs	r0, r0, r1, lsl #24
3481fc64:	e1500b81 	cmp	r0, r1, lsl #23
3481fc68:	e0a22002 	adc	r2, r2, r2
3481fc6c:	20400b81 	subcs	r0, r0, r1, lsl #23
3481fc70:	e1500b01 	cmp	r0, r1, lsl #22
3481fc74:	e0a22002 	adc	r2, r2, r2
3481fc78:	20400b01 	subcs	r0, r0, r1, lsl #22
3481fc7c:	e1500a81 	cmp	r0, r1, lsl #21
3481fc80:	e0a22002 	adc	r2, r2, r2
3481fc84:	20400a81 	subcs	r0, r0, r1, lsl #21
3481fc88:	e1500a01 	cmp	r0, r1, lsl #20
3481fc8c:	e0a22002 	adc	r2, r2, r2
3481fc90:	20400a01 	subcs	r0, r0, r1, lsl #20
3481fc94:	e1500981 	cmp	r0, r1, lsl #19
3481fc98:	e0a22002 	adc	r2, r2, r2
3481fc9c:	20400981 	subcs	r0, r0, r1, lsl #19
3481fca0:	e1500901 	cmp	r0, r1, lsl #18
3481fca4:	e0a22002 	adc	r2, r2, r2
3481fca8:	20400901 	subcs	r0, r0, r1, lsl #18
3481fcac:	e1500881 	cmp	r0, r1, lsl #17
3481fcb0:	e0a22002 	adc	r2, r2, r2
3481fcb4:	20400881 	subcs	r0, r0, r1, lsl #17
3481fcb8:	e1500801 	cmp	r0, r1, lsl #16
3481fcbc:	e0a22002 	adc	r2, r2, r2
3481fcc0:	20400801 	subcs	r0, r0, r1, lsl #16
3481fcc4:	e1500781 	cmp	r0, r1, lsl #15
3481fcc8:	e0a22002 	adc	r2, r2, r2
3481fccc:	20400781 	subcs	r0, r0, r1, lsl #15
3481fcd0:	e1500701 	cmp	r0, r1, lsl #14
3481fcd4:	e0a22002 	adc	r2, r2, r2
3481fcd8:	20400701 	subcs	r0, r0, r1, lsl #14
3481fcdc:	e1500681 	cmp	r0, r1, lsl #13
3481fce0:	e0a22002 	adc	r2, r2, r2
3481fce4:	20400681 	subcs	r0, r0, r1, lsl #13
3481fce8:	e1500601 	cmp	r0, r1, lsl #12
3481fcec:	e0a22002 	adc	r2, r2, r2
3481fcf0:	20400601 	subcs	r0, r0, r1, lsl #12
3481fcf4:	e1500581 	cmp	r0, r1, lsl #11
3481fcf8:	e0a22002 	adc	r2, r2, r2
3481fcfc:	20400581 	subcs	r0, r0, r1, lsl #11
3481fd00:	e1500501 	cmp	r0, r1, lsl #10
3481fd04:	e0a22002 	adc	r2, r2, r2
3481fd08:	20400501 	subcs	r0, r0, r1, lsl #10
3481fd0c:	e1500481 	cmp	r0, r1, lsl #9
3481fd10:	e0a22002 	adc	r2, r2, r2
3481fd14:	20400481 	subcs	r0, r0, r1, lsl #9
3481fd18:	e1500401 	cmp	r0, r1, lsl #8
3481fd1c:	e0a22002 	adc	r2, r2, r2
3481fd20:	20400401 	subcs	r0, r0, r1, lsl #8
3481fd24:	e1500381 	cmp	r0, r1, lsl #7
3481fd28:	e0a22002 	adc	r2, r2, r2
3481fd2c:	20400381 	subcs	r0, r0, r1, lsl #7
3481fd30:	e1500301 	cmp	r0, r1, lsl #6
3481fd34:	e0a22002 	adc	r2, r2, r2
3481fd38:	20400301 	subcs	r0, r0, r1, lsl #6
3481fd3c:	e1500281 	cmp	r0, r1, lsl #5
3481fd40:	e0a22002 	adc	r2, r2, r2
3481fd44:	20400281 	subcs	r0, r0, r1, lsl #5
3481fd48:	e1500201 	cmp	r0, r1, lsl #4
3481fd4c:	e0a22002 	adc	r2, r2, r2
3481fd50:	20400201 	subcs	r0, r0, r1, lsl #4
3481fd54:	e1500181 	cmp	r0, r1, lsl #3
3481fd58:	e0a22002 	adc	r2, r2, r2
3481fd5c:	20400181 	subcs	r0, r0, r1, lsl #3
3481fd60:	e1500101 	cmp	r0, r1, lsl #2
3481fd64:	e0a22002 	adc	r2, r2, r2
3481fd68:	20400101 	subcs	r0, r0, r1, lsl #2
3481fd6c:	e1500081 	cmp	r0, r1, lsl #1
3481fd70:	e0a22002 	adc	r2, r2, r2
3481fd74:	20400081 	subcs	r0, r0, r1, lsl #1
3481fd78:	e1500001 	cmp	r0, r1
3481fd7c:	e0a22002 	adc	r2, r2, r2
3481fd80:	20400001 	subcs	r0, r0, r1
3481fd84:	e1a00002 	mov	r0, r2
3481fd88:	e12fff1e 	bx	lr
3481fd8c:	03a00001 	moveq	r0, #1
3481fd90:	13a00000 	movne	r0, #0
3481fd94:	e12fff1e 	bx	lr
3481fd98:	e16f2f11 	clz	r2, r1
3481fd9c:	e262201f 	rsb	r2, r2, #31
3481fda0:	e1a00230 	lsr	r0, r0, r2
3481fda4:	e12fff1e 	bx	lr
3481fda8:	e3500000 	cmp	r0, #0
3481fdac:	13e00000 	mvnne	r0, #0
3481fdb0:	ea0000ac 	b	34820068 <__aeabi_ldiv0>

3481fdb4 <__aeabi_uidivmod>:
3481fdb4:	e3510000 	cmp	r1, #0
3481fdb8:	0afffffa 	beq	3481fda8 <__udivsi3+0x1e0>
3481fdbc:	e92d4003 	push	{r0, r1, lr}
3481fdc0:	ebffff80 	bl	3481fbc8 <__udivsi3>
3481fdc4:	e8bd4006 	pop	{r1, r2, lr}
3481fdc8:	e0030092 	mul	r3, r2, r0
3481fdcc:	e0411003 	sub	r1, r1, r3
3481fdd0:	e12fff1e 	bx	lr

3481fdd4 <__divsi3>:
3481fdd4:	e3510000 	cmp	r1, #0
3481fdd8:	0a000081 	beq	3481ffe4 <.divsi3_skip_div0_test+0x208>

3481fddc <.divsi3_skip_div0_test>:
3481fddc:	e020c001 	eor	ip, r0, r1
3481fde0:	42611000 	rsbmi	r1, r1, #0
3481fde4:	e2512001 	subs	r2, r1, #1
3481fde8:	0a000070 	beq	3481ffb0 <.divsi3_skip_div0_test+0x1d4>
3481fdec:	e1b03000 	movs	r3, r0
3481fdf0:	42603000 	rsbmi	r3, r0, #0
3481fdf4:	e1530001 	cmp	r3, r1
3481fdf8:	9a00006f 	bls	3481ffbc <.divsi3_skip_div0_test+0x1e0>
3481fdfc:	e1110002 	tst	r1, r2
3481fe00:	0a000071 	beq	3481ffcc <.divsi3_skip_div0_test+0x1f0>
3481fe04:	e16f2f13 	clz	r2, r3
3481fe08:	e16f0f11 	clz	r0, r1
3481fe0c:	e0402002 	sub	r2, r0, r2
3481fe10:	e272201f 	rsbs	r2, r2, #31
3481fe14:	10822082 	addne	r2, r2, r2, lsl #1
3481fe18:	e3a00000 	mov	r0, #0
3481fe1c:	108ff102 	addne	pc, pc, r2, lsl #2
3481fe20:	e320f000 	nop	{0}
3481fe24:	e1530f81 	cmp	r3, r1, lsl #31
3481fe28:	e0a00000 	adc	r0, r0, r0
3481fe2c:	20433f81 	subcs	r3, r3, r1, lsl #31
3481fe30:	e1530f01 	cmp	r3, r1, lsl #30
3481fe34:	e0a00000 	adc	r0, r0, r0
3481fe38:	20433f01 	subcs	r3, r3, r1, lsl #30
3481fe3c:	e1530e81 	cmp	r3, r1, lsl #29
3481fe40:	e0a00000 	adc	r0, r0, r0
3481fe44:	20433e81 	subcs	r3, r3, r1, lsl #29
3481fe48:	e1530e01 	cmp	r3, r1, lsl #28
3481fe4c:	e0a00000 	adc	r0, r0, r0
3481fe50:	20433e01 	subcs	r3, r3, r1, lsl #28
3481fe54:	e1530d81 	cmp	r3, r1, lsl #27
3481fe58:	e0a00000 	adc	r0, r0, r0
3481fe5c:	20433d81 	subcs	r3, r3, r1, lsl #27
3481fe60:	e1530d01 	cmp	r3, r1, lsl #26
3481fe64:	e0a00000 	adc	r0, r0, r0
3481fe68:	20433d01 	subcs	r3, r3, r1, lsl #26
3481fe6c:	e1530c81 	cmp	r3, r1, lsl #25
3481fe70:	e0a00000 	adc	r0, r0, r0
3481fe74:	20433c81 	subcs	r3, r3, r1, lsl #25
3481fe78:	e1530c01 	cmp	r3, r1, lsl #24
3481fe7c:	e0a00000 	adc	r0, r0, r0
3481fe80:	20433c01 	subcs	r3, r3, r1, lsl #24
3481fe84:	e1530b81 	cmp	r3, r1, lsl #23
3481fe88:	e0a00000 	adc	r0, r0, r0
3481fe8c:	20433b81 	subcs	r3, r3, r1, lsl #23
3481fe90:	e1530b01 	cmp	r3, r1, lsl #22
3481fe94:	e0a00000 	adc	r0, r0, r0
3481fe98:	20433b01 	subcs	r3, r3, r1, lsl #22
3481fe9c:	e1530a81 	cmp	r3, r1, lsl #21
3481fea0:	e0a00000 	adc	r0, r0, r0
3481fea4:	20433a81 	subcs	r3, r3, r1, lsl #21
3481fea8:	e1530a01 	cmp	r3, r1, lsl #20
3481feac:	e0a00000 	adc	r0, r0, r0
3481feb0:	20433a01 	subcs	r3, r3, r1, lsl #20
3481feb4:	e1530981 	cmp	r3, r1, lsl #19
3481feb8:	e0a00000 	adc	r0, r0, r0
3481febc:	20433981 	subcs	r3, r3, r1, lsl #19
3481fec0:	e1530901 	cmp	r3, r1, lsl #18
3481fec4:	e0a00000 	adc	r0, r0, r0
3481fec8:	20433901 	subcs	r3, r3, r1, lsl #18
3481fecc:	e1530881 	cmp	r3, r1, lsl #17
3481fed0:	e0a00000 	adc	r0, r0, r0
3481fed4:	20433881 	subcs	r3, r3, r1, lsl #17
3481fed8:	e1530801 	cmp	r3, r1, lsl #16
3481fedc:	e0a00000 	adc	r0, r0, r0
3481fee0:	20433801 	subcs	r3, r3, r1, lsl #16
3481fee4:	e1530781 	cmp	r3, r1, lsl #15
3481fee8:	e0a00000 	adc	r0, r0, r0
3481feec:	20433781 	subcs	r3, r3, r1, lsl #15
3481fef0:	e1530701 	cmp	r3, r1, lsl #14
3481fef4:	e0a00000 	adc	r0, r0, r0
3481fef8:	20433701 	subcs	r3, r3, r1, lsl #14
3481fefc:	e1530681 	cmp	r3, r1, lsl #13
3481ff00:	e0a00000 	adc	r0, r0, r0
3481ff04:	20433681 	subcs	r3, r3, r1, lsl #13
3481ff08:	e1530601 	cmp	r3, r1, lsl #12
3481ff0c:	e0a00000 	adc	r0, r0, r0
3481ff10:	20433601 	subcs	r3, r3, r1, lsl #12
3481ff14:	e1530581 	cmp	r3, r1, lsl #11
3481ff18:	e0a00000 	adc	r0, r0, r0
3481ff1c:	20433581 	subcs	r3, r3, r1, lsl #11
3481ff20:	e1530501 	cmp	r3, r1, lsl #10
3481ff24:	e0a00000 	adc	r0, r0, r0
3481ff28:	20433501 	subcs	r3, r3, r1, lsl #10
3481ff2c:	e1530481 	cmp	r3, r1, lsl #9
3481ff30:	e0a00000 	adc	r0, r0, r0
3481ff34:	20433481 	subcs	r3, r3, r1, lsl #9
3481ff38:	e1530401 	cmp	r3, r1, lsl #8
3481ff3c:	e0a00000 	adc	r0, r0, r0
3481ff40:	20433401 	subcs	r3, r3, r1, lsl #8
3481ff44:	e1530381 	cmp	r3, r1, lsl #7
3481ff48:	e0a00000 	adc	r0, r0, r0
3481ff4c:	20433381 	subcs	r3, r3, r1, lsl #7
3481ff50:	e1530301 	cmp	r3, r1, lsl #6
3481ff54:	e0a00000 	adc	r0, r0, r0
3481ff58:	20433301 	subcs	r3, r3, r1, lsl #6
3481ff5c:	e1530281 	cmp	r3, r1, lsl #5
3481ff60:	e0a00000 	adc	r0, r0, r0
3481ff64:	20433281 	subcs	r3, r3, r1, lsl #5
3481ff68:	e1530201 	cmp	r3, r1, lsl #4
3481ff6c:	e0a00000 	adc	r0, r0, r0
3481ff70:	20433201 	subcs	r3, r3, r1, lsl #4
3481ff74:	e1530181 	cmp	r3, r1, lsl #3
3481ff78:	e0a00000 	adc	r0, r0, r0
3481ff7c:	20433181 	subcs	r3, r3, r1, lsl #3
3481ff80:	e1530101 	cmp	r3, r1, lsl #2
3481ff84:	e0a00000 	adc	r0, r0, r0
3481ff88:	20433101 	subcs	r3, r3, r1, lsl #2
3481ff8c:	e1530081 	cmp	r3, r1, lsl #1
3481ff90:	e0a00000 	adc	r0, r0, r0
3481ff94:	20433081 	subcs	r3, r3, r1, lsl #1
3481ff98:	e1530001 	cmp	r3, r1
3481ff9c:	e0a00000 	adc	r0, r0, r0
3481ffa0:	20433001 	subcs	r3, r3, r1
3481ffa4:	e35c0000 	cmp	ip, #0
3481ffa8:	42600000 	rsbmi	r0, r0, #0
3481ffac:	e12fff1e 	bx	lr
3481ffb0:	e13c0000 	teq	ip, r0
3481ffb4:	42600000 	rsbmi	r0, r0, #0
3481ffb8:	e12fff1e 	bx	lr
3481ffbc:	33a00000 	movcc	r0, #0
3481ffc0:	01a00fcc 	asreq	r0, ip, #31
3481ffc4:	03800001 	orreq	r0, r0, #1
3481ffc8:	e12fff1e 	bx	lr
3481ffcc:	e16f2f11 	clz	r2, r1
3481ffd0:	e262201f 	rsb	r2, r2, #31
3481ffd4:	e35c0000 	cmp	ip, #0
3481ffd8:	e1a00233 	lsr	r0, r3, r2
3481ffdc:	42600000 	rsbmi	r0, r0, #0
3481ffe0:	e12fff1e 	bx	lr
3481ffe4:	e3500000 	cmp	r0, #0
3481ffe8:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
3481ffec:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
3481fff0:	ea00001c 	b	34820068 <__aeabi_ldiv0>

3481fff4 <__aeabi_idivmod>:
3481fff4:	e3510000 	cmp	r1, #0
3481fff8:	0afffff9 	beq	3481ffe4 <.divsi3_skip_div0_test+0x208>
3481fffc:	e92d4003 	push	{r0, r1, lr}
34820000:	ebffff75 	bl	3481fddc <.divsi3_skip_div0_test>
34820004:	e8bd4006 	pop	{r1, r2, lr}
34820008:	e0030092 	mul	r3, r2, r0
3482000c:	e0411003 	sub	r1, r1, r3
34820010:	e12fff1e 	bx	lr

34820014 <__lshrdi3>:
34820014:	e2523020 	subs	r3, r2, #32
34820018:	e262c020 	rsb	ip, r2, #32
3482001c:	41a00230 	lsrmi	r0, r0, r2
34820020:	51a00331 	lsrpl	r0, r1, r3
34820024:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820028:	e1a01231 	lsr	r1, r1, r2
3482002c:	e12fff1e 	bx	lr

34820030 <__ashrdi3>:
34820030:	e2523020 	subs	r3, r2, #32
34820034:	e262c020 	rsb	ip, r2, #32
34820038:	41a00230 	lsrmi	r0, r0, r2
3482003c:	51a00351 	asrpl	r0, r1, r3
34820040:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820044:	e1a01251 	asr	r1, r1, r2
34820048:	e12fff1e 	bx	lr

3482004c <__ashldi3>:
3482004c:	e2523020 	subs	r3, r2, #32
34820050:	e262c020 	rsb	ip, r2, #32
34820054:	41a01211 	lslmi	r1, r1, r2
34820058:	51a01310 	lslpl	r1, r0, r3
3482005c:	41811c30 	orrmi	r1, r1, r0, lsr ip
34820060:	e1a00210 	lsl	r0, r0, r2
34820064:	e12fff1e 	bx	lr

34820068 <__aeabi_ldiv0>:
34820068:	e92d4002 	push	{r1, lr}
3482006c:	e3a00008 	mov	r0, #8
34820070:	ebfffecb 	bl	3481fba4 <raise>
34820074:	e8bd8002 	pop	{r1, pc}
